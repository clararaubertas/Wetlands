!% $MAX_ARRAYS=1500
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=10000
!% $MAX_ZCODE_SIZE=100000
!% $MAX_STATIC_DATA=180000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256


Constant Grammar__Version 2;

! This file was compiled by Inform 7: the build number and version of the
! I6 template layer used are as follows.
Constant NI_BUILD_COUNT "6G60";

Constant LibSerial = "080126";
Constant LibRelease = "6/12N";
Constant LIBRARY_VERSION = 612;

Constant PLUGIN_FILES;


Array UUID_ARRAY string "UUID://7E85B850-D8A7-11DF-8F89-0016EC4C6E66//";

Constant Story "Wetlands";
Constant Headline SC_2;
Constant Story_Author SC_3;
Release 1;
Serial "140126";

Default Story 0;
Default Headline 0;

[ ShowExtensionVersions;
    print "Standard Rules version 2/090402 by Graham Nelson^";
    print "Small Kindnesses version 12/111126 by Aaron Reed^";
    print "Considerate Holdall version 9 by Jon Ingold^";
    print "Rideable Vehicles version 3 by Graham Nelson^";
    print "Disambiguation Control version 7 by Jon Ingold^";
    print "Default Messages version 12/091223 by David Fisher^";
    print "Extended Grammar version 7/120107 by Aaron Reed^";
];
[ ShowFullExtensionVersions;
    print "Standard Rules version 2/090402 by Graham Nelson^";
    print "Small Kindnesses version 12/111126 by Aaron Reed^";
    print "Case Management by Emily Short^";
    print "Considerate Holdall version 9 by Jon Ingold^";
    print "Rideable Vehicles version 3 by Graham Nelson^";
    print "Locksmith version 11 by Emily Short^";
    print "Disambiguation Control version 7 by Jon Ingold^";
    print "Default Messages version 12/091223 by David Fisher^";
    print "Extended Grammar version 7/120107 by Aaron Reed^";
    print "Plurality version 9 by Emily Short^";
    print "Punctuation Removal version 4 by Emily Short^";
    print "Basic Screen Effects version 7 by Emily Short^";
];


! Use option:
 Constant DynamicMemoryAllocation = 8192; 
! Use option:
 Constant IT_MemoryBufferSize = 1024+3; 
! Use option:
 Constant MATCH_LIST_WORDS = 100; 
! Use option:
 Constant TRUNCATE_LIST = 6; 


#Ifndef WORDSIZE; ! compiling with Z-code only compiler
Constant TARGET_ZCODE;
Constant WORDSIZE 2;
#Endif;

#Iftrue (WORDSIZE == 2);
Constant NULL = $ffff;
Constant WORD_HIGHBIT = $8000;
Constant WORD_NEXTTOHIGHBIT = $4000;
Constant IMPROBABLE_VALUE = $7fe3;
Constant MAX_POSITIVE_NUMBER 32767;
Constant MIN_NEGATIVE_NUMBER -32768;
Constant REPARSE_CODE = 10000;
#Endif;

#Iftrue (WORDSIZE == 4);
Constant NULL = $ffffffff;
Constant WORD_HIGHBIT = $80000000;
Constant WORD_NEXTTOHIGHBIT = $40000000;
Constant IMPROBABLE_VALUE = $deadce11;
Constant MAX_POSITIVE_NUMBER 2147483647;
Constant MIN_NEGATIVE_NUMBER -2147483648;
Constant REPARSE_CODE = $40000000;
#Endif;

#Ifdef TARGET_ZCODE;

Global max_z_object;

Constant INDIV_PROP_START 64;

! Offsets into Z-machine header:

Constant HDR_ZCODEVERSION     = $00;     ! byte
Constant HDR_TERPFLAGS        = $01;     ! byte
Constant HDR_GAMERELEASE      = $02;     ! word
Constant HDR_HIGHMEMORY       = $04;     ! word
Constant HDR_INITIALPC        = $06;     ! word
Constant HDR_DICTIONARY       = $08;     ! word
Constant HDR_OBJECTS          = $0A;     ! word
Constant HDR_GLOBALS          = $0C;     ! word
Constant HDR_STATICMEMORY     = $0E;     ! word
Constant HDR_GAMEFLAGS        = $10;     ! word
Constant HDR_GAMESERIAL       = $12;     ! six ASCII characters
Constant HDR_ABBREVIATIONS    = $18;     ! word
Constant HDR_FILELENGTH       = $1A;     ! word
Constant HDR_CHECKSUM         = $1C;     ! word
Constant HDR_TERPNUMBER       = $1E;     ! byte
Constant HDR_TERPVERSION      = $1F;     ! byte
Constant HDR_SCREENHLINES     = $20;     ! byte
Constant HDR_SCREENWCHARS     = $21;     ! byte
Constant HDR_SCREENWUNITS     = $22;     ! word
Constant HDR_SCREENHUNITS     = $24;     ! word
Constant HDR_FONTWUNITS       = $26;     ! byte
Constant HDR_FONTHUNITS       = $27;     ! byte
Constant HDR_ROUTINEOFFSET    = $28;     ! word
Constant HDR_STRINGOFFSET     = $2A;     ! word
Constant HDR_BGCOLOUR         = $2C;     ! byte
Constant HDR_FGCOLOUR         = $2D;     ! byte
Constant HDR_TERMCHARS        = $2E;     ! word
Constant HDR_PIXELSTO3        = $30;     ! word
Constant HDR_TERPSTANDARD     = $32;     ! two bytes
Constant HDR_ALPHABET         = $34;     ! word
Constant HDR_EXTENSION        = $36;     ! word
Constant HDR_UNUSED           = $38;     ! two words
Constant HDR_INFORMVERSION    = $3C;     ! four ASCII characters

#Endif;

#IFDEF TARGET_GLULX;

Global unicode_gestalt_ok; ! Set if interpreter supports Unicode

! Offsets into Glulx header and start of ROM:

Constant HDR_MAGICNUMBER      = $00;     ! long word
Constant HDR_GLULXVERSION     = $04;     ! long word
Constant HDR_RAMSTART         = $08;     ! long word
Constant HDR_EXTSTART         = $0C;     ! long word
Constant HDR_ENDMEM           = $10;     ! long word
Constant HDR_STACKSIZE        = $14;     ! long word
Constant HDR_STARTFUNC        = $18;     ! long word
Constant HDR_DECODINGTBL      = $1C;     ! long word
Constant HDR_CHECKSUM         = $20;     ! long word
Constant ROM_INFO             = $24;     ! four ASCII characters
Constant ROM_MEMORYLAYOUT     = $28;     ! long word
Constant ROM_INFORMVERSION    = $2C;     ! four ASCII characters
Constant ROM_COMPVERSION      = $30;     ! four ASCII characters
Constant ROM_GAMERELEASE      = $34;     ! short word
Constant ROM_GAMESERIAL       = $36;     ! six ASCII characters

#Endif;

Array PowersOfTwo_TB
  --> $$100000000000
      $$010000000000
      $$001000000000
      $$000100000000
      $$000010000000
      $$000001000000
      $$000000100000
      $$000000010000
      $$000000001000
      $$000000000100
      $$000000000010
      $$000000000001;

Array IncreasingPowersOfTwo_TB
  --> $$0000000000000001
      $$0000000000000010
      $$0000000000000100
      $$0000000000001000
      $$0000000000010000
      $$0000000000100000
      $$0000000001000000
      $$0000000010000000
      $$0000000100000000
      $$0000001000000000
      $$0000010000000000
	  $$0000100000000000
	  $$0001000000000000
	  $$0010000000000000
	  $$0100000000000000
	  $$1000000000000000;

Constant NORMAL_VMSTY     = 0;
Constant HEADER_VMSTY     = 3;
Constant SUBHEADER_VMSTY  = 4;
Constant ALERT_VMSTY      = 5;
Constant NOTE_VMSTY       = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY      = 8;

Constant CLR_DEFAULT = 1;
Constant CLR_BLACK   = 2;
Constant CLR_RED     = 3;
Constant CLR_GREEN   = 4;
Constant CLR_YELLOW  = 5;
Constant CLR_BLUE    = 6;
Constant CLR_MAGENTA = 7; Constant CLR_PURPLE  = 7;
Constant CLR_CYAN    = 8; Constant CLR_AZURE   = 8;
Constant CLR_WHITE   = 9;

Constant WIN_ALL     = 0; ! Both windows at once
Constant WIN_STATUS  = 1;
Constant WIN_MAIN    = 2;

Constant PARA_COMPLETED          = 1;
Constant PARA_PROMPTSKIP         = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS   = 8;
Constant PARA_CONTENTEXPECTED    = 16;

Constant POSSESS_PK  = $100;
Constant DEFART_PK   = $101;
Constant INDEFART_PK = $102;

Constant RTP_BACKDROP                = 1;
Constant RTP_EXITDOOR                = 2;
Constant RTP_NOEXIT                  = 3;
Constant RTP_CANTCHANGE              = 4;
Constant RTP_IMPREL                  = 5;
Constant RTP_RULESTACK               = 6;
Constant RTP_TOOMANYRULEBOOKS        = 7;
Constant RTP_TOOMANYEVENTS           = 8;
Constant RTP_BADPROPERTY             = 9;
Constant RTP_UNPROVIDED              = 10;
Constant RTP_UNSET                   = 11;
Constant RTP_TOOMANYACTS             = 12;
Constant RTP_CANTABANDON             = 13;
Constant RTP_CANTEND                 = 14;
Constant RTP_CANTMOVENOTHING         = 15;
Constant RTP_CANTREMOVENOTHING       = 16;
Constant RTP_DIVZERO                 = 17;
Constant RTP_BADVALUEPROPERTY        = 18;
Constant RTP_NOTBACKDROP             = 19;
Constant RTP_TABLE_NOCOL             = 20;
Constant RTP_TABLE_NOCORR            = 21;
Constant RTP_TABLE_NOROW             = 22;
Constant RTP_TABLE_NOENTRY           = 23;
Constant RTP_TABLE_NOTABLE           = 24;
Constant RTP_TABLE_NOMOREBLANKS      = 25;
Constant RTP_TABLE_NOROWS            = 26;
Constant RTP_TABLE_CANTSORT          = 27;
Constant RTP_NOTINAROOM              = 28;
Constant RTP_BADTOPIC                = 29;
Constant RTP_ROUTELESS               = 30;
Constant RTP_PROPOFNOTHING           = 31;
Constant RTP_DECIDEONWRONGKIND       = 32;
Constant RTP_DECIDEONNOTHING         = 33;
Constant RTP_TABLE_CANTSAVE          = 34;
Constant RTP_TABLE_WONTFIT           = 35;
Constant RTP_TABLE_BADFILE           = 36;
Constant RTP_LOWLEVELERROR           = 37;
Constant RTP_DONTIGNORETURNSEQUENCE  = 38;
Constant RTP_SAYINVALIDSNIPPET       = 39;
Constant RTP_SPLICEINVALIDSNIPPET    = 40;
Constant RTP_INCLUDEINVALIDSNIPPET   = 41;
Constant RTP_LISTWRITERMEMORY        = 42;
Constant RTP_CANTREMOVEPLAYER        = 43;
Constant RTP_CANTREMOVEDOORS         = 44;
Constant RTP_CANTCHANGEOFFSTAGE      = 45;
Constant RTP_MSTACKMEMORY            = 46;
Constant RTP_TYPECHECK               = 47;
Constant RTP_FILEIOERROR             = 48;
Constant RTP_HEAPERROR               = 49;
Constant RTP_LISTRANGEERROR          = 50;
Constant RTP_REGEXPSYNTAXERROR       = 51;
Constant RTP_NOGLULXUNICODE          = 52;
Constant RTP_BACKDROPONLY            = 53;
Constant RTP_NOTTHING                = 54;
Constant RTP_SCENEHASNTSTARTED       = 55;
Constant RTP_SCENEHASNTENDED         = 56;
Constant RTP_NEGATIVEROOT            = 57;
Constant RTP_TABLE_CANTRUNTHROUGH    = 58;
Constant RTP_CANTITERATE             = 59;
Constant RTP_WRONGASSIGNEDKIND       = 60;

Constant PRINTING_THE_NAME_ACT           = 0;
Constant PRINTING_THE_PLURAL_NAME_ACT    = 1;
Constant PRINTING_A_NUMBER_OF_ACT        = 2;
Constant PRINTING_ROOM_DESC_DETAILS_ACT  = 3;
Constant LISTING_CONTENTS_ACT            = 4;
Constant GROUPING_TOGETHER_ACT           = 5;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT   = 6;
Constant LISTING_NONDESCRIPT_ITEMS_ACT   = 7;

Constant PRINTING_NAME_OF_DARK_ROOM_ACT  = 8;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT  = 9;
Constant PRINTING_NEWS_OF_DARKNESS_ACT   = 10;
Constant PRINTING_NEWS_OF_LIGHT_ACT      = 11;
Constant REFUSAL_TO_ACT_IN_DARK_ACT      = 12;

Constant CONSTRUCTING_STATUS_LINE_ACT    = 13;
Constant PRINTING_BANNER_TEXT_ACT        = 14;

Constant READING_A_COMMAND_ACT           = 15;
Constant DECIDING_SCOPE_ACT              = 16;
Constant DECIDING_CONCEALED_POSSESS_ACT  = 17;
Constant DECIDING_WHETHER_ALL_INC_ACT    = 18;
Constant CLARIFYING_PARSERS_CHOICE_ACT   = 19;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT    = 20;
Constant PRINTING_A_PARSER_ERROR_ACT     = 21;
Constant SUPPLYING_A_MISSING_NOUN_ACT    = 22;
Constant SUPPLYING_A_MISSING_SECOND_ACT  = 23;
Constant IMPLICITLY_TAKING_ACT           = 24;
Constant STARTING_VIRTUAL_MACHINE_ACT    = 25;

Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 26;
Constant PRINTING_PLAYERS_OBITUARY_ACT   = 27;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 28;

Constant PRINTING_LOCALE_DESCRIPTION_ACT = 29;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 30;
Constant PRINTING_LOCALE_PARAGRAPH_ACT   = 31;

Constant PROCEDURAL_RB                   = 0;

Constant STARTUP_RB                      = 1;
Constant TURN_SEQUENCE_RB                = 2;
Constant SHUTDOWN_RB                     = 3;

Constant WHEN_PLAY_BEGINS_RB             = 5;
Constant WHEN_PLAY_ENDS_RB               = 6;
Constant WHEN_SCENE_BEGINS_RB            = 7;
Constant WHEN_SCENE_ENDS_RB              = 8;

Constant ACTION_PROCESSING_RB            = 10;
Constant SETTING_ACTION_VARIABLES_RB     = 11;
Constant SPECIFIC_ACTION_PROCESSING_RB   = 12;

Constant ACCESSIBILITY_RB                = 14;
Constant REACHING_INSIDE_RB              = 15;
Constant REACHING_OUTSIDE_RB             = 16;
Constant VISIBLE_RB                      = 17;

Constant PERSUADE_RB                     = 18;
Constant UNSUCCESSFUL_ATTEMPT_RB         = 19;

Constant AFTER_RB                        = 24;
Constant REPORT_RB                       = 25;

Constant UNKNOWN_TY = 1;
Constant VALUE_TY = 2;
Constant POINTER_VALUE_TY = 3;
Constant WORD_VALUE_TY = 4;
Constant ARITHMETIC_VALUE_TY = 5;
Constant ENUMERATED_VALUE_TY = 6;
Constant SAYABLE_VALUE_TY = 7;
Constant COMBINED_VALUE_TY = 8;
Constant OBJECT_TY = 9;
Constant NUMBER_TY = 10;
Constant TRUTH_STATE_TY = 11;
Constant TEXT_TY = 12;
Constant INDEXED_TEXT_TY = 13;
Constant UNICODE_CHARACTER_TY = 14;
Constant USE_OPTION_TY = 15;
Constant SNIPPET_TY = 16;
Constant TABLE_TY = 17;
Constant EQUATION_TY = 18;
Constant RULEBOOK_OUTCOME_TY = 19;
Constant UNDERSTANDING_TY = 20;
Constant INTERMEDIATE_TY = 21;
Constant NIL_TY = 22;
Constant KIND_VARIABLE_TY = 23;
Constant PHRASE_TY = 24;
Constant TUPLE_ENTRY_TY = 25;
Constant RELATION_TY = 26;
Constant RULE_TY = 27;
Constant RULEBOOK_TY = 28;
Constant ACTIVITY_TY = 29;
Constant LIST_OF_TY = 30;
Constant DESCRIPTION_OF_TY = 31;
Constant PROPERTY_TY = 32;
Constant TABLE_COLUMN_TY = 33;
Constant COMBINATION_TY = 34;
Constant DESCRIPTION_OF_ACTION_TY = 35;
Constant STORED_ACTION_TY = 36;
Constant ACTION_NAME_TY = 37;
Constant TIME_TY = 38;
Constant SCENE_TY = 39;
Constant FIGURE_NAME_TY = 40;
Constant SOUND_NAME_TY = 41;
Constant EXTERNAL_FILE_TY = 42;
Constant BASE_KIND_HWM = 48; ! Base kind high-water-mark


Constant STUCK_PE     = 1;
Constant UPTO_PE      = 2;
Constant NUMBER_PE    = 3;
Constant ANIMA_PE     = 4;
Constant CANTSEE_PE   = 5;
Constant TOOLIT_PE    = 6;
Constant NOTHELD_PE   = 7;
Constant MULTI_PE     = 8;
Constant MMULTI_PE    = 9;
Constant VAGUE_PE     = 10;
Constant EXCEPT_PE    = 11;
Constant VERB_PE      = 12;
Constant SCENERY_PE   = 13;
Constant ITGONE_PE    = 14;
Constant JUNKAFTER_PE = 15;
Constant TOOFEW_PE    = 16;
Constant NOTHING_PE   = 17;
Constant ASKSCOPE_PE  = 18;
Constant NOTINCONTEXT_PE = 19;
Constant BLANKLINE_PE = 20; ! Not formally a parser error, but used by I7 as if

Constant PARSING_REASON       = 0;
Constant TALKING_REASON       = 1;
Constant EACH_TURN_REASON     = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON     = 6;

Constant ILLEGAL_TT         = 0;    ! Types of grammar token: illegal
Constant ELEMENTARY_TT      = 1;    !     (one of those below)
Constant PREPOSITION_TT     = 2;    !     e.g. 'into'
Constant ROUTINE_FILTER_TT  = 3;    !     e.g. noun=CagedCreature
Constant ATTR_FILTER_TT     = 4;    !     e.g. edible
Constant SCOPE_TT           = 5;    !     e.g. scope=Spells
Constant GPR_TT             = 6;    !     a general parsing routine

Constant NOUN_TOKEN         = 0;    ! The elementary grammar tokens, and
Constant HELD_TOKEN         = 1;    ! the numbers compiled by I6 to
Constant MULTI_TOKEN        = 2;    ! encode them
Constant MULTIHELD_TOKEN    = 3;
Constant MULTIEXCEPT_TOKEN  = 4;
Constant MULTIINSIDE_TOKEN  = 5;
Constant CREATURE_TOKEN     = 6;
Constant SPECIAL_TOKEN      = 7;
Constant NUMBER_TOKEN       = 8;
Constant TOPIC_TOKEN        = 9;
Constant ENDIT_TOKEN        = 15;   ! Value used to mean "end of grammar line"

Constant GPR_FAIL           = -1;   ! Return values from General Parsing
Constant GPR_PREPOSITION    = 0;    ! Routines
Constant GPR_NUMBER         = 1;
Constant GPR_MULTIPLE       = 2;
Constant GPR_REPARSE        = REPARSE_CODE;
Constant GPR_NOUN           = -256; ! Reparse, but as |NOUN_TOKEN| this time
Constant GPR_HELD           = GPR_NOUN + 1; ! And so on
Constant GPR_MULTI          = GPR_NOUN + 2;
Constant GPR_MULTIHELD      = GPR_NOUN + 3;
Constant GPR_MULTIEXCEPT    = GPR_NOUN + 4;
Constant GPR_MULTIINSIDE    = GPR_NOUN + 5;
Constant GPR_CREATURE       = GPR_NOUN + 6;

Constant NEWLINE_BIT        = $$0000000000000001; ! New-line after each entry
Constant INDENT_BIT         = $$0000000000000010; ! Indent each entry by depth
Constant FULLINV_BIT        = $$0000000000000100; ! Full inventory information after entry
Constant ENGLISH_BIT        = $$0000000000001000; ! English sentence style, with commas and and
Constant RECURSE_BIT        = $$0000000000010000; ! Recurse downwards with usual rules
Constant ALWAYS_BIT         = $$0000000000100000; ! Always recurse downwards
Constant TERSE_BIT          = $$0000000001000000; ! More terse English style
Constant PARTINV_BIT        = $$0000000010000000; ! Only brief inventory information after entry
Constant DEFART_BIT         = $$0000000100000000; ! Use the definite article in list
Constant WORKFLAG_BIT       = $$0000001000000000; ! At top level (only), only list objects
                                                  ! which have the "workflag" attribute
Constant ISARE_BIT          = $$0000010000000000; ! Print " is" or " are" before list
Constant CONCEAL_BIT        = $$0000100000000000; ! Omit objects with "concealed" or "scenery":
                                                  ! if WORKFLAG_BIT also set, then does not
                                                  ! apply at top level, but does lower down
Constant NOARTICLE_BIT      = $$0001000000000000; ! Print no articles, definite or not
Constant EXTRAINDENT_BIT    = $$0010000000000000; ! New in I7: extra indentation of 1 level
Constant CFIRSTART_BIT      = $$0100000000000000; ! Capitalise first article in list

Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;

Constant EMPTY_TEXT_VALUE "";

Array TheEmptyTable --> 0 0;

Array EMPTY_RULEBOOK -> $ff $ff $ff $ff;

[ Prop_Falsity reason obj; return 0; ];

Global MAX_SCORE = 100;

#Ifndef MAX_SCORE;
Global MAX_SCORE = 0;
#Endif;

Attribute absent; ! Used to mark objects removed from play
Attribute animate; ! I6-level marker for I7 kind "person"
Attribute clothing; ! = I7 "wearable"
Attribute concealed; ! = I7 "undescribed"
Attribute container; ! I6-level marker for I7 kind "container"
Attribute door; ! I6-level marker for I7 kind "door"
Attribute edible; ! = I7 "edible" vs "inedible"
Attribute enterable; ! = I7 "enterable"
Attribute light; ! = I7 "lighted" vs "dark"
Attribute lockable; ! = I7 "lockable"
Attribute locked; ! = I7 "locked"
Attribute moved; ! = I7 "handled"
Attribute on; ! = I7 "switched on" vs "switched off"
Attribute open; ! = I7 "open" vs "closed"
Attribute openable; ! = I7 "openable"
Attribute scenery; ! = I7 "scenery"
Attribute static; ! = I7 "fixed in place" vs "portable"
Attribute supporter; ! I6-level marker for I7 kind "supporter"
Attribute switchable; ! I6-level marker for I7 kind "device"
Attribute talkable; ! Not currently used by I7, but retained for possible future use
Attribute transparent; ! = I7 "transparent" vs "opaque"
Attribute visited; ! = I7 "visited"
Attribute worn; ! marks that an object tree edge represents wearing

Attribute male; ! not directly used by I7, but available for languages with genders
Attribute female; ! = I7 "female" vs "male"
Attribute neuter; ! = I7 "neuter"
Attribute pluralname; ! = I7 "plural-named"
Attribute proper; ! = I7 "proper-named"
Attribute remove_proper; ! remember to remove proper again when using ChangePlayer next

Attribute privately_named; ! New in I7
Attribute mentioned; ! New in I7
Attribute pushable; ! New in I7

Attribute mark_as_room; ! Used in I7 to speed up testing "ofclass K1_room"
Attribute mark_as_thing; ! Used in I7 to speed up testing "ofclass K2_thing"

Attribute workflag; ! = I7 "marked for listing", but basically temporary workspace 
Attribute workflag2; ! new in I7 and also temporary workspace
Constant list_filter_permits = privately_named; ! another I7 listwriter convenience

Property add_to_scope; ! used as in I6 to place component parts in scope
Property article "a"; ! used as in I6 to implement articles
Property capacity 100; ! = I7 "carrying capacity"
Property component_child; ! new in I7: forest structure holding "part of" relation
Property component_parent; ! new in I7
Property component_sibling; ! new in I7
Property description; ! = I7 "description"
Property door_dir; ! used to implement two-sided doors, but holds direction object, not a property
Property door_to; ! used as in I6 to implement two-sided doors
Property found_in; ! used as in I6 to implement two-sided doors and backdrops
Property initial; ! = I7 "initial description"
Property list_together; ! used as in I6 to implement "grouping together" activity
Property map_region; ! new in I7
Property parse_name 0; ! used as in I6 to implement "Understand... as..." grammars
Property plural; ! used as in I6 to implement plural names for duplicate objects
Property regional_found_in; ! new in I7
Property room_index; ! new in I7: storage for route-finding
Property short_name 0; ! = I7 "printed name"
Property vector; ! new in I7: storage for route-finding
Property with_key; ! = I7 "matching key"

Property KD_Count; ! Instance count of the kind of the current object
Property IK1_Count; ! These are instance counts within kinds K1, K2, ...
Property IK2_Count; ! and it is efficient to declare the common ones with Property
Property IK4_Count; ! since this results in a slightly smaller story file
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;

Property IK1_link; ! These are for linked lists used to make searches faster
Property IK2_link; ! and again it's memory-efficient to declare the common ones
Property IK5_link; ! 
Property IK6_link; ! 
Property IK8_link; ! 

Property articles; ! not used by I7, but an interesting hook in the parser
Property grammar; ! not used by I7, but an interesting hook in the parser
Property inside_description; ! not used by I7, but an interesting hook in the locale code
Property short_name_indef 0; ! not used by I7, but an interesting hook in the listmaker

Constant life = NULL;

Constant ActionCount = 138;

Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;

	Constant RUCKSACK_CLASS = K15_player_s_holdall;

  Constant LibraryMessages = I410_i7_librarymessages;

[ InitLibraryMessages n;

#Ifndef TARGET_GLULX;
  if (I410_i7_librarymessages.&before)
  {
      ! get rid of any other "before" routines
      for (n = 0 : n < I410_i7_librarymessages.#before / WORDSIZE : n++)
      {
          if (I410_i7_librarymessages.&before --> n ~= LibraryMessagesBefore)
              I410_i7_librarymessages.&before --> n = nothing;
      }
  }
#Endif; ! TARGET_GLULX
];


! [1]
Global location = InformLibrary; ! does not = I7 "location": see below
Global sline1; Global sline2;

! [2]
Global say__p = 1; Global say__pc = 0; Global say__n;
Global ct_0 = 0; Global ct_1 = 0;
Global los_rv = false;
Global subst__v; ! = I7 "substitution-variable"
Global parameter_object; ! = I7 "parameter-object" = I7 "container in question"
Array deferred_calling_list --> 16;
Global property_to_be_totalled; ! used to implement "total P of..."
Global property_loop_sign; ! $+1$ for increasing order, $-1$ for decreasing
Global suppress_scope_loops;
Global temporary_value; ! can be used anywhere side-effects can't occur
Global enable_rte = true; ! reporting of run-time problems is enabled

Constant BLOCKV_STACK_SIZE = 224;
Global blockv_sp = 0;
Array blockv_stack --> BLOCKV_STACK_SIZE;
Global IT_RE_Err = 0;

Array LocalParking --> 16;

! [3]
Global standard_interpreter = 0;
Global undo_flag;

! [4]
Global deadflag = 0;
Global story_complete = 0;
Global resurrect_please = false;

! [5]
Global not_yet_in_play = true; ! set false when first command received
Global turns = 1; ! = I7 "turn count"
Global the_time = NULL; ! = I7 "time of day"
Global time_rate = 1;

Constant NUMBER_SCENES_CREATED = 14;
Constant SCENE_ARRAY_SIZE = (NUMBER_SCENES_CREATED+2);
Array scene_started --> SCENE_ARRAY_SIZE;
Array scene_ended --> SCENE_ARRAY_SIZE;
Array scene_status --> SCENE_ARRAY_SIZE;
Array scene_endings --> SCENE_ARRAY_SIZE;
Array scene_latest_ending --> SCENE_ARRAY_SIZE;

! [6]
Global score; ! = I7 "score"
Global last_score; ! = I7 "last notified score"
Global notify_mode = 1; ! score notification on or off
Global left_hand_status_line = SL_Location; ! = I7 "left hand status line"
Global right_hand_status_line = SL_Score_Moves; ! = I7 "right hand status line"

! [7]
Global player; ! = I7 "player"
Global real_location; ! = I7 "location"
Global visibility_ceiling; ! highest object in tree visible to player
Global visibility_levels; ! distance in tree to that

Global SACK_OBJECT; ! current player's holdall item in use

! [8]
Global act_requester;
Global actor; ! = I7 "person asked" = I7 "person reaching"
Global actors_location; ! like real_location, but for the actor
Global actor_location; ! = I7 "actor-location"
Global action;
Global meta; ! action is out of world
Global inp1;
Global inp2;
Array  multiple_object --> MATCH_LIST_WORDS; ! multiple-object list (I6 table array)
Global toomany_flag; ! multiple-object list overflowed
Global multiflag; ! multiple-object being processed
Global multiple_object_item; ! item currently being processed in multiple-object list
Global noun; ! = I7 "noun"
Global second; ! = I7 "second noun"
Global keep_silent; ! true if current action is being tried silently
Global etype; ! parser error number if command not recognised
Global trace_actions = 0;

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;

Global special_word; ! dictionary address of first word in "[text]" token
Global consult_from; ! word number of start of "[text]" token
Global consult_words; ! number of words in "[text]" token
Global parsed_number; ! value from any token not an object
Global special_number1; ! first value, if token not an object
Global special_number2; ! second value, if token not an object

Array  parser_results --> 16; ! for parser to write its results in
Global parser_trace = 0; ! normally 0, but 1 to 5 traces parser workings
Global pronoun_word; ! records which pronoun ("it", "them", ...) caused an error
Global pronoun_obj; ! and what object it was thought to refer to

Global players_command = 100; ! = I7 "player's command"
Global matched_text; ! = I7 "matched text"
Global reason_the_action_failed; ! = I7 "reason the action failed"
Global understand_as_mistake_number; ! which form of "Understand... as a mistake"
Global particular_possession; ! = I7 "particular possession"

! [9]
Global parser_action; ! written by the parser for the benefit of GPRs
Global parser_one;
Global parser_two;
Global parameters; ! number of I7 tokens parsed on the current line
Global action_to_be; ! (if the current line were accepted)
Global action_reversed; ! (parameters would be reversed in order)
Global wn; ! word number within "parse" buffer (from 1)
Global num_words; ! number of words in buffer
Global verb_word; ! dictionary address of command verb
Global verb_wordnum; ! word number of command verb

! [10]
Global scope_reason = PARSING_REASON; ! current reason for searching scope
Global scope_token; ! for "scope=Routine" grammar tokens
Global scope_error;
Global scope_stage; ! 1, 2 then 3
Global advance_warning; ! what a later-named thing will be
Global reason_code = NULL; ! for the I6 veneer

Global ats_flag = 0; ! for AddToScope routines
Global ats_hls;

! [11]
Global move_pushing;
Global move_from;
Global move_to;
Global move_by;
Global move_through;

! [12]
#Ifdef DEFAULT_BRIEF_DESCRIPTIONS;
Global lookmode = 1; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_VERBOSE_DESCRIPTIONS; 
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifdef DEFAULT_SUPERBRIEF_DESCRIPTIONS; 
Global lookmode = 3; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
#Ifndef lookmode;
Global lookmode = 2; ! 1 = BRIEF, 2 = VERBOSE, 3 = SUPERBRIEF
#Endif;
Global c_style; ! current list-writer style
Global c_depth; ! current recursion depth
Global c_iterator; ! current iteration function
Global lt_value; ! common value of list_together
Global listing_together; ! object number of one member of a group being listed together
Global listing_size; ! size of such a group
Global c_margin; ! current level of indentation printed by WriteListFrom()
Global inventory_stage = 1; ! 1 or 2 according to the context in which list_together uses

! [13]
Global clr_fg = 1; ! foreground colour
Global clr_bg = 1; ! background colour
Global clr_fgstatus = 1; ! foreground colour of statusline
Global clr_bgstatus = 1; ! background colour of statusline
Global clr_on; ! has colour been enabled by the player?
Global statuswin_current; ! if writing to top window

! [14]
Global statuswin_cursize = 0;
Global statuswin_size = 1;

! [15]
Global lm_act; Global lm_n; Global lm_o; Global lm_o2;

! [16]
Global debug_flag = 0;
Global debug_rules = 0;
Global debug_scenes = 0;
Global debug_rule_nesting;

#Ifdef TARGET_GLULX;
Array gg_event --> 4;
Array gg_arguments buffer 28;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;      ! true if gg_commandstr is being replayed
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;

Constant INPUT_BUFFER_LEN = 260;    ! No extra byte necessary
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;

Array  buffer    buffer INPUT_BUFFER_LEN;
Array  buffer2   buffer INPUT_BUFFER_LEN;
Array  buffer3   buffer INPUT_BUFFER_LEN;
Array  parse     --> PARSE_BUFFER_LEN;
Array  parse2    --> PARSE_BUFFER_LEN;

#IFNDEF infglk_h; ! Standard Glulx definitions contributed by John Cater
Constant infglk_h;
!-------------------------------------------------------------------------------
!  infglk.h - an Inform library to allow easy access to glk functions
!    under glulx
!  Dynamically created by glk2inf.pl on 08/31/2006 at 19:20:21.
!  Send comments or suggestions to: katre@ruf.rice.edu
!-------------------------------------------------------------------------------
#Ifdef infglk_h;  ! remove "Constant declared but not used" warnings
#Endif;

Constant GLK_NULL 0;

! Constant definitions from glk.h
Constant gestalt_Version 0;
Constant gestalt_CharInput 1;
Constant gestalt_LineInput 2;
Constant gestalt_CharOutput 3;
Constant gestalt_CharOutput_CannotPrint 0;
Constant gestalt_CharOutput_ApproxPrint 1;
Constant gestalt_CharOutput_ExactPrint 2;
Constant gestalt_MouseInput 4;
Constant gestalt_Timer 5;
Constant gestalt_Graphics 6;
Constant gestalt_DrawImage 7;
Constant gestalt_Sound 8;
Constant gestalt_SoundVolume 9;
Constant gestalt_SoundNotify 10;
Constant gestalt_Hyperlinks 11;
Constant gestalt_HyperlinkInput 12;
Constant gestalt_SoundMusic 13;
Constant gestalt_GraphicsTransparency 14;
Constant gestalt_Unicode 15;
Constant evtype_None 0;
Constant evtype_Timer 1;
Constant evtype_CharInput 2;
Constant evtype_LineInput 3;
Constant evtype_MouseInput 4;
Constant evtype_Arrange 5;
Constant evtype_Redraw 6;
Constant evtype_SoundNotify 7;
Constant evtype_Hyperlink 8;
Constant keycode_Unknown $ffffffff;
Constant keycode_Left $fffffffe;
Constant keycode_Right $fffffffd;
Constant keycode_Up $fffffffc;
Constant keycode_Down $fffffffb;
Constant keycode_Return $fffffffa;
Constant keycode_Delete $fffffff9;
Constant keycode_Escape $fffffff8;
Constant keycode_Tab $fffffff7;
Constant keycode_PageUp $fffffff6;
Constant keycode_PageDown $fffffff5;
Constant keycode_Home $fffffff4;
Constant keycode_End $fffffff3;
Constant keycode_Func1 $ffffffef;
Constant keycode_Func2 $ffffffee;
Constant keycode_Func3 $ffffffed;
Constant keycode_Func4 $ffffffec;
Constant keycode_Func5 $ffffffeb;
Constant keycode_Func6 $ffffffea;
Constant keycode_Func7 $ffffffe9;
Constant keycode_Func8 $ffffffe8;
Constant keycode_Func9 $ffffffe7;
Constant keycode_Func10 $ffffffe6;
Constant keycode_Func11 $ffffffe5;
Constant keycode_Func12 $ffffffe4;
Constant keycode_MAXVAL 28;
Constant style_Normal 0;
Constant style_Emphasized 1;
Constant style_Preformatted 2;
Constant style_Header 3;
Constant style_Subheader 4;
Constant style_Alert 5;
Constant style_Note 6;
Constant style_BlockQuote 7;
Constant style_Input 8;
Constant style_User1 9;
Constant style_User2 10;
Constant style_NUMSTYLES 11;
Constant wintype_AllTypes 0;
Constant wintype_Pair 1;
Constant wintype_Blank 2;
Constant wintype_TextBuffer 3;
Constant wintype_TextGrid 4;
Constant wintype_Graphics 5;
Constant winmethod_Left $00;
Constant winmethod_Right $01;
Constant winmethod_Above $02;
Constant winmethod_Below $03;
Constant winmethod_DirMask $0f;
Constant winmethod_Fixed $10;
Constant winmethod_Proportional $20;
Constant winmethod_DivisionMask $f0;
Constant fileusage_Data $00;
Constant fileusage_SavedGame $01;
Constant fileusage_Transcript $02;
Constant fileusage_InputRecord $03;
Constant fileusage_TypeMask $0f;
Constant fileusage_TextMode $100;
Constant fileusage_BinaryMode $000;
Constant filemode_Write $01;
Constant filemode_Read $02;
Constant filemode_ReadWrite $03;
Constant filemode_WriteAppend $05;
Constant seekmode_Start 0;
Constant seekmode_Current 1;
Constant seekmode_End 2;
Constant stylehint_Indentation 0;
Constant stylehint_ParaIndentation 1;
Constant stylehint_Justification 2;
Constant stylehint_Size 3;
Constant stylehint_Weight 4;
Constant stylehint_Oblique 5;
Constant stylehint_Proportional 6;
Constant stylehint_TextColor 7;
Constant stylehint_BackColor 8;
Constant stylehint_ReverseColor 9;
Constant stylehint_NUMHINTS 10;
Constant stylehint_just_LeftFlush 0;
Constant stylehint_just_LeftRight 1;
Constant stylehint_just_Centered 2;
Constant stylehint_just_RightFlush 3;
Constant imagealign_InlineUp $01;
Constant imagealign_InlineDown $02;
Constant imagealign_InlineCenter $03;
Constant imagealign_MarginLeft $04;
Constant imagealign_MarginRight $05;

! The actual glk functions.
[ glk_exit _vararg_count ret;
! glk_exit ()
  ! And now the @glk call
  @glk 1 _vararg_count ret;
  return ret;
];

[ glk_set_interrupt_handler _vararg_count ret;
! glk_set_interrupt_handler (func)
  ! And now the @glk call
  @glk 2 _vararg_count ret;
  return ret;
];

[ glk_tick _vararg_count ret;
! glk_tick ()
  ! And now the @glk call
  @glk 3 _vararg_count ret;
  return ret;
];

[ glk_gestalt _vararg_count ret;
! glk_gestalt (sel val)
  ! And now the @glk call
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
! glk_gestalt_ext (sel val arr arrlen)
  ! And now the @glk call
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
! glk_char_to_lower (ch)
  ! And now the @glk call
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
! glk_char_to_upper (ch)
  ! And now the @glk call
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
! glk_window_get_root ()
  ! And now the @glk call
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
! glk_window_open (split method size wintype rock)
  ! And now the @glk call
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count ret;
! glk_window_close (win result)
  ! And now the @glk call
  @glk 36 _vararg_count ret;
  return ret;
];

[ glk_window_get_size _vararg_count ret;
! glk_window_get_size (win widthptr heightptr)
  ! And now the @glk call
  @glk 37 _vararg_count ret;
  return ret;
];

[ glk_window_set_arrangement _vararg_count ret;
! glk_window_set_arrangement (win method size keywin)
  ! And now the @glk call
  @glk 38 _vararg_count ret;
  return ret;
];

[ glk_window_get_arrangement _vararg_count ret;
! glk_window_get_arrangement (win methodptr sizeptr keywinptr)
  ! And now the @glk call
  @glk 39 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
! glk_window_iterate (win rockptr)
  ! And now the @glk call
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
! glk_window_get_rock (win)
  ! And now the @glk call
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_type _vararg_count ret;
! glk_window_get_type (win)
  ! And now the @glk call
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
! glk_window_get_parent (win)
  ! And now the @glk call
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_get_sibling _vararg_count ret;
! glk_window_get_sibling (win)
  ! And now the @glk call
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count ret;
! glk_window_clear (win)
  ! And now the @glk call
  @glk 42 _vararg_count ret;
  return ret;
];

[ glk_window_move_cursor _vararg_count ret;
! glk_window_move_cursor (win xpos ypos)
  ! And now the @glk call
  @glk 43 _vararg_count ret;
  return ret;
];

[ glk_window_get_stream _vararg_count ret;
! glk_window_get_stream (win)
  ! And now the @glk call
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count ret;
! glk_window_set_echo_stream (win str)
  ! And now the @glk call
  @glk 45 _vararg_count ret;
  return ret;
];

[ glk_window_get_echo_stream _vararg_count ret;
! glk_window_get_echo_stream (win)
  ! And now the @glk call
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count ret;
! glk_set_window (win)
  ! And now the @glk call
  @glk 47 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
! glk_stream_open_file (fileref fmode rock)
  ! And now the @glk call
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
! glk_stream_open_memory (buf buflen fmode rock)
  ! And now the @glk call
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count ret;
! glk_stream_close (str result)
  ! And now the @glk call
  @glk 68 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
! glk_stream_iterate (str rockptr)
  ! And now the @glk call
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
! glk_stream_get_rock (str)
  ! And now the @glk call
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_set_position _vararg_count ret;
! glk_stream_set_position (str pos seekmode)
  ! And now the @glk call
  @glk 69 _vararg_count ret;
  return ret;
];

[ glk_stream_get_position _vararg_count ret;
! glk_stream_get_position (str)
  ! And now the @glk call
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count ret;
! glk_stream_set_current (str)
  ! And now the @glk call
  @glk 71 _vararg_count ret;
  return ret;
];

[ glk_stream_get_current _vararg_count ret;
! glk_stream_get_current ()
  ! And now the @glk call
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count ret;
! glk_put_char (ch)
  ! And now the @glk call
  @glk 128 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream _vararg_count ret;
! glk_put_char_stream (str ch)
  ! And now the @glk call
  @glk 129 _vararg_count ret;
  return ret;
];

[ glk_put_string _vararg_count ret;
! glk_put_string (s)
  ! And now the @glk call
  @glk 130 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream _vararg_count ret;
! glk_put_string_stream (str s)
  ! And now the @glk call
  @glk 131 _vararg_count ret;
  return ret;
];

[ glk_put_buffer _vararg_count ret;
! glk_put_buffer (buf len)
  ! And now the @glk call
  @glk 132 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream _vararg_count ret;
! glk_put_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 133 _vararg_count ret;
  return ret;
];

[ glk_set_style _vararg_count ret;
! glk_set_style (styl)
  ! And now the @glk call
  @glk 134 _vararg_count ret;
  return ret;
];

[ glk_set_style_stream _vararg_count ret;
! glk_set_style_stream (str styl)
  ! And now the @glk call
  @glk 135 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream _vararg_count ret;
! glk_get_char_stream (str)
  ! And now the @glk call
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
! glk_get_line_stream (str buf len)
  ! And now the @glk call
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
! glk_get_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count ret;
! glk_stylehint_set (wintype styl hint val)
  ! And now the @glk call
  @glk 176 _vararg_count ret;
  return ret;
];

[ glk_stylehint_clear _vararg_count ret;
! glk_stylehint_clear (wintype styl hint)
  ! And now the @glk call
  @glk 177 _vararg_count ret;
  return ret;
];

[ glk_style_distinguish _vararg_count ret;
! glk_style_distinguish (win styl1 styl2)
  ! And now the @glk call
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
! glk_style_measure (win styl hint result)
  ! And now the @glk call
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
! glk_fileref_create_temp (usage rock)
  ! And now the @glk call
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
! glk_fileref_create_by_name (usage name rock)
  ! And now the @glk call
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
! glk_fileref_create_by_prompt (usage fmode rock)
  ! And now the @glk call
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
! glk_fileref_create_from_fileref (usage fref rock)
  ! And now the @glk call
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count ret;
! glk_fileref_destroy (fref)
  ! And now the @glk call
  @glk 99 _vararg_count ret;
  return ret;
];

[ glk_fileref_iterate _vararg_count ret;
! glk_fileref_iterate (fref rockptr)
  ! And now the @glk call
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
! glk_fileref_get_rock (fref)
  ! And now the @glk call
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count ret;
! glk_fileref_delete_file (fref)
  ! And now the @glk call
  @glk 102 _vararg_count ret;
  return ret;
];

[ glk_fileref_does_file_exist _vararg_count ret;
! glk_fileref_does_file_exist (fref)
  ! And now the @glk call
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count ret;
! glk_select (event)
  ! And now the @glk call
  @glk 192 _vararg_count ret;
  return ret;
];

[ glk_select_poll _vararg_count ret;
! glk_select_poll (event)
  ! And now the @glk call
  @glk 193 _vararg_count ret;
  return ret;
];

[ glk_request_timer_events _vararg_count ret;
! glk_request_timer_events (millisecs)
  ! And now the @glk call
  @glk 214 _vararg_count ret;
  return ret;
];

[ glk_request_line_event _vararg_count ret;
! glk_request_line_event (win buf maxlen initlen)
  ! And now the @glk call
  @glk 208 _vararg_count ret;
  return ret;
];

[ glk_request_char_event _vararg_count ret;
! glk_request_char_event (win)
  ! And now the @glk call
  @glk 210 _vararg_count ret;
  return ret;
];

[ glk_request_mouse_event _vararg_count ret;
! glk_request_mouse_event (win)
  ! And now the @glk call
  @glk 212 _vararg_count ret;
  return ret;
];

[ glk_cancel_line_event _vararg_count ret;
! glk_cancel_line_event (win event)
  ! And now the @glk call
  @glk 209 _vararg_count ret;
  return ret;
];

[ glk_cancel_char_event _vararg_count ret;
! glk_cancel_char_event (win)
  ! And now the @glk call
  @glk 211 _vararg_count ret;
  return ret;
];

[ glk_cancel_mouse_event _vararg_count ret;
! glk_cancel_mouse_event (win)
  ! And now the @glk call
  @glk 213 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
! glk_buffer_to_lower_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
! glk_buffer_to_upper_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
! glk_buffer_to_title_case_uni (buf len numchars lowerrest)
  ! And now the @glk call
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count ret;
! glk_put_char_uni (ch)
  ! And now the @glk call
  @glk 296 _vararg_count ret;
  return ret;
];

[ glk_put_string_uni _vararg_count ret;
! glk_put_string_uni (s)
  ! And now the @glk call
  @glk 297 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_uni _vararg_count ret;
! glk_put_buffer_uni (buf len)
  ! And now the @glk call
  @glk 298 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream_uni _vararg_count ret;
! glk_put_char_stream_uni (str ch)
  ! And now the @glk call
  @glk 299 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream_uni _vararg_count ret;
! glk_put_string_stream_uni (str s)
  ! And now the @glk call
  @glk 300 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream_uni _vararg_count ret;
! glk_put_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 301 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream_uni _vararg_count ret;
! glk_get_char_stream_uni (str)
  ! And now the @glk call
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
! glk_get_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
! glk_get_line_stream_uni (str buf len)
  ! And now the @glk call
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
! glk_stream_open_file_uni (fileref fmode rock)
  ! And now the @glk call
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
! glk_stream_open_memory_uni (buf buflen fmode rock)
  ! And now the @glk call
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count ret;
! glk_request_char_event_uni (win)
  ! And now the @glk call
  @glk 320 _vararg_count ret;
  return ret;
];

[ glk_request_line_event_uni _vararg_count ret;
! glk_request_line_event_uni (win buf maxlen initlen)
  ! And now the @glk call
  @glk 321 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
! glk_image_draw (win image val1 val2)
  ! And now the @glk call
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
! glk_image_draw_scaled (win image val1 val2 width height)
  ! And now the @glk call
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_image_get_info _vararg_count ret;
! glk_image_get_info (image width height)
  ! And now the @glk call
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count ret;
! glk_window_flow_break (win)
  ! And now the @glk call
  @glk 232 _vararg_count ret;
  return ret;
];

[ glk_window_erase_rect _vararg_count ret;
! glk_window_erase_rect (win left top width height)
  ! And now the @glk call
  @glk 233 _vararg_count ret;
  return ret;
];

[ glk_window_fill_rect _vararg_count ret;
! glk_window_fill_rect (win color left top width height)
  ! And now the @glk call
  @glk 234 _vararg_count ret;
  return ret;
];

[ glk_window_set_background_color _vararg_count ret;
! glk_window_set_background_color (win color)
  ! And now the @glk call
  @glk 235 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
! glk_schannel_create (rock)
  ! And now the @glk call
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count ret;
! glk_schannel_destroy (chan)
  ! And now the @glk call
  @glk 243 _vararg_count ret;
  return ret;
];

[ glk_schannel_iterate _vararg_count ret;
! glk_schannel_iterate (chan rockptr)
  ! And now the @glk call
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
! glk_schannel_get_rock (chan)
  ! And now the @glk call
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
! glk_schannel_play (chan snd)
  ! And now the @glk call
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
! glk_schannel_play_ext (chan snd repeats notify)
  ! And now the @glk call
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count ret;
! glk_schannel_stop (chan)
  ! And now the @glk call
  @glk 250 _vararg_count ret;
  return ret;
];

[ glk_schannel_set_volume _vararg_count ret;
! glk_schannel_set_volume (chan vol)
  ! And now the @glk call
  @glk 251 _vararg_count ret;
  return ret;
];

[ glk_sound_load_hint _vararg_count ret;
! glk_sound_load_hint (snd flag)
  ! And now the @glk call
  @glk 252 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink _vararg_count ret;
! glk_set_hyperlink (linkval)
  ! And now the @glk call
  @glk 256 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink_stream _vararg_count ret;
! glk_set_hyperlink_stream (str linkval)
  ! And now the @glk call
  @glk 257 _vararg_count ret;
  return ret;
];

[ glk_request_hyperlink_event _vararg_count ret;
! glk_request_hyperlink_event (win)
  ! And now the @glk call
  @glk 258 _vararg_count ret;
  return ret;
];

[ glk_cancel_hyperlink_event _vararg_count ret;
! glk_cancel_hyperlink_event (win)
  ! And now the @glk call
  @glk 259 _vararg_count ret;
  return ret;
];
#ENDIF;

Constant GG_MAINWIN_ROCK        201;
Constant GG_STATUSWIN_ROCK      202;
Constant GG_QUOTEWIN_ROCK       203;
Constant GG_SAVESTR_ROCK        301;
Constant GG_SCRIPTSTR_ROCK      302;
Constant GG_COMMANDWSTR_ROCK    303;
Constant GG_COMMANDRSTR_ROCK    304;
Constant GG_SCRIPTFREF_ROCK     401;
Constant GG_FOREGROUNDCHAN_ROCK 410;
Constant GG_BACKGROUNDCHAN_ROCK 411;

#Stub HandleGlkEvent    2;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;

[ VM_PreInitialise res;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

	unicode_gestalt_ok = false;
	if (glk_gestalt(gestalt_Unicode, 0))
		unicode_gestalt_ok = true;

    ! Set the VM's I/O system to be Glk.
    @setiosys 2 0;
];

[ VM_Initialise res sty i;
    @gestalt 4 2 res; ! Test if this interpreter has Glk...
    if (res == 0) quit; ! ...without which there would be nothing we could do

    ! First, we must go through all the Glk objects that exist, and see
    ! if we created any of them. One might think this strange, since the
    ! program has just started running, but remember that the player might
    ! have just typed "restart".

    GGRecoverObjects();

	! Sound channel initialisation, and RNG fixing, must be done now rather
	! than later in case InitGlkWindow() returns a non-zero value.

	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan == 0)
			gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK);
		if (gg_backgroundchan == 0)
			gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK);
	}

	#ifdef FIX_RNG;
	@random 10000 i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@setrandom i;
	#endif; ! FIX_RNG

    res = InitGlkWindow(0);
    if (res ~= 0) return;

    ! Now, gg_mainwin and gg_storywin might already be set. If not, set them.

    if (gg_mainwin == 0) {
        ! Open the story window.
        res = InitGlkWindow(GG_MAINWIN_ROCK);
        if (res == 0) {
        	! Left-justify the header style
			glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
			! Try to make emphasized type in italics and not boldface
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
			glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
		}
        if (gg_mainwin == 0) quit; ! If we can't even open one window, give in
    } else {
        ! There was already a story window. We should erase it.
        glk_window_clear(gg_mainwin);
    }

    if (gg_statuswin == 0) {
        res = InitGlkWindow(GG_STATUSWIN_ROCK);
        if (res == 0) {
            statuswin_cursize = statuswin_size;
			for (sty=0: sty<style_NUMSTYLES: sty++)
				glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            gg_statuswin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        }
    }
    ! It's possible that the status window couldn't be opened, in which case
    ! gg_statuswin is now zero. We must allow for that later on.

    glk_set_window(gg_mainwin);

    InitGlkWindow(1);
];

[ GGRecoverObjects id;
    ! If GGRecoverObjects() has been called, all these stored IDs are
    ! invalid, so we start by clearing them all out.
    ! (In fact, after a restoreundo, some of them may still be good.
    ! For simplicity, though, we assume the general case.)
    gg_mainwin = 0;
    gg_statuswin = 0;
    gg_quotewin = 0;
    gg_scriptfref = 0;
    gg_scriptstr = 0;
    gg_savestr = 0;
    statuswin_cursize = 0;
    gg_foregroundchan = 0;
    gg_backgroundchan = 0;
    #Ifdef DEBUG;
    gg_commandstr = 0;
    gg_command_reading = false;
    #Endif; ! DEBUG
    ! Also tell the game to clear its object references.
    IdentifyGlkObject(0);

    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SAVESTR_ROCK: gg_savestr = id;
            GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
            #Ifdef DEBUG;
            GG_COMMANDWSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = false;
            GG_COMMANDRSTR_ROCK: gg_commandstr = id;
                                 gg_command_reading = true;
            #Endif; ! DEBUG
            default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
        }
        id = glk_stream_iterate(id, gg_arguments);
    }

    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_MAINWIN_ROCK: gg_mainwin = id;
            GG_STATUSWIN_ROCK: gg_statuswin = id;
            GG_QUOTEWIN_ROCK: gg_quotewin = id;
            default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
        }
        id = glk_window_iterate(id, gg_arguments);
    }

    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        switch (gg_arguments-->0) {
            GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
            default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
        }
        id = glk_fileref_iterate(id, gg_arguments);
    }

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

    ! Tell the game to tie up any loose ends.
    IdentifyGlkObject(2);
];

[ ENABLE_GLULX_ACCEL_R addr res;
	@gestalt 9 0 res;
	if (res == 0) return;
	addr = #classes_table;
	@accelparam 0 addr;
	@accelparam 1 INDIV_PROP_START;
	@accelparam 2 Class;
	@accelparam 3 Object;
	@accelparam 4 Routine;
	@accelparam 5 String;
	addr = #globals_array + WORDSIZE * #g$self;
	@accelparam 6 addr;
	@accelparam 7 NUM_ATTR_BYTES;
	addr = #cpv__start;
	@accelparam 8 addr;
	@accelfunc 1 Z__Region;
	@accelfunc 2 CP__Tab;
	@accelfunc 3 RA__Pr;
	@accelfunc 4 RL__Pr;
	@accelfunc 5 OC__Cl;
	@accelfunc 6 RV__Pr;
	@accelfunc 7 OP__Pr;
	rfalse;
];

[ VM_Describe_Release i;
	print "Release ";
	@aloads ROM_GAMERELEASE 0 i;
	print i;
	print " / Serial number ";
	for (i=0 : i<6 : i++) print (char) ROM_GAMESERIAL->i;
];

[ VM_KeyChar win nostat done res ix jx ch;
    jx = ch; ! squash compiler warnings
    if (win == 0) win = gg_mainwin;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, gg_arguments, 31);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! fall through to normal user input.
        } else {
            ! Trim the trailing newline
            if (gg_arguments->(done-1) == 10) done = done-1;
            res = gg_arguments->0;
            if (res == '\') {
                res = 0;
                for (ix=1 : ix<done : ix++) {
                    ch = gg_arguments->ix;
                    if (ch >= '0' && ch <= '9') {
                        @shiftl res 4 res;
                        res = res + (ch-'0');
                    } else if (ch >= 'a' && ch <= 'f') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'a');
                    } else if (ch >= 'A' && ch <= 'F') {
                        @shiftl res 4 res;
                        res = res + (ch+10-'A');
                    }
                }
            }
       		jump KCPContinue;
        }
    }
    done = false;
    glk_request_char_event(win);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            if (nostat) {
                glk_cancel_char_event(win);
                res = $80000000;
                done = true;
                break;
            }
            DrawStatusLine();
          2: ! evtype_CharInput
            if (gg_event-->1 == win) {
                res = gg_event-->2;
                done = true;
                }
        }
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            res = gg_arguments-->0;
            done = true;
        } else if (ix == -1)  done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        if (res < 32 || res >= 256 || (res == '\' or ' ')) {
            glk_put_char_stream(gg_commandstr, '\');
            done = 0;
            jx = res;
            for (ix=0 : ix<8 : ix++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                ch = ch & $0F;
                if (ch ~= 0 || ix == 7) done = 1;
                if (done) {
                    if (ch >= 0 && ch <= 9) ch = ch + '0';
                    else                    ch = (ch - 10) + 'A';
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KCPContinue;
    return res;
];

[ VM_KeyDelay tenths  key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events(tenths*100);
    while (~~done) {
        glk_select(gg_event);
        ix = HandleGlkEvent(gg_event, 1, gg_arguments);
        if (ix == 2) {
            key = gg_arguments-->0;
            done = true;
        }
        else if (ix >= 0 && gg_event-->0 == 1 or 2) {
            key = gg_event-->2;
            done = true;
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];

[ VM_ReadKeyboard  a_buffer a_table done ix;
    if (gg_commandstr ~= 0 && gg_command_reading ~= false) {
        done = glk_get_line_stream(gg_commandstr, a_buffer+WORDSIZE,
        	(INPUT_BUFFER_LEN-WORDSIZE)-1);
        if (done == 0) {
            glk_stream_close(gg_commandstr, 0);
            gg_commandstr = 0;
            gg_command_reading = false;
            ! L__M(##CommandsRead, 5); would come after prompt
            ! fall through to normal user input.
        }
        else {
            ! Trim the trailing newline
            if ((a_buffer+WORDSIZE)->(done-1) == 10) done = done-1;
            a_buffer-->0 = done;
            VM_Style(INPUT_VMSTY);
            glk_put_buffer(a_buffer+WORDSIZE, done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    done = false;
    glk_request_line_event(gg_mainwin, a_buffer+WORDSIZE, INPUT_BUFFER_LEN-WORDSIZE, 0);
    while (~~done) {
        glk_select(gg_event);
        switch (gg_event-->0) {
          5: ! evtype_Arrange
            DrawStatusLine();
          3: ! evtype_LineInput
            if (gg_event-->1 == gg_mainwin) {
                a_buffer-->0 = gg_event-->2;
                done = true;
            }
        }
        ix = HandleGlkEvent(gg_event, 0, a_buffer);
        if (ix == 2) done = true;
        else if (ix == -1) done = false;
    }
    if (gg_commandstr ~= 0 && gg_command_reading == false) {
        glk_put_buffer_stream(gg_commandstr, a_buffer+WORDSIZE, a_buffer-->0);
        glk_put_char_stream(gg_commandstr, 10); ! newline
    }
  .KPContinue;
    VM_Tokenise(a_buffer,a_table);
    ! It's time to close any quote window we've got going.
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        gg_quotewin = 0;
    }
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (ix=WORDSIZE: ix<(a_buffer-->0)+WORDSIZE: ix++) print (char) a_buffer->ix;
    print "^";
    #endif; ! ECHO_COMMANDS
];

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if (metaclass(a) == Object && a.#b == WORDSIZE
            && metaclass(a.b) == String)
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a.b);
		else if (metaclass(a) == Routine)
			buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
        else
            buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b);
    }
    else if (metaclass(a) == Routine)
        buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a, b, c);
    else
		buf-->0 = Glulx_PrintAnyToArray(buf+WORDSIZE, len, a);
    if (buf-->0 > len) buf-->0 = len;
    return buf-->0;
];

[ VM_Tokenise buf tab
    cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    len = buf-->0;
    buf = buf+WORDSIZE;

    ! First, split the buffer up into words. We use the standard Infocom
    ! list of word separators (comma, period, double-quote).

    cx = 0;
    numwords = 0;
    while (cx < len) {
        while (cx < len && buf->cx == ' ') cx++;
        if (cx >= len) break;
        bx = cx;
        if (buf->cx == '.' or ',' or '"') cx++;
        else {
            while (cx < len && buf->cx ~= ' ' or '.' or ',' or '"') cx++;
        }
        tab-->(numwords*3+2) = (cx-bx);
        tab-->(numwords*3+3) = WORDSIZE+bx;
        numwords++;
        if (numwords >= MAX_BUFFER_WORDS) break;
    }
    tab-->0 = numwords;

    ! Now we look each word up in the dictionary.

    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;

    for (wx=0 : wx<numwords : wx++) {
        wlen = tab-->(wx*3+2);
        wpos = tab-->(wx*3+3);

        ! Copy the word into the gg_tokenbuf array, clipping to DICT_WORD_SIZE
        ! characters and lower case.
        if (wlen > DICT_WORD_SIZE) wlen = DICT_WORD_SIZE;
        cx = wpos - WORDSIZE;
        for (ix=0 : ix<wlen : ix++) gg_tokenbuf->ix = VM_UpperToLowerCase(buf->(cx+ix));
        for (: ix<DICT_WORD_SIZE : ix++) gg_tokenbuf->ix = 0;

        val = #dictionary_table + WORDSIZE;
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        tab-->(wx*3+1) = res;
    }
];

[ LTI_Insert i ch  b y;

    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b-->0;
    if (y > INPUT_BUFFER_LEN) y = INPUT_BUFFER_LEN;

    ! Move the subsequent text along one character:
    for (y=y+WORDSIZE : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b-->0 < INPUT_BUFFER_LEN) (b-->0)++;
];

[ VM_InvalidDictionaryAddress addr;
	if (addr < 0) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return w; ];
[ VM_NumberToDictionaryAddress n; return n; ];

Array gg_tokenbuf -> DICT_WORD_SIZE;

[ GGWordCompare str1 str2 ix jx;
    for (ix=0 : ix<DICT_WORD_SIZE : ix++) {
        jx = (str1->ix) - (str2->ix);
        if (jx ~= 0) return jx;
    }
    return 0;
];

#Ifdef DEBUG;
[ DebugAction a str;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
    else {
        str = #identifiers_table-->6;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed action ", a, ">";
    }
];

[ DebugAttribute a str;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
];
#Endif;

[ VM_CommandTableAddress i;
	return (#grammar_table)-->(i+1);
];

[ VM_PrintCommandWords i wd j dictlen entrylen;
    dictlen = #dictionary_table-->0;
    entrylen = DICT_WORD_SIZE + 7;
    for (j=0 : j<dictlen : j++) {
        wd = #dictionary_table + WORDSIZE + entrylen*j;
        if (DictionaryWordToVerbNum(wd) == i)
            print "'", (address) wd, "' ";
    }
];

[ VM_Seed_RNG n;
	@setrandom n;
];

[ VM_AllocateMemory amount i;
	@gestalt 7 0 i;
	if (i == 0) return i;
	@malloc amount i;
	return i;
];

[ VM_FreeMemory address i;
	@gestalt 7 0 i;
	if (i == 0) return;
	@mfree address;
];

[ VM_Picture resource_ID;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
];

[ VM_SoundEffect resource_ID;
	if (glk_gestalt(gestalt_Sound, 0)) {
		glk_schannel_play(gg_foregroundchan, resource_ID);
	} else {
		print "[Sound effect number ", resource_ID, " here.]^";
	}
];

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY:     glk_set_style(style_Normal);
		HEADER_VMSTY:     glk_set_style(style_Header);
		SUBHEADER_VMSTY:  glk_set_style(style_Subheader);
		NOTE_VMSTY:       glk_set_style(style_Note);
		ALERT_VMSTY:      glk_set_style(style_Alert);
		BLOCKQUOTE_VMSTY: glk_set_style(style_BlockQuote);
		INPUT_VMSTY:      glk_set_style(style_Input);
	}
];

[ VM_UpperToLowerCase c; return glk_char_to_lower(c); ];
[ VM_LowerToUpperCase c; return glk_char_to_upper(c); ];

! Glulx_PrintAnything()                    <nothing printed>
! Glulx_PrintAnything(0)                   <nothing printed>
! Glulx_PrintAnything("string");           print (string) "string";
! Glulx_PrintAnything('word')              print (address) 'word';
! Glulx_PrintAnything(obj)                 print (name) obj;
! Glulx_PrintAnything(obj, prop)           obj.prop();
! Glulx_PrintAnything(obj, prop, args...)  obj.prop(args...);
! Glulx_PrintAnything(func)                func();
! Glulx_PrintAnything(func, args...)       func(args...);

[ Glulx_PrintAnything _vararg_count obj mclass;
    if (_vararg_count == 0) return;
    @copy sp obj;
    _vararg_count--;
    if (obj == 0) return;

    if (obj->0 == $60) {
        ! Dictionary word. Metaclass() can't catch this case, so we do it manually
        print (address) obj;
        return;
    }

    mclass = metaclass(obj);
    switch (mclass) {
      nothing:
        return;
      String:
        print (string) obj;
        return;
      Routine:
        ! Call the function with all the arguments which are already
        ! on the stack.
        @call obj _vararg_count 0;
        return;
      Object:
        if (_vararg_count == 0) {
            print (name) obj;
        }
        else {
            ! Push the object back onto the stack, and call the
            ! veneer routine that handles obj.prop() calls.
            @copy obj sp;
            _vararg_count++;
            @call CA__Pr _vararg_count 0;
        }
        return;
    }
];

[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    _vararg_count = _vararg_count - 2;

    oldstr = glk_stream_get_current();
    str = glk_stream_open_memory(arr, arrlen, 1, 0);
    if (str == 0) return 0;

    glk_stream_set_current(str);

    @call Glulx_PrintAnything _vararg_count 0;

    glk_stream_set_current(oldstr);
    @copy $ffffffff sp;
    @copy str sp;
    @glk $0044 2 0; ! stream_close
    @copy sp len;
    @copy sp 0;
    return len;
];

Constant GG_ANYTOSTRING_LEN 66;
Array AnyToStrArr -> GG_ANYTOSTRING_LEN+1;

[ Glulx_ChangeAnyToCString _vararg_count ix len;
    ix = GG_ANYTOSTRING_LEN-2;
    @copy ix sp;
    ix = AnyToStrArr+1;
    @copy ix sp;
    ix = _vararg_count+2;
    @call Glulx_PrintAnyToArray ix len;
    AnyToStrArr->0 = $E0;
    if (len >= GG_ANYTOSTRING_LEN)
        len = GG_ANYTOSTRING_LEN-1;
    AnyToStrArr->(len+1) = 0;
    return AnyToStrArr;
];

[ VM_ClearScreen window;
    if (window == WIN_ALL or WIN_MAIN) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            gg_quotewin = 0;
        }
    }
    if (gg_statuswin && window == WIN_ALL or WIN_STATUS) glk_window_clear(gg_statuswin);
];

[ VM_ScreenWidth  id;
    id=gg_mainwin;
    if (gg_statuswin && statuswin_current) id = gg_statuswin;
    glk_window_get_size(id, gg_arguments, 0);
    return gg_arguments-->0;
];

[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return gg_arguments-->0;
];

[ VM_SetWindowColours f b window doclear  i fwd bwd swin;
    if (clr_on && f && b) {
        if (window) swin = 5-window; ! 4 for TextGrid, 3 for TextBuffer

        fwd = MakeColourWord(f);
        bwd = MakeColourWord(b);
        for (i=0 : i<style_NUMSTYLES: i++) {
            if (f == CLR_DEFAULT || b == CLR_DEFAULT) {  ! remove style hints
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }

        ! Now re-open the windows to apply the hints
        if (gg_statuswin) glk_window_close(gg_statuswin, 0);
        gg_statuswin = 0;

        if (doclear || ( window ~= 1 && (clr_fg ~= f || clr_bg ~= b) ) ) {
            glk_window_close(gg_mainwin, 0);
            gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK);
            if (gg_scriptstr ~= 0)
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
        }

        gg_statuswin =
        	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
        		statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK);
        if (statuswin_current && gg_statuswin) VM_MoveCursorInStatusLine(); else VM_MainWindow();

        if (window ~= 2) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window ~= 1) {
            clr_fg = f;
            clr_bg = b;
        }
    }
];

[ VM_RestoreWindowColours; ! used after UNDO: compare I6 patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
];

[ MakeColourWord c;
    if (c > 9) return c;
    c = c-2;
    return $ff0000*(c&1) + $ff00*(c&2 ~= 0) + $ff*(c&4 ~= 0);
];

[ VM_MainWindow;
    glk_set_window(gg_mainwin); ! set_window
    statuswin_current=0;
];

[ VM_StatusLineHeight hgt;
    if (gg_statuswin == 0) return;
    if (hgt == statuswin_cursize) return;
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), $12, hgt, 0);
    statuswin_cursize = hgt;
];

[ VM_MoveCursorInStatusLine line column;
    if (gg_statuswin == 0) return;
    glk_set_window(gg_statuswin);
    if (line == 0) { line = 1; column = 1; }
    glk_window_move_cursor(gg_statuswin, column-1, line-1);
    statuswin_current=1;
];

[ Box__Routine maxwid arr ix lines lastnl parwin;
    maxwid = 0; ! squash compiler warning
    lines = arr-->0;

    if (gg_quotewin == 0) {
        gg_arguments-->0 = lines;
        ix = InitGlkWindow(GG_QUOTEWIN_ROCK);
        if (ix == 0)
            gg_quotewin =
            	glk_window_open(gg_mainwin, winmethod_Fixed + winmethod_Above,
            		lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK);
    } else {
        parwin = glk_window_get_parent(gg_quotewin);
        glk_window_set_arrangement(parwin, $12, lines, 0);
    }

    lastnl = true;
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        lastnl = false;
    }

	VM_Style(BLOCKQUOTE_VMSTY);
    for (ix=0 : ix<lines : ix++) {
        print (string) arr-->(ix+1);
        if (ix < lines-1 || lastnl) new_line;
    }
	VM_Style(NORMAL_VMSTY);

    if (gg_quotewin) glk_set_window(gg_mainwin);
];

#Ifdef DEBUG;
[ GlkListSub id val;
    id = glk_window_iterate(0, gg_arguments);
    while (id) {
        print "Window ", id, " (", gg_arguments-->0, "): ";
        val = glk_window_get_type(id);
        switch (val) {
          1: print "pair";
          2: print "blank";
          3: print "textbuffer";
          4: print "textgrid";
          5: print "graphics";
          default: print "unknown";
        }
        val = glk_window_get_parent(id);
        if (val) print ", parent is window ", val;
        else     print ", no parent (root)";
        val = glk_window_get_stream(id);
        print ", stream ", val;
        val = glk_window_get_echo_stream(id);
        if (val) print ", echo stream ", val;
        print "^";
        id = glk_window_iterate(id, gg_arguments);
    }
    id = glk_stream_iterate(0, gg_arguments);
    while (id) {
        print "Stream ", id, " (", gg_arguments-->0, ")^";
        id = glk_stream_iterate(id, gg_arguments);
    }
    id = glk_fileref_iterate(0, gg_arguments);
    while (id) {
        print "Fileref ", id, " (", gg_arguments-->0, ")^";
        id = glk_fileref_iterate(id, gg_arguments);
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        id = glk_schannel_iterate(0, gg_arguments);
        while (id) {
            print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
            id = glk_schannel_iterate(id, gg_arguments);
        }
    }
];

Verb meta 'glklist'

    *                                           -> Glklist;
#Endif;

[ VM_Undo result_code;
	@restoreundo result_code;
	return (~~result_code);
];

[ VM_Save_Undo result_code;
    @saveundo result_code;
    if (result_code == -1) { GGRecoverObjects(); return 2; }
    return (~~result_code);
];

[ QUIT_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Quit, 2); if (YesOrNo()~=0) quit;
];

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Restart, 1);
	if (YesOrNo() ~= 0) {
		@restart;
		GL__M(##Restart, 2);
	}
];

[ RESTORE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $02, 0);
	if (fref == 0) jump RFailed;
	gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump RFailed;
	@restore gg_savestr res;
	glk_stream_close(gg_savestr, 0);
	gg_savestr = 0;
	.RFailed;
	GL__M(##Restore, 1);
];

[ SAVE_THE_GAME_R res fref;
	if (actor ~= player) rfalse;
	fref = glk_fileref_create_by_prompt($01, $01, 0);
	if (fref == 0) jump SFailed;
	gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
	glk_fileref_destroy(fref);
	if (gg_savestr == 0) jump SFailed;
	@save gg_savestr res;
	if (res == -1) {
		! The player actually just typed "restore". We're going to print
		!  GL__M(##Restore,2); the Z-Code Inform library does this correctly
		! now. But first, we have to recover all the Glk objects; the values
		! in our global variables are all wrong.
		GGRecoverObjects();
		glk_stream_close(gg_savestr, 0); ! stream_close
		gg_savestr = 0;
		return GL__M(##Restore, 2);
	}
	glk_stream_close(gg_savestr, 0); ! stream_close
	gg_savestr = 0;
	if (res == 0) return GL__M(##Save, 2);
	.SFailed;
	GL__M(##Save, 1);
];

[ VERIFY_THE_STORY_FILE_R res;
	if (actor ~= player) rfalse;
	@verify res;
	if (res == 0) return GL__M(##Verify, 1);
	GL__M(##Verify, 2);
];

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) return GL__M(##ScriptOn, 1);
	if (gg_scriptfref == 0) {
		gg_scriptfref = glk_fileref_create_by_prompt($102, $05, GG_SCRIPTFREF_ROCK);
		if (gg_scriptfref == 0) jump S1Failed;
	}
	! stream_open_file
	gg_scriptstr = glk_stream_open_file(gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	if (gg_scriptstr == 0) jump S1Failed;
	glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
	GL__M(##ScriptOn, 2);
	VersionSub();
	return;
	.S1Failed;
	GL__M(##ScriptOn, 3);
];

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff, 2);
	glk_stream_close(gg_scriptstr, 0); ! stream_close
	gg_scriptstr = 0;
];

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	@gestalt 1 0 ix;
	print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	".", ix & $FF, " / ";
	@gestalt 0 0 ix;
	print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	ShowExtensionVersions();
	say__p = 1;
];

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->(action+1));
	rtrue;
];

#Endif;

#Ifdef TARGET_ZCODE;
Global top_object; ! largest valid number of any tree object
Global xcommsdir; ! true if command recording is on
Global transcript_mode; ! true if game scripting is on

Constant INPUT_BUFFER_LEN = 120; ! Length of buffer array

Array  buffer    -> 123;            ! Buffer for parsing main line of input
Array  buffer2   -> 123;            ! Buffers for supplementary questions
Array  buffer3   -> 123;            ! Buffer retaining input for "again"
Array  parse     buffer 63;         ! Parse table mirroring it
Array  parse2    buffer 63;         !

Global dict_start;
Global dict_entry_size;
Global dict_end;

[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	transcript_mode = ((HDR_GAMEFLAGS-->0) & 1);

	dict_start = HDR_DICTIONARY-->0;
	dict_entry_size = dict_start->(dict_start->0 + 1);
	dict_start = dict_start + dict_start->0 + 4;
	dict_end = dict_start + ((dict_start - 2)-->0) * dict_entry_size;

	buffer->0  = INPUT_BUFFER_LEN;
	buffer2->0 = INPUT_BUFFER_LEN;
	buffer3->0 = INPUT_BUFFER_LEN;
	parse->0   = 15;
	parse2->0  = 15;

	top_object = #largest_object-255;

	#ifdef FIX_RNG;
	@random 10000 -> i;
	i = -i-2000;
	print "[Random number generator seed is ", i, "]^";
	@random i -> i;
	#endif; ! FIX_RNG	
];

[ ENABLE_GLULX_ACCEL_R;
	rfalse;
];

[ VM_Describe_Release i;
	print "Release ", (HDR_GAMERELEASE-->0) & $03ff, " / Serial number ";
	for (i=0 : i<6 : i++) print (char) HDR_GAMESERIAL->i;
];

[ VM_KeyChar win  key;
    if (win) @set_window win;
    @read_char 1 -> key;
    return key;
];

[ VM_KeyDelay tenths  key;
    @read_char 1 tenths VM_KeyDelay_Interrupt -> key;
    return key;
];
[ VM_KeyDelay_Interrupt; rtrue; ];

[ VM_ReadKeyboard  a_buffer a_table i;
    read a_buffer a_table;
    #ifdef ECHO_COMMANDS;
    print "** ";
    for (i=2: i<=(a_buffer->1)+1: i++) print (char) a_buffer->i;
    print "^";
    #ifnot;
    i=0;  ! suppress compiler warning
    #endif;

    #Iftrue (#version_number == 6);
    @output_stream -1;
    @loadb a_buffer 1 -> sp;
    @add a_buffer 2 -> sp;
    @print_table sp sp;
    new_line;
    @output_stream 1;
    #Endif;
];

[ VM_CopyBuffer bto bfrom i;
    for (i=0: i<INPUT_BUFFER_LEN: i++) bto->i = bfrom->i;
];

[ VM_PrintToBuffer buf len a b c;
    @output_stream 3 buf;
    switch (metaclass(a)) {
		String: print (string) a;
		Routine: a(b, c);
		Object, Class: if (b) PrintOrRun(a, b, true); else print (name) a;
    }
    @output_stream -3;
    if (buf-->0 > len) print "Error: Overflow in VM_PrintToBuffer.^";
    return buf-->0;
];

[ VM_Tokenise b p; b->(2 + b->1) = 0; @tokenise b p; ];

[ LTI_Insert i ch  b y;
    ! Protect us from strict mode, as this isn't an array in quite the
    ! sense it expects
    b = buffer;

    ! Insert character ch into buffer at point i.
    ! Being careful not to let the buffer possibly overflow:
    y = b->1;
    if (y > b->0) y = b->0;

    ! Move the subsequent text along one character:
    for (y=y+2 : y>i : y--) b->y = b->(y-1);
    b->i = ch;

    ! And the text is now one character longer:
    if (b->1 < b->0) (b->1)++;
];

[ VM_InvalidDictionaryAddress addr;
    if ((UnsignedCompare(addr, dict_start) < 0) ||
		(UnsignedCompare(addr, dict_end) >= 0) ||
		((addr - dict_start) % dict_entry_size ~= 0)) rtrue;
	rfalse;
];

[ VM_DictionaryAddressToNumber w; return (w-(HDR_DICTIONARY-->0 + 7))/9; ];
[ VM_NumberToDictionaryAddress n; return HDR_DICTIONARY-->0 + 7 + 9*n; ];

[ VM_CommandTableAddress i;
	return (HDR_STATICMEMORY-->0)-->i;
];

[ VM_PrintCommandWords i da j;
    da = HDR_DICTIONARY-->0;
    for (j=0 : j<(da+5)-->0 : j++)
        if (da->(j*9 + 14) == $ff-i)
        	print "'", (address) VM_NumberToDictionaryAddress(j), "' ";
];

#Ifdef DEBUG;
[ DebugAction a anames;
    if (a >= 4096) { print "<fake action ", a-4096, ">"; return; }
    anames = #identifiers_table;
    anames = anames + 2*(anames-->0) + 2*48;
    print (string) anames-->a;
];

[ DebugAttribute a anames;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
];
#Endif;

[ VM_Seed_RNG n;
	if (n > 0) n = -n;
	@random n -> n;
];

[ VM_AllocateMemory amount;
	return 0;
];

[ VM_FreeMemory address;
];

[ VM_Picture resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@draw_picture resource_ID;
	#ENDIF;
];

[ VM_SoundEffect resource_ID;
	#IFTRUE #version_number == 6; ! Z-machine version 6
	@sound_effect resource_ID;
	#ENDIF;
];

[ VM_Style sty;
	switch (sty) {
		NORMAL_VMSTY, NOTE_VMSTY: style roman;
		HEADER_VMSTY, SUBHEADER_VMSTY, ALERT_VMSTY: style bold;
	}
];

[ VM_UpperToLowerCase c;
   switch (c) {
     'A' to 'Z': c = c + 32;
     202, 204, 212, 214, 221: c--;
     217, 218: c = c - 2;
     158 to 160, 167 to 169, 208 to 210: c = c - 3;
     186 to 190, 196 to 200: c = c - 5 ;
     175 to 180: c = c - 6;
   }
   return c;
];

[ VM_LowerToUpperCase c;
   switch (c) {
     'a' to 'z': c = c - 32;
     201, 203, 211, 213, 220: c++;
     215, 216: c = c + 2;
     155 to 157, 164 to 166, 205 to 207: c = c + 3;
     181 to 185, 191 to 195: c = c + 5 ;
     169 to 174: c = c + 6;
   }
   return c;
];

[ VM_ClearScreen window;
    switch (window) {
		WIN_ALL:    @erase_window -1; statuswin_cursize = 0;
		WIN_STATUS: @erase_window 1;
		WIN_MAIN:   @erase_window 0;
    }
];

#Iftrue (#version_number == 6);
[ VM_ScreenWidth  width charw;
    @get_wind_prop 1 3 -> width;
    @get_wind_prop 1 13 -> charw;
    charw = charw & $FF;
    return (width+charw-1) / charw;
];
#Ifnot;
[ VM_ScreenWidth; return (HDR_SCREENWCHARS->0); ];
#Endif;

[ VM_ScreenHeight; return (HDR_SCREENHLINES->0); ];

[ VM_SetWindowColours f b window;
    if (clr_on && f && b) {
        if (window == 0) {  ! if setting both together, set reverse
            clr_fgstatus = b;
            clr_bgstatus = f;
            }
        if (window == 1) {
            clr_fgstatus = f;
            clr_bgstatus = b;
        }
        if (window == 0 or 2) {
            clr_fg = f;
            clr_bg = b;
        }
        if (statuswin_current)
            @set_colour clr_fgstatus clr_bgstatus;
        else
            @set_colour clr_fg clr_bg;
    }
];

[ VM_RestoreWindowColours; ! compare I6 library patch L61007
    if (clr_on) { ! check colour has been used
        VM_SetWindowColours(clr_fg, clr_bg, 2); ! make sure both sets of variables are restored
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, true);
        VM_ClearScreen();
    }
    #Iftrue (#version_number == 6); ! request screen update
    (0-->8) = (0-->8) | $$00000100;
    #Endif;
];

[ VM_MainWindow;
    if (statuswin_current) {
        if (clr_on && clr_bgstatus > 1) @set_colour clr_fg clr_bg;
        else style roman;
        @set_window 0;
    }
    statuswin_current = false;
];

[ VM_MoveCursorInStatusLine line column; ! 1-based position on text grid
    if (~~statuswin_current) {
         @set_window 1;
         if (clr_on && clr_bgstatus > 1) @set_colour clr_fgstatus clr_bgstatus;
         else                            style reverse;
    }
    if (line == 0) {
        line = 1;
        column = 1;
    }
    #Iftrue (#version_number == 6);
    Z6_MoveCursor(line, column);
    #Ifnot;
    @set_cursor line column;
    #Endif;
	statuswin_current = true;
];

#Iftrue (#version_number == 6);
[ Z6_MoveCursor line column  charw charh; ! 1-based position on text grid
	@get_wind_prop 1 13 -> charw; ! font size
	@log_shift charw $FFF8 -> charh;
	charw = charw / $100;
	line = 1 + charh*(line-1);
	column = 1 + charw*(column-1);
	@set_cursor line column;
];
#Endif;

#Iftrue (#version_number == 6);
[ VM_StatusLineHeight height  wx wy x y charh;
    ! Split the window. Standard 1.0 interpreters should keep the window 0
    ! cursor in the same absolute position, but older interpreters,
    ! including Infocom's don't - they keep the window 0 cursor in the
    ! same position relative to its origin. We therefore compensate
    ! manually.
    @get_wind_prop 0 0 -> wy; @get_wind_prop 0 1 -> wx;
    @get_wind_prop 0 13 -> charh; @log_shift charh $FFF8 -> charh;
    @get_wind_prop 0 4 -> y; @get_wind_prop 0 5 -> x;
    height = height * charh;
    @split_window height;
    y = y - height + wy - 1;
    if (y < 1) y = 1;
    x = x + wx - 1;
    @set_cursor y x 0;
    statuswin_cursize = height;
];
#Ifnot;
[ VM_StatusLineHeight height;
    if (statuswin_cursize ~= height)
        @split_window height;
    statuswin_cursize = height;
];
#Endif;

#Iftrue (#version_number == 6);
[ Z6_DrawStatusLine width x charw scw;
	(0-->8) = (0-->8) &~ $$00000100;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	VM_MoveCursorInStatusLine(1, 1);
	@set_font 4 -> x;
	width = VM_ScreenWidth();
	spaces width;
	ClearParagraphing();
	if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
		! Back to standard font for the display. We use output_stream 3 to
		! measure the space required, the aim being to get 50 characters
		! worth of space for the location name.
		VM_MoveCursorInStatusLine(1, 2);
		@set_font 1 -> x;
		switch (metaclass(left_hand_status_line)) {
			String: print (string) left_hand_status_line;
			Routine: left_hand_status_line();
		}
		@get_wind_prop 1 3 -> width;
		@get_wind_prop 1 13 -> charw;
		charw = charw & $FF;
		@output_stream 3 StorageForShortName;
		print (PrintText) right_hand_status_line;
		@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
		x = 1+width-scw;
		@set_cursor 1 x; print (PrintText) right_hand_status_line;
	}
	! Reselect roman, as Infocom's interpreters go funny if reverse is selected twice.
	VM_MainWindow();
	ClearParagraphing();
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;

[ VM_Undo result_code;
	@restore_undo result_code;
	return result_code;
];

[ VM_Save_Undo result_code;
    @save_undo result_code;
	return result_code;
];

[ QUIT_THE_GAME_R; if (actor ~= player) rfalse;
	GL__M(##Quit,2); if (YesOrNo()~=0) quit; ];

[ RESTART_THE_GAME_R;
	if (actor ~= player) rfalse;
	GL__M(##Restart,1);
	if (YesOrNo()~=0) { @restart; GL__M(##Restart,2); }
];

[ RESTORE_THE_GAME_R;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	return GL__M(##Restore,1);
	.RMaybe; GL__M(##Restore,2);
];

[ SAVE_THE_GAME_R flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: GL__M(##Save,1);
		1: GL__M(##Save,2);
		2: GL__M(##Restore,2);
	}
	#IFNOT;
	save Smaybe;
	return GL__M(##Save,1);
	.SMaybe; GL__M(##Save,2);
	#ENDIF;
];

[ VERIFY_THE_STORY_FILE_R;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; return GL__M(##Verify,1);
	.Vwrong;
	GL__M(##Verify,2);
];

[ SWITCH_TRANSCRIPT_ON_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) return GL__M(##ScriptOn,1);
	@output_stream 2;
	if (((0-->8) & 1) == 0) return GL__M(##ScriptOn,3);
	GL__M(##ScriptOn,2); VersionSub();
	transcript_mode = true;
];

[ SWITCH_TRANSCRIPT_OFF_R;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff,2);
	@output_stream -2;
	if ((0-->8) & 1) return GL__M(##ScriptOff,3);
	transcript_mode = false;
];

[ ANNOUNCE_STORY_FILE_VERSION_R ix;
	if (actor ~= player) rfalse;
	Banner();
	print "Identification number: ";
	for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	print "^";
	ix = 0; ! shut up compiler warning
	if (standard_interpreter > 0) {
		print "Standard interpreter ",
			standard_interpreter/256, ".", standard_interpreter%256,
			" (", HDR_TERPNUMBER->0;
		#Iftrue (#version_number == 6);
		print (char) '.', HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print ") / ";
	} else {
		print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		#Iftrue (#version_number == 6);
		print HDR_TERPVERSION->0;
		#Ifnot;
		print (char) HDR_TERPVERSION->0;
		#Endif;
		print " / ";
	}
	print "Library serial number ", (string) LibSerial, "^";
	#Ifdef LanguageVersion;
	print (string) LanguageVersion, "^";
	#Endif; ! LanguageVersion
	#ifdef ShowExtensionVersions;
	ShowExtensionVersions();
	#endif;
	say__p = 1;
];

[ DESCEND_TO_SPECIFIC_ACTION_R;
	indirect(#actions_table-->action);
	rtrue;
];

[ OhLookItsReal; ];
[ OhLookItsRoom; ];
[ OhLookItsThing; ];

[ OC__Cl obj cla j a n objflag;

!	if (cla > 4) OhLookItsReal();
!	if (cla == K1_room) OhLookItsRoom();
!	if (cla == K2_thing) OhLookItsThing();

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	@je cla K1_room ?~NotRoom;
	@test_attr obj mark_as_room ?rtrue;
	@rfalse;
	.NotRoom;
	@je cla K2_thing ?~NotObj;
	@test_attr obj mark_as_thing ?rtrue;
	@rfalse;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];

[ Unsigned__Compare x y u v;
	@je x y ?rfalse; ! i.e., return 0
	@jl x 0 ?XNegative;
	! So here x >= 0 and x ~= y
	@jl y 0 ?XPosYNeg;

	! Here x >=0, y >= 0, x ~= y

	@jg x y ?rtrue; ! i.e., return 1
	@ret -1;

	.XPosYNeg;
	! Here x >= 0, y < 0, x ~= y
	@ret -1;

	.XNegative;
	@jl y 0 ?~rtrue; ! if x < 0, y >= 0, return 1
	
	! Here x < 0, y < 0, x ~= y
	@jg x y ?rtrue;
	@ret -1;
];

[ RT__ChLDW base offset;
    @loadw base offset -> sp;
    @ret sp;
];

#Endif;

Object Compass "compass" has concealed;

Constant AGAIN1__WD     = 'again';
Constant AGAIN2__WD     = 'g//';
Constant AGAIN3__WD     = 'again';
Constant OOPS1__WD      = 'oops';
Constant OOPS2__WD      = 'o//';
Constant OOPS3__WD      = 'oops';
Constant UNDO1__WD      = 'undo';
Constant UNDO2__WD      = 'undo';
Constant UNDO3__WD      = 'undo';

Constant ALL1__WD       = 'all';
Constant ALL2__WD       = 'each';
Constant ALL3__WD       = 'every';
Constant ALL4__WD       = 'everything';
Constant ALL5__WD       = 'both';
Constant AND1__WD       = 'and';
Constant AND2__WD       = 'and';
Constant AND3__WD       = 'and';
Constant BUT1__WD       = 'but';
Constant BUT2__WD       = 'except';
Constant BUT3__WD       = 'but';
Constant ME1__WD        = 'me';
Constant ME2__WD        = 'myself';
Constant ME3__WD        = 'self';
Constant OF1__WD        = 'of';
Constant OF2__WD        = 'of';
Constant OF3__WD        = 'of';
Constant OF4__WD        = 'of';
Constant OTHER1__WD     = 'another';
Constant OTHER2__WD     = 'other';
Constant OTHER3__WD     = 'other';
Constant THEN1__WD      = 'then';
Constant THEN2__WD      = 'then';
Constant THEN3__WD      = 'then';

Constant NO1__WD        = 'n//';
Constant NO2__WD        = 'no';
Constant NO3__WD        = 'no';
Constant YES1__WD       = 'y//';
Constant YES2__WD       = 'yes';
Constant YES3__WD       = 'yes';

Constant AMUSING__WD    = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD      = 'q//';
Constant QUIT2__WD      = 'quit';
Constant RESTART__WD    = 'restart';
Constant RESTORE__WD    = 'restore';

Array LanguagePronouns table

  ! word        possible GNAs                   connected
  !             to follow:                      to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'it'      $$001000111000                    NULL
    'him'     $$100000000000                    NULL
    'her'     $$010000000000                    NULL
    'them'    $$000111000111                    NULL;

Array LanguageDescriptors table

  ! word        possible GNAs   descriptor      connected
  !             to follow:      type:           to:
  !             a     i
  !             s  p  s  p
  !             mfnmfnmfnmfn

    'my'      $$111111111111    POSSESS_PK      0
    'this'    $$111111111111    POSSESS_PK      0
    'these'   $$000111000111    POSSESS_PK      0
    'that'    $$111111111111    POSSESS_PK      1
    'those'   $$000111000111    POSSESS_PK      1
    'his'     $$111111111111    POSSESS_PK      'him'
    'her'     $$111111111111    POSSESS_PK      'her'
    'their'   $$111111111111    POSSESS_PK      'them'
    'its'     $$111111111111    POSSESS_PK      'it'
    'the'     $$111111111111    DEFART_PK       NULL
    'a//'     $$111000111000    INDEFART_PK     NULL
    'an'      $$111000111000    INDEFART_PK     NULL
    'some'    $$000111000111    INDEFART_PK     NULL
    'lit'     $$111111111111    light           NULL
    'lighted' $$111111111111    light           NULL
    'unlit'   $$111111111111    (-light)        NULL;

Array LanguageNumbers table
    'one' 1 'two' 2 'three' 3 'four' 4 'five' 5
    'six' 6 'seven' 7 'eight' 8 'nine' 9 'ten' 10
    'eleven' 11 'twelve' 12 'thirteen' 13 'fourteen' 14 'fifteen' 15
    'sixteen' 16 'seventeen' 17 'eighteen' 18 'nineteen' 19 'twenty' 20
    'twenty-one' 21 'twenty-two' 22 'twenty-three' 23 'twenty-four' 24
	'twenty-five' 25 'twenty-six' 26 'twenty-seven' 27 'twenty-eight' 28
	'twenty-nine' 29 'thirty' 30
;

[ LanguageNumber n f;
    if (n == 0)    { print "zero"; rfalse; }
    if (n < 0)     { print "minus "; n = -n; }
#Iftrue (WORDSIZE == 4);
    if (n >= 1000000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000000, " billion"; n = n%1000000000; f = 1;
    }
    if (n >= 1000000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000000, " million"; n = n%1000000; f = 1;
    }
#Endif;
    if (n >= 1000) {
        if (f == 1) print ", ";
    	print (LanguageNumber) n/1000, " thousand"; n = n%1000; f = 1;
    }
    if (n >= 100)  {
        if (f == 1) print ", ";
        print (LanguageNumber) n/100, " hundred"; n = n%100; f = 1;
    }
    if (n == 0) rfalse;
    #Ifdef DIALECT_US;
    if (f == 1) print " ";
    #Ifnot;
    if (f == 1) print " and ";
    #Endif;
    switch (n) {
      1:    print "one";
      2:    print "two";
      3:    print "three";
      4:    print "four";
      5:    print "five";
      6:    print "six";
      7:    print "seven";
      8:    print "eight";
      9:    print "nine";
      10:   print "ten";
      11:   print "eleven";
      12:   print "twelve";
      13:   print "thirteen";
      14:   print "fourteen";
      15:   print "fifteen";
      16:   print "sixteen";
      17:   print "seventeen";
      18:   print "eighteen";
      19:   print "nineteen";
      20 to 99: switch (n/10) {
        2:  print "twenty";
        3:  print "thirty";
        4:  print "forty";
        5:  print "fifty";
        6:  print "sixty";
        7:  print "seventy";
        8:  print "eighty";
        9:  print "ninety";
        }
        if (n%10 ~= 0) print "-", (LanguageNumber) n%10;
    }
];

[ LanguageTimeOfDay hours mins i;
    i = hours%12;
    if (i == 0) i = 12;
    if (i < 10) print " ";
    print i, ":", mins/10, mins%10;
    if ((hours/12) > 0) print " pm"; else print " am";
];

[ LanguageDirection d;
	print (name) d;
];

[ LanguageToInformese; ];

Constant LanguageAnimateGender   = male;
Constant LanguageInanimateGender = neuter;

Constant LanguageContractionForms = 2;     ! English has two:
                                           ! 0 = starting with a consonant
                                           ! 1 = starting with a vowel

[ LanguageContraction text;
    if (text->0 == 'a' or 'e' or 'i' or 'o' or 'u'
                or 'A' or 'E' or 'I' or 'O' or 'U') return 1;
    return 0;
];

Array LanguageArticles -->

 !   Contraction form 0:     Contraction form 1:
 !   Cdef   Def    Indef     Cdef   Def    Indef

     "The " "the " "a "      "The " "the " "an "          ! Articles 0
     "The " "the " "some "   "The " "the " "some ";       ! Articles 1

                   !             a           i
                   !             s     p     s     p
                   !             m f n m f n m f n m f n

Array LanguageGNAsToArticles --> 0 0 0 1 1 1 0 0 0 1 1 1;

[ LanguageVerb i;
    switch (i) {
      'i//','inv','inventory':
               print "take inventory";
      'l//':   print "look";
      'x//':   print "examine";
      'z//':   print "wait";
      default: rfalse;
    }
    rtrue;
];

[ LanguageVerbLikesAdverb w;
    if (w == 'look' or 'go' or 'push' or 'walk')
        rtrue;
    rfalse;
];

[ LanguageVerbMayBeName w;
    if (w == 'long' or 'short' or 'normal'
                    or 'brief' or 'full' or 'verbose')
        rtrue;
    rfalse;
];

Constant NKEY__TX       = "N = next subject";
Constant PKEY__TX       = "P = previous";
Constant QKEY1__TX      = "  Q = resume game";
Constant QKEY2__TX      = "Q = previous menu";
Constant RKEY__TX       = "RETURN = read subject";

Constant NKEY1__KY      = 'N';
Constant NKEY2__KY      = 'n';
Constant PKEY1__KY      = 'P';
Constant PKEY2__KY      = 'p';
Constant QKEY1__KY      = 'Q';
Constant QKEY2__KY      = 'q';

Constant SCORE__TX      = "Score: ";
Constant MOVES__TX      = "Moves: ";
Constant TIME__TX       = "Time: ";
Global CANTGO__TX     = "You can't go that way.";
Global FORMER__TX     = "your former self";
Global YOURSELF__TX   = "yourself";
Constant YOU__TX        = "You";
Constant DARKNESS__TX   = "Darkness";

Constant THOSET__TX     = "those things";
Constant THAT__TX       = "that";
Constant OR__TX         = " or ";
Constant NOTHING__TX    = "nothing";
Constant NOTHING2__TX    = "Nothing";
Global IS__TX         = " is";
Global ARE__TX        = " are";
Global IS2__TX        = "is ";
Global ARE2__TX       = "are ";
Global IS3__TX        = "is";
Global ARE3__TX       = "are";
Constant AND__TX        = " and ";
#ifdef SERIAL_COMMA;
Constant LISTAND__TX   = ", and ";
Constant LISTAND2__TX  = " and ";
#ifnot;
Constant LISTAND__TX   = " and ";
Constant LISTAND2__TX  = " and ";
#endif; ! SERIAL_COMMA
Constant WHOM__TX       = "whom ";
Constant WHICH__TX      = "which ";
Constant COMMA__TX      = ", ";

[ ThatorThose obj;      ! Used in the accusative
    if (obj == player)            { print "you"; return; }
    if (obj has pluralname)       { print "those"; return; }
    if (obj has animate) {
        if (obj has female)       { print "her"; return; }
        else
            if (obj hasnt neuter) { print "him"; return; }
    }
    print "that";
];

[ ItorThem obj;
    if (obj == player)            { print "yourself"; return; }
    if (obj has pluralname)       { print "them"; return; }
    if (obj has animate) {
        if (obj has female)       { print "her"; return; }
        else
            if (obj hasnt neuter) { print "him"; return; }
    }
    print "it";
];

[ IsorAre obj;
    if (obj has pluralname || obj == player) print "are"; else print "is";
];

[ HasorHave obj;
    if (obj has pluralname || obj == player) print "have"; else print "has";
];

[ CThatorThose obj;     ! Used in the nominative
    if (obj == player)            { print "You"; return; }
    if (obj has pluralname)       { print "Those"; return; }
    if (obj has animate) {
        if (obj has female)       { print "She"; return; }
        else
            if (obj hasnt neuter) { print "He"; return; }
    }
    print "That";
];

[ CTheyreorThats obj;
    if (obj == player)             { print "You're"; return; }
    if (obj has pluralname)        { print "They're"; return; }
    if (obj has animate) {
        if (obj has female)        { print "She's"; return; }
        else if (obj hasnt neuter) { print "He's"; return; }
    }
    print "That's";
];

[ HisHerTheir o; if (o has pluralname) { print "their"; return; }
	if (o has female) { print "her"; return; }
	if (o has neuter) { print "its"; return; }
	print "his";
];

[ HimHerItself o; if (o has pluralname) { print "theirselves"; return; }
	if (o has female) { print "herself"; return; }
	if (o has neuter) { print "itself"; return; }
	print "himself";
];

[ LanguageLM n x1 x2;
  say__p = 1;
  Answer,Ask:
            "There is no reply.";
! Ask:      see Answer
  Attack:   "Violence isn't the answer to this one.";
  Burn:     "This dangerous act would achieve little.";
  Buy:      "Nothing is on sale.";
  Climb:    "I don't think much is to be achieved by that.";
  Close: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can close.";
        2:  print_ret (ctheyreorthats) x1, " already closed.";
        3:  "You close ", (the) x1, ".";
		4:	print (The) actor, " closes ", (the) x1, ".^";
		5:	print (The) x1, " close"; if (x1 hasnt pluralname) print "s";
			print ".^";
    }
  Consult: switch (n) {
  		1:	"You discover nothing of interest in ", (the) x1, ".";
  		2:	print (The) actor, " looks at ", (the) x1, ".^";
    }
  Cut:      "Cutting ", (thatorthose) x1, " up would achieve little.";
  Disrobe: switch (n) {
        1:  "You're not wearing ", (thatorthose) x1, ".";
        2:  "You take off ", (the) x1, ".";
		3:	print (The) actor, " takes off ", (the) x1, ".^";
    }
  Drink:    "There's nothing suitable to drink here.";
  Drop: switch (n) {
        1:  if (x1 has pluralname) print (The) x1, " are "; else print (The) x1, " is ";
            "already here.";
        2:  "You haven't got ", (thatorthose) x1, ".";
        3:  print "(first taking ", (the) x1, " off)^"; say__p = 0; return;
        4:  "Dropped.";
        5:	"There is no more room on ", (the) x1, ".";
        6:	"There is no more room in ", (the) x1, ".";
        7:	print (The) actor, " puts down ", (the) x1, ".^";
    }
  Eat: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " plainly inedible.";
        2:  "You eat ", (the) x1, ". Not bad.";
        3:	print (The) actor, " eats ", (the) x1, ".^";
    }
  Enter: switch (n) {
        1:  print "But you're already ";
            if (x1 has supporter) print "on "; else print "in ";
            print_ret (the) x1, ".";
        2:  if (x1 has pluralname) print "They're"; else print "That's";
            print " not something you can ";
            switch (verb_word) {
              'stand':  "stand on.";
              'sit':    "sit down on.";
              'lie':    "lie down on.";
              default:  "enter.";
            }
        3:  "You can't get into the closed ", (name) x1, ".";
        4:  "You can only get into something free-standing.";
        5:  print "You get ";
            if (x1 has supporter) print "onto "; else print "into ";
            print_ret (the) x1, ".";
        6:  print "(getting ";
            if (x1 has supporter) print "off "; else print "out of ";
            print (the) x1; print ")^"; say__p = 0; return;
        7:  ! say__p = 0;
            if (x1 has supporter) "(getting onto ", (the) x1, ")";
            if (x1 has container) "(getting into ", (the) x1, ")";
            "(entering ", (the) x1, ")";
		8:	print (The) actor, " gets into ", (the) x1, ".^";
        9:  print (The) actor, " gets onto ", (the) x1, ".^";
    }
  Examine: switch (n) {
        1:  "Darkness, noun.  An absence of light to see by.";
        2:  "You see nothing special about ", (the) x1, ".";
        3:  print (The) x1, " ", (isorare) x1, " currently switched ";
            if (x1 has on) "on."; else "off.";
		4:	print (The) actor, " looks closely at ", (the) x1, ".^";
		5:	"You see nothing unexpected in that direction.";
	}
  Exit: switch (n) {
        1:  "But you aren't in anything at the moment.";
        2:  "You can't get out of the closed ", (name) x1, ".";
        3:  print "You get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, ".";
        4:  print "But you aren't ";
            if (x1 has supporter) print "on "; else print "in ";
            print_ret (the) x1, ".";
		5:	print (The) actor, " gets off ", (the) x1, ".^";
		6:	print (The) actor, " gets out of ", (the) x1, ".^";
    }
  GetOff:   "But you aren't on ", (the) x1, " at the moment.";
  Give: switch (n) {
        1:  "You aren't holding ", (the) x1, ".";
        2:  "You juggle ", (the) x1, " for a while, but don't achieve much.";
        3:  print (The) x1;
            if (x1 has pluralname) print " don't"; else print " doesn't";
            " seem interested.";
        4:  print (The) x1;
            if (x1 has pluralname) print " aren't";
            else print " isn't";
            " able to receive things.";
		5:	"You give ", (the) x1, " to ", (the) second, ".";
		6: print (The) actor, " gives ", (the) x1, " to you.^";
		7: print (The) actor, " gives ", (the) x1, " to ", (the) second, ".^";
    }
  Go: switch (n) {
        1:  print "You'll have to get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, " first.";
        2:  print_ret (string) CANTGO__TX;   ! "You can't go that way."
        6:  print "You can't, since ", (the) x1;
            if (x1 has pluralname) " lead nowhere."; else " leads nowhere.";
		7:	"You'll have to say which compass direction to go in.";
		8:	print (The) actor, " goes up";
		9:	print (The) actor, " goes down";
		10:	print (The) actor, " goes ", (name) x1;
		11:	print (The) actor, " arrives from above";
		12:	print (The) actor, " arrives from below";
		13:	print (The) actor, " arrives from the ", (name) x1;
		14:	print (The) actor, " arrives";
		15:	print (The) actor, " arrives at ", (the) x1, " from above";
		16:	print (The) actor, " arrives at ", (the) x1, " from below";
		17:	print (The) actor, " arrives at ", (the) x1, " from the ", (name) x2;
		18:	print (The) actor, " goes through ", (the) x1;
		19:	print (The) actor, " arrives from ", (the) x1;
		20:	print "on ", (the) x1;
		21:	print "in ", (the) x1;
		22:	print ", pushing ", (the) x1, " in front, and you along too";
		23:	print ", pushing ", (the) x1, " in front";
		24:	print ", pushing ", (the) x1, " away";
		25:	print ", pushing ", (the) x1, " in";
		26:	print ", taking you along";
		27: print "(first getting off ", (the) x1, ")^"; say__p = 0; return;
		28: print "(first opening ", (the) x1, ")^"; say__p = 0; return;
    }
  Insert: switch (n) {
        1:  "You need to be holding ", (the) x1, " before you can put ", (itorthem) x1,
            " into something else.";
        2:  print_ret (Cthatorthose) x1, " can't contain things.";
        3:  print_ret (The) x1, " ", (isorare) x1, " closed.";
        4:  "You'll need to take ", (itorthem) x1, " off first.";
        5:  "You can't put something inside itself.";
        6:  print "(first taking ", (itorthem) x1, " off)^"; say__p = 0; return;
        7:  "There is no more room in ", (the) x1, ".";
        8:  "Done.";
        9:  "You put ", (the) x1, " into ", (the) second, ".";
       10:  print (The) actor, " puts ", (the) x1, " into ", (the) second, ".^";
    }
  Inv: switch (n) {
        1:  "You are carrying nothing.";
        2:  print "You are carrying";
        3:  print ":^";
        4:  print ".^";
        5:	print (The) x1, " looks through ", (HisHerTheir) x1, " possessions.^";
    }
  Jump:     "You jump on the spot, fruitlessly.";
  Kiss:     "Keep your mind on the game.";
  Listen:   "You hear nothing unexpected.";
  ListMiscellany: switch (n) {
        1:  print " (providing light)";
        2:  print " (closed)";
        4:  print " (empty)";
        6:  print " (closed and empty)";
        3:  print " (closed and providing light)";
        5:  print " (empty and providing light)";
        7:  #ifdef SERIAL_COMMA;
        	print " (closed, empty, and providing light)";
        	#ifnot;
        	print " (closed, empty and providing light)";
        	#endif;
        8:  print " (providing light and being worn";
        9:  print " (providing light";
        10: print " (being worn";
        11: print " (";
        12: print "open";
        13: print "open but empty";
        14: print "closed";
        15: print "closed and locked";
        16: print " and empty";
        17: print " (empty)";
        18: print " containing ";
        19: print " (on ";
        20: print ", on top of ";
        21: print " (in ";
        22: print ", inside ";
    }
  LMode1:   " is now in its ~brief~ printing mode, which gives long descriptions
             of places never before visited and short descriptions otherwise.";
  LMode2:   " is now in its ~verbose~ mode, which always gives long descriptions
             of locations (even if you've been there before).";
  LMode3:   " is now in its ~superbrief~ mode, which always gives short descriptions
             of locations (even if you haven't been there before).";
  Lock: switch (n) {
        1:  if (x1 has pluralname) print "They don't "; else print "That doesn't ";
            "seem to be something you can lock.";
        2:  print_ret (ctheyreorthats) x1, " locked at the moment.";
        3:  "First you'll have to close ", (the) x1, ".";
        4:  if (x1 has pluralname) print "Those don't "; else print "That doesn't ";
            "seem to fit the lock.";
        5:  "You lock ", (the) x1, ".";
        6:	print (The) actor, " locks ", (the) x1, ".^";
    }
  Look: switch (n) {
        1:  print " (on ", (the) x1, ")";
        2:  print " (in ", (the) x1, ")";
        3:  print " (as ", (object) x1, ")";
        4:  print "On ", (the) x1, " ";
            WriteListFrom(child(x1),
              ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
        5,6:
            if (x1 ~= location) {
                if (x1 has supporter) print "On "; else print "In ";
                print (the) x1, " you";
            }
            else print "You";
            print " can ";
            if (n == 5) print "also ";
            print "see ";
            WriteListFrom(child(x1),
              ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+TERSE_BIT+CONCEAL_BIT+WORKFLAG_BIT);
            if (x1 ~= location) "."; else " here.";
        7:  "You see nothing unexpected in that direction.";
        8:  if (x1 has supporter) print " (on "; else print " (in ";
        	print (the) x1, ")";
		9:	print (The) actor, " looks around.^";
    }
  LookUnder: switch (n) {
        1:  "But it's dark.";
        2:  "You find nothing of interest.";
		3:	print (The) actor, " looks under ", (the) x1, ".^";
    }
  Mild:     "Quite.";
  Miscellany: switch (n) {
        1:  "(considering the first sixteen objects only)^";
        2:  "Nothing to do!";
        3:  print " You have died ";
        4:  print " You have won ";
        5:  print "^Would you like to RESTART, RESTORE a saved game";
            #Ifdef DEATH_MENTION_UNDO;
            print ", UNDO your last move";
            #Endif;
            #ifdef SERIAL_COMMA;
            print ",";
            #endif;
            " or QUIT?";
        6:  "[Your interpreter does not provide ~undo~.  Sorry!]";
            #Ifdef TARGET_ZCODE;
        7:  "~Undo~ failed.  [Not all interpreters provide it.]";
            #Ifnot; ! TARGET_GLULX
        7:  "[You cannot ~undo~ any further.]";
            #Endif; ! TARGET_
        8:  "Please give one of the answers above.";
        9:  "It is now pitch dark in here!";
        10: "I beg your pardon?";
        11: "[You can't ~undo~ what hasn't been done!]";
        12: "[Can't ~undo~ twice in succession. Sorry!]";
        13: "[Previous turn undone.]";
        14: "Sorry, that can't be corrected.";
        15: "Think nothing of it.";
        16: "~Oops~ can only correct a single word.";
        17: "It is pitch dark, and you can't see a thing.";
        18: print "yourself";
        19: "As good-looking as ever.";
        20: "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~.";
        21: "You can hardly repeat that.";
        22: "You can't begin with a comma.";
        23: "You seem to want to talk to someone, but I can't see whom.";
        24: "You can't talk to ", (the) x1, ".";
        25: "To talk to someone, try ~someone, hello~ or some such.";
        26: "(first taking ", (the) x1, ")";
        27: "I didn't understand that sentence.";
        28: print "I only understood you as far as wanting to ";
        29: "I didn't understand that number.";
        30: "You can't see any such thing.";
        31: "You seem to have said too little!";
        32: "You aren't holding that!";
        33: "You can't use multiple objects with that verb.";
        34: "You can only use multiple objects once on a line.";
        35: "I'm not sure what ~", (address) pronoun_word, "~ refers to.";
        36: "You excepted something not included anyway!";
        37: "You can only do that to something animate.";
            #Ifdef DIALECT_US;
        38: "That's not a verb I recognize.";
            #Ifnot;
        38: "That's not a verb I recognise.";
            #Endif;
        39: "That's not something you need to refer to in the course of this game.";
        40: "You can't see ~", (address) pronoun_word, "~ (", (the) pronoun_obj,
            ") at the moment.";
        41: "I didn't understand the way that finished.";
        42: if (x1 == 0) print "None"; else print "Only ", (number) x1;
            print " of those ";
            if (x1 == 1) print "is"; else print "are";
            " available.";
        43: "Nothing to do!";
        44: "There are none at all available!";
        45: print "Who do you mean, ";
        46: print "Which do you mean, ";
        47: "Sorry, you can only have one item here. Which exactly?";
        48: print "Whom do you want";
            if (actor ~= player) print " ", (the) actor;
            print " to "; PrintCommand(); print "?^";
        49: print "What do you want";
            if (actor ~= player) print " ", (the) actor;
            print " to "; PrintCommand(); print "?^";
        50: print "Your score has just gone ";
            if (x1 > 0) print "up"; else { x1 = -x1; print "down"; }
            print " by ", (number) x1, " point";
            if (x1 > 1) print "s";
        51: "(Since something dramatic has happened, your list of commands has been cut short.)";
        52: "^Type a number from 1 to ", x1, ", 0 to redisplay or press ENTER.";
        53: "^[Please press SPACE.]";
        54: "[Comment recorded.]";
        55: "[Comment NOT recorded.]";
        56: print ".^";
        57: print "?^";
        58: print (The) actor, " ", (IsOrAre) actor, " unable to do that.^";
		59:	"You must supply a noun.";
		60:	"You may not supply a noun.";
		61:	"You must name an object.";
		62:	"You may not name an object.";
		63:	"You must name a second object.";
		64:	"You may not name a second object.";
		65:	"You must supply a second noun.";
		66:	"You may not supply a second noun.";
		67:	"You must name something more substantial.";
		68:	print "(", (The) actor, " first taking ", (the) x1, ")^";
        69: "(first taking ", (the) x1, ")";
        70: "The use of UNDO is forbidden in this game.";
        71: print (string) DARKNESS__TX;
  		72: print (The) x1;
            if (x1 has pluralname) print " have"; else print " has";
            " better things to do.";
        73: "That noun did not make sense in this context.";
        74: print "[That command asks to do something outside of play, so it can
        	only make sense from you to me. ", (The) x1, " cannot be asked to do this.]^";
        75:  print " The End ";
    }
  No,Yes:   "That was a rhetorical question.";
  NotifyOff:
            "Score notification off.";
  NotifyOn: "Score notification on.";
  Open: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can open.";
        2:  if (x1 has pluralname) print "They seem "; else print "It seems ";
            "to be locked.";
        3:  print_ret (ctheyreorthats) x1, " already open.";
        4:  print "You open ", (the) x1, ", revealing ";
            if (WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT) == 0) "nothing.";
            ".";
        5:  "You open ", (the) x1, ".";
		6:	print (The) actor, " opens ", (the) x1, ".^";
		7:	print (The) x1, " open";
			if (x1 hasnt pluralname) print "s";
			print ".^";
    }
  Pronouns: switch (n) {
        1:  print "At the moment, ";
        2:  print "means ";
        3:  print "is unset";
        4:  "no pronouns are known to the game.";
        5:  ".";
    }
  Pull,Push,Turn: switch (n) {
        1:  if (x1 has pluralname) print "Those are "; else print "It is ";
            "fixed in place.";
        2:  "You are unable to.";
        3:  "Nothing obvious happens.";
        4:  "That would be less than courteous.";
		5:	print (The) actor, " pulls ", (the) x1, ".^";
		6:	print (The) actor, " pushes ", (the) x1, ".^";
		7:	print (The) actor, " turns ", (the) x1, ".^";
    }
! Push: see Pull
  PushDir: switch (n) {
        1:  print (The) x1, " cannot be pushed from place to place.^";
        2:  "That's not a direction.";
        3:  "Not that way you can't.";
    }
  PutOn: switch (n) {
        1:  "You need to be holding ", (the) x1, " before you can put ",
                (itorthem) x1, " on top of something else.";
        2:  "You can't put something on top of itself.";
        3:  "Putting things on ", (the) x1, " would achieve nothing.";
        4:  "You lack the dexterity.";
        5:  print "(first taking ", (itorthem) x1, " off)^"; say__p = 0; return;
        6:  "There is no more room on ", (the) x1, ".";
        7:  "Done.";
        8:  "You put ", (the) x1, " on ", (the) second, ".";
        9:  print (The) actor, " puts ", (the) x1, " on ", (the) second, ".^";
    }
  Quit: switch (n) {
        1:  print "Please answer yes or no.";
        2:  print "Are you sure you want to quit? ";
    }
  Remove: switch (n) {
        1:  if (x1 has pluralname) print "They are"; else print "It is";
            " unfortunately closed.";
        2:  if (x1 has pluralname) print "But they aren't"; else print "But it isn't";
            " there now.";
        3:  "Removed.";
    }
  Restart: switch (n) {
        1:  print "Are you sure you want to restart? ";
        2:  "Failed.";
    }
  Restore: switch (n) {
        1:  "Restore failed.";
        2:  "Ok.";
    }
  Rub:      "You achieve nothing by this.";
  Save: switch (n) {
        1:  "Save failed.";
        2:  "Ok.";
    }
  Score: switch (n) {
        1:  if (deadflag) print "In that game you scored "; else print "You have so far scored ";
            print score, " out of a possible ", MAX_SCORE, ", in ", turns, " turn";
            if (turns ~= 1) print "s";
            return;
        2:  "There is no score in this story.";
        3:	print ", earning you the rank of ";
    }
  ScriptOff: switch (n) {
        1:  "Transcripting is already off.";
        2:  "^End of transcript.";
        3:  "Attempt to end transcript failed.";
    }
  ScriptOn: switch (n) {
        1:  "Transcripting is already on.";
        2:  "Start of a transcript of";
        3:  "Attempt to begin transcript failed.";
    }
  Search: switch (n) {
        1:  "But it's dark.";
        2:  "There is nothing on ", (the) x1, ".";
        3:  print "On ", (the) x1, " ";
            WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
        4:  "You find nothing of interest.";
        5:  "You can't see inside, since ", (the) x1, " ", (isorare) x1, " closed.";
        6:  print_ret (The) x1, " ", (isorare) x1, " empty.";
        7:  print "In ", (the) x1, " ";
            WriteListFrom(child(x1), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT+ISARE_BIT);
            ".";
		8:	print (The) actor, " searches ", (the) x1, ".^";
    }
  SetTo:    "No, you can't set ", (thatorthose) x1, " to anything.";
  Show: switch (n) {
        1:  "You aren't holding ", (the) x1, ".";
        2:  print_ret (The) x1, " ", (isorare) x1, " unimpressed.";
    }
  Sing:     "Your singing is abominable.";
  Sleep:    "You aren't feeling especially drowsy.";
  Smell:    "You smell nothing unexpected.";
            #Ifdef DIALECT_US;
  Sorry:    "Oh, don't apologize.";
            #Ifnot;
  Sorry:    "Oh, don't apologise.";
            #Endif;
  Squeeze: switch (n) {
        1:  "Keep your hands to yourself.";
        2:  "You achieve nothing by this.";
		3:	print (The) actor, " squeezes ", (the) x1, ".^";
    }
  Strong:   "Real adventurers do not use such language.";
  Swing:    "There's nothing sensible to swing here.";
  SwitchOff: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can switch.";
        2:  print_ret (ctheyreorthats) x1, " already off.";
        3:  "You switch ", (the) x1, " off.";
		4:	print (The) actor, " switches ", (the) x1, " off.^";
    }
  SwitchOn: switch (n) {
        1:  print_ret (ctheyreorthats) x1, " not something you can switch.";
        2:  print_ret (ctheyreorthats) x1, " already on.";
        3:  "You switch ", (the) x1, " on.";
		4:	print (The) actor, " switches ", (the) x1, " on.^";
    }
  Take: switch (n) {
        1:  "Taken.";
        2:  "You are always self-possessed.";
        3:  "I don't suppose ", (the) x1, " would care for that.";
        4:  print "You'd have to get ";
            if (x1 has supporter) print "off "; else print "out of ";
            print_ret (the) x1, " first.";
        5:  "You already have ", (thatorthose) x1, ".";
        6:  if (noun has pluralname) print "Those seem "; else print "That seems ";
            "to belong to ", (the) x1, ".";
        7:  if (noun has pluralname) print "Those seem "; else print "That seems ";
            "to be a part of ", (the) x1, ".";
        8:  print_ret (Cthatorthose) x1, " ", (isorare) x1,
            "n't available.";
        9:  print_ret (The) x1, " ", (isorare) x1, "n't open.";
        10: if (x1 has pluralname) print "They're "; else print "That's ";
            "hardly portable.";
        11: if (x1 has pluralname) print "They're "; else print "That's ";
            "fixed in place.";
        12: "You're carrying too many things already.";
        13: print "(putting ", (the) x1, " into ", (the) x2,
            " to make room)^"; say__p = 0; return;
        14: "You can't reach into ", (the) x1, ".";
        15: "You cannot carry ", (the) x1, ".";
        16: print (The) actor, " picks up ", (the) x1, ".^";
    }
  Taste:    "You taste nothing unexpected.";
  Tell: switch (n) {
        1:  "You talk to yourself a while.";
        2:  "This provokes no reaction.";
    }
  Think:    "What a good idea.";
  ThrowAt: switch (n) {
        1:  "Futile.";
        2:  "You lack the nerve when it comes to the crucial moment.";
    }
  Tie:		"You would achieve nothing by this.";
  Touch: switch (n) {
        1:  "Keep your hands to yourself!";
        2:  "You feel nothing unexpected.";
        3:  "If you think that'll help.";
		4:	print (The) actor, " touches ", (himheritself) x1, ".^";
		5:	print (The) actor, " touches you.^";
		6:	print (The) actor, " touches ", (the) x1, ".^";
    }
! Turn: see Pull.
  Unlock:  switch (n) {
        1:  if (x1 has pluralname) print "They don't "; else print "That doesn't ";
            "seem to be something you can unlock.";
        2:  print_ret (ctheyreorthats) x1, " unlocked at the moment.";
        3:  if (x1 has pluralname) print "Those don't "; else print "That doesn't ";
            "seem to fit the lock.";
        4:  "You unlock ", (the) x1, ".";
        5:	print (The) actor, " unlocks ", (the) x1, ".^";
    }
  Verify: switch (n) {
        1:  "The game file has verified as intact.";
        2:  "The game file did not verify as intact, and may be corrupt.";
    }
  Wait: switch (n) {
        1:  "Time passes.";
        2:	print (The) actor, " waits.^";
    }
  Wake:     "The dreadful truth is, this is not a dream.";
  WakeOther:"That seems unnecessary.";
  Wave: switch (n) {
        1:  "But you aren't holding ", (thatorthose) x1, ".";
        2:  "You look ridiculous waving ", (the) x1, ".";
		3:	print (The) actor, " waves ", (the) x1, ".^";
    }
  WaveHands:"You wave, feeling foolish.";
  Wear: switch (n) {
        1:  "You can't wear ", (thatorthose) x1, "!";
        2:  "You're not holding ", (thatorthose) x1, "!";
        3:  "You're already wearing ", (thatorthose) x1, "!";
        4:  "You put on ", (the) x1, ".";
		5:	print (The) actor, " puts on ", (the) x1, ".^";
    }
! Yes:  see No.
];

[ L__M act n x1 x2 rv flag;
    @push sw__var;
    sw__var = act;
    if (n == 0) n = 1;
    @push action;
    lm_act = act;
    lm_n = n;
    lm_o = x1;
    lm_o2 = x2;
    switch (act) {
    	##Miscellany: rv =  ((((PHR_717_r0 ())))) ;
    	##ListMiscellany: rv =  ((((PHR_718_r1 ())))) ;
    	default: rv =  ((((PHR_719_r2 ())))) ;
    }
    action = sw__var;
    if (rv == false) rv = RunRoutines(LibraryMessages, before);
    @pull action;
    if (rv == false) LanguageLM(n, x1, x2);
    @pull sw__var;
];


Default LanguageCases 1;
#Ifndef LibraryMessages; Object LibraryMessages; #Endif;

Object thedark "(darkness object)";

[ OffersLight obj j;
    while (obj) {
		if (obj has light) rtrue;
		objectloop (j in obj) if (HasLightSource(j)) rtrue;
		if ((obj has container) && (obj hasnt open) && (obj hasnt transparent)) rfalse;
		if ((obj provides component_parent) && (obj.component_parent))
			obj = obj.component_parent;
		else
			obj = parent(obj);
	}
    rfalse;
];

[ HasLightSource i j ad sr po;
	if (i == 0) rfalse;
    if (i has light) rtrue;
    if ((IsSeeThrough(i)) && (~~(HidesLightSource(i))))
        objectloop (j in i)
            if (HasLightSource(j)) rtrue;
    ad = i.&add_to_scope;
    if (parent(i) ~= 0 && ad ~= 0) {
        if (metaclass(ad-->0) == Routine) {
            ats_hls = 0; ats_flag = 1;
            sr = scope_reason; po = parser_one;
            scope_reason = LOOPOVERSCOPE_REASON; parser_one = 0;
            RunRoutines(i, add_to_scope);
            scope_reason = sr; parser_one = po;
            ats_flag = 0; if (ats_hls == 1) rtrue;
        }
        else {
            for (j=0 : (WORDSIZE*j)<i.#add_to_scope : j++)
                if ((ad-->j) && (HasLightSource(ad-->j) == 1)) rtrue;
        }
    }
    if (ComponentHasLight(i)) rtrue;
    rfalse;
];

[ ComponentHasLight o obj next_obj;
	if (o provides component_child) {
		obj = o.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if (obj has light) rtrue;
			if (HasLightSource(obj)) rtrue;
			if ((obj provides component_child) && (ComponentHasLight(obj))) rtrue;
			obj = next_obj;
		}
	}
	rfalse;
];

[ HidesLightSource obj;
    if (obj == player) rfalse;
    if (obj has transparent or supporter) rfalse;
    if (obj has animate) rfalse;
    if (obj has container) return (obj hasnt open);
    return (obj hasnt enterable);
];

Global lightflag = false;

[ ADJUST_LIGHT_R previous_light_condition;
    previous_light_condition = lightflag;
    lightflag = OffersLight(parent(player));

    if ((previous_light_condition == false) && (lightflag == false)) {
    	location = thedark;
    	rfalse;
    }

    if ((previous_light_condition == false) && (lightflag == true)) {
        location = real_location;
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == false)) {
        location = thedark;
		DivideParagraphPoint();
		BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		if (ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == false) L__M(##Miscellany, 9);
		EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
		rfalse;
    }

    if ((previous_light_condition == true) && (lightflag == true)) {
    	location = real_location;
    	rfalse;
    }

    rfalse;
];

[ SilentlyConsiderLight;
    lightflag = OffersLight(parent(player));
	if (lightflag) location = real_location; else location = thedark;
	rfalse;
];

[ IsSeeThrough obj;
    if ((obj has supporter)
    	|| (obj has transparent)
    	|| (obj has animate)
    	|| ((obj has container) && (obj has open)))
        rtrue;
   rfalse;
];

[ VisibilityParent o;
    if (o && (o has container) && (o hasnt open) && (o hasnt transparent)) return nothing;
	if (o) o = CoreOfParentOfCoreOf(o);
    return o;
];

[ FindVisibilityLevels lc up;
	if (location == thedark) {
		visibility_ceiling = thedark;
		visibility_levels = 0;	
	} else {
		visibility_ceiling = player;
		while (true) {
			up = VisibilityParent(visibility_ceiling);
			if (up == 0) break;
			visibility_ceiling = up;
			lc++;
		}
		visibility_levels = lc;
	}
];

[ ScopeCeiling pos c;
	if (pos == player && location == thedark) return thedark;
	c = parent(pos);
	if (c == 0) return pos;
	while (VisibilityParent(c)) c = VisibilityParent(c);
	return c;
];

[ ObjectIsUntouchable item silent_flag flag2 p save_sp decision;
	if ((p ~= player) && (LocationOf(p) ~= LocationOf(player)) &&
		((item ofclass K4_door) || (item ofclass K7_backdrop))) {
		decision = false;
	} else {
		untouchable_object = item; untouchable_silence = silent_flag;
		touch_persona = p; if (p == actor) touch_persona = 0;
		save_sp = say__p; say__p = 0;
		if (ProcessRulebook(ACCESSIBILITY_RB, 0, true)) {
			if (RulebookSucceeded()) decision = false;
			else decision = true;
		} else decision = false;
		if (say__p == false) say__p = save_sp;
	}
	untouchable_silence = 0;
	return decision;
];

[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = CommonAncestor(p, untouchable_object);
	if ((ancestor == 0) && (LocationOf(untouchable_object) == nothing)
		&& ((untouchable_object ofclass K4_door or K7_backdrop) == false)) {
		if (touch_persona == 0) GL__M(##Take,8,untouchable_object);
		RulebookFails();
		rtrue;
	}

	! First, a barrier between the player and the ancestor.

	if (CoreOf(p) ~= ancestor) {
		i = parent(CoreOf(p)); j = CoreOf(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false)
				&& (ProcessRulebook(REACHING_OUTSIDE_RB, i))
				&& (RulebookFailed())) rtrue; ! Barrier
			i = parent(CoreOf(i)); j = CoreOf(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (CoreOf(untouchable_object) ~= ancestor) {
		! We can always get to the core of the item.
		i = CoreOf(untouchable_object);
		! This will be on the inside of its parent, if its parent is a
		! container, so there should be no exemption.
		i = parent(i); external = false;
		! j = CoreOf(i); if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) &&
				(ProcessRulebook(REACHING_INSIDE_RB, i)) &&
				(RulebookFailed())) rtrue; ! Barrier
			i = CoreOf(i);
			if (i == ancestor) break;
			i = parent(i); j = CoreOf(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];

[ CANT_REACH_INSIDE_CLOSED_R;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];

[ CANT_REACH_OUTSIDE_CLOSED_R;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];

[ CANT_REACH_INSIDE_ROOMS_R;
	if (parameter_object && parameter_object ofclass K1_room) {
		if (touch_persona == 0) GL__M(##Take,14,parameter_object);
		RulebookFails(); rtrue;
	}
	rfalse;
];


Constant REQUISITION_STACK_SIZE = 3*286;
Array requisition_stack --> REQUISITION_STACK_SIZE;
Global requisition_stack_pointer = 0;

[ RequisitionStack len top addr;
	top = requisition_stack_pointer + len;
	if (top > REQUISITION_STACK_SIZE) return false;
	addr = requisition_stack + requisition_stack_pointer*WORDSIZE;
	! print "Allocating ", addr, " at pointer ", requisition_stack_pointer, "^";
	requisition_stack_pointer = top;
	return addr;
];

[ FreeStack addr;
	if (addr == 0) return;
	requisition_stack_pointer = (addr - requisition_stack)/WORDSIZE;
];

Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;

[ WriteListOfMarkedObjects style
	obj common_parent first mixed_parentage length;

	objectloop (obj ofclass Object && obj has workflag2) {
		length++;
		if (first == nothing) { first = obj; common_parent = parent(obj); }
		else { if (parent(obj) ~= common_parent) mixed_parentage = true; }
	}
	if (mixed_parentage) common_parent = nothing;

	if (length == 0) {
    	if (style & ISARE_BIT ~= 0) print (string) IS3__TX, " ", (string) NOTHING__TX;
    	else if (style & CFIRSTART_BIT ~= 0) print (string) NOTHING2__TX;
		else print (string) NOTHING__TX;
	} else {
		@push MarkedObjectArray; @push MarkedObjectLength;
		MarkedObjectArray = RequisitionStack(length);
		MarkedObjectLength = length;
		if (MarkedObjectArray == 0) return RunTimeProblem(RTP_LISTWRITERMEMORY); 

		if (common_parent) {
			ObjectTreeCoalesce(child(common_parent));
			length = 0;
			objectloop (obj in common_parent) ! object tree order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		} else {
			length = 0;
			objectloop (obj ofclass Object) ! object number order
				if (obj has workflag2) MarkedObjectArray-->length++ = obj;
		}

		WriteListFrom(first, style, 0, false, MarkedListIterator);

		FreeStack(MarkedObjectArray);
		@pull MarkedObjectLength; @pull MarkedObjectArray;
	}
	return;
];

Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;

! Constant DBLW; ! Uncomment this to provide debugging information at run-time

[ MarkedListIterator obj depth required_lt function i;
    if (obj == nothing) return nothing;
    switch(function) {
    	START_ITF: return MarkedObjectArray-->0;
    	COALESCE_ITF: return MarkedListCoalesce();
    	SEEK_ITF, ADVANCE_ITF:
			for (i=0: i<MarkedObjectLength: i++)
				if (MarkedObjectArray-->i == obj) {
					if (function == ADVANCE_ITF) i++;
					for (:i<MarkedObjectLength: i++) {
						obj = MarkedObjectArray-->i;
						if ((required_lt) && (obj.list_together ~= required_lt)) continue;
						if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag))
							continue;
						if ((c_style & CONCEAL_BIT) &&
							((obj has concealed) || (obj has scenery))) continue;
						return obj;
					}
					return nothing;
				}
	}
	return nothing;
];

[ MarkedListCoalesce o i lt l swap m;
	for (i=0: i<MarkedObjectLength: i++) {
		lt = (MarkedObjectArray-->i).list_together;
		if (lt ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (i++: (i<MarkedObjectLength)&&((MarkedObjectArray-->i).list_together==lt): i++) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (i == MarkedObjectLength) return MarkedObjectArray-->0;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (l=i+1: l<MarkedObjectLength: l++)
				if ((MarkedObjectArray-->l).list_together == lt) {
					! Yes, they do: so we perform a rotation to insert it before element i:
					swap = MarkedObjectArray-->l;
					for (m=l: m>i: m--) MarkedObjectArray-->m = MarkedObjectArray-->(m-1);
					MarkedObjectArray-->i = swap;
					! And now the run is longer:
					i++;
					if (i == MarkedObjectLength) return MarkedObjectArray-->0;
				}
			i--;
		}
	}
	return MarkedObjectArray-->0;
];

Global list_filter_routine;

[ ObjectTreeIterator obj depth required_lt function;
    if ((obj == nothing) || (parent(obj) == nothing)) return nothing;
	if (function == START_ITF) return child(parent(obj));
	if (function == COALESCE_ITF) return ObjectTreeCoalesce(obj);
    if (function == ADVANCE_ITF) obj = sibling(obj);
    for (:: obj = sibling(obj)) {
        if (obj == nothing) return nothing;
		if ((required_lt) && (obj.list_together ~= required_lt)) continue;
		if ((c_style & WORKFLAG_BIT) && (depth==0) && (obj hasnt workflag)) continue;
		if (obj hasnt list_filter_permits) continue;
		if ((c_style & CONCEAL_BIT) &&
			((obj has concealed) || (obj has scenery))) continue;
		return obj;
    }
];

[ ObjectTreeCoalesce obj memb lt later;
	#Ifdef DBLW; print "^^Sorting out: "; DiagnoseSortList(obj); #Endif;
	.StartAgain;
	for (memb=obj: memb~=nothing: memb=sibling(memb)) {
		lt = memb.list_together;
		if (lt ~= 0) {
			! Find first object in list after contiguous run with this list_together value:
			for (memb=sibling(memb): (memb) && (memb.list_together == lt): memb = sibling(memb)) ;
			! If the contiguous run extends to end of list, the list is now perfect:
			if (memb == 0) return obj;
			! And otherwise we look to see if any future entries belong in the earlier run:
			for (later=sibling(memb): later: later=sibling(later))
				if (later.list_together == lt) {
					! Yes, they do: so we perform a regrouping of the list and start again:
					obj = GroupChildren(parent(obj), list_together, lt);
					#Ifdef DBLW; print "^^Sorted to: "; DiagnoseSortList(obj); #Endif;
					jump StartAgain;
				}
		}
	}
	return obj;
];
#Ifdef DBLW;
[ DiagnoseSortList obj memb;
    for (memb=child(obj): memb~=nothing: memb=sibling(memb)) print memb, " --> "; new_line;
];
#Endif;

[ WriteListFrom first style depth noactivity iter a ol;
	@push c_iterator; @push c_style; @push c_depth; @push c_margin;
    if (iter) c_iterator = iter; else c_iterator = ObjectTreeIterator;
    c_style = style; c_depth = depth;
	c_margin = 0; if (style & EXTRAINDENT_BIT) c_margin = 1;

	objectloop (a ofclass Object) {
		give a list_filter_permits;
		if ((list_filter_routine) && (list_filter_routine(a) == false))
			give a ~list_filter_permits;
	}

    first = c_iterator(first, depth, 0, START_ITF);
	if (first == nothing) {
        print (string) NOTHING__TX;
        if (style & NEWLINE_BIT ~= 0) new_line;
    } else {
		if ((noactivity) || (iter)) {
			WriteListR(first, c_depth, true);
			say__p = 1;
		} else {
			objectloop (ol provides list_together) ol.list_together = 0;
			CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
		}
	}

    @pull c_margin; @pull c_depth; @pull c_style; @pull c_iterator;
];

[ STANDARD_CONTENTS_LISTING_R;
	WriteListFrom(child(parameter_object), c_style, c_depth, true);
];

#Ifdef DBLW;
Global DBLW_no_classes; Global DBLW_no_objs;
[ DebugPartition partition_class_sizes partition_classes first depth i k o;
	print "[Length of list is ", DBLW_no_objs, " with ", k, " plural.]^";
	print "[Partitioned into ", DBLW_no_classes, " equivalence classes.]^";
    for (i=1: i<=DBLW_no_classes : i++) {
    	print "Class ", i, " has size ", partition_class_sizes->i, "^";
	}
	for (k=0, o=first: k<DBLW_no_objs : k++, o = c_iterator(o, depth, lt_value, ADVANCE_ITF)) {
    	print "Entry ", k, " has class ", partition_classes->k,
    		" represented by ", o, " with L=", o.list_together, "^";
	}
];
#Endif;

[ PartitionList first no_objs depth partition_classes partition_class_sizes
	i k l n m;
    for (i=0: i<no_objs: i++) partition_classes->i = 0;
    n = 1;
    for (i=first, k=0: k<no_objs: i=c_iterator(i, depth, lt_value, ADVANCE_ITF), k++)
        if (partition_classes->k == 0) {
            partition_classes->k = n; partition_class_sizes->n = 1;
            for (l=c_iterator(i, depth, lt_value, ADVANCE_ITF), m=k+1:
            	(l~=0) && (m<no_objs):
            	l=c_iterator(l, depth, lt_value, ADVANCE_ITF), m++) {
                if ((partition_classes->m == 0) && (ListEqual(i, l))) {
                    if (partition_class_sizes->n < 255) (partition_class_sizes->n)++;
                    partition_classes->m = n;
                }
            }
            if (n < 255) n++;
        }
    n--;
	#Ifdef DBLW;
	DBLW_no_classes = n; DBLW_no_objs = no_objs;
	DebugPartition(partition_class_sizes, partition_classes, first, depth);
	#Endif;
    return n;
];

[ ListEqual o1 o2;
	if ((o1.plural == 0) || (o2.plural == 0)) rfalse;
 	if (child(o1) ~= 0 && WillRecurs(o1) ~= 0) rfalse;
    if (child(o2) ~= 0 && WillRecurs(o2) ~= 0) rfalse;
    if (c_style & (FULLINV_BIT + PARTINV_BIT) ~= 0) {
        if ((o1 hasnt worn && o2 has worn) || (o2 hasnt worn && o1 has worn)) rfalse;
        if ((o1 hasnt light && o2 has light) || (o2 hasnt light && o1 has light)) rfalse;
        if (o1 has container) {
            if (o2 hasnt container) rfalse;
            if ((o1 has open && o2 hasnt open) || (o2 has open && o1 hasnt open))
                rfalse;
        }
        else if (o2 has container)
            rfalse;
    }
    return Identical(o1, o2);
];

[ WillRecurs o;
    if (c_style & ALWAYS_BIT ~= 0) rtrue;
    if (c_style & RECURSE_BIT == 0) rfalse;
    if ((o has supporter) || ((o has container) && (o has open or transparent))) rtrue;
    rfalse;
];

[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes
	no_groups cl memb k current_lt lt;
	no_groups = no_classes;
    for (cl=1, memb=o, k=0: cl<=no_classes: cl++) {
    	! Advance to first member of class number cl
        while (partition_classes->k ~= cl) {
            k++; memb = c_iterator(memb, depth, lt_value, ADVANCE_ITF);
        }
        if (memb) { ! In case of accidents, but should always happen
        	lt = memb.list_together;
            if ((lt ~= lt_value) && (lt ofclass Routine or String) && (lt == current_lt))
            	no_groups--;
            current_lt = lt;
        }
    }
 	#Ifdef DBLW; print "[There are ", no_groups, " groups.]^"; #Endif;
	return no_groups;
];

[ WriteListR o depth from_start
	partition_classes partition_class_sizes
	cl memb index k2 l m no_classes q groups_to_do current_lt;
    if (o == nothing) return; ! An empty list: no output

    if (from_start) {
    	o = c_iterator(o, depth, 0, COALESCE_ITF); ! Coalesce list and choose new start
	}
    o = c_iterator(o, depth, 0, SEEK_ITF); ! Find first entry in list from o
    if (o == nothing) return;

	! Count index = length of list
    for (memb=o, index=0: memb: memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF)) index++;

    if (c_style & ISARE_BIT ~= 0) {
        if (index == 1 && o hasnt pluralname) print (string) IS3__TX;
        else                              print (string) ARE3__TX;
        if (c_style & NEWLINE_BIT ~= 0)   print ":^";
        else                              print (char) ' ';
        c_style = c_style - ISARE_BIT;
    }

    partition_classes = RequisitionStack(index/WORDSIZE + 2);
    partition_class_sizes = RequisitionStack(index/WORDSIZE + 2);
    if ((partition_classes == 0) || (partition_class_sizes == 0))
    	return RunTimeProblem(RTP_LISTWRITERMEMORY);

	no_classes =
		PartitionList(o, index, depth, partition_classes, partition_class_sizes);

	groups_to_do =
		NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes);

    for (cl=1, memb=o, index=0, current_lt=0: groups_to_do>0: cl++) {
		! Set memb to first object of partition class cl
        while (partition_classes->index ~= cl) {
        	index++; memb=c_iterator(memb, depth, lt_value, ADVANCE_ITF);
            if (memb==0) { print "*** Error in list-writer ***^"; break; }
        }

    	#Ifdef DBLW;
		! DebugPartition(partition_class_sizes, partition_classes, o, depth);
		print "^[Class ", cl, " of ", no_classes, ": first object ", memb,
			" (", memb.list_together, "); groups_to_do ", groups_to_do, ",
			current_lt=", current_lt, " listing_size=", listing_size,
			" lt_value=", lt_value, " memb.list_together=", memb.list_together, "]^";
    	#Endif;

		if ((memb.list_together == lt_value) ||
        	(~~(memb.list_together ofclass Routine or String))) current_lt = 0;
		else {
            if (memb.list_together == current_lt) continue;
            
            ! Otherwise this class begins a new group
            @push listing_size;
            q = memb; listing_size = 1; l = index; m = cl;
			while (m < no_classes && q.list_together == memb.list_together) {
				m++;
				while (partition_classes->l ~= m) {
					l++; q = c_iterator(q, depth, lt_value, ADVANCE_ITF);
				}
				if (q.list_together == memb.list_together) listing_size++;
			}

			if (listing_size > 1) {
				! The new group contains more than one partition class
				WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
				current_lt = memb.list_together;
				jump GroupComplete;
			}
			current_lt = 0;
			@pull listing_size;
		}

		WriteSingleClassGroup(cl, memb, depth, partition_class_sizes->cl);

		.GroupComplete;
		groups_to_do--;
        if (c_style & ENGLISH_BIT ~= 0) {
            if (groups_to_do == 1) {
                if (cl <= 1) print (string) LISTAND2__TX;
                else print (string) LISTAND__TX;
            }
            if (groups_to_do > 1) print (string) COMMA__TX;
        }
    }

    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
]; ! end of WriteListR

[ WriteMultiClassGroup cl memb depth partition_class_sizes q k2 l;
	! Save the style, because the activity below is allowed to change it
	q = c_style;
	if (c_style & INDENT_BIT ~= 0) PrintSpaces(2*(depth+c_margin));

	BeginActivity(GROUPING_TOGETHER_ACT, memb);

	if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
		c_style = c_style &~ NEWLINE_BIT;
	} else {

		if (memb.list_together ofclass String) {
			! Set k2 to the number of objects covered by the group
			k2 = 0;
			for (l=0 : l<listing_size : l++) k2 = k2 + partition_class_sizes->(l+cl);
			EnglishNumber(k2); print " ";
			print (string) memb.list_together;
			if (c_style & ENGLISH_BIT ~= 0) print " (";
			if (c_style & INDENT_BIT ~= 0)  print ":^";
		} else {
			inventory_stage = 1;
			parser_one = memb; parser_two = depth + c_margin;
			if (RunRoutines(memb, list_together) == 1) jump Omit__Sublist2;
		}

		c_margin++;
		@push lt_value; @push listing_together; @push listing_size;
		
		lt_value = memb.list_together; listing_together = memb;
		#Ifdef DBLW; print "^^DOWN lt_value = ", lt_value, " listing_together = ", memb, "^^";
		@push DBLW_no_classes; @push DBLW_no_objs; #Endif;
		WriteListR(memb, depth, false); 
		#Ifdef DBLW; print "^^UP^^"; @pull DBLW_no_objs; @pull DBLW_no_classes; #Endif;

		@pull listing_size; @pull listing_together; @pull lt_value;
		c_margin--;
		
		if (memb.list_together ofclass String) {
			if (q & ENGLISH_BIT ~= 0) print ")";
		} else {
			inventory_stage = 2;
			parser_one = memb; parser_two = depth+c_margin;
			RunRoutines(memb, list_together);
		}
		.Omit__Sublist2;
	}
  
	EndActivity(GROUPING_TOGETHER_ACT, memb);

	! If the NEWLINE_BIT has been forced by the activity, act now
	! before it vanishes...
	if (q & NEWLINE_BIT ~= 0 && c_style & NEWLINE_BIT == 0) new_line;

	! ...when the original style is restored again:
	c_style = q;
];

[ WriteSingleClassGroup cl memb depth size q;
	q = c_style;
    if (c_style & INDENT_BIT) PrintSpaces(2*(depth+c_margin));
	if (size == 1) {
		if (c_style & NOARTICLE_BIT ~= 0) print (name) memb;
		else {
			if (c_style & DEFART_BIT) {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (The) memb;
				else print (the) memb;
			} else {
				if ((cl == 1) && (c_style & CFIRSTART_BIT)) print (CIndefArt) memb;
				else print (a) memb;
			}
		}
	} else {
		if (c_style & DEFART_BIT) {
			if ((cl == 1) && (c_style & CFIRSTART_BIT)) PrefaceByArticle(memb, 0, size);
			else PrefaceByArticle(memb, 1, size);
		}
		@push listing_size; listing_size = size;
		CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
		@pull listing_size;
	}
	if ((size > 1) && (memb hasnt pluralname)) {
		give memb pluralname;
		WriteAfterEntry(memb, depth);
		give memb ~pluralname;
	} else WriteAfterEntry(memb, depth);
	c_style = q;
];

[ WriteAfterEntry o depth
    p recurse_flag parenth_flag eldest_child child_count combo;

    inventory_stage = 2;
    if (c_style & PARTINV_BIT) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT);
        if (ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT) == false) {

        combo = 0;
        if (o has light && location hasnt light) combo=combo+1;
        if (o has container && o hasnt open)     combo=combo+2;
        if ((o has container && (o has open || o has transparent))
            && (child(o)==0))                    combo=combo+4;
        if (combo) L__M(##ListMiscellany, combo, o);
        }
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT);
    }   ! end of PARTINV_BIT processing

    if (c_style & FULLINV_BIT) {
        if (o has light && o has worn) { L__M(##ListMiscellany, 8, o);  parenth_flag = true; }
        else {
            if (o has light)           { L__M(##ListMiscellany, 9, o);  parenth_flag = true; }
            if (o has worn)            { L__M(##ListMiscellany, 10, o); parenth_flag = true; }
        }

        if (o has container)
            if (o has openable) {
                if (parenth_flag) {
                	#Ifdef SERIAL_COMMA; print ","; #Endif;
                	print (string) AND__TX;
                } else            L__M(##ListMiscellany, 11, o);
                if (o has open)
                    if (child(o)) L__M(##ListMiscellany, 12, o);
                    else          L__M(##ListMiscellany, 13, o);
                else
                    if (o has lockable && o has locked) L__M(##ListMiscellany, 15, o);
                    else                                L__M(##ListMiscellany, 14, o);
                parenth_flag = true;
            }
            else
                if (child(o)==0 && o has transparent)
                    if (parenth_flag) L__M(##ListMiscellany, 16, o);
                    else              L__M(##ListMiscellany, 17, o);

        if (parenth_flag) print ")";
    }   ! end of FULLINV_BIT processing

	child_count = 0;
	eldest_child = nothing;
	objectloop (p in o)
		if ((c_style & CONCEAL_BIT == 0) || (p hasnt concealed && p hasnt scenery))
			if (p has list_filter_permits) {
				child_count++;
				if (eldest_child == nothing) eldest_child = p;
			}

    if (child_count && (c_style & ALWAYS_BIT)) {
        if (c_style & ENGLISH_BIT) L__M(##ListMiscellany, 18, o);
        recurse_flag = true;
    }
    
    if (child_count && (c_style & RECURSE_BIT)) {
        if (o has supporter) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) L__M(##ListMiscellany, 19, o);
                else                     L__M(##ListMiscellany, 20, o);
                if (o has animate)       print (string) WHOM__TX;
                else                     print (string) WHICH__TX;
            }
            recurse_flag = true;
        }
        if (o has container && (o has open || o has transparent)) {
            if (c_style & ENGLISH_BIT) {
                if (c_style & TERSE_BIT) L__M(##ListMiscellany, 21, o);
                else                     L__M(##ListMiscellany, 22, o);
                if (o has animate)       print (string) WHOM__TX;
                else                     print (string) WHICH__TX;
            }
            recurse_flag = true;
        }
    }

    if (recurse_flag && (c_style & ENGLISH_BIT))
        if (child_count > 1 || eldest_child has pluralname) print (string) ARE2__TX;
        else                                                print (string) IS2__TX;

    if (c_style & NEWLINE_BIT) new_line;

    if (recurse_flag) {
        o = child(o);
        @push lt_value; @push listing_together; @push listing_size;
        @push c_iterator;
        c_iterator = ObjectTreeIterator;
        lt_value = 0;   listing_together = 0;   listing_size = 0;
        WriteListR(o, depth+1, true);
        @pull c_iterator;
        @pull listing_size; @pull listing_together; @pull lt_value;
        if (c_style & TERSE_BIT) print ")";
    }
];

[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];

[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];

[ DigitToValue c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];

[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;

[ GroupChildren par prop value;
    while (child(par) ~= 0) {
        if (child(par).prop ~= value) move child(par) to out_obj;
        else move child(par) to in_obj;
    }
    while (child(in_obj) ~= 0)  move child(in_obj) to par;
    while (child(out_obj) ~= 0) move child(out_obj) to par;
    return child(par);
];

[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];

[ RunRoutines obj prop;
    if (obj == thedark) obj = real_location;
    if ((obj.&prop == 0) && (prop >= INDIV_PROP_START)) rfalse;
    return obj.prop();
];

[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];

Constant NO_USE_OPTIONS = 30;
[ TestUseOption UO;
    if (UO == 1) rtrue;
    if (UO == 2) rtrue;
    if (UO == 3) rtrue;
    if (UO == 25) rtrue;
    rfalse;
];
[ PrintUseOption UO;
    switch(UO) {
        0: print "ineffectual option";
        1: print "dynamic memory allocation option [8192]";
        2: print "maximum indexed text length option [1024]";
        3: print "maximum things understood at once option [100]";
        4: print "American dialect option";
        5: print "serial comma option";
        6: print "full-length room descriptions option";
        7: print "abbreviated room descriptions option";
        8: print "memory economy option";
        9: print "authorial modesty option";
        10: print "no scoring option";
        11: print "command line echoing option";
        12: print "undo prevention option";
        13: print "predictable randomisation option";
        14: print "fast route-finding option";
        15: print "slow route-finding option";
        16: print "numbered rules option";
        17: print "telemetry recordings option";
        18: print "no deprecated features option";
        19: print "VERBOSE room descriptions option";
        20: print "BRIEF room descriptions option";
        21: print "SUPERBRIEF room descriptions option";
        22: print "no normal movement tricks option";
        23: print "inline implicit library option";
        24: print "sequential action option";
        25: print "disambiguation list length option [6]";
        26: print "no parser suggestions option";
        27: print "no multiple suggestions option";
        28: print "debug choose objects option";
        29: print "Manual Pronouns option";
    }
];


[ IntegerDivide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];

[ IntegerRemainder A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];

[ UnsignedCompare x y u v;
    if (x == y) return 0;
    if (x < 0 && y >= 0) return 1;
    if (x >= 0 && y < 0) return -1;
    u = x&~WORD_HIGHBIT; v= y&~WORD_HIGHBIT;
    if (u > v) return 1;
    return -1;
];

[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];

[ GL__M a b c d;
	if ((actor ~= player) || (untouchable_silence)) rtrue;
	return L__M(a,b,c,d); ];
[ AGL__M a b c d;
	if (untouchable_silence) rtrue;
	return L__M(a,b,c,d); ];


Object InformParser "(Inform Parser)" has proper;

Global best_etype;                  ! Preferred error number so far
Global nextbest_etype;              ! Preferred one, if ASKSCOPE_PE disallowed

Global parser_inflection;           ! A property (usually "name") to find object names in

Array pattern --> 32;               ! For the current pattern match
Global pcount;                      ! and a marker within it
Array pattern2 --> 32;              ! And another, which stores the best match
Global pcount2;                     ! so far

Array  line_ttype-->32;             ! For storing an analysed grammar line
Array  line_tdata-->32;
Array  line_token-->32;

Global nsns;                        ! Number of special_numbers entered so far

Global params_wanted;               ! Number of parameters needed (which may change in parsing)

Global inferfrom;                   ! The point from which the rest of the command must be inferred
Global inferword;                   ! And the preposition inferred
Global dont_infer;                  ! Another dull flag

Global cobj_flag = 0;

Global oops_from;                   ! The "first mistake" word number
Global saved_oops;                  ! Used in working this out
Array  oops_workspace -> 64;        ! Used temporarily by "oops" routine

Global held_back_mode;              ! Flag: is there some input from last time
Global hb_wn;                       ! left over?  (And a save value for wn.)
                                    ! (Used for full stops and "then".)

Global usual_grammar_after;         ! Point from which usual grammar is parsed (it may vary from
                                    ! the above if user's routines match multi-word verbs)


Global look_ahead = 0;
Global guessed_first_noun = false;
Constant PATTERN_NULL = $ffff;      ! Entry for a token producing no text

Global found_ttype;                 ! Used to break up tokens into type
Global found_tdata;                 ! and data (by AnalyseToken)
Global token_filter;                ! For noun filtering by user routines

Global length_of_noun;              ! Set by NounDomain to no of words in noun

Global lookahead;                   ! The token after the one now being matched

Global multi_mode;                  ! Multiple mode
Global multi_wanted;                ! Number of things needed in multitude
Global multi_had;                   ! Number of things actually found
Global multi_context;               ! What token the multi-obj was accepted for

Global indef_mode;                  ! "Indefinite" mode - ie, "take a brick"
                                    ! is in this mode
Global indef_type;                  ! Bit-map holding types of specification
Global indef_wanted;                ! Number of items wanted (INDEF_ALL_WANTED for all)
Constant INDEF_ALL_WANTED = 32767;
Global indef_guess_p;               ! Plural-guessing flag
Global indef_owner;                 ! Object which must hold these items
Global indef_cases;                 ! Possible gender and numbers of them
Global indef_possambig;             ! Has a possibly dangerous assumption
                                    ! been made about meaning of a descriptor?
Global indef_nspec_at;              ! Word at which a number like "two" was parsed
                                    ! (for backtracking)
Global allow_plurals;               ! Whether plurals presently allowed or not

Global take_all_rule;               ! Slightly different rules apply to "take all" than other uses
                                    ! of multiple objects, to make adjudication produce more
                                    ! pragmatically useful results
                                    ! (Not a flag: possible values 0, 1, 2)

Global dict_flags_of_noun;          ! Of the noun currently being parsed
                                    ! (a bitmap in #dict_par1 format)
Global pronoun__word;               ! Saved value
Global pronoun__obj;                ! Saved value

Constant comma_word = 'comma,';     ! An "untypeable word" used to substitute
                                    ! for commas in parse buffers

Array  match_list --> MATCH_LIST_WORDS;    ! An array of matched objects so far
Array  match_classes --> MATCH_LIST_WORDS; ! An array of equivalence classes for them
Array  match_scores --> MATCH_LIST_WORDS;  ! An array of match scores for them
Global number_matched;              ! How many items in it?  (0 means none)
Global number_of_classes;           ! How many equivalence classes?
Global match_length;                ! How many words long are these matches?
Global match_from;                  ! At what word of the input do they begin?

#Ifdef TARGET_ZCODE;
[ WordCount; return parse->1; ];
[ WordAddress wordnum; return buffer + parse->(wordnum*4+1); ];
[ WordLength wordnum; return parse->(wordnum*4); ];
[ MoveWord at1 b2 at2 x y;
    x = at1*2-1; y = at2*2-1;
    parse-->x++ = b2-->y++;
    parse-->x = b2-->y;
];
#Ifnot;
[ WordCount; return parse-->0; ];
[ WordAddress wordnum; return buffer + parse-->(wordnum*3); ];
[ WordLength wordnum; return parse-->(wordnum*3-1); ];
[ MoveWord at1 b2 at2 x y;
    x = at1*3-2; y = at2*3-2;
    parse-->x++ = b2-->y++;
    parse-->x++ = b2-->y++;
    parse-->x = b2-->y;
];
#Endif;

[ WordFrom w p i j wc;
	#Ifdef TARGET_ZCODE; wc = p->1; i = w*2-1;
	#Ifnot; wc = p-->0; i = w*3-2; #Endif;
    if ((w < 1) || (w > wc)) return 0;
    j = p-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWord i j wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; i = wn*2-1;
	#Ifnot; wc = parse-->0; i = wn*3-2; #Endif;
    wn++;
    if ((wn < 2) || (wn > wc+1)) return 0;
    j = parse-->i;
    if (j == ',//') j = comma_word;
    if (j == './/') j = THEN1__WD;
    return j;
];

[ NextWordStopped wc;
	#Ifdef TARGET_ZCODE; wc = parse->1; #Ifnot; wc = parse-->0; #Endif;
	if ((wn < 1) || (wn > wc)) { wn++; return -1; }
    return NextWord();
];

[ PrintSnippet snip from to i w1 w2;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1) || (w2>WordCount())) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
	}
	from = WordAddress(w1); to = WordAddress(w2) + WordLength(w2) - 1;
	for (i=from: i<=to: i++) print (char) i->0;
];

[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen;
	w1 = snip/100; w2 = w1 + (snip%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) return;
		return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
	}
	@push say__p; @push say__pc;
	nextw = w2 + 1;
	at = WordAddress(w1) - buffer;
	if (nextw <= WordCount()) endsnippet = 100*nextw + (WordCount() - nextw + 1);
	buffer2-->0 = 120;
	newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet);
	for (i=0: (i<newlen) && (at+i<120): i++) buffer->(at+i) = buffer2->(WORDSIZE+i);
	#Ifdef TARGET_ZCODE; buffer->1 = at+i; #ifnot; buffer-->0 = at+i; #endif;
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount();
	@pull say__pc; @pull say__p;
];

[ SpliceSnippet__TextPrinter t endsnippet;
	PrintText(t);
	if (endsnippet) { print " "; PrintSnippet(endsnippet); }
];

[ SnippetIncludes test snippet w1 w2 wlen i j;
	w1 = snippet/100; w2 = w1 + (snippet%100) - 1;
	if ((w2<w1) || (w1<1)) {
		if ((w1 == 1) && (w2 == 0)) rfalse;
		return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
	}
	if (metaclass(test) == Routine) {
		wlen = snippet%100;
		for (i=w1, j=wlen: j>0: i++, j--) {
			if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
		}
	}
	rfalse;
];

[ SnippetMatches snippet topic_gpr rv;
	wn=1;
	if (topic_gpr == 0) rfalse;
	if (metaclass(topic_gpr) == Routine) {
		rv = (topic_gpr)(snippet/100, snippet%100);
		if (rv ~= GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];

[ UnpackGrammarLine line_address i size;
    for (i=0 : i<32 : i++) {
        line_token-->i = ENDIT_TOKEN;
        line_ttype-->i = ELEMENTARY_TT;
        line_tdata-->i = ENDIT_TOKEN;
    }
#Ifdef TARGET_ZCODE;
    action_to_be = 256*(line_address->0) + line_address->1;
    action_reversed = ((action_to_be & $400) ~= 0);
    action_to_be = action_to_be & $3ff;
    line_address--;
    size = 3;
#Ifnot; ! GLULX
    @aloads line_address 0 action_to_be;
    action_reversed = (((line_address->2) & 1) ~= 0);
    line_address = line_address - 2;
    size = 5;
#Endif;
    params_wanted = 0;
    for (i=0 : : i++) {
        line_address = line_address + size;
        if (line_address->0 == ENDIT_TOKEN) break;
        line_token-->i = line_address;
        AnalyseToken(line_address);
        if (found_ttype ~= PREPOSITION_TT) params_wanted++;
        line_ttype-->i = found_ttype;
        line_tdata-->i = found_tdata;
    }
    return line_address + 1;
];

[ AnalyseToken token;
    if (token == ENDIT_TOKEN) {
        found_ttype = ELEMENTARY_TT;
        found_tdata = ENDIT_TOKEN;
        return;
    }
    found_ttype = (token->0) & $$1111;
    found_tdata = (token+1)-->0;
];

[ DictionaryWordToVerbNum dword verbnum;
#Ifdef TARGET_ZCODE;
	verbnum = $ff-(dword->#dict_par2);
#Ifnot; ! GLULX
	dword = dword + #dict_par2 - 1;
    @aloads dword 0 verbnum;
    verbnum = $ffff-verbnum;
#Endif;
	return verbnum;
];

[ KeyboardPrimitive a_buffer a_table;
#Ifdef DEBUG; #Iftrue (0 > 0);
	return TestKeyboardPrimitive(a_buffer, a_table);
#Endif; #Endif;
	return VM_ReadKeyboard(a_buffer, a_table);
];

[ Keyboard  a_buffer a_table  nw i w w2 x1 x2;
	sline1 = score; sline2 = turns;

	while (true) {
		! Save the start of the buffer, in case "oops" needs to restore it
		for (i=0 : i<64 : i++) oops_workspace->i = a_buffer->i;
	
		! In case of an array entry corruption that shouldn't happen, but would be
		! disastrous if it did:
		#Ifdef TARGET_ZCODE;
		a_buffer->0 = INPUT_BUFFER_LEN;
		a_table->0 = 15;  ! Allow to split input into this many words
		#Endif; ! TARGET_
	
		! Print the prompt, and read in the words and dictionary addresses
		PrintPrompt();
		DrawStatusLine();
		KeyboardPrimitive(a_buffer, a_table);
	
		! Set nw to the number of words
		#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
	
		! If the line was blank, get a fresh line
		if (nw == 0) {
			@push etype; etype = BLANKLINE_PE;
			players_command = 100;
			BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
			if (ForActivity(PRINTING_A_PARSER_ERROR_ACT) == false) L__M(##Miscellany,10);
			EndActivity(PRINTING_A_PARSER_ERROR_ACT);
			@pull etype;
			continue;
		}
	
		! Unless the opening word was OOPS, return
		! Conveniently, a_table-->1 is the first word on both the Z-machine and Glulx
	
		w = a_table-->1;
		if (w == OOPS1__WD or OOPS2__WD or OOPS3__WD) {
			if (oops_from == 0) { L__M(##Miscellany, 14); continue; }
			if (nw == 1) { L__M(##Miscellany, 15); continue; }
			if (nw > 2) { L__M(##Miscellany, 16); continue; }
		
			! So now we know: there was a previous mistake, and the player has
			! attempted to correct a single word of it.
		
			for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer2->i = a_buffer->i;
			#Ifdef TARGET_ZCODE;
			x1 = a_table->9;  ! Start of word following "oops"
			x2 = a_table->8;  ! Length of word following "oops"
			#Ifnot; ! TARGET_GLULX
			x1 = a_table-->6; ! Start of word following "oops"
			x2 = a_table-->5; ! Length of word following "oops"
			#Endif; ! TARGET_
		
			! Repair the buffer to the text that was in it before the "oops"
			! was typed:
			for (i=0 : i<64 : i++) a_buffer->i = oops_workspace->i;
			VM_Tokenise(a_buffer,a_table);
		
			! Work out the position in the buffer of the word to be corrected:
			#Ifdef TARGET_ZCODE;
			w = a_table->(4*oops_from + 1); ! Start of word to go
			w2 = a_table->(4*oops_from);    ! Length of word to go
			#Ifnot; ! TARGET_GLULX
			w = a_table-->(3*oops_from);      ! Start of word to go
			w2 = a_table-->(3*oops_from - 1); ! Length of word to go
			#Endif; ! TARGET_
		
			! Write spaces over the word to be corrected:
			for (i=0 : i<w2 : i++) a_buffer->(i+w) = ' ';
		
			if (w2 < x2) {
				! If the replacement is longer than the original, move up...
				for (i=INPUT_BUFFER_LEN-1 : i>=w+x2 : i--)
					a_buffer->i = a_buffer->(i-x2+w2);
		
				! ...increasing buffer size accordingly.
				#Ifdef TARGET_ZCODE;
				a_buffer->1 = (a_buffer->1) + (x2-w2);
				#Ifnot; ! TARGET_GLULX
				a_buffer-->0 = (a_buffer-->0) + (x2-w2);
				#Endif; ! TARGET_
			}
		
			! Write the correction in:
			for (i=0 : i<x2 : i++) a_buffer->(i+w) = buffer2->(i+x1);
		
			VM_Tokenise(a_buffer, a_table);
			#Ifdef TARGET_ZCODE; nw = a_table->1; #Ifnot; nw = a_table-->0; #Endif;
		
			return nw;
		}

		! Undo handling
	
		if ((w == UNDO1__WD or UNDO2__WD or UNDO3__WD) && (nw==1)) {
			Perform_Undo();
			continue;
		}
		i = VM_Save_Undo();
		#ifdef PREVENT_UNDO; undo_flag = 0; #endif;
		#ifndef PREVENT_UNDO; undo_flag = 2; #endif;
		if (i == -1) undo_flag = 0;
		if (i == 0) undo_flag = 1;
		if (i == 2) {
			VM_RestoreWindowColours();
			VM_Style(SUBHEADER_VMSTY);
			SL_Location(); print "^";
			! print (name) location, "^";
			VM_Style(NORMAL_VMSTY);
			L__M(##Miscellany, 13);
			continue;
		}
		return nw;
	}
];

[ Parser__parse
	syntax line num_lines line_address i j k token l m;

	cobj_flag = 0;
	parser_results-->ACTION_PRES = 0;
	parser_results-->NO_INPS_PRES = 0;
	parser_results-->INP1_PRES = 0;
	parser_results-->INP2_PRES = 0;
	meta = false;



    if (held_back_mode == 1) {
        held_back_mode = 0;
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }

  .ReType;
	cobj_flag = 0;
    BeginActivity(READING_A_COMMAND_ACT); if (ForActivity(READING_A_COMMAND_ACT)==false) {
		Keyboard(buffer,parse);

		players_command = 100 + WordCount();
		num_words = WordCount();

    } if (EndActivity(READING_A_COMMAND_ACT)) jump ReType;

  .ReParse;

	! added in for the purposes of the bug fix
	guessed_first_noun = false;
	cobj_flag = 0;
    	parser_inflection = name;

    ! Initially assume the command is aimed at the player, and the verb
    ! is the first word

    num_words = WordCount();
    wn = 1;

    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese


    num_words = WordCount();

    k=0;
    #Ifdef DEBUG;
    if (parser_trace >= 2) {
        print "[ ";
        for (i=0 : i<num_words : i++) {

            #Ifdef TARGET_ZCODE;
            j = parse-->(i*2 + 1);
            #Ifnot; ! TARGET_GLULX
            j = parse-->(i*3 + 1);
            #Endif; ! TARGET_
            k = WordAddress(i+1);
            l = WordLength(i+1);
            print "~"; for (m=0 : m<l : m++) print (char) k->m; print "~ ";

            if (j == 0) print "?";
            else {
                #Ifdef TARGET_ZCODE;
                if (UnsignedCompare(j, HDR_DICTIONARY-->0) >= 0 &&
                    UnsignedCompare(j, HDR_HIGHMEMORY-->0) < 0)
                     print (address) j;
                else print j;
                #Ifnot; ! TARGET_GLULX
                if (j->0 == $60) print (address) j;
                else print j;
                #Endif; ! TARGET_
            }
            if (i ~= num_words-1) print " / ";
        }
        print " ]^";
    }
    #Endif; ! DEBUG
    verb_wordnum = 1;
    actor = player;
    actors_location = ScopeCeiling(player);
    usual_grammar_after = 0;

  .AlmostReParse;

    scope_token = 0;
    action_to_be = NULL;

    ! Begin from what we currently think is the verb word

  .BeginCommand;

    wn = verb_wordnum;
    verb_word = NextWordStopped();

    ! If there's no input here, we must have something like "person,".

    if (verb_word == -1) {
        best_etype = STUCK_PE;
        jump GiveError;
    }

    ! Now try for "again" or "g", which are special cases: don't allow "again" if nothing
    ! has previously been typed; simply copy the previous text across


    if (verb_word == AGAIN2__WD or AGAIN3__WD) verb_word = AGAIN1__WD;
    if (verb_word == AGAIN1__WD) {
        if (actor ~= player) {
            L__M(##Miscellany, 20);
            jump ReType;
        }
        #Ifdef TARGET_ZCODE;
        if (buffer3->1 == 0) {
            L__M(##Miscellany, 21);
            jump ReType;
        }
        #Ifnot; ! TARGET_GLULX
        if (buffer3-->0 == 0) {
            L__M(##Miscellany, 21);
            jump ReType;
        }
        #Endif; ! TARGET_
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer->i = buffer3->i;
        VM_Tokenise(buffer,parse);
		num_words = WordCount();
    	players_command = 100 + WordCount();
		jump ReParse;
    }



    ! Save the present input in case of an "again" next time

    if (verb_word ~= AGAIN1__WD)
        for (i=0 : i<INPUT_BUFFER_LEN : i++) buffer3->i = buffer->i;

    if (usual_grammar_after == 0) {
        j = verb_wordnum;
        i = RunRoutines(actor, grammar); 
        #Ifdef DEBUG;
        if (parser_trace >= 2 && actor.grammar ~= 0 or NULL)
            print " [Grammar property returned ", i, "]^";
        #Endif; ! DEBUG

        if ((i ~= 0 or 1) && (VM_InvalidDictionaryAddress(i))) {
            usual_grammar_after = verb_wordnum; i=-i;
        }

        if (i == 1) {
            parser_results-->0 = action;
            parser_results-->1 = noun;
            parser_results-->2 = second;
            rtrue;
        }
        if (i ~= 0) { verb_word = i; wn--; verb_wordnum--; }
        else { wn = verb_wordnum; verb_word = NextWord(); }
    }
    else usual_grammar_after = 0;


    #Ifdef LanguageIsVerb;
    if (verb_word == 0) {
        i = wn; verb_word = LanguageIsVerb(buffer, parse, verb_wordnum);
        wn = i;
    }
    #Endif; ! LanguageIsVerb

    ! If the first word is not listed as a verb, it must be a direction
    ! or the name of someone to talk to

    if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {

        ! So is the first word an object contained in the special object "compass"
        ! (i.e., a direction)?  This needs use of NounDomain, a routine which
        ! does the object matching, returning the object number, or 0 if none found,
        ! or REPARSE_CODE if it has restructured the parse table so the whole parse
        ! must be begun again...

        wn = verb_wordnum; indef_mode = false; token_filter = 0; parameters = 0;
        @push actor; @push action; @push action_to_be;
        actor = player; meta = false; action = ##Go; action_to_be = ##Go;
        l = NounDomain(compass, 0, 0);
        @pull action_to_be; @pull action; @pull actor;
        if (l == REPARSE_CODE) jump ReParse;

        ! If it is a direction, send back the results:
        ! action=GoSub, no of arguments=1, argument 1=the direction.

        if ((l~=0) && (l ofclass K3_direction)) {
            parser_results-->ACTION_PRES = ##Go;
            parser_results-->NO_INPS_PRES = 1;
            parser_results-->INP1_PRES = l;
            jump LookForMore;
        }

    } ! end of first-word-not-a-verb

	! Only check for a comma (a "someone, do something" command) if we are
	! not already in the middle of one.  (This simplification stops us from
	! worrying about "robot, wizard, you are an idiot", telling the robot to
	! tell the wizard that she is an idiot.)
	
	if (actor == player) {
		for (j=2 : j<=num_words : j++) {
			i=NextWord();
			if (i == comma_word) jump Conversation;
		}
	}
	jump NotConversation;
	
	! NextWord nudges the word number wn on by one each time, so we've now
	! advanced past a comma.  (A comma is a word all on its own in the table.)
	
	.Conversation;
	
	j = wn - 1;
	if (j == 1) {
		L__M(##Miscellany, 22);
		jump ReType;
	}
	
	! Use NounDomain (in the context of "animate creature") to see if the
	! words make sense as the name of someone held or nearby
	
	wn = 1; lookahead = HELD_TOKEN;
	scope_reason = TALKING_REASON;
	l = NounDomain(player,actors_location,6);
	scope_reason = PARSING_REASON;
	if (l == REPARSE_CODE) jump ReParse;
	if (l == 0) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		L__M(##Miscellany, 23);
		jump ReType;
	}
	
	.Conversation2;
	
	! The object addressed must at least be "talkable" if not actually "animate"
	! (the distinction allows, for instance, a microphone to be spoken to,
	! without the parser thinking that the microphone is human).
	
	if (l hasnt animate && l hasnt talkable) {
		L__M(##Miscellany, 24, l);
		jump ReType;
	}
	
	! Check that there aren't any mystery words between the end of the person's
	! name and the comma (eg, throw out "dwarf sdfgsdgs, go north").
	
	if (wn ~= j) {
		if (verb_word && ((verb_word->#dict_par1) & 1)) jump NotConversation;
		L__M(##Miscellany, 25);
		jump ReType;
	}
	
	! The player has now successfully named someone.  Adjust "him", "her", "it":
	
	PronounNotice(l);
	
	! Set the global variable "actor", adjust the number of the first word,
	! and begin parsing again from there.
	
	verb_wordnum = j + 1;
	
	! Stop things like "me, again":
	
	if (l == player) {
		wn = verb_wordnum;
		if (NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
			L__M(##Miscellany, 20);
			jump ReType;
		}
	}
	
	actor = l;
	actors_location = ScopeCeiling(l);
	#Ifdef DEBUG;
	if (parser_trace >= 1)
		print "[Actor is ", (the) actor, " in ", (name) actors_location, "]^";
	#Endif; ! DEBUG
	jump BeginCommand;

	.NotConversation;
	if (verb_word == 0 || ((verb_word->#dict_par1) & 1) == 0) {
		if (actor == player) {
			verb_word = UnknownVerb(verb_word);
			if (verb_word ~= 0) jump VerbAccepted;
		}
		best_etype = VERB_PE;
		jump GiveError;
	}
	.VerbAccepted;

    ! We now definitely have a verb, not a direction, whether we got here by the
    ! "take ..." or "person, take ..." method.  Get the meta flag for this verb:

    meta = ((verb_word->#dict_par1) & 2)/2;

    ! You can't order other people to "full score" for you, and so on...

    if (meta == 1 && actor ~= player) {
        best_etype = VERB_PE;
        meta = 0;
        jump GiveError;
    }

    ! Now let i be the corresponding verb number...

    i = DictionaryWordToVerbNum(verb_word);

    ! ...then look up the i-th entry in the verb table, whose address is at word
    ! 7 in the Z-machine (in the header), so as to get the address of the syntax
    ! table for the given verb...

    #Ifdef TARGET_ZCODE;
    syntax = (HDR_STATICMEMORY-->0)-->i;
    #Ifnot; ! TARGET_GLULX
    syntax = (#grammar_table)-->(i+1);
    #Endif; ! TARGET_

    ! ...and then see how many lines (ie, different patterns corresponding to the
    ! same verb) are stored in the parse table...

    num_lines = (syntax->0) - 1;

    ! ...and now go through them all, one by one.
    ! To prevent pronoun_word 0 being misunderstood,

    pronoun_word = NULL; pronoun_obj = NULL;

    #Ifdef DEBUG;
    if (parser_trace >= 1)
    	print "[Parsing for the verb '", (address) verb_word, "' (", num_lines+1, " lines)]^";
    #Endif; ! DEBUG

    best_etype = STUCK_PE; nextbest_etype = STUCK_PE;
    multiflag = false;

    ! "best_etype" is the current failure-to-match error - it is by default
    ! the least informative one, "don't understand that sentence".
    ! "nextbest_etype" remembers the best alternative to having to ask a
    ! scope token for an error message (i.e., the best not counting ASKSCOPE_PE).
    ! multiflag is used here to prevent inappropriate MULTI_PE errors
    ! in addition to its unrelated duties passing information to action routines

    line_address = syntax + 1;

    for (line=0 : line<=num_lines : line++) {

        for (i=0 : i<32 : i++) {
            line_token-->i = ENDIT_TOKEN;
            line_ttype-->i = ELEMENTARY_TT;
            line_tdata-->i = ENDIT_TOKEN;
        }

        ! Unpack the syntax line from Inform format into three arrays; ensure that
        ! the sequence of tokens ends in an ENDIT_TOKEN.

        line_address = UnpackGrammarLine(line_address);

        #Ifdef DEBUG;
        if (parser_trace >= 1) {
            if (parser_trace >= 2) new_line;
            print "[line ", line; DebugGrammarLine();
            print "]^";
        }
        #Endif; ! DEBUG

        ! We aren't in "not holding" or inferring modes, and haven't entered
        ! any parameters on the line yet, or any special numbers; the multiple
        ! object is still empty.

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        multi_context = 0;
        etype = STUCK_PE;

        ! Put the word marker back to just after the verb

        wn = verb_wordnum+1;



        advance_warning = -1; indef_mode = false;
        for (i=0,m=false,pcount=0 : line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
            scope_token = 0;

            if (line_ttype-->pcount ~= PREPOSITION_TT) i++;

            if (line_ttype-->pcount == ELEMENTARY_TT) {
                if (line_tdata-->pcount == MULTI_TOKEN) m = true;
                if (line_tdata-->pcount == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN  && i == 1) {
                    ! First non-preposition is "multiexcept" or
                    ! "multiinside", so look ahead.


                    #Ifdef DEBUG;
                    if (parser_trace >= 2) print " [Trying look-ahead]^";
                    #Endif; ! DEBUG

                    ! We need this to be followed by 1 or more prepositions.

                    pcount++;
                    if (line_ttype-->pcount == PREPOSITION_TT) {
                        ! skip ahead to a preposition word in the input
                        do {
                            l = NextWord();
                        } until ((wn > num_words) ||
                                 (l && (l->#dict_par1) & 8 ~= 0));
                        
                        if (wn > num_words) {
                            #Ifdef DEBUG;
                            if (parser_trace >= 2)
                                print " [Look-ahead aborted: prepositions missing]^";
                            #Endif;
                            jump LineFailed;
                        }
                        
                        do {
                            if (PrepositionChain(l, pcount) ~= -1) {
                                ! advance past the chain
                                if ((line_token-->pcount)->0 & $20 ~= 0) {
                                    pcount++;
                                    while ((line_token-->pcount ~= ENDIT_TOKEN) &&
                                           ((line_token-->pcount)->0 & $10 ~= 0))
                                        pcount++;
                                } else {
                                    pcount++;
                                }
                            } else {
                                ! try to find another preposition word
                                do {
                                    l = NextWord();
                                } until ((wn >= num_words) ||
                                         (l && (l->#dict_par1) & 8 ~= 0));
                                
                                if (l && (l->#dict_par1) & 8) continue;
                                
                                ! lookahead failed
                                #Ifdef DEBUG;
                                if (parser_trace >= 2)
                                    print " [Look-ahead aborted: prepositions don't match]^";
                                #endif;
                                jump LineFailed;
                            }
                            l = NextWord();
                        } until (line_ttype-->pcount ~= PREPOSITION_TT);
                        
                        ! put back the non-preposition we just read
                        wn--;

                        if ((line_ttype-->pcount == ELEMENTARY_TT) &&
                        	(line_tdata-->pcount == NOUN_TOKEN)) {
                            l = Descriptors();  ! skip past THE etc
                            if (l~=0) etype=l;  ! don't allow multiple objects

	! set flags for choose objects to use
					look_ahead = true;
					cobj_flag = 0;
					
				
                            l = NounDomain(actors_location, actor, NOUN_TOKEN);
	
	! unset them again, so we can pretend this never happened
					look_ahead = 0;
					cobj_flag = 0;

                            #Ifdef DEBUG;
                            if (parser_trace >= 2) {
                                print " [Advanced to ~noun~ token: ";
                                if (l == REPARSE_CODE) print "re-parse request]^";
                                if (l == 1) print "but multiple found]^";
                                if (l == 0) print "error ", etype, "]^";
                                if (l >= 2) print (the) l, "]^";
                            }
                            #Endif; ! DEBUG
                            if (l == REPARSE_CODE) jump ReParse;
                            if (l >= 2) advance_warning = l;
                        }
                    }
                    break;
                }
            }
        }

        ! Slightly different line-parsing rules will apply to "take multi", to
        ! prevent "take all" behaving correctly but misleadingly when there's
        ! nothing to take.

        take_all_rule = 0;
        if (m && params_wanted == 1 && action_to_be == ##Take)
            take_all_rule = 1;

        ! And now start again, properly, forearmed or not as the case may be.
        ! As a precaution, we clear all the variables again (they may have been
        ! disturbed by the call to NounDomain, which may have called outside
        ! code, which may have done anything!).

        inferfrom = 0;
        parameters = 0;
        nsns = 0; special_word = 0;
        multiple_object-->0 = 0;
        etype = STUCK_PE;
        wn = verb_wordnum+1;

        for (pcount=1 : : pcount++) {
            pattern-->pcount = PATTERN_NULL; scope_token = 0;

            token = line_token-->(pcount-1);
            lookahead = line_token-->pcount;

            #Ifdef DEBUG;
            if (parser_trace >= 2)
                print " [line ", line, " token ", pcount, " word ", wn, " : ", (DebugToken) token,
                  "]^";
            #Endif; ! DEBUG

            if (token ~= ENDIT_TOKEN) {
                scope_reason = PARSING_REASON;
                AnalyseToken(token);

                l = ParseToken(found_ttype, found_tdata, pcount-1, token);
                while ((l >= GPR_NOUN) && (l < -1)) l = ParseToken(ELEMENTARY_TT, l + 256);
                scope_reason = PARSING_REASON;

                if (l == GPR_PREPOSITION) {
                    if (found_ttype~=PREPOSITION_TT && (found_ttype~=ELEMENTARY_TT ||
                        found_tdata~=TOPIC_TOKEN)) params_wanted--;
                    l = true;
                }
                else
                    if (l < 0) l = false;
                    else
                        if (l ~= GPR_REPARSE) {
                            if (l == GPR_NUMBER) {
                                if (nsns == 0) special_number1 = parsed_number;
                                else special_number2 = parsed_number;
                                nsns++; l = 1;
                            }
                            if (l == GPR_MULTIPLE) l = 0;
                            parser_results-->(parameters+INP1_PRES) = l;
                            parameters++;
                            pattern-->pcount = l;
                            l = true;
                        }

                #Ifdef DEBUG;
                if (parser_trace >= 3) {
                    print "  [token resulted in ";
                    if (l == REPARSE_CODE) print "re-parse request]^";
                    if (l == 0) print "failure with error type ", etype, "]^";
                    if (l == 1) print "success]^";
                }
                #Endif; ! DEBUG

                if (l == REPARSE_CODE) jump ReParse;
                if (l == false) break;
            }
            else {

                ! If the player has entered enough already but there's still
                ! text to wade through: store the pattern away so as to be able to produce
                ! a decent error message if this turns out to be the best we ever manage,
                ! and in the mean time give up on this line

                ! However, if the superfluous text begins with a comma or "then" then
                ! take that to be the start of another instruction

                if (wn <= num_words) {
                    l = NextWord();
                    if (l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
                        held_back_mode = 1; hb_wn = wn-1;
                    }
                    else {
                        for (m=0 : m<32 : m++) pattern2-->m = pattern-->m;
                        pcount2 = pcount;
                        etype = UPTO_PE;
                        break;
                    }
                }

                ! Now, we may need to revise the multiple object because of the single one
                ! we now know (but didn't when the list was drawn up).

                if (parameters >= 1 && parser_results-->INP1_PRES == 0) {
                    l = ReviseMulti(parser_results-->INP2_PRES);
                    if (l ~= 0) { etype = l; parser_results-->ACTION_PRES = action_to_be; break; }
                }
                if (parameters >= 2 && parser_results-->INP2_PRES == 0) {
                    l = ReviseMulti(parser_results-->INP1_PRES);
                    if (l ~= 0) { etype = l; break; }
                }

                ! To trap the case of "take all" inferring only "yourself" when absolutely
                ! nothing else is in the vicinity...

                if (take_all_rule == 2 && parser_results-->INP1_PRES == actor) {
                    best_etype = NOTHING_PE;
                    jump GiveError;
                }

                #Ifdef DEBUG;
                if (parser_trace >= 1) print "[Line successfully parsed]^";
                #Endif; ! DEBUG

                ! The line has successfully matched the text.  Declare the input error-free...

                oops_from = 0;

                ! ...explain any inferences made (using the pattern)...

                if (inferfrom ~= 0) {
                	PrintInferredCommand(inferfrom);
                    ClearParagraphing();
                }

                ! ...copy the action number, and the number of parameters...

                parser_results-->ACTION_PRES = action_to_be;
                parser_results-->NO_INPS_PRES = parameters;

                ! ...reverse first and second parameters if need be...

                if (action_reversed && parameters == 2) {
                    i = parser_results-->INP1_PRES;
                    parser_results-->INP1_PRES = parser_results-->INP2_PRES;
                    parser_results-->INP2_PRES = i;
                    if (nsns == 2) {
                        i = special_number1; special_number1 = special_number2;
                        special_number2 = i;
                    }
                }

                ! ...and to reset "it"-style objects to the first of these parameters, if
                ! there is one (and it really is an object)...

                if (parameters > 0 && parser_results-->INP1_PRES >= 2)
                    PronounNotice(parser_results-->INP1_PRES);

                ! ...and return from the parser altogether, having successfully matched
                ! a line.

                if (held_back_mode == 1) {
                    wn=hb_wn;
                    jump LookForMore;
                }
                rtrue;

            } ! end of if(token ~= ENDIT_TOKEN) else
        } ! end of for(pcount++)

        .LineFailed;
        ! The line has failed to match.
        ! We continue the outer "for" loop, trying the next line in the grammar.

        if (etype > best_etype) best_etype = etype;
        if (etype ~= ASKSCOPE_PE && etype > nextbest_etype) nextbest_etype = etype;

        ! ...unless the line was something like "take all" which failed because
        ! nothing matched the "all", in which case we stop and give an error now.

        if (take_all_rule == 2 && etype==NOTHING_PE) break;

    } ! end of for(line++)

    ! The grammar is exhausted: every line has failed to match.

  .GiveError;

    etype = best_etype;
    if (actor ~= player) {
        if (usual_grammar_after ~= 0) {
            verb_wordnum = usual_grammar_after;
            jump AlmostReParse;
        }
        wn = verb_wordnum;
        special_word = NextWord();
        if (special_word == comma_word) {
            special_word = NextWord();
            verb_wordnum++;
        }
        parser_results-->ACTION_PRES = ##Answer;
        parser_results-->NO_INPS_PRES = 2;
        parser_results-->INP1_PRES = actor;
        parser_results-->INP2_PRES = 1; special_number1 = special_word;
        actor = player;
        consult_from = verb_wordnum; consult_words = num_words-consult_from+1;
        rtrue;
    }

    ! If the player was the actor (eg, in "take dfghh") the error must be printed,
    ! and fresh input called for.  In three cases the oops word must be jiggled.

    if ((etype ofclass Routine) || (etype ofclass String)) {
        if (ParserError(etype) ~= 0) jump ReType;
    } else {
		if (verb_wordnum == 0 && etype == CANTSEE_PE) etype = VERB_PE;
		players_command = 100 + WordCount(); ! The snippet variable ``player's command''
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) jump SkipParserError;
    }
    pronoun_word = pronoun__word; pronoun_obj = pronoun__obj;

    if (etype == STUCK_PE) {    L__M(##Miscellany, 27); oops_from = 1; }
    if (etype == UPTO_PE) {     L__M(##Miscellany, 28);
        for (m=0 : m<32 : m++) pattern-->m = pattern2-->m;
        pcount = pcount2; PrintCommand(0); L__M(##Miscellany, 56);
    }
    if (etype == NUMBER_PE)     L__M(##Miscellany, 29);
    if (etype == CANTSEE_PE) {  L__M(##Miscellany, 30); oops_from=saved_oops; }
    if (etype == TOOLIT_PE)     L__M(##Miscellany, 31);
    if (etype == NOTHELD_PE) {  L__M(##Miscellany, 32); oops_from=saved_oops; }
    if (etype == MULTI_PE)      L__M(##Miscellany, 33);
    if (etype == MMULTI_PE)     L__M(##Miscellany, 34);
    if (etype == VAGUE_PE)      L__M(##Miscellany, 35);
    if (etype == EXCEPT_PE)     L__M(##Miscellany, 36);
    if (etype == ANIMA_PE)      L__M(##Miscellany, 37);
    if (etype == VERB_PE)       L__M(##Miscellany, 38);
    if (etype == SCENERY_PE)    L__M(##Miscellany, 39);
    if (etype == ITGONE_PE) {
        if (pronoun_obj == NULL)
                                L__M(##Miscellany, 35);
        else                    L__M(##Miscellany, 40);
    }
    if (etype == JUNKAFTER_PE)  L__M(##Miscellany, 41);
    if (etype == TOOFEW_PE)     L__M(##Miscellany, 42, multi_had);
    if (etype == NOTHING_PE) {
        if (parser_results-->ACTION_PRES == ##Remove &&
        	parser_results-->INP2_PRES ofclass Object) {
            noun = parser_results-->INP2_PRES; ! ensure valid for messages
            if (noun has animate) L__M(##Take, 6, noun);
            else if (noun hasnt container or supporter) L__M(##Insert, 2, noun);
            else if (noun has container && noun hasnt open) L__M(##Take, 9, noun);
            else if (children(noun)==0) L__M(##Search, 6, noun);
            else parser_results-->ACTION_PRES = 0;
            }
        if (parser_results-->ACTION_PRES ~= ##Remove) {
            if (multi_wanted==100)  L__M(##Miscellany, 43);
            else                    L__M(##Miscellany, 44);
        }
    }
    if (etype == ASKSCOPE_PE) {
        scope_stage = 3;
        if (indirect(scope_error) == -1) {
            best_etype = nextbest_etype;
            if (~~((etype ofclass Routine) || (etype ofclass String)))
            	EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            jump GiveError;
        }
    }
    if (etype == NOTINCONTEXT_PE) L__M(##Miscellany, 73);

    .SkipParserError;
    if ((etype ofclass Routine) || (etype ofclass String)) jump ReType;
    say__p = 1;
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);

    ! And go (almost) right back to square one...

    jump ReType;

    ! ...being careful not to go all the way back, to avoid infinite repetition
    ! of a deferred command causing an error.

    ! At this point, the return value is all prepared, and we are only looking
    ! to see if there is a "then" followed by subsequent instruction(s).

  .LookForMore;

    if (wn > num_words) rtrue;

    i = NextWord();
    if (i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word) {
        if (wn > num_words) {
           held_back_mode = false;
           return;
        }
        i = WordAddress(verb_wordnum);
        j = WordAddress(wn);
        for (: i<j : i++) i->0 = ' ';
        i = NextWord();
        if (i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD) {
            ! Delete the words "then again" from the again buffer,
            ! in which we have just realised that it must occur:
            ! prevents an infinite loop on "i. again"

            i = WordAddress(wn-2)-buffer;
            if (wn > num_words) j = INPUT_BUFFER_LEN-1;
            else j = WordAddress(wn)-buffer;
            for (: i<j : i++) buffer3->i = ' ';
        }
        VM_Tokenise(buffer,parse);
        held_back_mode = true;
        return;
    }
    best_etype = UPTO_PE;
    jump GiveError;

]; ! end of Parser__parse

[ ParseTokenStopped x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

Global parsetoken_nesting = 0;
[ ParseToken given_ttype given_tdata token_n token  i t rv;
	if (parsetoken_nesting > 0) {
		! save match globals
		@push match_from; @push token_filter; @push match_length;
		@push number_of_classes; @push oops_from;
		for (i=0: i<number_matched: i++) {
			t = match_list-->i; @push t;
			t = match_classes-->i; @push t;
			t = match_scores-->i; @push t;
		}
		@push number_matched;
	 }

	parsetoken_nesting++;
	rv = ParseToken__(given_ttype, given_tdata, token_n, token);
	parsetoken_nesting--;

	if (parsetoken_nesting > 0) {
		! restore match globals
		@pull number_matched;
		for (i=0: i<number_matched: i++) {
 			@pull t; match_scores-->i = t;
			@pull t; match_classes-->i = t;
			@pull t; match_list-->i = t;
   		}
		@pull oops_from; @pull number_of_classes;
		@pull match_length; @pull token_filter; @pull match_from;
	}
	return rv;
];

[ ParseToken__ given_ttype given_tdata token_n token
	l o i j k and_parity single_object desc_wn many_flag
	token_allows_multiple prev_indef_wanted;

    token_filter = 0;
    parser_inflection = name;

    switch (given_ttype) {
      ELEMENTARY_TT:
        switch (given_tdata) {
          SPECIAL_TOKEN:
            l = TryNumber(wn);
            special_word = NextWord();
            #Ifdef DEBUG;
            if (l ~= -1000)
                if (parser_trace >= 3) print "  [Read special as the number ", l, "]^";
            #Endif; ! DEBUG
            if (l == -1000) {
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Read special word at word number ", wn, "]^";
                #Endif; ! DEBUG
                l = special_word;
            }
            parsed_number = l;
            return GPR_NUMBER;

          NUMBER_TOKEN:
            l=TryNumber(wn++);
            if (l == -1000) {
                etype = NUMBER_PE;
                return GPR_FAIL;
            }
            #Ifdef DEBUG;
            if (parser_trace>=3) print "  [Read number as ", l, "]^";
            #Endif; ! DEBUG
            parsed_number = l;
            return GPR_NUMBER;

          CREATURE_TOKEN:
            if (action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)
                scope_reason = TALKING_REASON;

          TOPIC_TOKEN:
            consult_from = wn;
            if ((line_ttype-->(token_n+1) ~= PREPOSITION_TT) &&
               (line_token-->(token_n+1) ~= ENDIT_TOKEN))
                RunTimeError(13);
            do o = NextWordStopped();
            until (o == -1 || PrepositionChain(o, token_n+1) ~= -1);
            wn--;
            consult_words = wn-consult_from;
            if (consult_words == 0) return GPR_FAIL;
            if (action_to_be == ##Ask or ##Answer or ##Tell) {
                o = wn; wn = consult_from; parsed_number = NextWord();
                wn = o; return 1;
            }
            if (o==-1 && (line_ttype-->(token_n+1) == PREPOSITION_TT))
                return GPR_FAIL;    ! don't infer if required preposition is absent
            return GPR_PREPOSITION;
        }

      PREPOSITION_TT:
        ! Is it an unnecessary alternative preposition, when a previous choice
        ! has already been matched?
        if ((token->0) & $10) return GPR_PREPOSITION;

        ! If we've run out of the player's input, but still have parameters to
        ! specify, we go into "infer" mode, remembering where we are and the
        ! preposition we are inferring...

        if (wn > num_words) {
            if (inferfrom==0 && parameters<params_wanted) {
                inferfrom = pcount; inferword = token;
                pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            }

            ! If we are not inferring, then the line is wrong...

            if (inferfrom == 0) return -1;

            ! If not, then the line is right but we mark in the preposition...

            pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata);
            return GPR_PREPOSITION;
        }

        o = NextWord();

        pattern-->pcount = REPARSE_CODE + VM_DictionaryAddressToNumber(o);

        ! Whereas, if the player has typed something here, see if it is the
        ! required preposition... if it's wrong, the line must be wrong,
        ! but if it's right, the token is passed (jump to finish this token).

        if (o == given_tdata) return GPR_PREPOSITION;
        if (PrepositionChain(o, token_n) ~= -1) return GPR_PREPOSITION;
        return -1;

      GPR_TT:
        l = indirect(given_tdata);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Outside parsing routine returned ", l, "]^";
        #Endif; ! DEBUG
        return l;

      SCOPE_TT:
        scope_token = given_tdata;
        scope_stage = 1;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 1]^";
        #Endif; ! DEBUG
        l = indirect(scope_token);
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine returned multiple-flag of ", l, "]^";
        #Endif; ! DEBUG
        if (l == 1) given_tdata = MULTI_TOKEN; else given_tdata = NOUN_TOKEN;

      ATTR_FILTER_TT:
        token_filter = 1 + given_tdata;
        given_tdata = NOUN_TOKEN;

      ROUTINE_FILTER_TT:
        token_filter = given_tdata;
        given_tdata = NOUN_TOKEN;

    } ! end of switch(given_ttype)

    token = given_tdata;

    ! There are now three possible ways we can be here:
    !     parsing an elementary token other than "special" or "number";
    !     parsing a scope token;
    !     parsing a noun-filter token (either by routine or attribute).
    !
    ! In each case, token holds the type of elementary parse to
    ! perform in matching one or more objects, and
    ! token_filter is 0 (default), an attribute + 1 for an attribute filter
    ! or a routine address for a routine filter.

    token_allows_multiple = false;
    if (token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        token_allows_multiple = true;

    many_flag = false; and_parity = true; dont_infer = false;

    ! We expect to find a list of objects next in what the player's typed.

  .ObjectList;

    #Ifdef DEBUG;
    if (parser_trace >= 3) print "  [Object list from word ", wn, "]^";
    #Endif; ! DEBUG

    ! Take an advance look at the next word: if it's "it" or "them", and these
    ! are unset, set the appropriate error number and give up on the line
    ! (if not, these are still parsed in the usual way - it is not assumed
    ! that they still refer to something in scope)

    o = NextWord(); wn--;

    pronoun_word = NULL; pronoun_obj = NULL;
    l = PronounValue(o);
    if (l ~= 0) {
        pronoun_word = o; pronoun_obj = l;
        if (l == NULL) {
            ! Don't assume this is a use of an unset pronoun until the
            ! descriptors have been checked, because it might be an
            ! article (or some such) instead

            for (l=1 : l<=LanguageDescriptors-->0 : l=l+4)
                if (o == LanguageDescriptors-->l) jump AssumeDescriptor;
            pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
            etype = VAGUE_PE;
            if (parser_trace >= 3) print "  [Stop: unset pronoun]^";
            return GPR_FAIL;
        }
    }

  .AssumeDescriptor;

    if (o == ME1__WD or ME2__WD or ME3__WD) { pronoun_word = o; pronoun_obj = player; }

    allow_plurals = true; desc_wn = wn;

  .TryAgain;

    ! First, we parse any descriptive words (like "the", "five" or "every"):
    l = Descriptors(token_allows_multiple);
    if (l ~= 0) { etype = l; return 0; }

  .TryAgain2;

    ! This is an actual specified object, and is therefore where a typing error
    ! is most likely to occur, so we set:

    oops_from = wn;

    ! So, two cases.  Case 1: token not equal to "held" (so, no implicit takes)
    ! but we may well be dealing with multiple objects

    ! In either case below we use NounDomain, giving it the token number as
    ! context, and two places to look: among the actor's possessions, and in the
    ! present location.  (Note that the order depends on which is likeliest.)

    if (token ~= HELD_TOKEN) {
        i = multiple_object-->0;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Calling NounDomain on location and actor]^";
        #Endif; ! DEBUG
        l = NounDomain(actors_location, actor, token);
        if (l == REPARSE_CODE) return l;                  ! Reparse after Q&A
        if (indef_wanted == INDEF_ALL_WANTED && l == 0 && number_matched == 0)
            l = 1;  ! ReviseMulti if TAKE ALL FROM empty container

        if (token_allows_multiple && ~~multiflag) {
            if (best_etype==MULTI_PE) best_etype=STUCK_PE;
            multiflag = true;
        }
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            if (etype == MULTI_PE or TOOFEW_PE && multiflag) etype = STUCK_PE;
            etype=CantSee();
            jump FailToken;
        } ! Choose best error

        #Ifdef DEBUG;
        if (parser_trace >= 3) {
            if (l > 1) print "  [ND returned ", (the) l, "]^";
            else {
                print "  [ND appended to the multiple object list:^";
                k = multiple_object-->0;
                for (j=i+1 : j<=k : j++)
                    print "  Entry ", j, ": ", (The) multiple_object-->j,
                          " (", multiple_object-->j, ")^";
                print "  List now has size ", k, "]^";
            }
        }
        #Endif; ! DEBUG

        if (l == 1) {
            if (~~many_flag) many_flag = true;
            else {                                ! Merge with earlier ones
                k = multiple_object-->0;            ! (with either parity)
                multiple_object-->0 = i;
                for (j=i+1 : j<=k : j++) {
                    if (and_parity) MultiAdd(multiple_object-->j);
                    else            MultiSub(multiple_object-->j);
                }
                #Ifdef DEBUG;
                if (parser_trace >= 3)
                	print "  [Merging ", k-i, " new objects to the ", i, " old ones]^";
                #Endif; ! DEBUG
            }
        }
        else {
            ! A single object was indeed found

            if (match_length == 0 && indef_possambig) {
                ! So the answer had to be inferred from no textual data,
                ! and we know that there was an ambiguity in the descriptor
                ! stage (such as a word which could be a pronoun being
                ! parsed as an article or possessive).  It's worth having
                ! another go.

                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }

            if ((token == CREATURE_TOKEN) && (CreatureTest(l) == 0)) {
                etype = ANIMA_PE;
                jump FailToken;
            } !  Animation is required

            if (~~many_flag) single_object = l;
            else {
                if (and_parity) MultiAdd(l); else MultiSub(l);
                #Ifdef DEBUG;
                if (parser_trace >= 3) print "  [Combining ", (the) l, " with list]^";
                #Endif; ! DEBUG
            }
        }
    }

    else {

    ! Case 2: token is "held" (which fortunately can't take multiple objects)
    ! and may generate an implicit take

        l = NounDomain(actor,actors_location,token);       ! Same as above...
        if (l == REPARSE_CODE) return l;
        if (l == 0) {
            if (indef_possambig) {
                ResetDescriptors();
                wn = desc_wn;
                jump TryAgain2;
            }
            etype = CantSee(); jump FailToken;            ! Choose best error
        }

        ! ...until it produces something not held by the actor.  Then an implicit
        ! take must be tried.  If this is already happening anyway, things are too
        ! confused and we have to give up (but saving the oops marker so as to get
        ! it on the right word afterwards).
        ! The point of this last rule is that a sequence like
        !
        !     > read newspaper
        !     (taking the newspaper first)
        !     The dwarf unexpectedly prevents you from taking the newspaper!
        !
        ! should not be allowed to go into an infinite repeat - read becomes
        ! take then read, but take has no effect, so read becomes take then read...
        ! Anyway for now all we do is record the number of the object to take.

        o = parent(l);
        if (o ~= actor) {
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Allowing object ", (the) l, " for now]^";
            #Endif; ! DEBUG
        }
        single_object = l;
    } ! end of if (token ~= HELD_TOKEN) else

    ! The following moves the word marker to just past the named object...

    wn = oops_from + match_length;

    ! Object(s) specified now: is that the end of the list, or have we reached
    ! "and", "but" and so on?  If so, create a multiple-object list if we
    ! haven't already (and are allowed to).

  .NextInList;

    o = NextWord();

    if (o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word) {

        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Read connective '", (address) o, "']^";
        #Endif; ! DEBUG

        if (~~token_allows_multiple) {
            if (multiflag) jump PassToken; ! give UPTO_PE error
            etype=MULTI_PE;
            jump FailToken;
        }

        if (o == BUT1__WD or BUT2__WD or BUT3__WD) and_parity = 1-and_parity;

        if (~~many_flag) {
            multiple_object-->0 = 1;
            multiple_object-->1 = single_object;
            many_flag = true;
            #Ifdef DEBUG;
            if (parser_trace >= 3) print "  [Making new list from ", (the) single_object, "]^";
            #Endif; ! DEBUG
        }
        dont_infer = true; inferfrom=0;           ! Don't print (inferences)
        jump ObjectList;                          ! And back around
    }

    wn--;   ! Word marker back to first not-understood word

    ! Happy or unhappy endings:

  .PassToken;

    if (many_flag) {
        single_object = GPR_MULTIPLE;
        multi_context = token;
    }
    else {
        if (indef_mode == 1 && indef_type & PLURAL_BIT ~= 0) {
            if (indef_wanted < INDEF_ALL_WANTED && indef_wanted > 1) {
                multi_had = 1; multi_wanted = indef_wanted;
                etype = TOOFEW_PE;
                jump FailToken;
            }
        }
    }
    return single_object;

  .FailToken;

    ! If we were only guessing about it being a plural, try again but only
    ! allowing singulars (so that words like "six" are not swallowed up as
    ! Descriptors)

    if (allow_plurals && indef_guess_p == 1) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   [Retrying singulars after failure ", etype, "]^";
        #Endif;
        prev_indef_wanted = indef_wanted;
        allow_plurals = false;
        wn = desc_wn;
        jump TryAgain;
    }

    if ((indef_wanted > 0 || prev_indef_wanted > 0) && (~~multiflag)) etype = MULTI_PE;

    return GPR_FAIL;

]; ! end of ParseToken__

Constant OTHER_BIT  =   1;     !  These will be used in Adjudicate()
Constant MY_BIT     =   2;     !  to disambiguate choices
Constant THAT_BIT   =   4;
Constant PLURAL_BIT =   8;
Constant LIT_BIT    =  16;
Constant UNLIT_BIT  =  32;

[ ResetDescriptors;
    indef_mode = 0; indef_type = 0; indef_wanted = 0; indef_guess_p = 0;
    indef_possambig = false;
    indef_owner = nothing;
    indef_cases = $$111111111111;
    indef_nspec_at = 0;
];

[ ArticleDescriptors  o x flag cto type n;
    if (wn > num_words) return 0;

    for (flag=true : flag :) {
        o = NextWordStopped(); flag = false;

       for (x=1 : x<=LanguageDescriptors-->0 : x=x+4)
            if (o == LanguageDescriptors-->x) {
                type = LanguageDescriptors-->(x+2);
                if (type == DEFART_PK or INDEFART_PK) flag = true;
            }
    }
    wn--;
    return 0;
];



Global mf;

[ Descriptors allow_multiple  o x flag cto type n;

 mf = 0;

   ResetDescriptors();
   if (wn > num_words) return 0;

   for (flag=true:flag:)
   {   o=NextWordStopped(); flag=false;

       for (x=1:x<=LanguageDescriptors-->0:x=x+4)
           if (o == LanguageDescriptors-->x)
           {   flag = true;
               type = LanguageDescriptors-->(x+2);
               if (type ~= DEFART_PK) indef_mode = true;
               indef_possambig = true;
               indef_cases = indef_cases & (LanguageDescriptors-->(x+1));

               if (type == POSSESS_PK)
               {   cto = LanguageDescriptors-->(x+3);
                   switch(cto)
                   {  0: indef_type = indef_type | MY_BIT;
                      1: indef_type = indef_type | THAT_BIT;
                      default: indef_owner = PronounValue(cto);
                        if (indef_owner == NULL) indef_owner = InformParser;
                   }
               }

               if (type == light)
                   indef_type = indef_type | LIT_BIT;
               if (type == -light)
                   indef_type = indef_type | UNLIT_BIT;
           }

       if (o==OTHER1__WD or OTHER2__WD or OTHER3__WD)
                            { indef_mode=1; flag=1;
                              indef_type = indef_type | OTHER_BIT; }
       if (o==ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)
                            { indef_mode=1; flag=1; indef_wanted=100;
                              if (take_all_rule == 1)
                                  take_all_rule = 2;
                              indef_type = indef_type | PLURAL_BIT; 
                              if (mf==0) mf = wn-1;
                            }
       if (allow_plurals && allow_multiple)
       {   n=TryNumber(wn-1);
           if (n==1)        { indef_mode=1; flag=1; }
           if (n>1)         { indef_guess_p=1;
                              indef_mode=1; flag=1; indef_wanted=n;
                              indef_nspec_at=wn-1;
                              indef_type = indef_type | PLURAL_BIT;
                              if (mf==0) mf = wn-1;
                            }
       }
       if (flag==1
           && NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)
           wn--;  ! Skip 'of' after these
   }
   wn--;

!   if ((indef_wanted > 0) && (~~allow_multiple)) return MULTI_PE;

   return 0;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];

[ PrepositionChain wd index;
    if (line_tdata-->index == wd) return wd;
    if ((line_token-->index)->0 & $20 == 0) return -1;
    do {
        if (line_tdata-->index == wd) return wd;
        index++;
    } until ((line_token-->index == ENDIT_TOKEN) || (((line_token-->index)->0 & $10) == 0));
    return -1;
];

[ CreatureTest obj;
    if (obj has animate) rtrue;
    if (obj hasnt talkable) rfalse;
    if (action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor) rtrue;
    rfalse;
];



Array  printed_text -> 123;  



Global guessing;
[GuessingI6; return guessing; ];

! ----------------------------------------------------------------------------
!  NounDomain does the most substantial part of parsing an object name.
!
!  It is given two "domains" - usually a location and then the actor who is
!  looking - and a context (i.e. token type), and returns:
!
!   0    if no match at all could be made,
!   1    if a multiple object was made,
!   k    if object k was the one decided upon,
!   REPARSE_CODE if it asked a question of the player and consequently rewrote
!        the player's input, so that the whole parser should start again
!        on the rewritten input.
!
!   In the case when it returns 1<k<REPARSE_CODE, it also sets the variable
!   length_of_noun to the number of words in the input text matched to the
!   noun.
!   In the case k=1, the multiple objects are added to multiple_object by
!   hand (not by MultiAdd, because we want to allow duplicates).
! ----------------------------------------------------------------------------


[ MultiContext tkn;

! return true if the grammar token is one that allows for multiple objects
! ie. grammar line expects multiple objects

  if (tkn == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
     rtrue;
  rfalse;
];



[ WorthGuessingNoun act;

! Version 7 - I think this routine is no longer used, having been replaced by the I7 rules

	if (act == 

! list of actions for which guessing the only available non-scenery-type noun is worth doing

 ##Take or ##Drop or ##PutOn or ##Insert or ##Remove

	) rtrue; 
  rfalse;
];


[ NounDomain domain1 domain2 context    first_word i j k l
                                        answer_words marker flag;


#ifdef DEBUG;
  if (parser_trace>=4)
  {   print "   [NounDomain called at word ", wn, "^";
      print "   ";
      if (indef_mode)
      {   print "seeking indefinite object: ";
          if (indef_type & OTHER_BIT)  print "other ";
          if (indef_type & MY_BIT)     print "my ";
          if (indef_type & THAT_BIT)   print "that ";
          if (indef_type & PLURAL_BIT) print "plural ";
          if (indef_type & LIT_BIT)    print "lit ";
          if (indef_type & UNLIT_BIT)  print "unlit ";
          if (indef_owner ~= 0) print "owner:", (name) indef_owner;
          new_line;
          print "   number wanted: ";
          if (indef_wanted == 100) print "all"; else print indef_wanted;
          new_line;
          print "   most likely GNAs of names: ", indef_cases, "^";
      }
      else print "seeking definite object^";
  }
#endif;

! initialise variables

match_length=0; 
number_matched=0; 
match_from=wn; 

! build the match list

  SearchScope(domain1, domain2, context);

#ifdef DEBUG;
  if (parser_trace>=4) print "   [ND made ", number_matched, " matches]^";
#endif;

! use the match-list to determine if we were guessing or not
! seems backwards to use the results of parsing to decide if there's no text, but
! that's the way it's done.

  guessing = MatchListGuessing();

  #ifdef DEBUG;
  if (parser_trace>=4)
  {
  if (guessing)
   {
     print "[ND guessing]^";
   }
  else
   { print "[ND informed]^";

     for (i = 0: i< number_matched: i++)
  	if (match_list-->i~=0) print "^", (the) match_list-->i, "..?^";
   }
  }
  #endif;

  wn=match_from+match_length;

!  If nothing worked at all, leave with the word marker skipped past the
!  first unmatched word, and ditch this line

  if (number_matched==0) { wn++; rfalse; }

!  Suppose that there really were some words being parsed (i.e., we did
!  not just guess).  If so, and if there was only one match, it must be
!  right and we return it...

  if (match_from <= num_words)
  {   if (number_matched==1) 
      {
        i=match_list-->0; return i;
      }

!  ...now suppose that there was more typing to come, i.e. suppose that
!  the user entered something beyond this noun.  If nothing ought to follow,
!  then there must be a mistake, (unless what does follow is just a full
!  stop, and or comma)

!!! this, note, would be a great place to check PUT <x> DOWN and catch that problem!!
 
     if (wn<=num_words)
      {   i=NextWord(); wn--;
          if (i ~=  AND1__WD or AND2__WD or AND3__WD or comma_word
                 or THEN1__WD or THEN2__WD or THEN3__WD
                 or BUT1__WD or BUT2__WD or BUT3__WD)
          {   if (lookahead==ENDIT_TOKEN) rfalse;
          }

! DC Improvement
! We add the ability for the grammar line to check, here and now, if the next word in the input
! is the preposition the game is expecting for this line. This lets us fail the grammar line quickly
! if we're matching the wrong line entirely. The standard parser does do this, and can lead to Inform
! making guesses and disambiguating in contexts when it's no good to even try.

	#ifdef COBJ_DEBUG;
		print "Next token lookahead: ", line_ttype-->pcount , "!^";
	#endif;

		if (line_ttype-->pcount == PREPOSITION_TT)
		{
      	  		if (~~PrepositionChain(i, pcount) ~= -1) 
			{
!				print "(We've failed to match our preposition. Woohoo! Let's move on)";
      		 	rfalse;
			}
		}


! otherwise, if the next token is another noun, we run the parser to gather results for the second noun, so we
! can do a ChooseObjects pass - using the I7 rules - using full lines, rather than partially matched ones.

		if (line_ttype-->pcount == ELEMENTARY_TT or ATTR_FILTER_TT or ROUTINE_FILTER_TT)
		{		

			SafeSkipDescriptors();

			! save the current match state, since we're experimenting here
			@push token_filter; @push wn; @push match_length; @push match_from; @push number_matched;
			
			! now get all the matches for the second noun
			match_length = 0; number_matched = 0; match_from = wn;

			if (line_ttype-->pcount == ELEMENTARY_TT)
			{
				! cheapest way of filling the match list
				SearchScope(actor, actors_location, line_tdata-->pcount);
			}
			else
			{
				! more complex tokens need a bit more work

				if (line_ttype-->pcount == ATTR_FILTER_TT)
				{	token_filter = 1 + line_tdata-->pcount;
				}
				else
				{	token_filter = line_tdata-->pcount;
				}
				SearchScope(actor, actors_location, NOUN_TOKEN);
			}

			#ifdef DEBUG;
				if (parser_trace >= 4)
					print number_matched, " possible continuation nouns";
			#endif;

			i = number_matched;

			! reset the position of the parser from before this pass
			@pull number_matched; @pull match_from; @pull match_length; @pull wn; @pull token_filter;

			! Are there no matches for the second noun? If so, we can give up here and now.
			if (i == 0) 
			{
				#ifdef DEBUG;
					if (parser_trace >= 4)
						print "(Failed to match follow-on words. Moving to next line.)^";
				#endif;
				rfalse;
			}
					
		}
      }
}

!  Now, if there's more than one choice, let's see if we can do better

  number_of_classes=0;

  if (number_matched > 1) 
  {  	
	(Global_Vars-->14) = false; 	! we set the list-writer to false and see if the outcomes can make it true again

	! Now we run Adjudicate, which in turn runs ChooseObjects and the I7 routines
	! these routines will score the options, and delete inappropriate ones

	i=Adjudicate(context);
	
	! Did we fail to get anything from Adjudicate?
	if (i == -1)
	{
		! If we're guessing, then there was nothing valid. So let's ask the player to explain themselves.
		if (guessing) 
		{
			if (indef_possambig)
			{
				if (parser_trace == 5)
					print "    [Failed to find anything using an ambiguous input.]^";
				rfalse;
			}
			jump Incomplete;		
		}
		
		! otherwise, if we weren't guessing, then what the player typed made no sense after all, so fail the line.
		rfalse;
	}

      if (i==1)  ! A multiple object was matched. 
      {

		! If we're not looking for a multiple noun, then we have a fundamental problem
	 	if (~~MultiContext(context)) 
			 print "[BUG in Disambiguation: Multiple object made it out of Adjudicate!]^";

		rtrue;

      }

  }

! If i is non-zero, then we're looking at an object

!  If i is non-zero here, one of two things is happening: either
!  (a) an inference has been successfully made that object i is
!      the intended one from the user's specification, or
!  (b) the user finished typing some time ago, but we've decided
!      on i because it's the only possible choice.
!  In either case we have to keep the pattern up to date,
!  note that an inference has been made and return.
!  (Except, we don't note which of a pile of identical objects.)


  if (i~=0)
  {   
	if (dont_infer && ~~guessing) 
	{
		
		! we're not guessing. We're always allow to default
		! when we're not guessing
		return i;
	}

	! if we are guessing, we're only allowed to default if list-outcomes made it to true

	if (guessing && (Global_Vars-->14) == false)	
	{
		! in which case, we jump to incomplete and act all surprised.

	!	print "[*** Jumping to incomplete due to rubbish matches ***]^";

		jump Incomplete;
	}

! this is where we record that we guessed this one, rather than being told about it
! we need to record this fact for the insertion of "it" that'll happen later, if there's a parse-line
! reconstruction. 

! for a first-pass, let's just set a flag.

      if (inferfrom==0) 
	{
		inferfrom=pcount;
		if (guessing)
		{
			! this was our first point of guesswork on this line, as the interfrom was still zero
			if (parser_trace >= 4) print "[Setting guessed first noun to true]^";
			guessed_first_noun = true;
		}
	}
      pattern-->pcount = i;
      return i;
  }


!  If we get here, there was no obvious choice of object to make.  If in
!  fact we've already gone past the end of the player's typing (which
!  means the match list must contain every object in scope, regardless
!  of its name), then it's foolish to give an enormous list to choose
!  from - instead we go and ask a more suitable question...

! if we're not guessing, but at the end of the line, we still want to add
! extra text to the end of the input, rather that in the middle somewhere
! We have to do these two differently, because of the way text is spliced together

  if (match_from > num_words && ~~guessing) jump Incomplete;

.ListOutPoint;

!  Now we print up the question, using the equivalence classes as worked
!  out by Adjudicate() so as not to repeat ourselves on plural objects...

	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump SkipWhichQuestionB;


#ifdef NO_SUGGESTIONS;
			ParserMessage(1);
            	if (context==CREATURE_TOKEN) ParserMessage(8); else ParserMessage(9);

#ifnot;

	
	if (number_of_classes > TRUNCATE_LIST || (Global_Vars-->14) == false) 
	{		
			ParserMessage(1);
			if (context==CREATURE_TOKEN) ParserMessage(8); else ParserMessage(9);
			jump SkipWhichQuestionB;
	}

	else
	{

		if (context==CREATURE_TOKEN) ParserMessage(2); else ParserMessage(3);

		PrintMatchClasses(match_list, number_of_classes, 0);

		ParserMessage(10);

	}

	.SkipWhichQuestionB; 
	EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);

    ! ...and get an answer:


  .WhichOne;
  for (i=2:i<120:i++) buffer2->i=' ';
  answer_words=Keyboard(buffer2, parse2);


  if (guessing==1) jump DoneIncompleteInput;



  first_word=(parse2-->1);

!  Take care of "all", because that does something too clever here to do
!  later on:

  if (first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)
  {
      if (MultiContext(context)) ! we stick all of these guys into the multiple object list. Do we really want to do it this way?
						  ! this list just then gets "used" as a normal reply (i guess it's okay; isn't it?!?)
      {   l=multiple_object-->0;
          for (i=0:i<number_matched && l+i<63:i++)
          {   k=match_list-->i;
              multiple_object-->(i+1+l) = k;
          }
          multiple_object-->0 = i+l;   
          rtrue;
      }

	ParserMessage(12);
!      L__M(##Miscellany, 47);
      jump WhichOne;
  }

!  If the first word of the reply can be interpreted as a verb, then
!  assume that the player has ignored the question and given a new
!  command altogether.
!  (This is one time when it's convenient that the directions are
!  not themselves verbs - thus, "north" as a reply to "Which, the north
!  or south door" is not treated as a fresh command but as an answer.)

  #ifdef LanguageIsVerb;
  if (first_word==0)
  {   j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
  }
  #endif;
    if (first_word ~= 0) {
        j = first_word->#dict_par1;
        if ((0 ~= j&1) && ~~LanguageVerbMayBeName(first_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }

!  Now we insert the answer into the original typed command, as
!  words additionally describing the same object
!  (eg, > take red button
!       Which one, ...
!       > music
!  becomes "take music red button".  The parser will thus have three
!  words to work from next time, not two.)

    #Ifdef TARGET_ZCODE;
    k = WordAddress(match_from) - buffer; l=buffer2->1+1;
    for (j=buffer + buffer->0 - 1 : j>=buffer+k+l : j-- ) j->0 = 0->(j-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(2+i);
    buffer->(k+l-1) = ' ';
    buffer->1 = buffer->1 + l;
    if (buffer->1 >= (buffer->0 - 1)) buffer->1 = buffer->0;
    #Ifnot; ! TARGET_GLULX
    k = WordAddress(match_from) - buffer;
    l = (buffer2-->0) + 1;
    for (j=buffer+INPUT_BUFFER_LEN-1 : j>=buffer+k+l : j-- ) j->0 = j->(-l);
    for (i=0 : i<l : i++) buffer->(k+i) = buffer2->(WORDSIZE+i);
    buffer->(k+l-1) = ' ';
    buffer-->0 = buffer-->0 + l;
    if (buffer-->0 > (INPUT_BUFFER_LEN-WORDSIZE)) buffer-->0 = (INPUT_BUFFER_LEN-WORDSIZE);
    #Endif; ! TARGET_
  


!  Having reconstructed the input, we warn the parser accordingly
!  and get out.

	.RECONSTRUCT_INPUT;

	num_words = WordCount();
    wn = 1;
    #Ifdef LanguageToInformese;
    LanguageToInformese();
    ! Re-tokenise:
    VM_Tokenise(buffer,parse);
    #Endif; ! LanguageToInformese
	num_words = WordCount();
    players_command = 100 + WordCount();
	FollowRulebook(Activity_after_rulebooks-->READING_A_COMMAND_ACT, true);

  return REPARSE_CODE;

!  Now we come to the question asked when the input has run out
!  and can't easily be guessed (eg, the player typed "take" and there
!  were plenty of things which might have been meant).

  .Incomplete;

  	BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
	if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) jump AfterWhichMessage;


      if (context==CREATURE_TOKEN)
      	ParserMessage(4); else ParserMessage(5);

	.AfterWhichMessage;

	EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);


 	.AskedIncomplete;

    #Ifdef TARGET_ZCODE;
    for (i=2 : i<INPUT_BUFFER_LEN : i++) buffer2->i=' ';
    #Endif; ! TARGET_ZCODE
    answer_words = Keyboard(buffer2, parse2);


.DoneIncompleteInput;

  first_word=(parse2-->1);
  #ifdef LanguageIsVerb;
  if (first_word==0)
  {   j = wn; first_word=LanguageIsVerb(buffer2, parse2, 1); wn = j;
  }
  #endif;

!  Once again, if the reply looks like a command, give it to the
!  parser to get on with and forget about the question...



  if (first_word ~= 0)
  {   j=first_word->#dict_par1;
      if (0~=j&1)
      {   VM_CopyBuffer(buffer, buffer2);


          return REPARSE_CODE;
      }
  }

!  ...but if we have a genuine answer, then:
!
!  (1) we must glue in text suitable for anything that's been inferred.

    if (inferfrom ~= 0) {
        for (j=inferfrom : j<pcount : j++) {
            if (pattern-->j == PATTERN_NULL) continue;
            #Ifdef TARGET_ZCODE;
            i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
            #Ifnot; ! TARGET_GLULX
            i = WORDSIZE + buffer-->0;
            (buffer-->0)++; buffer->(i++) = ' ';
            #Endif; ! TARGET_

            #Ifdef DEBUG;
            if (parser_trace >= 5)
            	print "[Gluing in inference with pattern code ", pattern-->j, "]^";
            #Endif; ! DEBUG

            ! Conveniently, parse2-->1 is the first word in both ZCODE and GLULX.

            parse2-->1 = 0;

            ! An inferred object.  Best we can do is glue in a pronoun.
            ! (This is imperfect, but it's very seldom needed anyway.)

! BUG 24/7/10:
! The following code provides for cases where the parser has filled in the first word
! from no input entirely and asked for clarification on the second word.
! It needs to glue something into the "gap" to cover the missing noun, otherwise the 
! line will no longer match.
! Problem is, if the parser had some text here -- which seems to happen in the case
! of an adjudication between identical copy items -- then it shoves "it" on the end, and 
! this fails to match.
! So ideally this block of code will ONLY fire if there was NOTHING in the input line for the first noun.
! How do we check for this? Can we use one of the guessing-type flags set above??

! First pass: get something to print out which case we're in
! Tests are : >GIVE ITEM X / >PERSON Y when the player has 2 Xs
! SNARK / > PERSON Y, when there is a rule for "Suggesting" item X for snarking (no duplicate X required.)

            if (pattern-->j >= 2 && pattern-->j < REPARSE_CODE)
		{
			if (guessed_first_noun)
			{
	                PronounNotice(pattern-->j);
       	        for (k=1 : k<=LanguagePronouns-->0 : k=k+3)
              	      if (pattern-->j == LanguagePronouns-->(k+2)) {
                     	   parse2-->1 = LanguagePronouns-->k;
                        		#Ifdef DEBUG;
                        		if (parser_trace >= 4)
                        			print "[Using pronoun as guessed_first was true.]^";
                        		if (parser_trace >= 5)
                        			print "[Using pronoun '", (address) parse2-->1, "']^";
                        		#Endif; ! DEBUG
                       	   break;
                    }
			else if (parser_trace >=4 ) print "[Not using pronoun as guessed_first was false.]^";
		}
            }
            else {
                ! An inferred preposition.
                parse2-->1 = VM_NumberToDictionaryAddress(pattern-->j - REPARSE_CODE);
                #Ifdef DEBUG;
                if (parser_trace >= 5)
                	print "[Using preposition '", (address) parse2-->1, "']^";
                #Endif; ! DEBUG
            }

            ! parse2-->1 now holds the dictionary address of the word to glue in.

            if (parse2-->1 ~= 0) {
                k = buffer + i;
                #Ifdef TARGET_ZCODE;
                @output_stream 3 k;
                 print (address) parse2-->1;
                @output_stream -3;
                k = k-->0;
                for (l=i : l<i+k : l++) buffer->l = buffer->(l+2);
                i = i + k; buffer->1 = i-2;
                #Ifnot; ! TARGET_GLULX
                k = Glulx_PrintAnyToArray(buffer+i, INPUT_BUFFER_LEN-i, parse2-->1);
                i = i + k; buffer-->0 = i - WORDSIZE;
                #Endif; ! TARGET_
            }
        }
    }

!  (2) we must glue the newly-typed text onto the end.

    #Ifdef TARGET_ZCODE;
    i = 2+buffer->1; (buffer->1)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2->1 : i++,j++) {
        buffer->i = buffer2->(j+2);
        (buffer->1)++;
        if (buffer->1 == INPUT_BUFFER_LEN) break;
    }
    #Ifnot; ! TARGET_GLULX
    i = WORDSIZE + buffer-->0;
    (buffer-->0)++; buffer->(i++) = ' ';
    for (j=0 : j<buffer2-->0 : i++,j++) {
        buffer->i = buffer2->(j+WORDSIZE);
        (buffer-->0)++;
        if (buffer-->0 == INPUT_BUFFER_LEN) break;
    }
    #Endif; ! TARGET_

    ! (3) we fill up the buffer with spaces, which is unnecessary, but may
    !     help incorrectly-written interpreters to cope.

    #Ifdef TARGET_ZCODE;
    for (: i<INPUT_BUFFER_LEN : i++) buffer->i = ' ';
    #Endif; ! TARGET_ZCODE


    return REPARSE_CODE;

];



[ PrintMatchClasses ar max imark i marker k ;
!print "(max ", max, " imark ", imark, ")^";
    marker = imark;
    for (i=1 : i<=max : i++) {
        while (((match_classes-->marker) ~= i) && ((match_classes-->marker) ~= -i))
	  {
!		print match_classes-->marker, " / from marker ", marker, "^";
		marker++;
	  }
        k = ar-->marker;

        if (match_classes-->marker > 0) print (the) k; else print (a) k;

        if (i < max-1)  print (string) COMMA__TX;
        if (i == max-1) {
			#Ifdef SERIAL_COMMA;
			print ",";
        	#Endif; ! SERIAL_COMMA
        	print (string) OR__TX;
        }
    }
 ];




[ BestScore its_score best i;
    best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i; if (its_score > best) best = its_score; 
    }
    return best;
];

[ Adjudicate context i j k good_flag good_ones last n ultimate flag offset  best_score;


    #Ifdef DEBUG;
    if (parser_trace >= 4) {
        print "   [Adjudicating match list of size ", number_matched,
        	" in context ", context, "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (indef_type & OTHER_BIT)  print "other ";
            if (indef_type & MY_BIT)     print "my ";
            if (indef_type & THAT_BIT)   print "that ";
            if (indef_type & PLURAL_BIT) print "plural ";
            if (indef_type & LIT_BIT)    print "lit ";
            if (indef_type & UNLIT_BIT)  print "unlit ";
            if (indef_owner ~= 0) print "owner:", (name) indef_owner;
            new_line;
            print "   number wanted: ";
            if (indef_wanted == 100) print "all"; else print indef_wanted;
            new_line;
            print "   most likely GNAs of names: ", indef_cases, "^";
        }
        else print "definite object^";
    }
    #Endif; ! DEBUG

    j = number_matched-1; good_ones = 0; last = match_list-->0;
    for (i=0 : i<=j : i++) {
        n = match_list-->i;
        match_scores-->i = good_ones;
        ultimate = ScopeCeiling(n);

        if (context==HELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTI_TOKEN && ultimate==ScopeCeiling(actor)
            && n~=actor && n hasnt concealed !&& n hasnt scenery
		) 
        {   good_ones++; last=n; }

        if (context==MULTIHELD_TOKEN && parent(n)==actor)
        {   good_ones++; last=n; }

        if (context==MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)
        {   if (advance_warning==-1)
            {   if (context==MULTIEXCEPT_TOKEN)
                {   good_ones++; last=n;
                 }
                if (context==MULTIINSIDE_TOKEN)
                {   if (parent(n)~=actor) { good_ones++; last=n; }
                 }
            }
            else
            {   if (context==MULTIEXCEPT_TOKEN && n~=advance_warning)
                {   good_ones++; last=n; }
                if (context==MULTIINSIDE_TOKEN && n in advance_warning)
                {   good_ones++; last=n; }
            }
         }
        if (context==CREATURE_TOKEN && CreatureTest(n)==1)
        {   good_ones++; last=n; }
        
        match_scores-->i = 1000*(good_ones - match_scores-->i);
    }

    if (good_ones == 1)
	{	
		! these are good, regardless of our rules (this is duplication, but it'll do for now)

		(Global_Vars-->14) = true;		

		 return last;
	}

  ! If there is ambiguity about what was typed, but it definitely wasn't
  ! animate as required, then return anything; higher up in the parser
  ! a suitable error will be given.  (This prevents a question being asked.)
  ! if (context==CREATURE_TOKEN && good_ones==0) return match_list-->0;

  	if (indef_mode==0) indef_type=0;

	ScoreMatchL(context);
	if (number_matched == 0) return -1;

	!print "(Made ", number_matched, " indef ", indef_mode, " & ", indef_wanted, ".^";
 
  if (indef_mode == 0 && guessing == false)
  {   !  Is there now a single highest-scoring object?
      i = SingleBestGuess();
      if (i >= 0)
      {
#ifdef DEBUG;
          if (parser_trace>=4)
              print "   Single best-scoring object returned.]^";
#endif;
          return i;
      }
  }

  best_score = BestScore();

 ! ------If we've made a multiple object we investigate it, term by term, to check that everything in it should be in it
 !         note that we load up the multiple object list not from 0 but from wherever it happens to be
 ! 	   and, even worse, we load it up out of order, chuck away the match list scores and chuck away the match list itself
 ! 	   and the only ray of hope in all this is it assembles the multiple object list in order of preference
 !	   (although why it does that I have no idea, because I'm sure all this info is later ignored.)


  

  if (indef_mode==1 && indef_type & PLURAL_BIT ~= 0)
  {

#ifndef PUT_IN_FOR_NOW;

	if (~~MultiContext(context)) 
	{
		indef_mode = 0; !print "JUMPING MULTI";
		jump PostMultiObject; 
	}


#endif;

!print "DOING MULTI";

      i=0; offset=multiple_object-->0; 
      for (j=BestGuess():j~=-1 && i<indef_wanted
           && i+offset<63:j=BestGuess())
      {   flag=0;


	
	            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
	            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j)) == 0) {

        	  if (j hasnt concealed && j hasnt worn) flag=1;

       		   if (context==MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN
       	      		 && parent(j)~=actor) flag=0;
	       	   if (action_to_be == ##Take or ##Remove && parent(j)==actor) flag=0;

        	  k=ChooseObjects(j,flag);
	
	          if (k==1) flag=1; else { if (k==2) flag=0; }
	
	            } else {
	                flag = 0; if (RulebookSucceeded()) flag = 1;
	            }
	            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);



          if (flag==1)
          {   i++; multiple_object-->(i+offset) = j;
#ifdef DEBUG;
              if (parser_trace>=4) print "   Accepting it^";
#endif;
          }
          else
          {   i=i;
#ifdef DEBUG;
              if (parser_trace>=4) print "   Rejecting it^";
#endif;
          }
      }
      if (i<indef_wanted && indef_wanted<100)
      {   etype=TOOFEW_PE; multi_wanted=indef_wanted;
          multi_had=i;
          return -1;
      }
      multiple_object-->0 = i+offset;
      multi_context=context;
#ifdef DEBUG;
      if (parser_trace>=4)
          print "   Made multiple object of size ", i, "]^";
#endif;
      return 1;
  }


.PostMultiObject;

! We set match classes in a routine so we can do it again below

		n =	SetMatchClasses(match_list, 0, number_matched);


#ifdef DEBUG;
  if (parser_trace>=4)
  {   print "  ** Grouped into ", n, " possibilities by name:^";
      for (i=0:i<number_matched:i++)
          if (match_classes-->i > 0)
              print "   ", (The) match_list-->i,
                  " (", match_list-->i, ")  ---  group ",
                  match_classes-->i, "^";
  }
#endif;


  if (indef_mode == 0)
  {   if (n > 1)
      {   k = -1;
          for (i=0:i<number_matched:i++)
          {   if (match_scores-->i > k)
              {   k = match_scores-->i;                ! current highest
                  j = match_classes-->i; j=j*j;        ! j = classes^2 ?!? (fix sign?)
                  flag = 0;
              }
              else
              if (match_scores-->i == k)                ! we found a draw
              {   if ((match_classes-->i) * (match_classes-->i) ~= j)
                      flag = 1;                                 ! we found a different class
              }
          }
          if (flag)
          {
#ifdef DEBUG;
              if (parser_trace>=4)
                  print "   Unable to choose best group, so ask player.]^";
#endif;

!                  if (guessing)
!                  {
#ifdef DEBUG;
              if (parser_trace>=4)
                    print "[Highest score ", k, " -- deleting all lower scores.]^";
#endif;

                     for (i=0:i<number_matched:i++)
                      {   while (match_scores-->i < k)
                          {   if (i == number_matched-1) { number_matched--; break; }
                              for (j=i:j<number_matched:j++)
                              {   match_list-->j = match_list-->(j+1);
                                  match_scores-->j = match_scores-->(j+1);
                              }
                              number_matched--;
                          }
                      }

#ifdef DEBUG;
              if (parser_trace>=4)
                       print "[", number_matched, " entries remaining.]^";
#endif;
		
			SetMatchClasses(match_list, 0, number_matched);
!                  }
              return 0;
          }

#ifdef DEBUG;
          if (parser_trace>=4)
              print "   Best choices are all from the same group.^";
#endif;
      }
  }

!  When the player is really vague, or there's a single collection of
!  indistinguishable objects to choose from, choose the one the player
!  most recently acquired, or if the player has none of them, then
!  the one most recently put where it is.

  !if (n == 1) dont_infer = true;
  return BestGuess();
];




[ SetMatchClasses ar st en max i n flag j;
	max = en + st - 1;

  for (i = st :i <= max  :i++) match_classes-->i=0;

  n=1;
  for (i = st :i <= max : i++)
      if (match_classes-->i==0)
      {   match_classes-->i=n++; flag=0; 
          for (j=i+1 : j<=max : j++)
              if (match_classes-->j==0
                  && Identical(ar-->i, ar-->j)==1)
              {   flag=1; 
                  match_classes-->j=match_classes-->i;
              }
          if (flag==1) match_classes-->i = 1-n;
      }
  n--; number_of_classes = n;
  return n;
];



[ ReviseMulti second_p  i low;
    #Ifdef DEBUG;
    if (parser_trace >= 4)
    	print "   Revising multiple object list of size ", multiple_object-->0,
     	" with 2nd ", (name) second_p, "^";
    #Endif; ! DEBUG

    if (multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN) {
        for (i=1,low=0 : i<=multiple_object-->0 : i++) {
            if ( (multi_context==MULTIEXCEPT_TOKEN && multiple_object-->i ~= second_p) ||
                 (multi_context==MULTIINSIDE_TOKEN && multiple_object-->i in second_p)) {
                low++;
                multiple_object-->low = multiple_object-->i;
            }
        }
        multiple_object-->0 = low;
    }

    if (multi_context == MULTI_TOKEN && action_to_be == ##Take) {
        #Ifdef DEBUG;
        if (parser_trace >= 4) print "   Token 2 plural case: number with actor ", low, "^";
        #Endif; ! DEBUG
        if (take_all_rule == 2) {
            for (i=1,low=0 : i<=multiple_object-->0 : i++) {
                if (ScopeCeiling(multiple_object-->i) == ScopeCeiling(actor)) {
                    low++;
                    multiple_object-->low = multiple_object-->i;
                }
            }
            multiple_object-->0 = low;
        }
    }

    i = multiple_object-->0;
    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Done: new size ", i, "^";
    #Endif; ! DEBUG
    if (i == 0) return NOTHING_PE;
    return 0;
];

[ MakeMatch obj quality i;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match with quality ",quality,"^";
    #Endif; ! DEBUG
    if (token_filter ~= 0 && ConsultNounFilterToken(obj) == 0) {
        #Ifdef DEBUG;
        if (parser_trace >= 6) print "    Match filtered out: token filter ", token_filter, "^";
        #Endif; ! DEBUG
        rtrue;
    }
    if (quality < match_length) rtrue;
    if (quality > match_length) { match_length = quality; number_matched = 0; }
    else {
        if (number_matched >= MATCH_LIST_WORDS) rtrue;
        for (i=0 : i<number_matched : i++)
            if (match_list-->i == obj) rtrue;
    }
    match_list-->number_matched++ = obj;
    #Ifdef DEBUG;
    if (parser_trace >= 6) print "    Match added to list^";
    #Endif; ! DEBUG
];

[ ConsultNounFilterToken obj;
    if (token_filter ofclass Routine) {
	    noun = obj;
    	return indirect(token_filter);
    }
    if (obj has (token_filter-1)) rtrue;
    rfalse;
];



Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;

Constant PREFER_HELD;

[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s fda ;

!   if (indef_type & OTHER_BIT ~= 0) threshold++;
    if (indef_type & MY_BIT ~= 0)    threshold++;
    if (indef_type & THAT_BIT ~= 0)  threshold++;
    if (indef_type & LIT_BIT ~= 0)   threshold++;
    if (indef_type & UNLIT_BIT ~= 0) threshold++;
    if (indef_owner ~= nothing)      threshold++;

    #Ifdef DEBUG;
    if (parser_trace >= 4) print "   Scoring match list: indef mode ", indef_mode, " type ",
      indef_type, ", satisfying ", threshold, " requirements:^";
    #Endif; ! DEBUG

    #ifdef PREFER_HELD;
    a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    if (action_to_be == ##Take or ##Remove) {
        a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    }
    context = context;  ! silence warning
    #ifnot;
    a_s = SCORE__NEXTBESTLOC; l_s = SCORE__BESTLOC;
    if (context == HELD_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN) {
        a_s = SCORE__BESTLOC; l_s = SCORE__NEXTBESTLOC;
    }
    #endif; ! PREFER_HELD


  for (i=0: i<number_matched: i++) {
      obj = match_list-->i; its_owner = parent(obj); its_score=0;

!      if (indef_type & OTHER_BIT ~=0
!          &&  obj~=itobj or himobj or herobj) met++;
      if (indef_type & MY_BIT ~=0  &&  its_owner==actor) met++;
      if (indef_type & THAT_BIT ~=0  &&  its_owner==actors_location) met++;
      if (indef_type & LIT_BIT ~=0  &&  obj has light) met++;
      if (indef_type & UNLIT_BIT ~=0  &&  obj hasnt light) met++;
      if (indef_owner~=0 && its_owner == indef_owner) met++;

      if (met < threshold)
      {
#ifdef DEBUG;
          if (parser_trace >= 4)
              print "   ", (The) match_list-->i,
                    " (", match_list-->i, ") in ", (the) its_owner,
                    " is rejected (doesn't match descriptors)^";
#endif;
          match_list-->i=-1;
      }
      else
      {   its_score = 0;



		fda = ChooseObjects(obj, 2, context);
		if (fda > -1) its_score = SCORE__CHOOSEOBJ * fda;
		else match_list-->i = -1;

          if (obj hasnt concealed) its_score = its_score + SCORE__UNCONCEALED;

          if (its_owner==actor)   its_score = its_score + a_s;
          else
          if (its_owner==actors_location) its_score = its_score + l_s;
          else
          if (its_owner~=compass) its_score = its_score + SCORE__NOTCOMPASS;
	

          if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
          if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

          !   A small bonus for having the correct GNA,
          !   for sorting out ambiguous articles and the like.

          if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
              its_score = its_score + SCORE__GNA;



          match_scores-->i = match_scores-->i + its_score;

#ifdef DEBUG;
          if (parser_trace >= 4)
	{
		
	              print "     ", (The) obj,
                    " (", obj, ") in ", (the) its_owner;
		if (match_list-->i == -1) print " :  deleted by ChooseObjects^";
		else print " : ", match_scores-->i, " points^";
	}
#endif;
      }
  }



! remove dead entries from the match list

  for (i=0:i<number_matched:i++)
  {   while (match_list-->i == -1)
      {   if (i == number_matched-1) { number_matched--; break; }
          for (j=i:j<number_matched:j++)
          {   match_list-->j = match_list-->(j+1);
              match_scores-->j = match_scores-->(j+1);              
          }
          number_matched--;
      }
  }


if (guessing == true || (guessing == false && ChooseObjectsBypassDisambiguate()))
  for (i=0: i<number_matched:i++)
  { 
	if (match_list-->i~=-1)
	{	! we need to rescore everything using the more straightforward system
		! this gives scores for everything except actor's held / player held, which tends to separate stuff out

		its_score = 0;
		obj = match_list-->i; 

		its_owner = parent(obj);	 

		fda = ChooseObjects(obj, 2, context);
		if (fda > -1) its_score = its_score + SCORE__CHOOSEOBJ * fda;

          if (obj hasnt concealed) its_score = its_score +  SCORE__UNCONCEALED;

          if (its_owner~=compass) its_score = its_score + SCORE__NOTCOMPASS;

   !       if (obj hasnt scenery) its_score = its_score + SCORE__NOTSCENERY;
          if (obj ~= actor) its_score = its_score + SCORE__NOTACTOR;

          !   A small bonus for having the correct GNA,
          !   for sorting out ambiguous articles and the like.

          if (indef_cases & (PowersOfTwo_TB-->(GetGNAOfObject(obj))))
              its_score = its_score + SCORE__GNA;

          match_scores-->i = its_score;
#ifdef DEBUG;
          if (parser_trace >= 4)
              print "     ", (The) match_list-->i,
                    " (", match_list-->i, ") rescored at: ", match_scores-->i, " points^";
#endif;
	
	
	}

  }




];

[ BestGuess  earliest its_score best i;
    earliest = 0; best = -1;
    for (i=0 : i<number_matched : i++) {
        if (match_list-->i >= 0) {
            its_score = match_scores-->i;
            if (its_score > best) { best = its_score; earliest = i; }
        }
    }
    #Ifdef DEBUG;
    if (parser_trace >= 4)
      if (best < 0) print "   Best guess ran out of choices^";
      else print "   Best guess ", (the) match_list-->earliest,
      	" (", match_list-->earliest, ")^";
    #Endif; ! DEBUG
    if (best < 0) return -1;
    i = match_list-->earliest;
    match_list-->earliest = -1;
    return i;
];

[ SingleBestGuess  earliest its_score best i;
    earliest = -1; best = -1000;
    for (i=0 : i<number_matched : i++) {
        its_score = match_scores-->i;
        if (its_score == best) earliest = -1;
        if (its_score > best) { best = its_score; earliest = match_list-->i; }
    }
    return earliest;
];

[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if (o1 == o2) rtrue;  ! This should never happen, but to be on the safe side
    if (o1 == 0 || o2 == 0) rfalse;  ! Similarly
    if (o1 ofclass K3_direction || o2 ofclass K3_direction) rfalse; ! Saves time

    !  What complicates things is that o1 or o2 might have a parsing routine,
    !  so the parser can't know from here whether they are or aren't the same.
    !  If they have different parsing routines, we simply assume they're
    !  different.  If they have the same routine (which they probably got from
    !  a class definition) then the decision process is as follows:
    !
    !     the routine is called (with self being o1, not that it matters)
    !       with noun and second being set to o1 and o2, and action being set
    !       to the fake action TheSame.  If it returns -1, they are found
    !       identical; if -2, different; and if >=0, then the usual method
    !       is used instead.

    if (o1.parse_name ~= 0 || o2.parse_name ~= 0) {
      if (o1.parse_name ~= o2.parse_name) rfalse;
      parser_action = ##TheSame; parser_one = o1; parser_two = o2;
      j = wn; i = RunRoutines(o1,parse_name); wn = j;
      if (i == -1) rtrue;
      if (i == -2) rfalse;
    }

    !  This is the default algorithm: do they have the same words in their
    !  "name" (i.e. property no. 1) properties.  (Note that the following allows
    !  for repeated words and words in different orders.)

    p1 = o1.&1; n1 = (o1.#1)/WORDSIZE;
    p2 = o2.&1; n2 = (o2.#1)/WORDSIZE;

    !  for (i=0 : i<n1 : i++) { print (address) p1-->i, " "; } new_line;
    !  for (i=0 : i<n2 : i++) { print (address) p2-->i, " "; } new_line;

    for (i=0 : i<n1 : i++) {
        flag = 0;
        for (j=0 : j<n2 : j++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    for (j=0 : j<n2 : j++) {
        flag = 0;
        for (i=0 : i<n1 : i++)
            if (p1-->i == p2-->j) flag = 1;
        if (flag == 0) rfalse;
    }

    !  print "Which are identical!^";
    rtrue;
];

[ PrintInferredCommand from singleton_noun;
	singleton_noun = FALSE;
	if ((from ~= 0) && (from == pcount-1) &&
		(pattern-->from > 1) && (pattern-->from < REPARSE_CODE))
			singleton_noun = TRUE;

	if (singleton_noun) {
		BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
		if (ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from) == 0) {
			print "("; PrintCommand(from); print ")^";
		}
		EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, pattern-->from);
	} else {
		print "("; PrintCommand(from); print ")^";
	}
];

[ PrintCommand from i k spacing_flag;
    if (from == 0) {
        i = verb_word;
        if (LanguageVerb(i) == 0)
            if (PrintVerb(i) == 0) print (address) i;
        from++; spacing_flag = true;
    }
    for (k=from : k<pcount : k++) {
        i = pattern-->k;
        if (i == PATTERN_NULL) continue;
        if (spacing_flag) print (char) ' ';
        if (i == 0) { print (string) THOSET__TX; jump TokenPrinted; }
        if (i == 1) { print (string) THAT__TX;   jump TokenPrinted; }
        if (i >= REPARSE_CODE)
            print (address) VM_NumberToDictionaryAddress(i-REPARSE_CODE);
        else
            if (i ofclass K3_direction)
                print (LanguageDirection) i; ! the direction name as adverb
            else
                print (the) i;
      .TokenPrinted;
        spacing_flag = true;
    }
];

[ CantSee  i w e;
    saved_oops=oops_from;

    if (scope_token ~= 0) {
        scope_error = scope_token; return ASKSCOPE_PE;
    }

    wn--; w = NextWord();
    e = CANTSEE_PE;
    if (w == pronoun_word) {
		w = NextWordStopped(); wn--;
		if ((w == -1) || (line_token-->(pcount) ~= ENDIT_TOKEN)) {
	    	AnalyseToken(line_token-->(pcount-1));
			!DebugToken(pcount-1); print " ", found_ttype, "^";
			if (found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT)
				e = NOTINCONTEXT_PE;
			else {
				pronoun__word = pronoun_word; pronoun__obj = pronoun_obj;
				e = ITGONE_PE;
			}
		}
    }
    
    if (etype > e) return etype;
    return e;
];

[ MultiAdd o i j;
    i = multiple_object-->0;
    if (i == MATCH_LIST_WORDS-1) { toomany_flag = 1; rtrue; }
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) rtrue;
    i++;
    multiple_object-->i = o;
    multiple_object-->0 = i;
];

[ MultiSub o i j k;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++)
        if (o == multiple_object-->j) {
            for (k=j : k<=i : k++) multiple_object-->k = multiple_object-->(k+1);
            multiple_object-->0 = --i;
            return 0;
        }
    return VAGUE_PE;
];

[ MultiFilter attr  i j o;
	.MFiltl;
    i = multiple_object-->0;
    for (j=1 : j<=i : j++) {
        o = multiple_object-->j;
        if (o hasnt attr) { MultiSub(o); jump Mfiltl; }
    }
];

[ PlaceInScope O opts; ! If opts is set, do not place contents in scope
	wn = match_from;
	if (opts == false) DoScopeActionAndRecurse(O);
	else DoScopeAction(O);
	return;
];

[ AddToScope obj;
    if (ats_flag >= 2) DoScopeActionAndRecurse(obj, 0, ats_flag-2);
    if (ats_flag == 1) { if (HasLightSource(obj)==1) ats_hls = 1; }
];

[ TestScope obj act a al sr x y;
    x = parser_one; y = parser_two;
    parser_one = obj; parser_two = 0; a = actor; al = actors_location;
    sr = scope_reason; scope_reason = TESTSCOPE_REASON;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    SearchScope(actors_location, actor, 0); scope_reason = sr; actor = a;
    actors_location = al; parser_one = x; x = parser_two; parser_two = y;
    return x;
];

[ LoopOverScope routine act x y a al;
    x = parser_one; y = scope_reason; a = actor; al = actors_location;
    parser_one = routine;
    if (act == 0) actor = player; else actor = act;
    actors_location = ScopeCeiling(actor);
    scope_reason = LOOPOVERSCOPE_REASON;
    SearchScope(actors_location, actor, 0);
    parser_one = x; scope_reason = y; actor = a; actors_location = al;
];

[ SearchScope domain1 domain2 context i;
	if (domain1 == 0) return;
	! (a)
    if (scope_token) {
        scope_stage = 2;
        #Ifdef DEBUG;
        if (parser_trace >= 3) print "  [Scope routine called at stage 2]^";
        #Endif;
        if (indirect(scope_token) ~= 0) rtrue;
    }
	! (b)
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if (ForActivity(DECIDING_SCOPE_ACT, actor) == false) {
		! (c.1)
		if ((scope_reason == PARSING_REASON) && (context == MULTIINSIDE_TOKEN) &&
			(advance_warning ~= -1)) {
			if (IsSeeThrough(advance_warning) == 1)
			    ScopeWithin(advance_warning, 0, context);
		} else {
			! (c.2)
			if ((scope_reason == PARSING_REASON) && (context ~= CREATURE_TOKEN) &&
				(indef_mode == 0) && (domain1 == actors_location))
					ScopeWithin(compass);
			! (c.3)
			if (domain1 has supporter or container) DoScopeAction(domain1);
			ScopeWithin(domain1, domain2, context);
			! (c.4)
			if (domain2) {
				if (domain2 has supporter or container) DoScopeAction(domain2);
				ScopeWithin(domain2, 0, context);
			}
		}
		! (c.5)
		if (thedark == domain1 or domain2) {
			DoScopeActionAndRecurse(actor, actor, context);
			if (parent(actor) has supporter or container)
				DoScopeActionAndRecurse(parent(actor), parent(actor), context);
		}
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];

[ ScopeWithin domain nosearch context obj next_obj;
    if (domain == 0) rtrue;

    ! Look through the objects in the domain, avoiding "objectloop" in case
    ! movements occur.
    obj = child(domain);
    while (obj) {
        next_obj = sibling(obj);
        if ((domain == actor) || (TestConcealment(domain, obj) == false))
            DoScopeActionAndRecurse(obj, nosearch, context);
        obj = next_obj;
    }
];

[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
	DoScopeAction(domain);

 	! (a)
    if ((domain ~= nosearch) &&
        ((domain ofclass K1_room or K8_person) || (IsSeeThrough(domain) == 1))) {
		obj = child(domain);
		while (obj) {
			next_obj = sibling(obj);
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, nosearch, context);
			obj = next_obj;
		}
	}

	! (b)
	if (domain provides component_child) {
		obj = domain.component_child;
		while (obj) {
			next_obj = obj.component_sibling;
			if ((domain == actor) || (TestConcealment(domain, obj) == false))
				DoScopeActionAndRecurse(obj, 0, context);
			obj = next_obj;
		}
	}

    ! (c)
    ad = domain.&add_to_scope;
    if (ad ~= 0) {
        ! Test if the property value is not an object.
        #Ifdef TARGET_ZCODE;
        i = (UnsignedCompare(ad-->0, top_object) > 0);
        #Ifnot; ! TARGET_GLULX
        i = (((ad-->0)->0) ~= $70);
        #Endif; ! TARGET_

        if (i) {
            ats_flag = 2+context;
            RunRoutines(domain, add_to_scope);
            ats_flag = 0;
        }
        else {
            n = domain.#add_to_scope;
            for (i=0 : (WORDSIZE*i)<n : i++)
                if (ad-->i)
                    DoScopeActionAndRecurse(ad-->i, 0, context);
        }
    }
];

[ DoScopeAction item;

    #Ifdef DEBUG;
    if (parser_trace >= 6)
        print "[DSA on ", (the) item, " with reason = ", scope_reason,
            " p1 = ", parser_one, " p2 = ", parser_two, "]^";
    #Endif; ! DEBUG

    @push parser_one; @push scope_reason;

	switch(scope_reason) {
		TESTSCOPE_REASON: if (item == parser_one) parser_two = 1;
		LOOPOVERSCOPE_REASON: if (parser_one ofclass Routine) indirect(parser_one, item);
		PARSING_REASON, TALKING_REASON: MatchTextAgainstObject(item);
    }

    @pull scope_reason; @pull parser_one;
];

[ MatchTextAgainstObject item i;
	if (match_from <= num_words) { ! If there's any text to match, that is
		wn = match_from;
		i = NounWord();
		if ((i == 1) && (player == item)) MakeMatch(item, 1); ! "me"
		if ((i >= 2) && (i < 128) && (LanguagePronouns-->i == item)) MakeMatch(item, 1);
	}

	! Construing the current word as the start of a noun, can it refer to the
	! object?

	wn = match_from;
	if (TryGivenObject(item) > 0)
		if (indef_nspec_at > 0 && match_from ~= indef_nspec_at) {
			! This case arises if the player has typed a number in
			! which is hypothetically an indefinite descriptor:
			! e.g. "take two clubs".  We have just checked the object
			! against the word "clubs", in the hope of eventually finding
			! two such objects.  But we also backtrack and check it
			! against the words "two clubs", in case it turns out to
			! be the 2 of Clubs from a pack of cards, say.  If it does
			! match against "two clubs", we tear up our original
			! assumption about the meaning of "two" and lapse back into
			! definite mode.

			wn = indef_nspec_at;
			if (TryGivenObject(item) > 0) {
				match_from = indef_nspec_at;
				ResetDescriptors();
			}
			wn = match_from;
		}
];

[ TryGivenObject obj nomatch threshold k w j;
    #Ifdef DEBUG;
    if (parser_trace >= 5) print "    Trying ", (the) obj, " (", obj, ") at word ", wn, "^";
    #Endif; ! DEBUG

	if (nomatch && obj == 0) return 0;

! if (nomatch) print "*** TryGivenObject *** on ", (the) obj, " at wn = ", wn, "^";

    dict_flags_of_noun = 0;

!  If input has run out then always match, with only quality 0 (this saves
!  time).

    if (wn > num_words) {
    	if (nomatch) return 0;
        if (indef_mode ~= 0)
            dict_flags_of_noun = $$01110000;  ! Reject "plural" bit
        MakeMatch(obj,0);
        #Ifdef DEBUG;
        if (parser_trace >= 5) print "    Matched (0)^";
        #Endif; ! DEBUG
        return 1;
    }

!  Ask the object to parse itself if necessary, sitting up and taking notice
!  if it says the plural was used:

    if (obj.parse_name~=0) {
        parser_action = NULL; j=wn;
        k = RunRoutines(obj,parse_name);
        if (k > 0) {
            wn=j+k;

          .MMbyPN;

            if (parser_action == ##PluralFound)
                dict_flags_of_noun = dict_flags_of_noun | 4;

            if (dict_flags_of_noun & 4) {
                if (~~allow_plurals) k = 0;
                else {
                    if (indef_mode == 0) {
                        indef_mode = 1; indef_type = 0; indef_wanted = 0;
                    }
                    indef_type = indef_type | PLURAL_BIT;
                    if (indef_wanted == 0) indef_wanted = INDEF_ALL_WANTED;
                }
            }

            #Ifdef DEBUG;
            if (parser_trace >= 5) print "    Matched (", k, ")^";
            #Endif; ! DEBUG
            if (nomatch == false) MakeMatch(obj,k);
            return k;
        }
        if (k == 0) jump NoWordsMatch;
    }

    ! The default algorithm is simply to count up how many words pass the
    ! Refers test:

    parser_action = NULL;

    w = NounWord();

    if (w == 1 && player == obj) { k=1; jump MMbyPN; }

    if (w >= 2 && w < 128 && (LanguagePronouns-->w == obj)) { k = 1; jump MMbyPN; }

    if (Refers(obj, wn-1) == 0) {
        .NoWordsMatch;
        if (indef_mode ~= 0) { k = 0; parser_action = NULL; jump MMbyPN; }
        rfalse;
    }

	threshold = 1;
	dict_flags_of_noun = (w->#dict_par1) & $$01110100;
	w = NextWord();
	while (Refers(obj, wn-1)) {
		threshold++;
		if (w)
		   dict_flags_of_noun = dict_flags_of_noun | ((w->#dict_par1) & $$01110100);
		w = NextWord();
	}

    k = threshold;
    jump MMbyPN;
];

[ Refers obj wnum   wd k l m;
    if (obj == 0) rfalse;

    #Ifdef LanguageRefers;
    k = LanguageRefers(obj,wnum); if (k >= 0) return k;
    #Endif; ! LanguageRefers

    k = wn; wn = wnum; wd = NextWordStopped(); wn = k;

    if (parser_inflection >= 256) {
        k = indirect(parser_inflection, obj, wd);
        if (k >= 0) return k;
        m = -k;
    }
    else
        m = parser_inflection;
    k = obj.&m; l = (obj.#m)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ WordInProperty wd obj prop k l m;
    k = obj.&prop; l = (obj.#prop)/WORDSIZE-1;
    for (m=0 : m<=l : m++)
        if (wd == k-->m) rtrue;
    rfalse;
];

[ NounWord i j s;
    i = NextWord();
    if (i == 0) rfalse;
    if (i == ME1__WD or ME2__WD or ME3__WD) return 1;
    s = LanguagePronouns-->0;
    for (j=1 : j<=s : j=j+3)
        if (i == LanguagePronouns-->j)
            return j+2;
    if ((i->#dict_par1)&128 == 0) rfalse;
    return i;
];

[ TryNumber wordnum   i j c num len mul tot d digit;
    i = wn; wn = wordnum; j = NextWord(); wn = i;
    j = NumberWord(j); ! Test for verbal forms ONE to TWENTY
    if (j >= 1) return j;

    #Ifdef TARGET_ZCODE;
    i = wordnum*4+1; j = parse->i; num = j+buffer; len = parse->(i-1);
    #Ifnot; ! TARGET_GLULX
    i = wordnum*3; j = parse-->i; num = j+buffer; len = parse-->(i-1);
    #Endif; ! TARGET_

    if (len >= 4) mul=1000;
    if (len == 3) mul=100;
    if (len == 2) mul=10;
    if (len == 1) mul=1;

    tot = 0; c = 0; len = len-1;

    for (c=0 : c<=len : c++) {
        digit=num->c;
        if (digit == '0') { d = 0; jump digok; }
        if (digit == '1') { d = 1; jump digok; }
        if (digit == '2') { d = 2; jump digok; }
        if (digit == '3') { d = 3; jump digok; }
        if (digit == '4') { d = 4; jump digok; }
        if (digit == '5') { d = 5; jump digok; }
        if (digit == '6') { d = 6; jump digok; }
        if (digit == '7') { d = 7; jump digok; }
        if (digit == '8') { d = 8; jump digok; }
        if (digit == '9') { d = 9; jump digok; }
        return -1000;
     .digok;
        tot = tot+mul*d; mul = mul/10;
    }
    if (len > 3) tot=10000;
    return tot;
];

[ I7_ExtendedTryNumber wordnum i j;
	i = wn; wn = wordnum; j = NextWordStopped(); wn = i;
	switch (j) {
		'twenty-one': return 21;
		'twenty-two': return 22;
		'twenty-three': return 23;
		'twenty-four': return 24;
		'twenty-five': return 25;
		'twenty-six': return 26;
		'twenty-seven': return 27;
		'twenty-eight': return 28;
		'twenty-nine': return 29;
		'thirty': return 30;
		default: return TryNumber(wordnum);
	}
];

[ GetGender person;
    if (person hasnt female) rtrue;
    rfalse;
];

[ GetGNAOfObject obj case gender;
    if (obj hasnt animate) case = 6;
    if (obj has male) gender = male;
    if (obj has female) gender = female;
    if (obj has neuter) gender = neuter;
    if (gender == 0) {
        if (case == 0) gender = LanguageAnimateGender;
        else gender = LanguageInanimateGender;
    }
    if (gender == female)   case = case + 1;
    if (gender == neuter)   case = case + 2;
    if (obj has pluralname) case = case + 3;
    return case;
];

[ DetectPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];

[ SetPronoun dword value x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword) {
            LanguagePronouns-->(x+2) = value; return;
        }
    RunTimeError(14);
];

[ PronounValue dword x;
    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (LanguagePronouns-->x == dword)
            return LanguagePronouns-->(x+2);
    return 0;
];

[ ResetVagueWords obj; PronounNotice(obj); ];

[ PronounNotice obj x bm;
    if (obj == player) return;

    bm = PowersOfTwo_TB-->(GetGNAOfObject(obj));

    for (x=1 : x<=LanguagePronouns-->0 : x=x+3)
        if (bm & (LanguagePronouns-->(x+1)) ~= 0)
            LanguagePronouns-->(x+2) = obj;
];

[ PronounNoticeHeldObjects x;
#IFNDEF MANUAL_PRONOUNS;
	objectloop(x in player) PronounNotice(x);
#ENDIF;
	x = 0; ! To prevent a "not used" error
	rfalse;
];

[ YesOrNo i j;
    for (::) {
        #Ifdef TARGET_ZCODE;
        if (location == nothing || parent(player) == nothing) read buffer parse;
        else read buffer parse DrawStatusLine;
        j = parse->1;
        #Ifnot; ! TARGET_GLULX;
        KeyboardPrimitive(buffer, parse);
        j = parse-->0;
        #Endif; ! TARGET_
        if (j) { ! at least one word entered
            i = parse-->1;
            if (i == YES1__WD or YES2__WD or YES3__WD) rtrue;
            if (i == NO1__WD or NO2__WD or NO3__WD) rfalse;
        }
        L__M(##Quit, 1); print "> ";
    }
];

[ NumberWord o i n;
    n = LanguageNumbers-->0;
    for (i=1 : i<=n : i=i+2)
        if (o == LanguageNumbers-->i) return LanguageNumbers-->(i+1);
    return 0;
];





Constant COBJ_BITS_SIZE = (MATCH_LIST_WORDS*MATCH_LIST_WORDS/8);

! the highest value returned by CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 9;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i-- ) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];



! ChooseObjects comes with three strategies:
! 1)   	We're trying the first noun of a line like TAKE FISH WITH POLE, with the query on the first noun.
!			We use scope/matching to build a list of possible second nouns, and loop across all of them, collecting the best score
! 2)		We're doing nothing complicated: either TAKE ROCK, or TAKE ROCK WITH MAGNET with the query on the second noun
!			We just build an action pattern and try it.	
! 3)		We're doing the reverse of 1 - the query is on the second noun, but the first noun is variable
!			Either because we're doing a lookahead (PUT CAT IN BAG checks BAG before CAT)
!			or we're looking at a multiple object (GIVE ALL TO JIM or GIVE COINS TO JIM)


[ ChooseObjects obj code context  l i swn spcount a b c old_ad otf gdata;


	#ifdef COBJ_DEBUG;
 		print "(entering with ", (the) obj, " and flag ", cobj_flag, " lookahead? ", look_ahead, ")^";
	#endif;


! we ditch the no-object tracking object immediately
	if (obj == I92_no_object) return -1;

! we record this for use by the expectation rules - currently redundant, but may well reappear

	if (context == CREATURE_TOKEN) 
		(Global_Vars-->13) = 1;
	else 
		(Global_Vars-->13) = 0;
	
! we shouldn't really be here under I7 rules with an all...
	if (code<2) rfalse;

! by default, the smart score should be always ignore 
	c = -1;

!	if  multiple object exists for the first parameter and we're now looking for the second
! 	then copy the mult into the alt list, and use code 3

	if (parameters > 0  && multiple_object-->0 > 0)
	{
		#ifdef COBJ_DEBUG;
			print "[We've found a multiple list in the first object.]^";
		#endif;
	
		CopyMultipleObjectList();
		cobj_flag = 3;
	}

	if (cobj_flag == 1 && parameters > 0)
	{
		#ifdef COBJ_DEBUG;
			print "[now scoring the second: drop into simple mode.]^";
		#endif;
		cobj_flag = 2;
	}

	if (cobj_flag == 1) 
	{
		.CodeOne;
		if (parameters > 0) 
			print_ret "[Bug in C-Ob: this should be unreachable. (Are we here directly from a jump statement?]^";

			#ifdef COBJ_DEBUG;
				print "[scoring ", (the) obj, " (first) in ", alt_match_list-->0, " combinations]^";
			#endif;

			return ScoreCombos(0, 1, obj, context);
	}


	if (cobj_flag == 2) {
	
	!Works for TAKE FISH(?) or WEAR HAT(?)
	! also TIE FISH(!) TO CARPET(?)
	!Both occasions we know everything we need to in advance

		.CodeTwo;
		#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (simple)]^";
		#endif;
		if (parameters==0)
		{	
			b = GuessScoreDabCombo(obj, 0, context, 1);
			c = SmartScoreDabCombo(obj, 0);
		}
		else
		{
			b =  GuessScoreDabCombo(parser_results-->2, obj, context, 2);
			c =  SmartScoreDabCombo(parser_results-->2, obj);
		}
		return ResolveChooseScores(b, c);
	}


	if (cobj_flag == 3)
	{
! we loop over the possible first nouns and score them
! same as code 1 above only backwards!

		.CodeThree;
	
			#ifdef COBJ_DEBUG;
				print "[scoring ", alt_match_list-->0, " combinations for ", (the) obj, " (second)^";
			#endif;

			return ScoreCombos(-1, 2, obj, context); ! testing for no. two
	}

	.ChooseStrategy;
	#ifdef COBJ_DEBUG;
		print "[choosing a cobj strategy: ";
	#endif;

	swn = wn;
	spcount = pcount;

	if (look_ahead ~= 0)
	{
		wn = verb_wordnum + 1; 
		pcount = 0;

		SkipPrepositions();

		if ((line_ttype-->pcount == ELEMENTARY_TT or ATTR_FILTER_TT or ROUTINE_FILTER_TT) && (
						line_tdata-->pcount ~= SPECIAL_TOKEN  or NUMBER_TOKEN   or TOPIC_TOKEN  or ENDIT_TOKEN
							)) 
		{

			! Advance past the prepositions in the input
			while (wn < swn-1) 
			{

				l = NextWord(); 	
				if ( 		l && (l->#dict_par1) &8 == 0	)				! if *not* preposition
				{
					if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) 
					{
						CreateAltList();
						#ifdef COBJ_DEBUG;
							print "all generated ", alt_match_list-->0, " possible first nouns]^";
						#endif;

					}
					else
					{
						wn--;

	                              BuildTheLookAheadList();

						#ifdef COBJ_DEBUG;
							print alt_match_list-->0, " possible first nouns]^";
						#endif;
					}					
			
					wn = swn;
					pcount = spcount;
					cobj_flag = 3;
					jump CodeThree;				
				}
			}
		}
		
		print "[Lookahead mode failed to achieve anything. Not sure how this is possible?]^";	

	}

	! so now we just look ahead ourselves and see what happens next in the grammar line

	if (line_ttype-->pcount == PREPOSITION_TT or ELEMENTARY_TT or ROUTINE_FILTER_TT or ATTR_FILTER_TT) 
	{
		SkipPrepositions();
		if ((line_ttype-->pcount == ELEMENTARY_TT or ROUTINE_FILTER_TT or ATTR_FILTER_TT) && (

				line_tdata-->pcount ~= SPECIAL_TOKEN  or NUMBER_TOKEN   or TOPIC_TOKEN  or ENDIT_TOKEN

							)) 
		{
			! Advance past the last preposition
			while (wn < num_words)
			{
				l = NextWord();
				if ( l && (l->#dict_par1) &8 ) 		! if preposition
				{	

					if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) continue;

                              BuildtheLookAheadList();

					#ifdef COBJ_DEBUG;
						print alt_match_list-->0, " possible second nouns]^";
					#endif;

					wn = swn;
					cobj_flag = 1;
					pcount = spcount;
					jump CodeOne;
				}
			}
		}
		
	}

	#ifdef COBJ_DEBUG;
		print "nothing interesting]^";
	#endif;

	! reset everything

	pcount = spcount;
	wn = swn;	
	cobj_flag = 2;
	jump CodeTwo;
];


[ BuildTheLookAheadList otf gdata;

! remembers filters and reset if we need to

	otf = token_filter;
	token_filter = 0;
        gdata = line_tdata-->pcount;
	if (line_ttype-->pcount == ROUTINE_FILTER_TT)
	{
	   print "(checking routine filter)^";
	   token_filter = line_tdata-->pcount;
	   gdata = NOUN_TOKEN;
	}
	if (line_ttype-->pcount == ATTR_FILTER_TT)
	{
	   print "(checking attribute filter)^";
	   token_filter = 1 + line_tdata-->pcount;
	   gdata = NOUN_TOKEN;
	}

	SafeSkipDescriptors();

	! save the current match state
	@push match_length; @push match_from;

	alt_match_list-->0 = number_matched;
	COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);

	! now get all the matches we can
	match_length = 0; number_matched = 0; match_from = wn;

	SearchScope(actor, actors_location, gdata);

	! restore match variables
	COBJ__SwapMatches();
       @pull match_from; @pull match_length;
       token_filter = otf;

];

[	SkipPrepositions;
		while (line_ttype-->pcount == PREPOSITION_TT) 	pcount++;
];

[ ScoreCombos
	defaultscore	varier	obj	context		l	i	spcount		b	c	n	s
;
			l = defaultscore;		! note the difference. Because now ...?
			for (i=1: i<=alt_match_list-->0: i++)
			 {
				if (varier == 2) 
				{
					s = obj;
					n = alt_match_list-->i;	
				}
	
				if (varier == 1) ! varier = thing we're testing NOT thing which varies (what dumbass wrote this?)
				{
					n = obj;
					s = alt_match_list-->i;	
				}
				b = GuessScoreDabCombo(n, s, context, varier);
				c = SmartScoreDabCombo(n, s);
				spcount = ResolveChooseScores(b, c);
			!	print (the) n, " / ", (the) s, " => b ", b, " c ", c , " => ", spcount, ".^";

				if (spcount == HIGHEST_DPMR_SCORE) 
				{
					#ifdef COBJ_DEBUG;
						print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			#ifdef COBJ_DEBUG;
				print "[scored ", spcount, "]^";
			#endif;
			return l;
];


[ CreateAltList i;
! we copy the whole scope into the alt_match_list
	LoopOverScope(AddToAltMatch);
];

[ AddToAltMatch obj;
	(alt_match_list-->0)++;
	alt_match_list-->(alt_match_list-->0) = obj;
];

[ CopyMultToMatch i;
	for (i = 0: i < multiple_object-->0 : i++)
	{	match_list-->i = multiple_object-->(i+1);
		#ifdef COBJ_DEBUG;
			if (i > 0) print (the) match_list-->i, " / ";
		#endif;
	}
	return multiple_object-->0;
];


[ CopyMultipleObjectList i;
	for (i = 0: i<=multiple_object-->0 : i++)
	{	alt_match_list-->i = multiple_object-->i;
		#ifdef COBJ_DEBUG;
			if (i > 0) print (the) alt_match_list-->i, " / ";
		#endif;
	}
!	new_line;
	
];

[ DefaultTopic; return GPR_FAIL; ];



[ ParserError error_type;
	if (error_type ofclass String or Routine) PrintSingleParagraph(error_type);
	rfalse;
];

Object InformLibrary "(Inform Library)" has proper;

Array Protect_I7_Arrays --> 16339 12345;

Global EarlyInTurnSequence;

[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	ProcessRulebook(STARTUP_RB);
	#ifdef DEBUG; InternalTestCases(); #endif;
	while (true) {
		while (deadflag == false) {
			EarlyInTurnSequence = true;
			action = ##Wait; meta = false; noun = nothing; second = nothing;
			actor = player;
			FollowRulebook(TURN_SEQUENCE_RB);
		}
		if (FollowRulebook(SHUTDOWN_RB) == false) return;
	}
];

[ VIRTUAL_MACHINE_STARTUP_R;
	ProcessRulebook(Activity_before_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);
	ProcessRulebook(Activity_for_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);
	ProcessRulebook(Activity_after_rulebooks-->STARTING_VIRTUAL_MACHINE_ACT);

	VM_Initialise();

	print "^^^";
	rfalse;
];

Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DONE_INIS = 4;

Array InitialSituation --> selfobj I447_outside_waterworks I447_outside_waterworks 540 0;



[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	not_yet_in_play = true;
	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	player = InitialSituation-->PLAYER_OBJECT_INIS;
	the_time = InitialSituation-->START_TIME_INIS;
	real_location = nothing;
	location = nothing;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	InitialHeapAllocation(); ! Allocate empty blocks for variables, properties, and such
	CreateBlockConstants(); ! Allocate and fill in blocks for constant values
	DistributeBlockConstants(); ! Ensure these exist in multiple independent copies when needed
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];

[ SEED_RANDOM_NUMBER_GENERATOR_R i;
	if (0) VM_Seed_RNG(0);
	for (i=1: i<=100: i++) random(i);
	rfalse;
];

[ POSITION_PLAYER_IN_MODEL_R player_to_be;

	player = selfobj;
	player_to_be = InitialSituation-->PLAYER_OBJECT_INIS;
	
	location = LocationOf(player_to_be);
	if (location == 0) {
		location = InitialSituation-->START_ROOM_INIS;
		if (InitialSituation-->START_OBJECT_INIS)
			move player_to_be to InitialSituation-->START_OBJECT_INIS;
		else move player_to_be to location;
	}

	if (player_to_be ~= player) { remove selfobj; ChangePlayer(player_to_be); }

	real_location = location; SilentlyConsiderLight();

	NOTE_OBJECT_ACQUISITIONS_R(); MoveFloatingObjects();
	
	actor = player; act_requester = nothing; actors_location = real_location; action = ##Wait;

	InitialSituation-->DONE_INIS = true;
	rfalse;
];

Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3; ! Parser.i6t code assumes this is INP1_PRES + 1

[ PARSE_COMMAND_R;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	not_yet_in_play = false;

	Parser__parse();
	TreatParserResults();
	rfalse;
];

[ TreatParserResults;
	if (parser_results-->ACTION_PRES == ##MistakeAction) meta = true;

	if (parser_results-->ACTION_PRES == ##Tell &&
		parser_results-->INP1_PRES == player && actor ~= player) {
		parser_results-->ACTION_PRES = ##Ask;
		parser_results-->INP1_PRES = actor; actor = player;
	}
];

[ GENERATE_ACTION_R i j k l;
	if (EarlyInTurnSequence == false) rfalse; ! Prevent use outside top level
	EarlyInTurnSequence = false;

	action = parser_results-->ACTION_PRES;
	act_requester = nothing; if (actor ~= player) act_requester = player;

	inp1 = 0; inp2 = 0; multiflag = false;
	if (parser_results-->NO_INPS_PRES >= 1) {
		inp1 = parser_results-->INP1_PRES; if (inp1 == 0) multiflag = true;
	}
	if (parser_results-->NO_INPS_PRES >= 2) {
		inp2 = parser_results-->INP2_PRES; if (inp2 == 0) multiflag = true;
	}

	if (inp1 == 1) {
		noun = nothing; ! noun = special_number1;
	} else noun = inp1;
	if (inp2 == 1) {
		second = nothing;
		! if (inp1 == 1) second = special_number2; else second = special_number1;
	} else second = inp2;

	if (multiflag) {
		if (multiple_object-->0 == 0) { L__M(##Miscellany, 2); return; }
		if (toomany_flag) { toomany_flag = false; L__M(##Miscellany, 1); }
		GenerateMultipleActions();
		multiflag = false;
	} else BeginAction(action, noun, second);

	if ((actor ~= player) || (act_requester)) action = ##Wait;
	actor = player; act_requester = 0;

	if (meta) { RulebookSucceeds(); rtrue; }
	rfalse;
];

[ GenerateMultipleActions initial_location k item;
	initial_location = location;
	for (k=1: k<=multiple_object-->0: k++) {
		item = multiple_object-->k;
		RunParagraphOn();
		if (inp1 == 0) { inp1 = item; BeginAction(action, item, second, item); inp1 = 0; }
		else { inp2 = item; BeginAction(action, noun, item, item); inp2 = 0; }
		if (deadflag) return;
		if (location ~= initial_location) { L__M(##Miscellany, 51); return; }
	}
];

[ TIMED_EVENTS_R i event_timer fire rule;
	for (i=1: i<=(TimedEventsTable-->0): i++)
		if ((rule=TimedEventsTable-->i) ~= 0) {
			event_timer = TimedEventTimesTable-->i; fire = false;
			if (event_timer<0) {
				(TimedEventTimesTable-->i)++;
				if (TimedEventTimesTable-->i == 0) fire = true;
			} else {
				if ((the_time >= event_timer) && (the_time < event_timer+30)) fire = true;
			}
			if (fire) {
				TimedEventsTable-->i = 0;
				ProcessRulebook(rule);
			}
		}
	rfalse;
];

[ SetTimedEvent rule event_time absolute_time i b;
	for (i=1: i<=(TimedEventsTable-->0): i++) {
		if (rule == TimedEventsTable-->i) { b=i; break; }
		if ((b==0) && (TimedEventsTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	TimedEventsTable-->b = rule;
	if (absolute_time) TimedEventTimesTable-->b = event_time;
	else TimedEventTimesTable-->b = -event_time;
];

Global time_step;

[ SetTime t s;
    the_time = t; time_rate = s; time_step = 0;
    if (s < 0) time_step = 0-s;
];

[ ADVANCE_TIME_R;
    turns++;
    if (the_time ~= NULL) {
        if (time_rate >= 0) the_time = the_time+time_rate;
        else {
            time_step--;
            if (time_step == 0) {
                the_time++;
                time_step = -time_rate;
            }
        }
        the_time = the_time % TWENTY_FOUR_HOURS;
    }
	rfalse;
];

[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) give obj moved;
    objectloop (obj has concealed)
    	if (IndirectlyContains(player, obj)) give obj ~concealed;
    #Ifdef RUCKSACK_CLASS;
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	objectloop (obj ofclass RUCKSACK_CLASS && obj provides component_parent
		&& obj.component_parent == player)
		SACK_OBJECT = obj;
	#Endif;
	rfalse;
];

[ RESURRECT_PLAYER_IF_ASKED_R;
	if (resurrect_please) {
		RulebookSucceeds(); resurrect_please = false;
		deadflag = 0; story_complete = false; rtrue;
	}
	rfalse;
];

[ ASK_FINAL_QUESTION_R;
	print "^";
	while (true) {
		CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
		DivideParagraphPoint();
    }
];

[ READ_FINAL_ANSWER_R;
	DrawStatusLine();
	KeyboardPrimitive(buffer, parse);
	players_command = 100 + WordCount();
	num_words = WordCount();
	wn = 1;
	rfalse;
];

[ IMMEDIATELY_RESTART_VM_R; @restart; ];

[ IMMEDIATELY_RESTORE_SAVED_R; actor = player; RESTORE_THE_GAME_R(); ];

[ IMMEDIATELY_QUIT_R; @quit; ];

[ IMMEDIATELY_UNDO_R;
	if (not_yet_in_play == false) turns++;
	Perform_Undo();
	if (not_yet_in_play == false) turns--;
];

[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if (deadflag == 1) L__M(##Miscellany, 3);
    if (deadflag == 2) L__M(##Miscellany, 4);
    if (deadflag == 3) L__M(##Miscellany, 75);
    if (deadflag ~= 0 or 1 or 2 or 3)  {
        print " ";
        if (deadflag ofclass Routine) (deadflag)();
		if (deadflag ofclass String) print (string) deadflag;
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^"; #Ifndef NO_SCORE; print "^"; #Endif;
    rfalse;
];

[ PRINT_FINAL_SCORE_R;
	#Ifndef NO_SCORING; ANNOUNCE_SCORE_R(); #Endif;
	rfalse;
];

[ DISPLAY_FINAL_STATUS_LINE_R;
	sline1 = score; sline2 = turns;
	rfalse;
];


Constant p3_printed_name = short_name;
Constant p4_printed_plural_name = plural;
Constant p5_indefinite_article = article;
Constant p6_description = description;
Constant p7_map_region = map_region;
Constant p8_initial_appearance = initial;
Constant p10_other_side = door_to;
Constant p11_carrying_capacity = capacity;
Constant p12_matching_key = with_key;
Constant p18_plural_named = pluralname;
Constant p20_proper_named = proper;
Constant p22_privately_named = privately_named;
Constant p24_lighted = light;
Constant p26_visited = visited;
Constant p28_lit = light;
Constant p30_edible = edible;
Constant p32_fixed_in_place = static;
Constant p34_scenery = scenery;
Constant p35_wearable = clothing;
Constant p36_pushable_between_rooms = pushable;
Constant p37_handled = moved;
Constant p39_undescribed = concealed;
Constant p40_marked_for_listing = workflag;
Constant p42_mentioned = mentioned;
Constant p44_enterable = enterable;
Constant p46_transparent = transparent;
Constant p47_open = open;
Constant p49_openable = openable;
Constant p51_lockable = lockable;
Constant p52_locked = locked;
Constant p54_female = female;
Constant p56_neuter = neuter;
Constant p57_switched_on = on;
Constant p127 = worn;
Constant p128 = vector;
Constant p129 = room_index;
Constant p130 = door_dir;
Constant p131 = door_to;
Constant p132 = found_in;
Constant p133 = absent;
Constant p134 = list_together;
Constant p135 = cap_short_name;
Constant p136 = mark_as_room;
Constant p137 = mark_as_thing;
Constant p138 = component_parent;
Constant p139 = component_child;
Constant p140 = component_sibling;
Constant p141 = regional_found_in;
Constant p142 = IK1_Count;
Constant p143 = IK1_Link;
Constant p144 = IK2_Count;
Constant p145 = IK2_Link;
Constant p146 = IK3_Count;
Constant p147 = IK3_Link;
Constant p148 = IK4_Count;
Constant p149 = IK4_Link;
Constant p150 = IK5_Count;
Constant p151 = IK5_Link;
Constant p152 = IK6_Count;
Constant p153 = IK6_Link;
Constant p154 = IK7_Count;
Constant p155 = IK7_Link;
Constant p156 = IK8_Count;
Constant p157 = IK8_Link;
Constant p158 = IK9_Count;
Constant p159 = IK9_Link;
Constant p160 = IK10_Count;
Constant p161 = IK10_Link;
Constant p162 = IK11_Count;
Constant p163 = IK11_Link;
Constant p164 = IK12_Count;
Constant p165 = IK12_Link;
Constant p166 = IK13_Count;
Constant p167 = IK13_Link;
Constant p168 = IK14_Count;
Constant p169 = IK14_Link;
Constant p170 = IK15_Count;
Constant p171 = IK15_Link;
Constant p172 = IK16_Count;
Constant p173 = IK16_Link;
Constant p174 = IK17_Count;
Constant p175 = IK17_Link;
Constant p176 = IK18_Count;
Constant p177 = IK18_Link;
Constant p178 = IK19_Count;
Constant p179 = IK19_Link;
Constant p180 = IK20_Count;
Constant p181 = IK20_Link;
Constant p182 = IK21_Count;
Constant p183 = IK21_Link;
Constant p184 = IK22_Count;
Constant p185 = IK22_Link;
Constant p186 = IK23_Count;
Constant p187 = IK23_Link;
Constant p188 = IK24_Count;
Constant p189 = IK24_Link;
Constant p190 = IK25_Count;
Constant p191 = IK25_Link;
Constant p192 = IK26_Count;
Constant p193 = IK26_Link;
Constant p194 = IK27_Count;
Constant p195 = IK27_Link;
Constant p196 = IK28_Count;
Constant p197 = IK28_Link;
Constant p198 = IK29_Count;
Constant p199 = IK29_Link;
Constant p200 = IK30_Count;
Constant p201 = IK30_Link;
Constant p202 = IK31_Count;
Constant p203 = IK31_Link;
Constant p204 = KD_Count;
Constant p205 = name;
Constant p206 = parse_name;
Constant p207 = action_bitmap;

Attribute p61_stashable;
Attribute p63_chavailable;
Attribute p65_chviable;
Attribute p69_dbg_on;
Attribute p71_ambiguously_plural;
Attribute p73_examined;
Attribute p75_accessed;
Attribute p77_indoors;
Attribute p79_pocketed;
Attribute p81_metal;
Attribute p83_moved;
Constant FBNA_PROP_NUMBER = p59_recurring;
Object property_numberspace_forcer
    with p59_recurring false
    with p86_soft false
    with p88_boaty false
    with p90_peeled false
    with p92_irked false
    with p94_curious false
    with p96_plugged false
    with p98_fixed false
    with p100_secure false
    with p102_flipped_up false
    with p104_important false
    with p106_upside_down false
    with p108_trapped false
    with p110_roaming false
    with p112_keyed false
    with p114_flooded false
    with p116_spinning false
    with p118_accessible false
    with p121_satisfied false
    with p123_distracted false
    with p125_asleep false
;

Array property_metadata -->
    ! offset 0: property p0_specification
    "specification" NULL
    ! offset 2: property p1_indefinite_appearance_tex
    "indefinite appearance text" NULL
    ! offset 4: property p2_variable_initial_value
    "variable initial value" K1_room K2_thing K3_direction K9_region NULL
    ! offset 10: property short_name
    "printed name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 16: property plural
    "printed plural name" K1_room K2_thing K3_direction K9_region NULL
    ! offset 22: property article
    "indefinite article" K1_room K2_thing K3_direction K9_region NULL
    ! offset 28: property description
    "description" K1_room K2_thing NULL
    ! offset 32: property map_region
    "map region" K1_room NULL
    ! offset 35: property initial
    "initial appearance" K2_thing NULL
    ! offset 38: property p9_opposite
    "opposite" K3_direction NULL
    ! offset 41: property door_to
    "other side" K4_door NULL
    ! offset 44: property capacity
    "carrying capacity" K5_container K6_supporter K8_person NULL
    ! offset 49: property with_key
    "matching key" K2_thing K4_door K5_container NULL
    ! offset 54: property p13_last_location
    "last location" K8_person NULL
    ! offset 57: property p14_fluid_capacity
    "fluid capacity" K25_fluid_container K26_liquid_source NULL
    ! offset 61: property p15_current_volume
    "current volume" K25_fluid_container K26_liquid_source NULL
    ! offset 65: property p16_station
    "station" I439_steam_train NULL
    ! offset 68: property p17_apology
    "apology" K8_person NULL
    ! offset 71: property pluralname
    "plural-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 77: property proper
    "proper-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 83: property privately_named
    "privately-named" K1_room K2_thing K3_direction K9_region NULL
    ! offset 89: property light
    "lighted" K1_room K2_thing NULL
    ! offset 93: property visited
    "visited" K1_room NULL
    ! offset 96: property light
    "lit" K1_room K2_thing NULL
    ! offset 100: property edible
    "edible" K2_thing NULL
    ! offset 103: property static
    "fixed in place" K2_thing NULL
    ! offset 106: property scenery
    "scenery" K2_thing NULL
    ! offset 109: property clothing
    "wearable" K2_thing NULL
    ! offset 112: property pushable
    "pushable between rooms" K2_thing NULL
    ! offset 115: property moved
    "handled" K2_thing NULL
    ! offset 118: property concealed
    "undescribed" K2_thing NULL
    ! offset 121: property workflag
    "marked for listing" K2_thing K3_direction NULL
    ! offset 125: property mentioned
    "mentioned" K2_thing NULL
    ! offset 128: property enterable
    "enterable" K5_container K6_supporter NULL
    ! offset 132: property transparent
    "transparent" K5_container NULL
    ! offset 135: property open
    "open" K4_door K5_container NULL
    ! offset 139: property openable
    "openable" K4_door K5_container NULL
    ! offset 143: property lockable
    "lockable" K4_door K5_container NULL
    ! offset 147: property locked
    "locked" K4_door K5_container NULL
    ! offset 151: property female
    "female" K8_person NULL
    ! offset 154: property neuter
    "neuter" K2_thing K8_person NULL
    ! offset 158: property on
    "switched on" K13_device NULL
    ! offset 161: property p59_recurring
    "recurring" NULL
    ! offset 163: property p61_stashable
    "stashable" K2_thing NULL
    ! offset 166: property p63_chavailable
    "chavailable" K15_player_s_holdall NULL
    ! offset 169: property p65_chviable
    "chviable" K2_thing NULL
    ! offset 172: property p67_unbolting
    "unbolting" K2_thing NULL
    ! offset 175: property p68_message_text
    "message text" NULL
    ! offset 177: property p69_dbg_on
    "dbg_on" I409_library_message_debug NULL
    ! offset 180: property p71_ambiguously_plural
    "ambiguously plural" K2_thing NULL
    ! offset 183: property p73_examined
    "examined" K2_thing NULL
    ! offset 186: property p75_accessed
    "accessed" K5_container NULL
    ! offset 189: property p77_indoors
    "indoors" K1_room NULL
    ! offset 192: property p79_pocketed
    "pocketed" K2_thing NULL
    ! offset 195: property p81_metal
    "metal" K2_thing NULL
    ! offset 198: property p83_moved
    "moved" K14_vehicle NULL
    ! offset 201: property p85_liquid
    "liquid" K25_fluid_container K26_liquid_source NULL
    ! offset 205: property p86_soft
    "soft" K2_thing NULL
    ! offset 208: property p88_boaty
    "boaty" K8_person NULL
    ! offset 211: property p90_peeled
    "peeled" I489_large_painted_mural NULL
    ! offset 214: property p92_irked
    "irked" K8_person NULL
    ! offset 217: property p94_curious
    "curious" K8_person NULL
    ! offset 220: property p96_plugged
    "plugged" I526_leaky_hose NULL
    ! offset 223: property p98_fixed
    "fixed" K28_gizmo NULL
    ! offset 226: property p100_secure
    "secure" I534_security_gadget NULL
    ! offset 229: property p102_flipped_up
    "flipped up" K27_lever K29_switch NULL
    ! offset 233: property p104_important
    "important" K2_thing NULL
    ! offset 236: property p106_upside_down
    "upside-down" I589_wooden_drawer NULL
    ! offset 239: property p108_trapped
    "trapped" K8_person NULL
    ! offset 242: property p110_roaming
    "roaming" K12_animal NULL
    ! offset 245: property p112_keyed
    "keyed" K1_room NULL
    ! offset 248: property p114_flooded
    "flooded" K1_room NULL
    ! offset 251: property p116_spinning
    "spinning" K20_wheel NULL
    ! offset 254: property p118_accessible
    "accessible" I701_cavity NULL
    ! offset 257: property p120_approaching
    "approaching" NULL
    ! offset 259: property p121_satisfied
    "satisfied" I711_conductor NULL
    ! offset 262: property p123_distracted
    "distracted" I711_conductor NULL
    ! offset 265: property p125_asleep
    "asleep" K8_person NULL
    ! offset 268: property worn
    "<nameless>" NULL
    ! offset 270: property vector
    "<nameless>" NULL
    ! offset 272: property room_index
    "<nameless>" NULL
    ! offset 274: property door_dir
    "<nameless>" NULL
    ! offset 276: property door_to
    "<nameless>" K4_door NULL
    ! offset 279: property found_in
    "<nameless>" NULL
    ! offset 281: property absent
    "<nameless>" NULL
    ! offset 283: property list_together
    "<nameless>" NULL
    ! offset 285: property cap_short_name
    "<nameless>" NULL
    ! offset 287: property mark_as_room
    "<nameless>" NULL
    ! offset 289: property mark_as_thing
    "<nameless>" NULL
    ! offset 291: property component_parent
    "<nameless>" NULL
    ! offset 293: property component_child
    "<nameless>" NULL
    ! offset 295: property component_sibling
    "<nameless>" NULL
    ! offset 297: property regional_found_in
    "<nameless>" NULL
    ! offset 299: property IK1_Count
    "<nameless>" NULL
    ! offset 301: property IK1_Link
    "<nameless>" NULL
    ! offset 303: property IK2_Count
    "<nameless>" NULL
    ! offset 305: property IK2_Link
    "<nameless>" NULL
    ! offset 307: property IK3_Count
    "<nameless>" NULL
    ! offset 309: property IK3_Link
    "<nameless>" NULL
    ! offset 311: property IK4_Count
    "<nameless>" NULL
    ! offset 313: property IK4_Link
    "<nameless>" NULL
    ! offset 315: property IK5_Count
    "<nameless>" NULL
    ! offset 317: property IK5_Link
    "<nameless>" NULL
    ! offset 319: property IK6_Count
    "<nameless>" NULL
    ! offset 321: property IK6_Link
    "<nameless>" NULL
    ! offset 323: property IK7_Count
    "<nameless>" NULL
    ! offset 325: property IK7_Link
    "<nameless>" NULL
    ! offset 327: property IK8_Count
    "<nameless>" NULL
    ! offset 329: property IK8_Link
    "<nameless>" NULL
    ! offset 331: property IK9_Count
    "<nameless>" NULL
    ! offset 333: property IK9_Link
    "<nameless>" NULL
    ! offset 335: property IK10_Count
    "<nameless>" NULL
    ! offset 337: property IK10_Link
    "<nameless>" NULL
    ! offset 339: property IK11_Count
    "<nameless>" NULL
    ! offset 341: property IK11_Link
    "<nameless>" NULL
    ! offset 343: property IK12_Count
    "<nameless>" NULL
    ! offset 345: property IK12_Link
    "<nameless>" NULL
    ! offset 347: property IK13_Count
    "<nameless>" NULL
    ! offset 349: property IK13_Link
    "<nameless>" NULL
    ! offset 351: property IK14_Count
    "<nameless>" NULL
    ! offset 353: property IK14_Link
    "<nameless>" NULL
    ! offset 355: property IK15_Count
    "<nameless>" NULL
    ! offset 357: property IK15_Link
    "<nameless>" NULL
    ! offset 359: property IK16_Count
    "<nameless>" NULL
    ! offset 361: property IK16_Link
    "<nameless>" NULL
    ! offset 363: property IK17_Count
    "<nameless>" NULL
    ! offset 365: property IK17_Link
    "<nameless>" NULL
    ! offset 367: property IK18_Count
    "<nameless>" NULL
    ! offset 369: property IK18_Link
    "<nameless>" NULL
    ! offset 371: property IK19_Count
    "<nameless>" NULL
    ! offset 373: property IK19_Link
    "<nameless>" NULL
    ! offset 375: property IK20_Count
    "<nameless>" NULL
    ! offset 377: property IK20_Link
    "<nameless>" NULL
    ! offset 379: property IK21_Count
    "<nameless>" NULL
    ! offset 381: property IK21_Link
    "<nameless>" NULL
    ! offset 383: property IK22_Count
    "<nameless>" NULL
    ! offset 385: property IK22_Link
    "<nameless>" NULL
    ! offset 387: property IK23_Count
    "<nameless>" NULL
    ! offset 389: property IK23_Link
    "<nameless>" NULL
    ! offset 391: property IK24_Count
    "<nameless>" NULL
    ! offset 393: property IK24_Link
    "<nameless>" NULL
    ! offset 395: property IK25_Count
    "<nameless>" NULL
    ! offset 397: property IK25_Link
    "<nameless>" NULL
    ! offset 399: property IK26_Count
    "<nameless>" NULL
    ! offset 401: property IK26_Link
    "<nameless>" NULL
    ! offset 403: property IK27_Count
    "<nameless>" NULL
    ! offset 405: property IK27_Link
    "<nameless>" NULL
    ! offset 407: property IK28_Count
    "<nameless>" NULL
    ! offset 409: property IK28_Link
    "<nameless>" NULL
    ! offset 411: property IK29_Count
    "<nameless>" NULL
    ! offset 413: property IK29_Link
    "<nameless>" NULL
    ! offset 415: property IK30_Count
    "<nameless>" NULL
    ! offset 417: property IK30_Link
    "<nameless>" NULL
    ! offset 419: property IK31_Count
    "<nameless>" NULL
    ! offset 421: property IK31_Link
    "<nameless>" NULL
    ! offset 423: property KD_Count
    "<nameless>" NULL
    ! offset 425: property name
    "<nameless>" NULL
    ! offset 427: property parse_name
    "<nameless>" NULL
    ! offset 429: property action_bitmap
    "<nameless>" NULL
;

Constant attributed_property_offsets_SIZE 48;
Array attributed_property_offsets --> attributed_property_offsets_SIZE;
Constant valued_property_offsets_SIZE (100 + 208 + INDIV_PROP_START-48);
Array valued_property_offsets --> valued_property_offsets_SIZE;

[ CreatePropertyOffsets i;
    for (i=0: i<attributed_property_offsets_SIZE: i++)attributed_property_offsets-->i = -1;
    for (i=0: i<valued_property_offsets_SIZE: i++)valued_property_offsets-->i = -1;
    valued_property_offsets-->p0_specification = 0;
    valued_property_offsets-->p1_indefinite_appearance_tex = 2;
    valued_property_offsets-->p2_variable_initial_value = 4;
    valued_property_offsets-->short_name = 10;
    valued_property_offsets-->plural = 16;
    valued_property_offsets-->article = 22;
    valued_property_offsets-->description = 28;
    valued_property_offsets-->map_region = 32;
    valued_property_offsets-->initial = 35;
    valued_property_offsets-->p9_opposite = 38;
    valued_property_offsets-->door_to = 41;
    valued_property_offsets-->capacity = 44;
    valued_property_offsets-->with_key = 49;
    valued_property_offsets-->p13_last_location = 54;
    valued_property_offsets-->p14_fluid_capacity = 57;
    valued_property_offsets-->p15_current_volume = 61;
    valued_property_offsets-->p16_station = 65;
    valued_property_offsets-->p17_apology = 68;
    attributed_property_offsets-->pluralname = 71;
    attributed_property_offsets-->proper = 77;
    attributed_property_offsets-->privately_named = 83;
    attributed_property_offsets-->light = 89;
    attributed_property_offsets-->visited = 93;
    attributed_property_offsets-->light = 96;
    attributed_property_offsets-->edible = 100;
    attributed_property_offsets-->static = 103;
    attributed_property_offsets-->scenery = 106;
    attributed_property_offsets-->clothing = 109;
    attributed_property_offsets-->pushable = 112;
    attributed_property_offsets-->moved = 115;
    attributed_property_offsets-->concealed = 118;
    attributed_property_offsets-->workflag = 121;
    attributed_property_offsets-->mentioned = 125;
    attributed_property_offsets-->enterable = 128;
    attributed_property_offsets-->transparent = 132;
    attributed_property_offsets-->open = 135;
    attributed_property_offsets-->openable = 139;
    attributed_property_offsets-->lockable = 143;
    attributed_property_offsets-->locked = 147;
    attributed_property_offsets-->female = 151;
    attributed_property_offsets-->neuter = 154;
    attributed_property_offsets-->on = 158;
    valued_property_offsets-->p59_recurring = 161;
    attributed_property_offsets-->p61_stashable = 163;
    attributed_property_offsets-->p63_chavailable = 166;
    attributed_property_offsets-->p65_chviable = 169;
    valued_property_offsets-->p67_unbolting = 172;
    valued_property_offsets-->p68_message_text = 175;
    attributed_property_offsets-->p69_dbg_on = 177;
    attributed_property_offsets-->p71_ambiguously_plural = 180;
    attributed_property_offsets-->p73_examined = 183;
    attributed_property_offsets-->p75_accessed = 186;
    attributed_property_offsets-->p77_indoors = 189;
    attributed_property_offsets-->p79_pocketed = 192;
    attributed_property_offsets-->p81_metal = 195;
    attributed_property_offsets-->p83_moved = 198;
    valued_property_offsets-->p85_liquid = 201;
    valued_property_offsets-->p86_soft = 205;
    valued_property_offsets-->p88_boaty = 208;
    valued_property_offsets-->p90_peeled = 211;
    valued_property_offsets-->p92_irked = 214;
    valued_property_offsets-->p94_curious = 217;
    valued_property_offsets-->p96_plugged = 220;
    valued_property_offsets-->p98_fixed = 223;
    valued_property_offsets-->p100_secure = 226;
    valued_property_offsets-->p102_flipped_up = 229;
    valued_property_offsets-->p104_important = 233;
    valued_property_offsets-->p106_upside_down = 236;
    valued_property_offsets-->p108_trapped = 239;
    valued_property_offsets-->p110_roaming = 242;
    valued_property_offsets-->p112_keyed = 245;
    valued_property_offsets-->p114_flooded = 248;
    valued_property_offsets-->p116_spinning = 251;
    valued_property_offsets-->p118_accessible = 254;
    valued_property_offsets-->p120_approaching = 257;
    valued_property_offsets-->p121_satisfied = 259;
    valued_property_offsets-->p123_distracted = 262;
    valued_property_offsets-->p125_asleep = 265;
    attributed_property_offsets-->worn = 268;
    valued_property_offsets-->vector = 270;
    valued_property_offsets-->room_index = 272;
    valued_property_offsets-->door_dir = 274;
    valued_property_offsets-->door_to = 276;
    valued_property_offsets-->found_in = 279;
    attributed_property_offsets-->absent = 281;
    valued_property_offsets-->list_together = 283;
    valued_property_offsets-->cap_short_name = 285;
    attributed_property_offsets-->mark_as_room = 287;
    attributed_property_offsets-->mark_as_thing = 289;
    valued_property_offsets-->component_parent = 291;
    valued_property_offsets-->component_child = 293;
    valued_property_offsets-->component_sibling = 295;
    valued_property_offsets-->regional_found_in = 297;
    valued_property_offsets-->IK1_Count = 299;
    valued_property_offsets-->IK1_Link = 301;
    valued_property_offsets-->IK2_Count = 303;
    valued_property_offsets-->IK2_Link = 305;
    valued_property_offsets-->IK3_Count = 307;
    valued_property_offsets-->IK3_Link = 309;
    valued_property_offsets-->IK4_Count = 311;
    valued_property_offsets-->IK4_Link = 313;
    valued_property_offsets-->IK5_Count = 315;
    valued_property_offsets-->IK5_Link = 317;
    valued_property_offsets-->IK6_Count = 319;
    valued_property_offsets-->IK6_Link = 321;
    valued_property_offsets-->IK7_Count = 323;
    valued_property_offsets-->IK7_Link = 325;
    valued_property_offsets-->IK8_Count = 327;
    valued_property_offsets-->IK8_Link = 329;
    valued_property_offsets-->IK9_Count = 331;
    valued_property_offsets-->IK9_Link = 333;
    valued_property_offsets-->IK10_Count = 335;
    valued_property_offsets-->IK10_Link = 337;
    valued_property_offsets-->IK11_Count = 339;
    valued_property_offsets-->IK11_Link = 341;
    valued_property_offsets-->IK12_Count = 343;
    valued_property_offsets-->IK12_Link = 345;
    valued_property_offsets-->IK13_Count = 347;
    valued_property_offsets-->IK13_Link = 349;
    valued_property_offsets-->IK14_Count = 351;
    valued_property_offsets-->IK14_Link = 353;
    valued_property_offsets-->IK15_Count = 355;
    valued_property_offsets-->IK15_Link = 357;
    valued_property_offsets-->IK16_Count = 359;
    valued_property_offsets-->IK16_Link = 361;
    valued_property_offsets-->IK17_Count = 363;
    valued_property_offsets-->IK17_Link = 365;
    valued_property_offsets-->IK18_Count = 367;
    valued_property_offsets-->IK18_Link = 369;
    valued_property_offsets-->IK19_Count = 371;
    valued_property_offsets-->IK19_Link = 373;
    valued_property_offsets-->IK20_Count = 375;
    valued_property_offsets-->IK20_Link = 377;
    valued_property_offsets-->IK21_Count = 379;
    valued_property_offsets-->IK21_Link = 381;
    valued_property_offsets-->IK22_Count = 383;
    valued_property_offsets-->IK22_Link = 385;
    valued_property_offsets-->IK23_Count = 387;
    valued_property_offsets-->IK23_Link = 389;
    valued_property_offsets-->IK24_Count = 391;
    valued_property_offsets-->IK24_Link = 393;
    valued_property_offsets-->IK25_Count = 395;
    valued_property_offsets-->IK25_Link = 397;
    valued_property_offsets-->IK26_Count = 399;
    valued_property_offsets-->IK26_Link = 401;
    valued_property_offsets-->IK27_Count = 403;
    valued_property_offsets-->IK27_Link = 405;
    valued_property_offsets-->IK28_Count = 407;
    valued_property_offsets-->IK28_Link = 409;
    valued_property_offsets-->IK29_Count = 411;
    valued_property_offsets-->IK29_Link = 413;
    valued_property_offsets-->IK30_Count = 415;
    valued_property_offsets-->IK30_Link = 417;
    valued_property_offsets-->IK31_Count = 419;
    valued_property_offsets-->IK31_Link = 421;
    valued_property_offsets-->KD_Count = 423;
    valued_property_offsets-->name = 425;
    valued_property_offsets-->parse_name = 427;
    valued_property_offsets-->action_bitmap = 429;
];


Constant NUMBER_RULEBOOKS_CREATED = 573;
Constant V0_printing_the_name_of_some = 0;
Constant V1_printing_the_plural_name_ = 1;
Constant V2_printing_a_number_of_some = 2;
Constant V3_printing_room_description = 3;
Constant V4_listing_contents_of_somet = 4;
Constant V5_grouping_together_somethi = 5;
Constant V6_writing_a_paragraph_about = 6;
Constant V7_listing_nondescript_items = 7;
Constant V8_printing_the_name_of_a_da = 8;
Constant V9_printing_the_description_ = 9;
Constant V10_printing_the_announcemen = 10;
Constant V11_printing_the_announcemen = 11;
Constant V12_printing_a_refusal_to_ac = 12;
Constant V13_constructing_the_status_ = 13;
Constant V14_printing_the_banner_text = 14;
Constant V15_reading_a_command = 15;
Constant V16_deciding_the_scope_of_so = 16;
Constant V17_deciding_the_concealed_p = 17;
Constant V18_deciding_whether_all_inc = 18;
Constant V19_clarifying_the_parser_s_ = 19;
Constant V20_asking_which_do_you_mean = 20;
Constant V21_printing_a_parser_error = 21;
Constant V22_supplying_a_missing_noun = 22;
Constant V23_supplying_a_missing_seco = 23;
Constant V24_implicitly_taking_someth = 24;
Constant V25_starting_the_virtual_mac = 25;
Constant V26_amusing_a_victorious_pla = 26;
Constant V27_printing_the_player_s_ob = 27;
Constant V28_handling_the_final_quest = 28;
Constant V29_printing_the_locale_desc = 29;
Constant V30_choosing_notable_locale_ = 30;
Constant V31_printing_a_locale_paragr = 31;
Constant V32_refusing_keys_of_somethi = 32;

Array Activity_before_rulebooks --> 29 32 35 38 41 44 47 50 53 56 59 62 65 68 71 74 77 80 83 86 89 92 95 98 101 104 107 110 113 116 119 122 385 NULL;

Array Activity_for_rulebooks --> 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99 102 105 108 111 114 117 120 123 386 NULL;

Array Activity_after_rulebooks --> 31 34 37 40 43 46 49 52 55 58 61 64 67 70 73 76 79 82 85 88 91 94 97 100 103 106 109 112 115 118 121 124 387 NULL;

Array Activity_atb_rulebooks -> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 $ff;


Constant RELS_SYMMETRIC $8000;
Constant RELS_EQUIVALENCE $4000;
Constant RELS_X_UNIQUE $2000;
Constant RELS_Y_UNIQUE $1000;
Constant RELS_TEST $0800;
Constant RELS_ASSERT_TRUE $0400;
Constant RELS_ASSERT_FALSE $0200;
Constant RELS_SHOW $0100;
Constant RELS_ROUTE_FIND $0080;
Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_LOOKUP_ANY $0008;
Constant RELS_LOOKUP_ALL_X $0004;
Constant RELS_LOOKUP_ALL_Y $0002;
Constant RELS_LIST $0001;
#Iftrue (WORDSIZE == 2);
Constant REL_BLOCK_HEADER ($100*5 + $$1101);
#Ifnot;
Constant REL_BLOCK_HEADER ($100*6 + $$1101)*$10000;
#Endif;


[ PrintSceneName value;
    switch(value) {
        I66_entire_game: print "Entire Game";
        I424_first_pump: print "First Pump";
        I425_lever_action: print "Lever-action";
        I426_gizmo_action: print "Gizmo-action";
        I427_gadget_action: print "Gadget-action";
        I428_hose_action: print "Hose-action";
        I429_second_pump: print "Second Pump";
        I430_third_pump: print "Third Pump";
        I431_conductor_s_story: print "conductor's story";
        I432_fourth_pump: print "Fourth Pump";
        I611_secretary_s_story: print "secretary's story";
        I674_vivian_s_story: print "Vivian's Story";
        I695_endgame: print "Endgame";
        I704_switch_action: print "Switch-action";
        default: print "<illegal scene>";
    }
];

[ A_PrintSceneName value;
    return (value % 14)+1;
];
[ B_PrintSceneName value;
    return ((value+12) % 14)+1;
];
[ R_PrintSceneName a b;
    if (a == 0 && b == 0) return (random(14));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintFigureName value;
    switch(value) {
        I65_figure_of_cover: print "Figure of cover";
        default: print "<illegal figure name>";
    }
];

[ A_PrintFigureName value;
    return (value % 1)+1;
];
[ B_PrintFigureName value;
    return ((value+-1) % 1)+1;
];
[ R_PrintFigureName a b;
    if (a == 0 && b == 0) return (random(1));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintSoundName value;
    switch(value) {
        default: print "<illegal sound name>";
    }
];

[ A_PrintSoundName value;
    return (value % 0)+1;
];
[ B_PrintSoundName value;
    return ((value+-2) % 0)+1;
];
[ R_PrintSoundName a b;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintExternalFileName value;
    switch(value) {
        default: print "<illegal external file>";
    }
];

[ A_PrintExternalFileName value;
    return (value % 0)+1;
];
[ B_PrintExternalFileName value;
    return ((value+-2) % 0)+1;
];
[ R_PrintExternalFileName a b;
    if (a == 0 && b == 0) return (random(0));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T57 value;
    switch(value) {
        I68_didn_t_understand_error: print "didn't understand error";
        I69_only_understood_as_far_a: print "only understood as far as error";
        I70_didn_t_understand_that_n: print "didn't understand that number error";
        I71_can_only_do_that_to_some: print "can only do that to something animate error";
        I72_can_t_see_any_such_thing: print "can't see any such thing error";
        I73_said_too_little_error: print "said too little error";
        I74_aren_t_holding_that_erro: print "aren't holding that error";
        I75_can_t_use_multiple_objec: print "can't use multiple objects error";
        I76_can_only_use_multiple_ob: print "can only use multiple objects error";
        I77_not_sure_what_it_refers_: print "not sure what it refers to error";
        I78_excepted_something_not_i: print "excepted something not included error";
        I79_not_a_verb_i_recognise_e: print "not a verb I recognise error";
        I80_not_something_you_need_t: print "not something you need to refer to error";
        I81_can_t_see_it_at_the_mome: print "can't see it at the moment error";
        I82_didn_t_understand_the_wa: print "didn't understand the way that finished error";
        I83_not_enough_of_those_avai: print "not enough of those available error";
        I84_nothing_to_do_error: print "nothing to do error";
        I85_noun_did_not_make_sense_: print "noun did not make sense in that context error";
        I86_referred_to_a_determinat: print "referred to a determination of scope error";
        I87_i_beg_your_pardon_error: print "I beg your pardon error";
        default: print "<illegal command parser error>";
    }
];

[ A_T57 value;
    return (value % 20)+1;
];
[ B_T57 value;
    return ((value+18) % 20)+1;
];
[ R_T57 a b;
    if (a == 0 && b == 0) return (random(20));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T62 value;
    switch(value) {
        I94_libmsg__you_have_died_: print "LibMsg <you have died>";
        I95_libmsg__you_have_won_: print "LibMsg <you have won>";
        I96_libmsg__player_self_desc: print "LibMsg <player self description>";
        I97_libmsg__unimportant_obje: print "LibMsg <unimportant object>";
        I98_libmsg__empty_line_: print "LibMsg <empty line>";
        I99_libmsg__confirm_quit_: print "LibMsg <confirm Quit>";
        I100_libmsg__yes_or_no_promp: print "LibMsg <yes or no prompt>";
        I101_libmsg__restrict_answer: print "LibMsg <restrict answer>";
        I102_libmsg__page_prompt_: print "LibMsg <page prompt>";
        I103_libmsg__menu_prompt_: print "LibMsg <menu prompt>";
        I104_libmsg__comment_recorde: print "LibMsg <comment recorded>";
        I105_libmsg__comment_not_rec: print "LibMsg <comment not recorded>";
        I106_libmsg__undo_succeeded_: print "LibMsg <undo succeeded>";
        I107_libmsg__undo_failed_: print "LibMsg <undo failed>";
        I108_libmsg__undo_not_provid: print "LibMsg <undo not provided>";
        I109_libmsg__cannot_undo_not: print "LibMsg <cannot undo nothing>";
        I110_libmsg__cannot_undo_twi: print "LibMsg <cannot undo twice in a row>";
        I111_libmsg__undo_forbidden_: print "LibMsg <undo forbidden>";
        I112_libmsg__oops_failed_: print "LibMsg <oops failed>";
        I113_libmsg__oops_too_many_a: print "LibMsg <oops too many arguments>";
        I114_libmsg__oops_no_argumen: print "LibMsg <oops no arguments>";
        I115_libmsg__cannot_do_again: print "LibMsg <cannot do again>";
        I116_libmsg__again_usage_: print "LibMsg <again usage>";
        I117_libmsg__command_not_und: print "LibMsg <command not understood>";
        I118_libmsg__command_partly_: print "LibMsg <command partly understood>";
        I119_libmsg__command_badly_e: print "LibMsg <command badly ended>";
        I120_libmsg__command_incompl: print "LibMsg <command incomplete>";
        I121_libmsg__command_cut_sho: print "LibMsg <command cut short>";
        I122_libmsg__number_not_unde: print "LibMsg <number not understood>";
        I123_libmsg__cannot_begin_at: print "LibMsg <cannot begin at comma>";
        I124_libmsg__extra_words_bef: print "LibMsg <extra words before comma>";
        I125_libmsg__unknown_object_: print "LibMsg <unknown object>";
        I126_libmsg__object_not_held: print "LibMsg <object not held>";
        I127_libmsg__unknown_verb_: print "LibMsg <unknown verb>";
        I128_libmsg__verb_cannot_hav: print "LibMsg <verb cannot have inanimate object>";
        I129_libmsg__noun_needed_: print "LibMsg <noun needed>";
        I130_libmsg__noun_not_needed: print "LibMsg <noun not needed>";
        I131_libmsg__object_needed_: print "LibMsg <object needed>";
        I132_libmsg__object_not_need: print "LibMsg <object not needed>";
        I133_libmsg__second_object_n: print "LibMsg <second object needed>";
        I134_libmsg__second_object_n: print "LibMsg <second object not needed>";
        I135_libmsg__second_noun_nee: print "LibMsg <second noun needed>";
        I136_libmsg__second_noun_not: print "LibMsg <second noun not needed>";
        I137_libmsg__something_more_: print "LibMsg <something more substantial needed>";
        I138_libmsg__verb_cannot_hav: print "LibMsg <verb cannot have multiple objects>";
        I139_libmsg__too_many_multip: print "LibMsg <too many multiple objects>";
        I140_libmsg__not_that_many_a: print "LibMsg <not that many available>";
        I141_libmsg__no_objects_avai: print "LibMsg <no objects available>";
        I142_libmsg__zero_multiple_o: print "LibMsg <zero multiple objects>";
        I143_libmsg__first_n_objects: print "LibMsg <first N objects>";
        I144_libmsg__excepted_object: print "LibMsg <excepted object not included anyway>";
        I145_libmsg__report_implicit: print "LibMsg <report implicit take>";
        I146_libmsg__report_npc_impl: print "LibMsg <report npc implicit take>";
        I147_libmsg__use_holdall_to_: print "LibMsg <use holdall to avoid exceeding carrying capacity>";
        I148_libmsg__cannot_put_if_t: print "LibMsg <cannot put if this exceeds carrying capacity>";
        I149_libmsg__who_disambiguat: print "LibMsg <who disambiguation>";
        I150_libmsg__which_disambigu: print "LibMsg <which disambiguation>";
        I151_libmsg__whom_disambigua: print "LibMsg <whom disambiguation>";
        I152_libmsg__what_disambigua: print "LibMsg <what disambiguation>";
        I153_libmsg__single_object_d: print "LibMsg <single object disambiguation>";
        I154_libmsg__pronoun_not_set: print "LibMsg <pronoun not set>";
        I155_libmsg__pronoun_absent_: print "LibMsg <pronoun absent>";
        I156_libmsg__pronouns_initia: print "LibMsg <Pronouns initial text>";
        I157_libmsg__pronouns__means: print "LibMsg <Pronouns -means- text>";
        I158_libmsg__pronouns__unset: print "LibMsg <Pronouns -unset- text>";
        I159_libmsg__no_pronouns_kno: print "LibMsg <no pronouns known>";
        I160_libmsg__person_ignores_: print "LibMsg <person ignores command>";
        I161_libmsg__cannot_talk_to_: print "LibMsg <cannot talk to absent person>";
        I162_libmsg__cannot_talk_to_: print "LibMsg <cannot talk to inanimate object>";
        I163_libmsg__npc_unable_to_d: print "LibMsg <npc unable to do that>";
        I164_libmsg__confirm_restart: print "LibMsg <confirm Restart>";
        I165_libmsg__restart_failed_: print "LibMsg <Restart failed>";
        I166_libmsg__restore_failed_: print "LibMsg <Restore failed>";
        I167_libmsg__restore_succeed: print "LibMsg <Restore succeeded>";
        I168_libmsg__save_failed_: print "LibMsg <Save failed>";
        I169_libmsg__save_succeeded_: print "LibMsg <Save succeeded>";
        I170_libmsg__verify_succeede: print "LibMsg <Verify succeeded>";
        I171_libmsg__verify_failed_: print "LibMsg <Verify failed>";
        I172_libmsg__transcript_alre: print "LibMsg <transcript already on>";
        I173_libmsg__transcript_alre: print "LibMsg <transcript already off>";
        I174_libmsg__start_of_transc: print "LibMsg <start of transcript>";
        I175_libmsg__end_of_transcri: print "LibMsg <end of transcript>";
        I176_libmsg__transcript_fail: print "LibMsg <transcript failed>";
        I177_libmsg__end_transcript_: print "LibMsg <end transcript failed>";
        I178_libmsg__score_command_: print "LibMsg <Score command>";
        I179_libmsg__score_changed_: print "LibMsg <score changed>";
        I180_libmsg__score_notificat: print "LibMsg <score notification turned on>";
        I181_libmsg__score_notificat: print "LibMsg <score notification turned off>";
        I182_libmsg__no_scoring_: print "LibMsg <no scoring>";
        I183_libmsg__score_rank_: print "LibMsg <score rank>";
        I184_libmsg__report_npc_taki: print "LibMsg <report npc taking inventory>";
        I185_libmsg__inventory_initi: print "LibMsg <Inventory initial text>";
        I186_libmsg__inventory_no_po: print "LibMsg <Inventory no possessions>";
        I187_libmsg__entering_darkne: print "LibMsg <entering darkness>";
        I188_libmsg__dark_descriptio: print "LibMsg <dark description>";
        I189_libmsg__examine_while_d: print "LibMsg <examine while dark>";
        I190_libmsg__search_while_da: print "LibMsg <search while dark>";
        I191_libmsg__look_under_whil: print "LibMsg <look under while dark>";
        I192_libmsg__dark_room_name_: print "LibMsg <dark room name>";
        I193_libmsg__report_player_t: print "LibMsg <report player taking>";
        I194_libmsg__report_npc_taki: print "LibMsg <report npc taking>";
        I195_libmsg__cannot_take_you: print "LibMsg <cannot take yourself>";
        I196_libmsg__cannot_take_oth: print "LibMsg <cannot take other people>";
        I197_libmsg__cannot_take_som: print "LibMsg <cannot take something you are within>";
        I198_libmsg__cannot_take_som: print "LibMsg <cannot take something already taken>";
        I199_libmsg__cannot_take_pos: print "LibMsg <cannot take possessions of others>";
        I200_libmsg__cannot_take_com: print "LibMsg <cannot take component parts>";
        I201_libmsg__cannot_take_hid: print "LibMsg <cannot take hidden parts>";
        I202_libmsg__cannot_reach_wi: print "LibMsg <cannot reach within closed containers>";
        I203_libmsg__cannot_take_sce: print "LibMsg <cannot take scenery>";
        I204_libmsg__cannot_take_som: print "LibMsg <cannot take something fixed>";
        I205_libmsg__cannot_reach_wi: print "LibMsg <cannot reach within other places>";
        I206_libmsg__cannot_exceed_c: print "LibMsg <cannot exceed carrying capacity>";
        I207_libmsg__report_player_r: print "LibMsg <report player removing>";
        I208_libmsg__report_npc_remo: print "LibMsg <report npc removing>";
        I209_libmsg__cannot_remove_f: print "LibMsg <cannot remove from closed containers>";
        I210_libmsg__cannot_remove_s: print "LibMsg <cannot remove something not within>";
        I211_libmsg__report_player_d: print "LibMsg <report player dropping>";
        I212_libmsg__report_npc_drop: print "LibMsg <report npc dropping>";
        I213_libmsg__cannot_drop_som: print "LibMsg <cannot drop something already dropped>";
        I214_libmsg__cannot_drop_not: print "LibMsg <cannot drop not holding>";
        I215_libmsg__cannot_drop_if_: print "LibMsg <cannot drop if this exceeds carrying capacity>";
        I216_libmsg__cannot_drop_clo: print "LibMsg <cannot drop clothes being worn>";
        I217_libmsg__report_player_i: print "LibMsg <report player inserting>";
        I218_libmsg__report_npc_inse: print "LibMsg <report npc inserting>";
        I219_libmsg__cannot_insert_s: print "LibMsg <cannot insert something not held>";
        I220_libmsg__cannot_insert_i: print "LibMsg <cannot insert into something not a container>";
        I221_libmsg__cannot_insert_i: print "LibMsg <cannot insert into closed containers>";
        I222_libmsg__need_to_take_of: print "LibMsg <need to take off before inserting>";
        I223_libmsg__cannot_insert_s: print "LibMsg <cannot insert something into itself>";
        I224_libmsg__cannot_insert_i: print "LibMsg <cannot insert if this exceeds carrying capacity>";
        I225_libmsg__cannot_insert_c: print "LibMsg <cannot insert clothes being worn>";
        I226_libmsg__report_player_p: print "LibMsg <report player putting on>";
        I227_libmsg__report_npc_putt: print "LibMsg <report npc putting on>";
        I228_libmsg__cannot_put_some: print "LibMsg <cannot put something not held>";
        I229_libmsg__cannot_put_some: print "LibMsg <cannot put something on it-self>";
        I230_libmsg__cannot_put_onto: print "LibMsg <cannot put onto something not a supporter>";
        I231_libmsg__cannot_put_onto: print "LibMsg <cannot put onto something being carried>";
        I232_libmsg__cannot_put_clot: print "LibMsg <cannot put clothes being worn>";
        I233_libmsg__report_player_g: print "LibMsg <report player giving>";
        I234_libmsg__report_npc_givi: print "LibMsg <report npc giving to player>";
        I235_libmsg__report_npc_givi: print "LibMsg <report npc giving to npc>";
        I236_libmsg__cannot_give_wha: print "LibMsg <cannot give what you have not got>";
        I237_libmsg__cannot_give_to_: print "LibMsg <cannot give to yourself>";
        I238_libmsg__block_giving_: print "LibMsg <block giving>";
        I239_libmsg__unable_to_recei: print "LibMsg <unable to receive things>";
        I240_libmsg__cannot_show_wha: print "LibMsg <cannot show what you have not got>";
        I241_libmsg__block_showing_: print "LibMsg <block showing>";
        I242_libmsg__report_player_e: print "LibMsg <report player entering>";
        I243_libmsg__report_npc_ente: print "LibMsg <report npc entering>";
        I244_libmsg__cannot_enter_so: print "LibMsg <cannot enter something already entered>";
        I245_libmsg__cannot_enter_so: print "LibMsg <cannot enter something not enterable>";
        I246_libmsg__cannot_enter_cl: print "LibMsg <cannot enter closed containers>";
        I247_libmsg__cannot_enter_so: print "LibMsg <cannot enter something carried>";
        I248_libmsg__implicitly_pass: print "LibMsg <implicitly pass outwards through other barriers>";
        I249_libmsg__implicitly_pass: print "LibMsg <implicitly pass inwards through other barriers>";
        I250_libmsg__report_player_e: print "LibMsg <report player exiting>";
        I251_libmsg__report_npc_exit: print "LibMsg <report npc exiting>";
        I252_libmsg__cannot_exit_whe: print "LibMsg <cannot exit when not within anything>";
        I253_libmsg__cannot_exit_clo: print "LibMsg <cannot exit closed containers>";
        I254_libmsg__cannot_get_off_: print "LibMsg <cannot get off things>";
        I255_libmsg__cannot_exit_thi: print "LibMsg <cannot exit thing not within>";
        I256_libmsg__cannot_go_that_: print "LibMsg <cannot go that way>";
        I257_libmsg__cannot_travel_i: print "LibMsg <cannot travel in something not a vehicle>";
        I258_libmsg__cannot_go_throu: print "LibMsg <cannot go through concealed doors>";
        I259_libmsg__cannot_go_up_th: print "LibMsg <cannot go up through closed doors>";
        I260_libmsg__cannot_go_down_: print "LibMsg <cannot go down through closed doors>";
        I261_libmsg__cannot_go_throu: print "LibMsg <cannot go through closed doors>";
        I262_libmsg__nothing_through: print "LibMsg <nothing through door>";
        I263_libmsg__block_vaguely_g: print "LibMsg <block vaguely going>";
        I264_libmsg__say_npc_goes_: print "LibMsg <say npc goes>";
        I265_libmsg__say_npc_arrives: print "LibMsg <say npc arrives>";
        I266_libmsg__say_npc_arrives: print "LibMsg <say npc arrives from unknown direction>";
        I267_libmsg__say_npc_arrives: print "LibMsg <say npc arrives at>";
        I268_libmsg__say_npc_goes_th: print "LibMsg <say npc goes through>";
        I269_libmsg__say_npc_arrives: print "LibMsg <say npc arrives from>";
        I270_libmsg__say_npc_vehicle: print "LibMsg <say npc vehicle>";
        I271_libmsg__say_npc_pushing: print "LibMsg <say npc pushing in front with player>";
        I272_libmsg__say_npc_pushing: print "LibMsg <say npc pushing in front>";
        I273_libmsg__say_npc_pushing: print "LibMsg <say npc pushing away>";
        I274_libmsg__say_npc_pushing: print "LibMsg <say npc pushing in>";
        I275_libmsg__say_npc_taking_: print "LibMsg <say npc taking player along>";
        I276_libmsg__brief_look_mode: print "LibMsg <brief look mode>";
        I277_libmsg__superbrief_look: print "LibMsg <superbrief look mode>";
        I278_libmsg__verbose_look_mo: print "LibMsg <verbose look mode>";
        I279_libmsg__report_npc_look: print "LibMsg <report npc looking>";
        I280_libmsg__top_line_what_o: print "LibMsg <top line what on>";
        I281_libmsg__top_line_what_i: print "LibMsg <top line what in>";
        I282_libmsg__top_line_what_a: print "LibMsg <top line what as>";
        I283_libmsg__say_things_with: print "LibMsg <say things within>";
        I284_libmsg__say_things_also: print "LibMsg <say things also within>";
        I285_libmsg__say_things_on_: print "LibMsg <say things on>";
        I286_libmsg__report_npc_exam: print "LibMsg <report npc examining>";
        I287_libmsg__examine_undescr: print "LibMsg <examine undescribed things>";
        I288_libmsg__examine_directi: print "LibMsg <examine direction>";
        I289_libmsg__examine_devices: print "LibMsg <examine devices>";
        I290_libmsg__examine_in_dark: print "LibMsg <examine in darkness>";
        I291_libmsg__report_npc_sear: print "LibMsg <report npc searching>";
        I292_libmsg__cannot_search_u: print "LibMsg <cannot search unless container or supporter>";
        I293_libmsg__cannot_search_c: print "LibMsg <cannot search closed opaque containers>";
        I294_libmsg__nothing_found_w: print "LibMsg <nothing found within container>";
        I295_libmsg__nothing_found_o: print "LibMsg <nothing found on top of>";
        I296_libmsg__search_in_darkn: print "LibMsg <search in darkness>";
        I297_libmsg__report_npc_look: print "LibMsg <report npc looking under>";
        I298_libmsg__look_under_: print "LibMsg <look under>";
        I299_libmsg__look_under_in_d: print "LibMsg <look under in darkness>";
        I300_libmsg__report_player_o: print "LibMsg <report player opening>";
        I301_libmsg__report_npc_open: print "LibMsg <report npc opening>";
        I302_libmsg__report_unseen_n: print "LibMsg <report unseen npc opening>";
        I303_libmsg__cannot_open_unl: print "LibMsg <cannot open unless openable>";
        I304_libmsg__cannot_open_som: print "LibMsg <cannot open something locked>";
        I305_libmsg__cannot_open_som: print "LibMsg <cannot open something already open>";
        I306_libmsg__reveal_any_newl: print "LibMsg <reveal any newly visible exterior initial text>";
        I307_libmsg__no_newly_visibl: print "LibMsg <no newly visible exterior>";
        I308_libmsg__report_player_c: print "LibMsg <report player closing>";
        I309_libmsg__report_npc_clos: print "LibMsg <report npc closing>";
        I310_libmsg__report_unseen_n: print "LibMsg <report unseen npc closing>";
        I311_libmsg__cannot_close_un: print "LibMsg <cannot close unless openable>";
        I312_libmsg__cannot_close_so: print "LibMsg <cannot close something already closed>";
        I313_libmsg__report_player_l: print "LibMsg <report player locking>";
        I314_libmsg__report_npc_lock: print "LibMsg <report npc locking>";
        I315_libmsg__cannot_lock_wit: print "LibMsg <cannot lock without a lock>";
        I316_libmsg__cannot_lock_som: print "LibMsg <cannot lock something already locked>";
        I317_libmsg__cannot_lock_som: print "LibMsg <cannot lock something open>";
        I318_libmsg__cannot_lock_wit: print "LibMsg <cannot lock without the correct key>";
        I319_libmsg__report_player_u: print "LibMsg <report player unlocking>";
        I320_libmsg__report_npc_unlo: print "LibMsg <report npc unlocking>";
        I321_libmsg__cannot_unlock_w: print "LibMsg <cannot unlock without a lock>";
        I322_libmsg__cannot_unlock_s: print "LibMsg <cannot unlock something already unlocked>";
        I323_libmsg__cannot_unlock_w: print "LibMsg <cannot unlock without the correct key>";
        I324_libmsg__report_player_s: print "LibMsg <report player switching on>";
        I325_libmsg__report_npc_swit: print "LibMsg <report npc switching on>";
        I326_libmsg__cannot_switch_o: print "LibMsg <cannot switch on unless switchable>";
        I327_libmsg__cannot_switch_o: print "LibMsg <cannot switch on something already on>";
        I328_libmsg__report_player_s: print "LibMsg <report player switching off>";
        I329_libmsg__report_npc_swit: print "LibMsg <report npc switching off>";
        I330_libmsg__cannot_switch_o: print "LibMsg <cannot switch off unless switchable>";
        I331_libmsg__cannot_switch_o: print "LibMsg <cannot switch off something already off>";
        I332_libmsg__report_player_w: print "LibMsg <report player wearing>";
        I333_libmsg__report_npc_wear: print "LibMsg <report npc wearing>";
        I334_libmsg__cannot_wear_som: print "LibMsg <cannot wear something not clothing>";
        I335_libmsg__cannot_wear_not: print "LibMsg <cannot wear not holding>";
        I336_libmsg__cannot_wear_som: print "LibMsg <cannot wear something already worn>";
        I337_libmsg__report_player_t: print "LibMsg <report player taking off>";
        I338_libmsg__report_npc_taki: print "LibMsg <report npc taking off>";
        I339_libmsg__cannot_take_off: print "LibMsg <cannot take off something not worn>";
        I340_libmsg__report_player_e: print "LibMsg <report player eating>";
        I341_libmsg__report_npc_eati: print "LibMsg <report npc eating>";
        I342_libmsg__cannot_eat_unle: print "LibMsg <cannot eat unless edible>";
        I343_libmsg__block_drinking_: print "LibMsg <block drinking>";
        I344_libmsg__block_tasting_: print "LibMsg <block tasting>";
        I345_libmsg__block_smelling_: print "LibMsg <block smelling>";
        I346_libmsg__block_listening: print "LibMsg <block listening>";
        I347_libmsg__report_player_t: print "LibMsg <report player touching things>";
        I348_libmsg__report_npc_touc: print "LibMsg <report npc touching things>";
        I349_libmsg__report_player_t: print "LibMsg <report player touching self>";
        I350_libmsg__report_npc_touc: print "LibMsg <report npc touching self>";
        I351_libmsg__report_player_t: print "LibMsg <report player touching other people>";
        I352_libmsg__report_npc_touc: print "LibMsg <report npc touching other people>";
        I353_libmsg__block_saying_ye: print "LibMsg <block saying yes>";
        I354_libmsg__block_saying_no: print "LibMsg <block saying no>";
        I355_libmsg__block_saying_so: print "LibMsg <block saying sorry>";
        I356_libmsg__block_swearing_: print "LibMsg <block swearing obscenely>";
        I357_libmsg__block_swearing_: print "LibMsg <block swearing mildly>";
        I358_libmsg__block_climbing_: print "LibMsg <block climbing>";
        I359_libmsg__block_jumping_: print "LibMsg <block jumping>";
        I360_libmsg__block_swinging_: print "LibMsg <block swinging>";
        I361_libmsg__block_waving_ha: print "LibMsg <block waving hands>";
        I362_libmsg__block_attacking: print "LibMsg <block attacking>";
        I363_libmsg__block_burning_: print "LibMsg <block burning>";
        I364_libmsg__block_cutting_: print "LibMsg <block cutting>";
        I365_libmsg__block_rubbing_: print "LibMsg <block rubbing>";
        I366_libmsg__block_setting_t: print "LibMsg <block setting to>";
        I367_libmsg__block_tying_: print "LibMsg <block tying>";
        I368_libmsg__report_player_w: print "LibMsg <report player waving things>";
        I369_libmsg__report_npc_wavi: print "LibMsg <report npc waving things>";
        I370_libmsg__cannot_wave_som: print "LibMsg <cannot wave something not held>";
        I371_libmsg__squeezing_peopl: print "LibMsg <squeezing people>";
        I372_libmsg__report_player_s: print "LibMsg <report player squeezing>";
        I373_libmsg__report_npc_sque: print "LibMsg <report npc squeezing>";
        I374_libmsg__block_throwing_: print "LibMsg <block throwing at>";
        I375_libmsg__throw_at_inanim: print "LibMsg <throw at inanimate object>";
        I376_libmsg__report_player_p: print "LibMsg <report player pushing>";
        I377_libmsg__report_npc_push: print "LibMsg <report npc pushing>";
        I378_libmsg__report_player_p: print "LibMsg <report player pulling>";
        I379_libmsg__report_npc_pull: print "LibMsg <report npc pulling>";
        I380_libmsg__report_player_t: print "LibMsg <report player turning>";
        I381_libmsg__report_npc_turn: print "LibMsg <report npc turning>";
        I382_libmsg__block_pushing_i: print "LibMsg <block pushing in directions>";
        I383_libmsg__not_pushed_in_a: print "LibMsg <not pushed in a direction>";
        I384_libmsg__pushed_in_illeg: print "LibMsg <pushed in illegal direction>";
        I385_libmsg__cannot_push_som: print "LibMsg <cannot push something fixed in place>";
        I386_libmsg__cannot_pull_som: print "LibMsg <cannot pull something fixed in place>";
        I387_libmsg__cannot_turn_som: print "LibMsg <cannot turn something fixed in place>";
        I388_libmsg__cannot_push_sce: print "LibMsg <cannot push scenery>";
        I389_libmsg__cannot_pull_sce: print "LibMsg <cannot pull scenery>";
        I390_libmsg__cannot_turn_sce: print "LibMsg <cannot turn scenery>";
        I391_libmsg__cannot_push_peo: print "LibMsg <cannot push people>";
        I392_libmsg__cannot_pull_peo: print "LibMsg <cannot pull people>";
        I393_libmsg__cannot_turn_peo: print "LibMsg <cannot turn people>";
        I394_libmsg__block_answering: print "LibMsg <block answering>";
        I395_libmsg__block_asking_: print "LibMsg <block asking>";
        I396_libmsg__block_buying_: print "LibMsg <block buying>";
        I397_libmsg__block_kissing_: print "LibMsg <block kissing>";
        I398_libmsg__block_singing_: print "LibMsg <block singing>";
        I399_libmsg__block_telling_: print "LibMsg <block telling>";
        I400_libmsg__telling_yoursel: print "LibMsg <telling yourself>";
        I401_libmsg__block_thinking_: print "LibMsg <block thinking>";
        I402_libmsg__block_player_co: print "LibMsg <block player consulting>";
        I403_libmsg__block_npc_consu: print "LibMsg <block npc consulting>";
        I404_libmsg__block_sleeping_: print "LibMsg <block sleeping>";
        I405_libmsg__block_waking_up: print "LibMsg <block waking up>";
        I406_libmsg__block_waking_ot: print "LibMsg <block waking other>";
        I407_libmsg__report_player_w: print "LibMsg <report player waiting>";
        I408_libmsg__report_npc_wait: print "LibMsg <report npc waiting>";
        default: print "<illegal library message id>";
    }
];

[ A_T62 value;
    return (value % 315)+1;
];
[ B_T62 value;
    return ((value+313) % 315)+1;
];
[ R_T62 a b;
    if (a == 0 && b == 0) return (random(315));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T70 value;
    switch(value) {
        I436_clean_water: print "clean water";
        I437_pond_water: print "pond water";
        default: print "<illegal liquid>";
    }
];

[ A_T70 value;
    return (value % 2)+1;
];
[ B_T70 value;
    return ((value+0) % 2)+1;
];
[ R_T70 a b;
    if (a == 0 && b == 0) return (random(2));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T75 value;
    switch(value) {
        I556_indigo: print "indigo";
        I557_crimson: print "crimson";
        I558_ochre: print "ochre";
        I559_saffron: print "saffron";
        I560_tyrian_purple: print "tyrian purple";
        default: print "<illegal autumnal color>";
    }
];

[ A_T75 value;
    return (value % 5)+1;
];
[ B_T75 value;
    return ((value+3) % 5)+1;
];
[ R_T75 a b;
    if (a == 0 && b == 0) return (random(5));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ T68 value which rem ran;
    if (value == 0) jump Use_LP_0;
    if ((value - 0) >= 1) jump Use_LP_0;
    jump Use_LP_0;
    return;

    ! 15.9 fl oz, with offset=0, multiplier=1

    .Use_LP_0;
    print value/10;
    ! Ran is 1, OM is 1
    if (rem > 0) {
        print ".";
        ran = 1;
        while ((rem % 10 == 0) && (rem > 0)) { rem=rem/10; ran=ran/10; }
        while (rem < ran/10) { print "0"; ran=ran/10; }
        print rem;
    }
    if ((value/1)%10 == 0) rtrue;
    print ".";
    print (value/1)%10;
    print " ";
    print "fl";
    print " ";
    print "oz";
    return;
];

[ R_T68 a b;
    if (a == 0 && b == 0) return (random(MAX_POSITIVE_NUMBER));
    if (a == b) return b;
    if (a > b) return b+(random(MAX_POSITIVE_NUMBER) % (a-b+1));
    return a+(random(MAX_POSITIVE_NUMBER) % (b-a+1));
];
[ PrintKindValuePair k v;
    k = KindAtomic(k);
      switch(k) {
        2: print (DA_Number) v;
        3: print (DA_Number) v;
        4: print (DA_Number) v;
        5: print (DA_Number) v;
        6: print (DA_Number) v;
        7: print (DA_Number) v;
        8: print (DA_Number) v;
        9: print (PrintShortName) v;
        10: print (DecimalNumber) v;
        11: print (DA_TruthState) v;
        12: print (PrintText) v;
        13: print (INDEXED_TEXT_TY_Say) v;
        14: print (DecimalNumber) v;
        15: print (PrintUseOption) v;
        16: print (PrintSnippet) v;
        17: print (PrintTableName) v;
        18: print (DA_Number) v;
        19: print (RulebookOutcomePrintingRule) v;
        20: print (DecimalNumber) v;
        22: print (DecimalNumber) v;
        24: print (SayPhraseName) v;
        25: print (DecimalNumber) v;
        26: print (RELATION_TY_Say) v;
        27: print (RulePrintingRule) v;
        28: print (RulePrintingRule) v;
        29: print (DecimalNumber) v;
        30: print (LIST_OF_TY_Say) v;
        31: print (DecimalNumber) v;
        32: print (PROPERTY_TY_Say) v;
        33: print (DecimalNumber) v;
        34: print (COMBINATION_TY_Say) v;
        35: print (DecimalNumber) v;
        36: print (STORED_ACTION_TY_Say) v;
        37: print (SayActionName) v;
        38: print (PrintTimeOfDay) v;
        39: print (PrintSceneName) v;
        40: print (PrintFigureName) v;
        41: print (PrintSoundName) v;
        42: print (PrintExternalFileName) v;
        43: print (T57) v;
        44: print (T62) v;
        45: print (T68) v;
        46: print (T70) v;
        47: print (T75) v;
        default: print v;
    }
];
[ DefaultValueOfKOV sk k;
    k = KindAtomic(sk);
    switch(k) {
        9: return nothing;
        10: return 0;
        11: return false;
        12: return EMPTY_TEXT_VALUE;
        13: return BlkValueCreate(k, 0, sk);
        14: return 32;
        15: return 0;
        16: return 101;
        17: return TheEmptyTable;
        18: return 0;
        19: return ;
        20: return DefaultTopic;
        22: return ;
        24: return Default_Value_0;
        25: return ;
        26: return BlkValueCreate(k, 0, sk);
        27: return LITTLE_USED_DO_NOTHING_R;
        28: return 0;
        29: return PRINTING_THE_NAME_ACT;
        30: return BlkValueCreate(k, 0, sk);
        31: return Prop_Falsity;
        32: return ;
        33: return ;
        34: return BlkValueCreate(k, 0, sk);
        35: return ;
        36: return BlkValueCreate(k, 0, sk);
        37: return ##Wait;
        38: return 540;
        39: return I66_entire_game;
        40: return I65_figure_of_cover;
        41: return ;
        42: return ;
        43: return I68_didn_t_understand_error;
        44: return I94_libmsg__you_have_died_;
        45: return 0;
        46: return I436_clean_water;
        47: return I556_indigo;
        default: return 0;
    }
];
[ KOVComparisonFunction k;
    k = KindAtomic(k);
    switch(k) {
        9: return UnsignedCompare;
        11: return UnsignedCompare;
        12: return UnsignedCompare;
        13: return BlkValueCompare;
        14: return UnsignedCompare;
        15: return UnsignedCompare;
        16: return UnsignedCompare;
        17: return UnsignedCompare;
        18: return UnsignedCompare;
        19: return UnsignedCompare;
        20: return UnsignedCompare;
        22: return UnsignedCompare;
        24: return UnsignedCompare;
        25: return UnsignedCompare;
        26: return BlkValueCompare;
        27: return UnsignedCompare;
        28: return UnsignedCompare;
        29: return UnsignedCompare;
        30: return BlkValueCompare;
        31: return UnsignedCompare;
        32: return UnsignedCompare;
        33: return UnsignedCompare;
        34: return BlkValueCompare;
        35: return UnsignedCompare;
        36: return BlkValueCompare;
        37: return UnsignedCompare;
        39: return UnsignedCompare;
        40: return UnsignedCompare;
        41: return UnsignedCompare;
        42: return UnsignedCompare;
        default: return 0;
    }
];
[ KOVDomainSize k;
    k = KindAtomic(k);
    switch(k) {
        39: return 14;
        40: return 1;
        41: return 0;
        42: return 0;
        43: return 20;
        44: return 315;
        46: return 2;
        47: return 5;
        default: return 0;
    }
];
[ KOVIsBlockValue k;
    k = KindAtomic(k);
    if (k == 13 or 26 or 30 or 34 or 36) rtrue;
    rfalse;
];
[ KOVSupportFunction k;
    k = KindAtomic(k);
    switch(k) {
        13: return INDEXED_TEXT_TY_Support;
        26: return RELATION_TY_Support;
        30: return LIST_OF_TY_Support;
        34: return COMBINATION_TY_Support;
        36: return STORED_ACTION_TY_Support;
    }
    rfalse;
];

[ I7_Kind_Name k;
    if (k == K1_room) print "room";
    if (k == K2_thing) print "thing";
    if (k == K3_direction) print "direction";
    if (k == K4_door) print "door";
    if (k == K5_container) print "container";
    if (k == K6_supporter) print "supporter";
    if (k == K7_backdrop) print "backdrop";
    if (k == K8_person) print "person";
    if (k == K9_region) print "region";
    if (k == K10_man) print "man";
    if (k == K11_woman) print "woman";
    if (k == K12_animal) print "animal";
    if (k == K13_device) print "device";
    if (k == K14_vehicle) print "vehicle";
    if (k == K15_player_s_holdall) print "player's holdall";
    if (k == K16_rideable_animal) print "rideable animal";
    if (k == K17_rideable_vehicle) print "rideable vehicle";
    if (k == K18_passkey) print "passkey";
    if (k == K19_keychain) print "keychain";
    if (k == K20_wheel) print "wheel";
    if (k == K21_pipe) print "pipe";
    if (k == K22_light_source) print "light source";
    if (k == K23_pump) print "pump";
    if (k == K24_small_rock) print "small rock";
    if (k == K25_fluid_container) print "fluid container";
    if (k == K26_liquid_source) print "liquid source";
    if (k == K27_lever) print "lever";
    if (k == K28_gizmo) print "gizmo";
    if (k == K29_switch) print "switch";
    if (k == K30_pinecone) print "pinecone";
    if (k == K31_flat_paper) print "flat paper";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "there is sufficient light";
Constant RBNO_3 = "there is insufficient light";
Constant RBNO_4 = "persuasion succeeds";
Constant RBNO_5 = "persuasion fails";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
Constant RBNO_11 = "it does not";
Constant RBNO_12 = "it does";
Constant RBNO_13 = "allow stashing";
Constant RBNO_14 = "no decision";
Constant RBNO_15 = "disallow stashing";
Constant RBNO_16 = "it is an excellent choice";
Constant RBNO_17 = "it is a good choice";
Constant RBNO_18 = "it is a passable choice";
Constant RBNO_19 = "never";
Constant RBNO_20 = "it is an excellent suggestion";
Constant RBNO_21 = "it is a good suggestion";
Constant RBNO_22 = "it is a passable suggestion";
Constant RBNO_23 = "it is a bad suggestion";
Constant RBNO_24 = "yes";
Constant RBNO_25 = "no";
[ RulebookOutcomePrintingRule rbno;
    print (string) rbno; rfalse;
];



Array KindHierarchy --> K0_kind (0) K1_room (0) K2_thing (0) K3_direction (0) K4_door (2) K5_container (2) K6_supporter (2) K7_backdrop (2) K8_person (2) K9_region (0) K10_man (8) K11_woman (8) K12_animal (8) K13_device (2) K14_vehicle (5) K15_player_s_holdall (5) K16_rideable_animal (12) K17_rideable_vehicle (6) K18_passkey (2) K19_keychain (6) K20_wheel (2) K21_pipe (2) K22_light_source (13) K23_pump (13) K24_small_rock (2) K25_fluid_container (5) K26_liquid_source (7) K27_lever (2) K28_gizmo (13) K29_switch (2) K30_pinecone (2) K31_flat_paper (2) ;
Constant IK1_First = I439_steam_train;
Constant IK2_First = I92_no_object;
Constant IK3_First = I46_north;
Constant IK4_First = I480_door_to_the_structure;
Constant IK5_First = I709_access_panel;
Constant IK6_First = I707_seat;
Constant IK7_First = I440_sound_of_the_wind_chime;
Constant IK8_First = I711_conductor;
Constant IK9_First = I500_otherland;
Constant IK10_First = I711_conductor;
Constant IK11_First = I652_daughter;
Constant IK12_First = I443_dog;
Constant IK13_First = I418_big_pump;
Constant IK14_First = I481_rowboat;
Constant IK15_First = I451_right_pocket;
Constant IK16_First = nothing;
Constant IK17_First = nothing;
Constant IK18_First = I485_brass_key;
Constant IK19_First = I486_red_foam_keychain;
Constant IK20_First = I698_giant_metal_wheel;
Constant IK21_First = nothing;
Constant IK22_First = I414_flashlight;
Constant IK23_First = I418_big_pump;
Constant IK24_First = X596;
Constant IK25_First = I472_beer_bottle;
Constant IK26_First = I462_running_water;
Constant IK27_First = I538_blue_lever;
Constant IK28_First = I531_triangular_gizmo;
Constant IK29_First = I691_blue_switch;
Constant IK30_First = X566;
Constant IK31_First = I448_page_torn_out_of_a_chil;
Constant No_Directions = 12;
! Table of direction object alias constants:
Constant DirectionObject_0 = I46_north;
Constant DirectionObject_1 = I47_northeast;
Constant DirectionObject_2 = I48_northwest;
Constant DirectionObject_3 = I49_south;
Constant DirectionObject_4 = I50_southeast;
Constant DirectionObject_5 = I51_southwest;
Constant DirectionObject_6 = I52_east;
Constant DirectionObject_7 = I53_west;
Constant DirectionObject_8 = I54_up;
Constant DirectionObject_9 = I55_down;
Constant DirectionObject_10 = in_obj;
Constant DirectionObject_11 = out_obj;
Array Map_Storage -->
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I439_steam_train
 I447_outside_waterworks 0 0 I511_pine_forest 0 I507_freshwater_crossing I508_visitor_center 0 I442_in_the_sweetgum_tree 0 0 0 ! Exits from: I441_hill
 0 0 0 0 0 0 0 0 0 I441_hill 0 0 ! Exits from: I442_in_the_sweetgum_tree
 0 0 I501_small_clearing 0 0 0 I494_other_side_of_the_pond 0 0 0 0 0 ! Exits from: I444_woods
 0 0 0 I441_hill 0 0 I516_door_to_the_waterworks 0 0 0 0 0 ! Exits from: I447_outside_waterworks
 I483_community_center_door 0 0 0 I465_spireland 0 0 0 0 0 0 0 ! Exits from: I464_grassy_shore
 0 I479_boat_house I464_grassy_shore 0 0 0 0 I494_other_side_of_the_pond 0 0 0 0 ! Exits from: I465_spireland
 0 0 0 0 0 I465_spireland I482_waterstained_door 0 0 0 0 0 ! Exits from: I466_floating_on_the_pond
 0 I470_rocky_beach 0 0 0 0 0 0 0 0 0 0 ! Exits from: I468_muddy_beach
 0 0 0 0 0 0 0 0 0 I502_large_clearing 0 0 ! Exits from: I469_atop_the_tank
 0 I474_sandy_beach 0 0 0 I468_muddy_beach 0 I480_door_to_the_structure 0 0 0 0 ! Exits from: I470_rocky_beach
 0 0 0 0 0 I470_rocky_beach 0 0 0 0 0 0 ! Exits from: I474_sandy_beach
 0 0 0 0 0 I465_spireland I480_door_to_the_structure I482_waterstained_door 0 0 0 0 ! Exits from: I479_boat_house
 0 0 0 I483_community_center_door 0 0 0 0 0 0 0 0 ! Exits from: I484_pondside_community_cent
 0 0 0 0 0 0 I465_spireland I444_woods 0 0 0 0 ! Exits from: I494_other_side_of_the_pond
 0 0 0 0 I444_woods I502_large_clearing 0 0 0 0 I637_inside_the_cinderblock_ 0 ! Exits from: I501_small_clearing
 0 I501_small_clearing 0 0 0 0 0 0 I469_atop_the_tank 0 0 0 ! Exits from: I502_large_clearing
 0 0 0 0 0 0 0 0 0 I669_underwater 0 0 ! Exits from: I504_weedy_island
 0 0 0 0 0 0 0 I516_door_to_the_waterworks 0 I510_pump_room 0 0 ! Exits from: I506_inside_waterworks
 0 I441_hill 0 0 0 I509_grassy_area I511_pine_forest 0 0 0 0 0 ! Exits from: I507_freshwater_crossing
 0 0 0 0 0 0 0 I441_hill 0 0 0 0 ! Exits from: I508_visitor_center
 0 I507_freshwater_crossing 0 0 0 0 0 0 0 0 0 0 ! Exits from: I509_grassy_area
 0 0 0 0 0 0 0 0 I506_inside_waterworks 0 0 0 ! Exits from: I510_pump_room
 I441_hill 0 0 0 0 0 0 I507_freshwater_crossing 0 0 0 0 ! Exits from: I511_pine_forest
 0 0 0 0 0 0 0 0 0 0 0 I501_small_clearing ! Exits from: I637_inside_the_cinderblock_
 0 0 0 0 0 0 0 0 I504_weedy_island 0 0 0 ! Exits from: I669_underwater
 0 0 0 0 0 0 0 0 0 0 0 0 ! Exits from: I677_the_crystal_city
;

Class VPH_Class;
Array KOV_representatives --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ValuePropertyHolder_39 0 0 0 0 ValuePropertyHolder_44 0 0 0 ;
VPH_Class ValuePropertyHolder_39
    with value_range 14
    with p59_recurring KOVP_39_P59
    with description KOVP_39_P6
;
! Storage for property p59_recurring of kind SCENE_TY
Array KOVP_39_P59 table 0 0 (true) (false) (true) (false) (false) (false) (false) (false) (false) (false) (false) (false) (false) (true) ;
! Storage for property description of kind SCENE_TY
Array KOVP_39_P6 table 0 0 (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) ;
VPH_Class ValuePropertyHolder_44
    with value_range 315
    with p68_message_text tab_7_1
;
! Storage for property p68_message_text of kind 
Array KOVP_44_P68 table 0 0 (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) (EMPTY_TEXT_VALUE) ;
Class K0_kind 
    has ~pluralname
    has ~proper
    with short_name EMPTY_TEXT_VALUE
    with plural EMPTY_TEXT_VALUE
    with article EMPTY_TEXT_VALUE
;

Class K1_room 
    class K0_kind
    with p114_flooded false
    has ~p77_indoors
    has ~privately_named
    has light
    has ~visited
    with description EMPTY_TEXT_VALUE
    with map_region nothing
    with p112_keyed false
;

Class K2_thing 
    class K0_kind
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with component_parent nothing
    with component_child nothing
    with component_sibling nothing
    with p104_important true
    with p86_soft false
    has ~p79_pocketed
    has ~p81_metal
    has ~p71_ambiguously_plural
    has ~p73_examined
    has p61_stashable
    has neuter
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description EMPTY_TEXT_VALUE
    with initial EMPTY_TEXT_VALUE
    with with_key nothing
    has ~p65_chviable
    with p67_unbolting nothing
;

Class K6_supporter 
    class K2_thing

    	has transparent supporter

    has static
    with capacity 100
    with plural "supporters"
    has ~enterable
;

Class K17_rideable_vehicle 
    class K6_supporter

    	with before [; Go: return 1; ],

    has enterable
    has static
    with plural "rideable vehicles"
;

Class K19_keychain 
    class K6_supporter
    with parse_name Parse_Name_GV173
    has ~static
    with plural "keychains"
;

Class K8_person 
    class K2_thing

    	has transparent animate
    	with before NULL,

    with p108_trapped false
    with p92_irked false
    with p94_curious true
    with p86_soft true
    has ~female
    has ~neuter
    with capacity 100
    with plural "people"
    with p13_last_location I439_steam_train
    with p88_boaty false
    with p17_apology EMPTY_TEXT_VALUE
    with p125_asleep false
;

Class K10_man 
    class K8_person
    has ~female
    has ~neuter
    with plural "men"
;

Class K11_woman 
    class K8_person
    has female
    has ~neuter
    with plural "women"
;

Class K12_animal 
    class K8_person
    with plural "animals"
    with p110_roaming false
;

Class K16_rideable_animal 
    class K12_animal

    	has enterable supporter,
    	with before [; Go: return 1; ],

    has static
    with plural "rideable animals"
;

Class K4_door 
    class K2_thing
     has door, 
    has ~open
    has openable
    has ~lockable
    has ~locked
    has static
    has ~pushable
    has concealed
    with plural "doors"
    with door_to nothing
    with with_key nothing
;

Class K5_container 
    class K2_thing
     has container, 
    has ~p75_accessed
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    with capacity 100
    with plural "containers"
    has ~enterable
    with with_key nothing
;

Class K14_vehicle 
    class K5_container
    has enterable
    has static
    with plural "vehicles"
    has ~p83_moved
;

Class K15_player_s_holdall 
    class K5_container
    has openable
    has ~static
    with plural "player's holdalls"
    has ~p63_chavailable
;

Class K25_fluid_container 
    class K5_container
    with parse_name Parse_Name_GV124
    with p14_fluid_capacity 120
    with p15_current_volume 0
    with plural "fluid containers"
    with p85_liquid I436_clean_water
;

Class K7_backdrop 
    class K2_thing
    has static
    has scenery
    has ~pushable
    with plural "backdrops"
;

Class K26_liquid_source 
    class K7_backdrop
    with parse_name [
        original_wn  ! first word of text parsed
        group_wn  ! first word matched against A/B/C/... disjunction
        try_from_wn  ! position to try matching from
        n  ! number of words matched
        f  ! flag: sufficiently good match found to justify success
        w  ! for use by individual grammar lines
        rv  ! for use by individual grammar lines
        g  ! temporary: success flag for parsing visibles
        ss  ! temporary: saves 'self' in distinguishing visibles
        spn  ! temporary: saves 'parsed_number' in parsing visibles
        pass  ! pass counter (1 to 3)
        pass1_n  ! value of n recorded during pass 1
        pass2_n  ! value of n recorded during pass 2
        ;
        if (parser_trace >= 3) print "Parse_name called^";
        original_wn = wn;
        for (pass = 1: pass <= 3: pass++) {
            wn = original_wn;
            try_from_wn = wn; f = false; n = 0;
            while (true) {
                ! On pass 1 only, advance wn past name property words
    ! (but do not do this for ##TheSame, when wn is undefined)
    if ((parser_action ~= ##TheSame) && (pass == 1)) {
    while (WordInProperty(NextWordStopped(), self, name)) f = true;
    wn--; try_from_wn = wn;
    }
    if (pass == 1 or 2) {
    if (parser_action==##TheSame) {
    if (parser_trace >= 4) print "p1, p2 = ", parser_one, ", ", parser_two, "^";
    ss = self;
    ! Distinguishing property p85_liquid
    if (parser_one.p85_liquid ~= parser_two.p85_liquid) return -2;
    self = ss; return 0;
    }
    ! Match any number of visible property values
    try_from_wn = wn; g = true; while (g) {
    g = false;
    ! Parsing property p85_liquid
    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
    try_from_wn = wn;
    g = true;
    f = true;
    }
    parsed_number = spn;
    }
    ! try_from_wn is now advanced past any visible property values
    wn = try_from_wn;
    }
    if ((parser_action ~= ##TheSame) && (pass == 1)) {
    while (WordInProperty(NextWordStopped(), self, name)) f = true;
    wn--; try_from_wn = wn;
    }
    break;
    } ! End of endless loop
    while (WordInProperty(NextWordStopped(), self, name)) n++;
    if ((f) || (n>0)) n = n + try_from_wn - original_wn;
    if (pass == 1) pass1_n = n;
    if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
    print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
    ],
    with p14_fluid_capacity 32767
    with p15_current_volume 32767
    with plural "liquid sources"
    with p85_liquid I436_clean_water
;

Class K13_device 
    class K2_thing
     has switchable, 
    has ~on
    with plural "devices"
;

Class K22_light_source 
    class K13_device
    with plural "light sources"
;

Class K23_pump 
    class K13_device
    has static
    with plural "pumps"
;

Class K28_gizmo 
    class K13_device
    with parse_name Parse_Name_GV180
    has p81_metal
    with plural "gizmoes"
    with p98_fixed false
;

Class K18_passkey 
    class K2_thing
    with plural "passkeys"
;

Class K20_wheel 
    class K2_thing
    with p116_spinning false
    with plural "wheels"
;

Class K21_pipe 
    class K2_thing
    has p81_metal
    with plural "pipes"
;

Class K24_small_rock 
    class K2_thing
    with parse_name Parse_Name_GV214
    with p104_important false
    with plural "small rocks"
    with description SC_4
;

Class K27_lever 
    class K2_thing
    with p102_flipped_up false
    has p81_metal
    with plural "levers"
    with description text_routine_0
;

Class K29_switch 
    class K2_thing
    with p102_flipped_up false
    with plural "switches"
    with description text_routine_1
;

Class K30_pinecone 
    class K2_thing
    with parse_name Parse_Name_GV199
    with p104_important false
    has concealed
    with plural "pinecones"
    with description SC_5
;

Class K31_flat_paper 
    class K2_thing
    with parse_name Parse_Name_GV209
    with p86_soft true
    with plural "flat papers"
;

Class K9_region 
    class K0_kind
    has ~privately_named
    with plural "regions"
;

Class K3_direction 
    class K0_kind

    	has scenery, ! class CompassDirection,

    has ~privately_named
    has ~workflag
    with plural "directions"
    with p9_opposite I46_north
;

Object I46_north "" Compass
    class K3_direction
    with name 'north' 'n//' 
    with parse_name Parse_Name_GV1
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 0
    with IK3_Link I47_northeast
    with list_together 0
    with vector 0
    with short_name "north"
    with article SC_6
    with p9_opposite I49_south
;

Object I47_northeast "" Compass
    class K3_direction
    with name 'northeast' 'ne' 
    with parse_name Parse_Name_GV2
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 1
    with IK3_Link I48_northwest
    with list_together 0
    with vector 0
    with short_name "northeast"
    with article SC_6
    with p9_opposite I51_southwest
;

Object I48_northwest "" Compass
    class K3_direction
    with name 'northwest' 'nw' 
    with parse_name Parse_Name_GV3
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 2
    with IK3_Link I49_south
    with list_together 0
    with vector 0
    with short_name "northwest"
    with article SC_6
    with p9_opposite I50_southeast
;

Object I49_south "" Compass
    class K3_direction
    with name 'south' 's//' 
    with parse_name Parse_Name_GV4
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 3
    with IK3_Link I50_southeast
    with list_together 0
    with vector 0
    with short_name "south"
    with article SC_6
    with p9_opposite I46_north
;

Object I50_southeast "" Compass
    class K3_direction
    with name 'southeast' 'se' 
    with parse_name Parse_Name_GV5
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 4
    with IK3_Link I51_southwest
    with list_together 0
    with vector 0
    with short_name "southeast"
    with article SC_6
    with p9_opposite I48_northwest
;

Object I51_southwest "" Compass
    class K3_direction
    with name 'southwest' 'sw' 
    with parse_name Parse_Name_GV6
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 5
    with IK3_Link I52_east
    with list_together 0
    with vector 0
    with short_name "southwest"
    with article SC_6
    with p9_opposite I47_northeast
;

Object I52_east "" Compass
    class K3_direction
    with name 'east' 'e//' 
    with parse_name Parse_Name_GV7
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 6
    with IK3_Link I53_west
    with list_together 0
    with vector 0
    with short_name "east"
    with article SC_6
    with p9_opposite I53_west
;

Object I53_west "" Compass
    class K3_direction
    with name 'west' 'w//' 
    with parse_name Parse_Name_GV8
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 7
    with IK3_Link I54_up
    with list_together 0
    with vector 0
    with short_name "west"
    with article SC_6
    with p9_opposite I52_east
;

Object I54_up "" Compass
    class K3_direction
    with name 'up' 'u//' 
    with parse_name Parse_Name_GV9
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 8
    with IK3_Link I55_down
    with list_together 0
    with vector 0
    with short_name "up"
    with article SC_6
    with p9_opposite I55_down
;

Object I55_down "" Compass
    class K3_direction
    with name 'down' 'd//' 
    with parse_name Parse_Name_GV10
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 9
    with IK3_Link in_obj
    with list_together 0
    with vector 0
    with short_name "down"
    with article SC_6
    with p9_opposite I54_up
;

Object in_obj "" Compass
    class K3_direction
    with name 'inside' 'in' 
    with parse_name Parse_Name_GV11
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 10
    with IK3_Link out_obj
    with list_together 0
    with vector 0
    with short_name "inside"
    with article SC_6
    with p9_opposite out_obj
;

Object out_obj "" Compass
    class K3_direction
    with name 'outside' 'out' 
    with parse_name Parse_Name_GV12
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 3
    with IK3_Count 11
    with IK3_Link nothing
    with list_together 0
    with vector 0
    with short_name "outside"
    with article SC_6
    with p9_opposite in_obj
;

Object I92_no_object ""
    class K2_thing
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 1
    with IK2_Link I409_library_message_debug
    with list_together 0
    with cap_short_name "No-object"
    with vector 0
    has proper
    has privately_named
    with short_name "No-object"
;

Object I409_library_message_debug ""
    class K2_thing
    with name 'library' 'message' 'debug' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 2
    with IK2_Link I410_i7_librarymessages
    with list_together 0
    with cap_short_name "Library message debug"
    with vector 0
    has ~p69_dbg_on
    has proper
    with short_name "Library message debug"
;

Object I410_i7_librarymessages ""
    class K2_thing

      with before LibraryMessagesBefore,

    with name 'i7_librarymessages' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 3
    with IK2_Link I418_big_pump
    with list_together 0
    with cap_short_name "I7_LibraryMessages"
    with vector 0
    has proper
    with short_name "I7_LibraryMessages"
;

Object I418_big_pump ""
    class K23_pump
    with name 'big' 'pump' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK23_Count 2
    with IK23_Link I416_complicated_pump
    with KD_Count 23
    with IK13_Count 3
    with IK13_Link I414_flashlight
    has mark_as_thing
    with IK2_Count 7
    with IK2_Link I422_small_blue_light
    with list_together 0
    with vector 0
    with short_name "big pump"
;

Object I422_small_blue_light ""
    class K2_thing
    with name 'small' 'blue' 'light' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I421_small_metal_detector
    with component_sibling I423_small_button
    with IK2_Count 10
    with IK2_Link I423_small_button
    with list_together 0
    with vector 0
    with short_name "small blue light"
    with description text_routine_2
;

Object I423_small_button ""
    class K2_thing
    with name 'small' 'button' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I421_small_metal_detector
    with IK2_Count 11
    with IK2_Link I707_seat
    with list_together 0
    with vector 0
    with short_name "small button"
    with description SC_7
;

Object I439_steam_train ""
    class K1_room
    with name 'steam' 'train' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 0
    with IK1_Link I441_hill
    with list_together 0
    with vector 0
    with room_index -1
    has p77_indoors
    with p16_station I439_steam_train
    with short_name "Steam Train"
    with description text_routine_3
    with map_region I512_trainland
;

Object -> I707_seat ""
    class K6_supporter
    with name 'seat' 'seats' 'corduroy' 'fabric' 
    with parse_name Parse_Name_GV263
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with IK2_Count 232
    with IK2_Link I708_train_window
    with IK6_Count 7
    with IK6_Link I552_bench
    with list_together 0
    with vector 0
    has enterable
    has static
    has scenery
    with short_name "seat"
    with description SC_8
;

Object -> I708_train_window ""
    class K2_thing
    with name 'train' 'window' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 233
    with IK2_Link I709_access_panel
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "train window"
    with description text_routine_4
;

Object -> I709_access_panel ""
    class K5_container
    with name 'access' 'panel' 'handle' 'dent' 
    with parse_name Parse_Name_GV264
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with IK2_Count 234
    with IK2_Link I414_flashlight
    with IK5_Count 18
    with IK5_Link I451_right_pocket
    with list_together 0
    with vector 0
    has ~open
    has openable
    has static
    has scenery
    with short_name "access panel"
    with description text_routine_5
;

Object -> -> I414_flashlight ""
    class K22_light_source
    with name 'flashlight' 'flash' 'light' 'tool' 'tool' 
    with parse_name Parse_Name_GV265
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK22_Link nothing
    with KD_Count 22
    with IK13_Count 0
    with IK13_Link I461_water_fountain
    with IK22_Count 0
    has mark_as_thing
    with IK2_Count 4
    with IK2_Link I636_screwdriver
    with list_together 0
    with vector 0
    with short_name "flashlight"
    with description SC_9
;

Object -> -> I636_screwdriver ""
    class K2_thing
    with name 'screwdriver' 'tool' 'tool' 
    with parse_name Parse_Name_GV267
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 168
    with IK2_Link I710_wrench
    with list_together 0
    with vector 0
    has p81_metal
    with short_name "screwdriver"
    with description SC_10
;

Object -> -> I710_wrench ""
    class K2_thing
    with name 'wrench' 'tool' 'tool' 
    with parse_name Parse_Name_GV266
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 235
    with IK2_Link I711_conductor
    with list_together 0
    with vector 0
    has p81_metal
    with short_name "wrench"
    with description SC_11
;

Object -> I711_conductor ""
    class K10_man
    with name 'conductor' 'eric' 
    with parse_name Parse_Name_GV269
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 10
    with IK10_Count 2
    with IK10_Link I651_father
    has mark_as_thing
    with component_child I715_mustache
    with IK2_Count 236
    with IK2_Link I712_pants
    with IK8_Count 10
    with IK8_Link I443_dog
    with list_together 0
    with vector 0
    with p121_satisfied false
    with short_name "conductor"
    with description text_routine_6
    with p123_distracted false
;

Object -> -> I712_pants ""
    class K2_thing
    with name 'pants' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 237
    with IK2_Link I713_suspenders
    with list_together 0
    with cap_short_name "Pants"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "pants"
    with description SC_12
;

Object -> -> I713_suspenders ""
    class K2_thing
    with name 'suspenders' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 238
    with IK2_Link I714_striped_cap
    with list_together 0
    with cap_short_name "Suspenders"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "suspenders"
    with description SC_13
;

Object -> -> I714_striped_cap ""
    class K2_thing
    with name 'striped' 'cap' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 239
    with IK2_Link I440_sound_of_the_wind_chime
    with list_together 0
    with vector 0
    has worn
    with p86_soft true
    has clothing
    with short_name "striped cap"
    with description SC_14
;

Object I440_sound_of_the_wind_chime ""
    class K7_backdrop
    with name 'sound' 'of' 'the' 'wind' 'chimes' 'tinkling' 'chimes' 'tink' 'notes' 
    with parse_name Parse_Name_GV140
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 12
    with IK2_Link I548_grove_of_pine_trees
    with IK7_Count 0
    with IK7_Link I454_large_rusty_pipe
    with list_together 0
    with vector 0
    with found_in I441_hill I442_in_the_sweetgum_tree 
    with short_name "sound of the wind chimes"
    with description text_routine_7
;

Object I441_hill ""
    class K1_room
    with name 'hill' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 1
    with IK1_Link I442_in_the_sweetgum_tree
    with list_together 0
    with vector 0
    with room_index -1
    with short_name "Hill"
    with description text_routine_8
    with map_region I505_regular_pondside
;

Object -> I548_grove_of_pine_trees ""
    class K2_thing
    with name 'grove' 'of' 'pine' 'trees' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I572_pine_bark
    with IK2_Count 89
    with IK2_Link I549_distant_trees
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "grove of pine trees"
    with description SC_15
;

Object -> I549_distant_trees ""
    class K2_thing
    with name 'distant' 'trees' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 90
    with IK2_Link I550_carpet_of_leaves
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "distant trees"
    with description text_routine_9
;

Object -> I550_carpet_of_leaves ""
    class K2_thing
    with name 'carpet' 'of' 'leaves' 'leaf' 
    with parse_name Parse_Name_GV191
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 91
    with IK2_Link I551_church
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "carpet of leaves"
    with description SC_16
;

Object -> I551_church ""
    class K2_thing
    with name 'church' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 92
    with IK2_Link I552_bench
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "church"
    with description SC_17
;

Object -> I552_bench ""
    class K6_supporter
    with name 'bench' 
    with parse_name Parse_Name_GV192
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with IK2_Count 93
    with IK2_Link I554_visitor_center_building
    with IK6_Count 2
    with IK6_Link I657_brass_metal_pipe
    with list_together 0
    with vector 0
    has enterable
    with short_name "bench"
    with description text_routine_10
;

Object -> I554_visitor_center_building ""
    class K2_thing
    with name 'visitor' 'center' 'building' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 95
    with IK2_Link I563_metal_wind_chimes
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "visitor center building"
    with description SC_18
;

Object I442_in_the_sweetgum_tree ""
    class K1_room
    with name 'in' 'the' 'sweetgum' 'tree' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 2
    with IK1_Link I444_woods
    with list_together 0
    with cap_short_name "In The Sweetgum Tree"
    with vector 0
    with room_index -1
    has proper
    with short_name "In The Sweetgum Tree"
    with description text_routine_11
    with map_region I505_regular_pondside
;

Object -> I563_metal_wind_chimes ""
    class K2_thing
    with name 'metal' 'wind' 'chimes' 'chime' 'windchimes' 
    with parse_name Parse_Name_GV194
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 98
    with IK2_Link I443_dog
    with list_together 0
    with vector 0
    has pluralname
    with short_name "metal wind chimes"
    with description text_routine_12
;

Object I444_woods ""
    class K1_room
    with name 'woods' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 3
    with IK1_Link I447_outside_waterworks
    with list_together 0
    with vector 0
    with room_index -1
    with short_name "Woods"
    with description text_routine_13
    with map_region I500_otherland
;

Object -> I443_dog ""
    class K12_animal
    with name 'dog' 'mutt' 'edda' 
    with parse_name Parse_Name_GV141
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 12
    with IK12_Count 0
    with IK12_Link I588_gull
    has mark_as_thing
    with component_child I445_tail
    with IK2_Count 13
    with IK2_Link I626_mat_of_leaves
    with IK8_Count 1
    with IK8_Link selfobj
    with list_together 0
    with vector 0
    with p110_roaming false
    with short_name "dog"
    with description SC_19
;

Object -> I626_mat_of_leaves ""
    class K2_thing
    with name 'mat' 'of' 'leaves' 'leaf' 
    with parse_name Parse_Name_GV232
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 158
    with IK2_Link I627_small_boulders
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "mat of leaves"
    with description SC_20
;

Object -> I627_small_boulders ""
    class K2_thing
    with name 'small' 'boulders' 
    with parse_name Parse_Name_GV233
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 159
    with IK2_Link I445_tail
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "small boulders"
    with description SC_21
;

Object I445_tail ""
    class K2_thing
    with name 'tail' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I443_dog
    with component_sibling I446_tongue
    with IK2_Count 14
    with IK2_Link I446_tongue
    with list_together 0
    with vector 0
    with short_name "tail"
    with description SC_22
;

Object I446_tongue ""
    class K2_thing
    with name 'tongue' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I443_dog
    with IK2_Count 15
    with IK2_Link selfobj
    with list_together 0
    with vector 0
    with short_name "tongue"
    with description SC_23
;

Object I447_outside_waterworks ""
    class K1_room
    with name 'outside' 'waterworks' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 4
    with IK1_Link I464_grassy_shore
    with list_together 0
    with cap_short_name "Outside Waterworks"
    with vector 0
    with room_index -1
    has proper
    with short_name "Outside Waterworks"
    with description text_routine_14
    with map_region I513_pathland
;

Object -> selfobj ""
    class K8_person

    	with saved_short_name "yourself",
     
    with name 'yourself' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 8
    has mark_as_thing
    with IK2_Count 0
    with IK2_Link I448_page_torn_out_of_a_chil
    with IK8_Count 0
    with IK8_Link I650_family
    with list_together 0
    with cap_short_name "Yourself"
    with vector 0
    with p88_boaty false
    has female
    has proper
    has concealed
    with capacity 4
    with short_name "yourself"
    with description text_routine_15
;

Object -> -> I448_page_torn_out_of_a_chil ""
    class K31_flat_paper
    with name 'page' 'torn' 'out' 'of' 'a//' 'children^s' 'book' 'paper' 
    with parse_name Parse_Name_GV143
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK31_Count 0
    with IK31_Link I585_newspaper
    with KD_Count 31
    has mark_as_thing
    with IK2_Count 16
    with IK2_Link I449_your_tall_rubber_boots
    with list_together 0
    with vector 0
    with short_name "page torn out of a children's book"
    with description text_routine_16
;

Object -> -> I449_your_tall_rubber_boots ""
    class K2_thing
    with name 'my' 'tall' 'rubber' 'boots' 'boot' 
    with parse_name Parse_Name_GV144
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 17
    with IK2_Link I450_your_coat
    with list_together 0
    with cap_short_name "Your tall rubber boots"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "your tall rubber boots"
    with description SC_24
;

Object -> -> I450_your_coat ""
    class K2_thing
    with name 'my' 'coat' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I451_right_pocket
    with IK2_Count 18
    with IK2_Link I453_watch
    with list_together 0
    with cap_short_name "Your coat"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "your coat"
    with description text_routine_17
;

Object -> -> I453_watch ""
    class K2_thing
    with name 'watch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 21
    with IK2_Link I455_waterworks
    with list_together 0
    with vector 0
    has worn
    with p86_soft true
    has clothing
    with short_name "watch"
    with description text_routine_18
;

Object -> I455_waterworks ""
    class K2_thing
    with name 'waterworks' 'building' 
    with parse_name Parse_Name_GV148
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I456_lighted_archway
    with IK2_Count 23
    with IK2_Link I460_path
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "Waterworks"
    with article SC_6
    with description text_routine_19
;

Object -> I460_path ""
    class K2_thing
    with name 'path' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 28
    with IK2_Link I461_water_fountain
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "path"
    with description SC_25
;

Object -> I461_water_fountain ""
    class K13_device
    with name 'water' 'fountain' 
    with parse_name Parse_Name_GV150
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 13
    with IK13_Count 6
    with IK13_Link I416_complicated_pump
    has mark_as_thing
    with IK2_Count 29
    with IK2_Link I451_right_pocket
    with list_together 0
    with vector 0
    has p81_metal
    has static
    has concealed
    with short_name "water fountain"
    with description text_routine_20
;

Object I451_right_pocket ""
    class K15_player_s_holdall
    with name 'right' 'pocket' 'pockets' 
    with parse_name Parse_Name_GV145
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 15
    with IK15_Count 0
    with IK15_Link I452_left_pocket
    has mark_as_thing
    with component_parent I450_your_coat
    with component_sibling I452_left_pocket
    with IK2_Count 19
    with IK2_Link I452_left_pocket
    with IK5_Count 0
    with IK5_Link I452_left_pocket
    with list_together 0
    with vector 0
    with short_name "right pocket"
    with description SC_26
;

Object I452_left_pocket ""
    class K15_player_s_holdall
    with name 'left' 'pocket' 'pockets' 
    with parse_name Parse_Name_GV146
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 15
    with IK15_Count 1
    with IK15_Link nothing
    has mark_as_thing
    with component_parent I450_your_coat
    with IK2_Count 20
    with IK2_Link I454_large_rusty_pipe
    with IK5_Count 1
    with IK5_Link I472_beer_bottle
    with list_together 0
    with vector 0
    with short_name "left pocket"
    with description SC_26
;

Object I454_large_rusty_pipe ""
    class K7_backdrop
    with name 'large' 'rusty' 'pipe' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 22
    with IK2_Link I456_lighted_archway
    with IK7_Count 1
    with IK7_Link I462_running_water
    with list_together 0
    with vector 0
    with found_in I468_muddy_beach I447_outside_waterworks 
    with short_name "large rusty pipe"
    with description text_routine_21
;

Object I456_lighted_archway ""
    class K2_thing
    with name 'lighted' 'archway' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I455_waterworks
    with component_sibling I457_glowing_clock
    with IK2_Count 24
    with IK2_Link I457_glowing_clock
    with list_together 0
    with vector 0
    with short_name "lighted archway"
    with description SC_27
;

Object I457_glowing_clock ""
    class K2_thing
    with name 'glowing' 'clock' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I455_waterworks
    with component_sibling I458_pointed_tower
    with IK2_Count 25
    with IK2_Link I458_pointed_tower
    with list_together 0
    with vector 0
    with short_name "glowing clock"
    with description text_routine_22
;

Object I458_pointed_tower ""
    class K2_thing
    with name 'pointed' 'tower' 
    with parse_name Parse_Name_GV149
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I455_waterworks
    with IK2_Count 26
    with IK2_Link I459_warning_light
    with list_together 0
    with vector 0
    with short_name "pointed tower"
    with description SC_28
;

Object I459_warning_light ""
    class K2_thing
    with name 'warning' 'light' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 27
    with IK2_Link I462_running_water
    with list_together 0
    with vector 0
    with short_name "warning light"
    with description SC_29
;

Object I462_running_water ""
    class K26_liquid_source
    with name 'running' 'water' 'water' 'water' 
    with parse_name Parse_Name_GV119
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK26_Count 0
    with IK26_Link I463_pond
    with KD_Count 26
    has mark_as_thing
    with IK2_Count 30
    with IK2_Link I463_pond
    with IK7_Count 2
    with IK7_Link I463_pond
    with list_together 0
    with vector 0
    with found_in [; rfalse; ],
    has absent
    with p85_liquid I436_clean_water
    has pluralname
    has concealed
    with short_name SC_30
    with description SC_31
;

Object I463_pond ""
    class K26_liquid_source
    with name 'pond' 'waves' 'vista' 'water' 
    with parse_name Parse_Name_GV151
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK26_Count 1
    with IK26_Link I613_small_rusty_pipe
    with KD_Count 26
    has mark_as_thing
    with component_child I467_lumpy_island
    with IK2_Count 31
    with IK2_Link I487_community_center_buildi
    with IK7_Count 3
    with IK7_Link I471_congregation
    with list_together 0
    with vector 0
    with found_in I504_weedy_island I494_other_side_of_the_pond I464_grassy_shore I465_spireland I466_floating_on_the_pond I468_muddy_beach I469_atop_the_tank I470_rocky_beach I474_sandy_beach I439_steam_train I441_hill I442_in_the_sweetgum_tree I447_outside_waterworks 
    with p85_liquid I437_pond_water
    has scenery
    with short_name "pond"
    with description text_routine_23
;

Object I464_grassy_shore ""
    class K1_room
    with name 'grassy' 'shore' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 5
    with IK1_Link I465_spireland
    with list_together 0
    with cap_short_name "Grassy Shore"
    with vector 0
    with room_index -1
    has proper
    with short_name "Grassy Shore"
    with description SC_32
    with map_region I503_waterland
;

Object -> I487_community_center_buildi ""
    class K2_thing
    with name 'community' 'center' 'building' 'church' 
    with parse_name Parse_Name_GV160
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I488_steeple
    with IK2_Count 46
    with IK2_Link I495_real_crystal_spire
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "community center building"
    with description text_routine_24
;

Object I465_spireland ""
    class K1_room
    with name 'spireland' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 6
    with IK1_Link I466_floating_on_the_pond
    with list_together 0
    with vector 0
    with room_index -1
    has proper
    with short_name SC_33
    with description text_routine_25
    with map_region I503_waterland
;

Object -> I495_real_crystal_spire ""
    class K2_thing
    with name 'real' 'crystal' 'spire' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I496_oval_indentations
    with IK2_Count 53
    with IK2_Link I467_lumpy_island
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name SC_34
    with description SC_35
;

Object I466_floating_on_the_pond ""
    class K1_room
    with name 'floating' 'on' 'the' 'pond' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 7
    with IK1_Link I468_muddy_beach
    with list_together 0
    with cap_short_name "Floating on the Pond"
    with vector 0
    with room_index -1
    has proper
    with short_name "Floating on the Pond"
    with description text_routine_26
    with map_region I503_waterland
;

Object I467_lumpy_island ""
    class K2_thing
    with name 'lumpy' 'island' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I463_pond
    with component_sibling I499_buildings
    with IK2_Count 32
    with IK2_Link I472_beer_bottle
    with list_together 0
    with vector 0
    with short_name "lumpy island"
    with description SC_36
;

Object I468_muddy_beach ""
    class K1_room
    with name 'muddy' 'beach' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 8
    with IK1_Link I469_atop_the_tank
    with list_together 0
    with cap_short_name "Muddy Beach"
    with vector 0
    with room_index -1
    has proper
    with short_name "Muddy Beach"
    with description text_routine_27
    with map_region I505_regular_pondside
;

Object -> I472_beer_bottle ""
    class K25_fluid_container
    with name 'beer' 'bottle' 'of' 
    with parse_name Parse_Name_GV152
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK25_Count 0
    with IK25_Link nothing
    with KD_Count 25
    has mark_as_thing
    with IK2_Count 34
    with IK2_Link I475_sticks
    with IK5_Count 2
    with IK5_Link I589_wooden_drawer
    with list_together 0
    with vector 0
    with short_name "beer bottle"
    with description SC_37
;

Object -> I475_sticks ""
    class K2_thing
    with name 'sticks' 
    with parse_name Parse_Name_GV153
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 36
    with IK2_Link I476_wide_stick
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "sticks"
    with description text_routine_28
;

Object -> I476_wide_stick ""
    class K2_thing
    with name 'wide' 'stick' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 37
    with IK2_Link I655_colorful_tip_of_the_dis
    with list_together 0
    with vector 0
    has concealed
    with short_name "wide stick"
    with description SC_38
;

Object I469_atop_the_tank ""
    class K1_room
    with name 'atop' 'the' 'tank' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 9
    with IK1_Link I470_rocky_beach
    with list_together 0
    with cap_short_name "Atop the Tank"
    with vector 0
    with room_index -1
    has proper
    with short_name "Atop the Tank"
    with description text_routine_29
    with map_region I500_otherland
;

Object -> I655_colorful_tip_of_the_dis ""
    class K2_thing
    with name 'colorful' 'tip' 'of' 'the' 'distant' 'sweetgum' 'tree' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 186
    with IK2_Link I656_tank_top
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "colorful tip of the distant sweetgum tree"
    with description text_routine_30
;

Object -> I656_tank_top ""
    class K2_thing
    with name 'tank' 'top' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 187
    with IK2_Link I657_brass_metal_pipe
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "tank top"
    with description SC_39
;

Object -> I657_brass_metal_pipe ""
    class K6_supporter
    with name 'brass' 'metal' 'pipe' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with component_child I662_pipe_holes
    with IK2_Count 188
    with IK2_Link I660_medium_sized_wheel
    with IK6_Count 6
    with IK6_Link I629_large_boulder
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "brass metal pipe"
    with description text_routine_31
;

Object -> -> I660_medium_sized_wheel ""
    class K2_thing
    with name 'medium-sized' 'wheel' 'medium' 
    with parse_name Parse_Name_GV245
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I661_wheel_holes
    with IK2_Count 191
    with IK2_Link I658_weird_lumpy_island
    with list_together 0
    with vector 0
    with short_name "medium-sized wheel"
    with description SC_40
;

Object -> I658_weird_lumpy_island ""
    class K2_thing
    with name 'weird' 'lumpy' 'island' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 189
    with IK2_Link I659_distant_house
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "weird lumpy island"
    with description SC_41
;

Object -> I659_distant_house ""
    class K2_thing
    with name 'distant' 'house' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 190
    with IK2_Link I589_wooden_drawer
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "distant house"
    with description SC_42
;

Object I470_rocky_beach ""
    class K1_room
    with name 'rocky' 'beach' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 10
    with IK1_Link I474_sandy_beach
    with list_together 0
    with cap_short_name "Rocky Beach"
    with vector 0
    with room_index -1
    has proper
    with short_name "Rocky Beach"
    with description text_routine_32
    with map_region I505_regular_pondside
;

Object -> I589_wooden_drawer ""
    class K5_container
    with name 'wooden' 'drawer' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_child I590_drawer_bottom
    with IK2_Count 123
    with IK2_Link I601_rock_selection
    with IK5_Count 10
    with IK5_Link I481_rowboat
    with list_together 0
    with vector 0
    with p106_upside_down false
    has concealed
    with short_name "wooden drawer"
    with description text_routine_33
;

Object -> I601_rock_selection ""
    class K2_thing
    with name 'rock' 'selection' 'shoreline' 'rocks' 'disc' 'discs' 
    with parse_name Parse_Name_GV213
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 134
    with IK2_Link I471_congregation
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name SC_43
    with description SC_44
;

Object I471_congregation ""
    class K7_backdrop
    with name 'congregation' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 33
    with IK2_Link I473_chain_link_fence
    with IK7_Count 4
    with IK7_Link I473_chain_link_fence
    with list_together 0
    with vector 0
    with found_in I469_atop_the_tank I441_hill 
    with short_name "congregation"
    with description SC_45
;

Object I473_chain_link_fence ""
    class K7_backdrop
    with name 'chain-link' 'fence' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 35
    with IK2_Link I602_sand
    with IK7_Count 5
    with IK7_Link I477_structure
    with list_together 0
    with vector 0
    with found_in I468_muddy_beach I470_rocky_beach I474_sandy_beach I447_outside_waterworks 
    has p81_metal
    has concealed
    with short_name "chain-link fence"
    with description SC_46
;

Object I474_sandy_beach ""
    class K1_room
    with name 'sandy' 'beach' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 11
    with IK1_Link I479_boat_house
    with list_together 0
    with cap_short_name "Sandy Beach"
    with vector 0
    with room_index -1
    has proper
    with short_name "Sandy Beach"
    with description text_routine_34
    with map_region I505_regular_pondside
;

Object -> I602_sand ""
    class K2_thing
    with name 'sand' 'grains' 'beach' 
    with parse_name Parse_Name_GV216
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I603_particular_spot
    with IK2_Count 135
    with IK2_Link I477_structure
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "sand"
    with article SC_47
    with description SC_48
;

Object I477_structure ""
    class K7_backdrop
    with name 'structure' 'boat-house' 'spring-house' 'house' 'boathouse' 'springhouse' 
    with parse_name Parse_Name_GV155
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 38
    with IK2_Link I478_puddle_of_water
    with IK7_Count 6
    with IK7_Link I497_sunlight
    with list_together 0
    with vector 0
    with found_in I468_muddy_beach I470_rocky_beach I447_outside_waterworks 
    with short_name "structure"
    with description text_routine_35
;

Object I479_boat_house ""
    class K1_room
    with name 'boat' 'house' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 12
    with IK1_Link I484_pondside_community_cent
    with list_together 0
    with vector 0
    with room_index -1
    has p77_indoors
    has ~light
    with short_name "Boat House"
    with description text_routine_36
    with map_region I503_waterland
;

Object -> I478_puddle_of_water ""
    class K2_thing
    with name 'puddle' 'of' 'water' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 39
    with IK2_Link I481_rowboat
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "puddle of water"
    with description SC_49
;

Object -> I481_rowboat ""
    class K14_vehicle
    with name 'rowboat' 
    with parse_name Parse_Name_GV157
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 14
    with IK14_Count 0
    with IK14_Link nothing
    has mark_as_thing
    with IK2_Count 41
    with IK2_Link I480_door_to_the_structure
    with IK5_Count 3
    with IK5_Link I489_large_painted_mural
    with list_together 0
    with vector 0
    with short_name "rowboat"
    with description SC_50
;

Object I480_door_to_the_structure ""
    class K4_door
    with name 'door' 'to' 'the' 'structure' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 4
    has mark_as_thing
    with component_child I705_structure_lock
    with IK2_Count 40
    with IK2_Link I482_waterstained_door
    with IK4_Count 0
    with IK4_Link I482_waterstained_door
    with list_together 0
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I479_boat_house) return I52_east; return I53_west; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I479_boat_house) return I470_rocky_beach; return I479_boat_house; ],
    with found_in I479_boat_house I470_rocky_beach
    has lockable
    has locked
    with with_key I640_old_key
    with short_name "door to the structure"
    with description SC_51
;

Object I482_waterstained_door ""
    class K4_door
    with name 'waterstained' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 4
    has mark_as_thing
    with IK2_Count 42
    with IK2_Link I483_community_center_door
    with IK4_Count 1
    with IK4_Link I483_community_center_door
    with list_together 0
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I466_floating_on_the_pond) return I52_east; return I53_west; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I466_floating_on_the_pond) return I479_boat_house; return I466_floating_on_the_pond; ],
    with found_in I466_floating_on_the_pond I479_boat_house
    has ~open
    has openable
    with short_name "waterstained door"
    with description SC_52
;

Object I483_community_center_door ""
    class K4_door
    with name 'community' 'center' 'door' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 4
    has mark_as_thing
    with component_child I706_center_lock
    with IK2_Count 43
    with IK2_Link I489_large_painted_mural
    with IK4_Count 2
    with IK4_Link I516_door_to_the_waterworks
    with list_together 0
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I484_pondside_community_cent) return I49_south; return I46_north; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I484_pondside_community_cent) return I464_grassy_shore; return I484_pondside_community_cent; ],
    with found_in I484_pondside_community_cent I464_grassy_shore
    has ~open
    has lockable
    has locked
    with with_key I485_brass_key
    with short_name "community center door"
    with description SC_53
;

Object I484_pondside_community_cent ""
    class K1_room
    with name 'pondside' 'community' 'center' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 13
    with IK1_Link I494_other_side_of_the_pond
    with list_together 0
    with cap_short_name "Pondside Community Center"
    with vector 0
    with room_index -1
    has p77_indoors
    has proper
    with short_name "Pondside Community Center"
    with description text_routine_37
    with map_region I500_otherland
;

Object -> I489_large_painted_mural ""
    class K5_container
    with name 'large' 'painted' 'mural' 'wall' 'painting' 
    with parse_name Parse_Name_GV161
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_child I491_peeling_paint
    with IK2_Count 48
    with IK2_Link I490_flagpole
    with IK5_Count 4
    with IK5_Link I635_metal_plate
    with list_together 0
    with vector 0
    with p90_peeled false
    has static
    has scenery
    with short_name "large painted mural"
    with description text_routine_38
;

Object -> -> I490_flagpole ""
    class K2_thing
    with name 'flagpole' 'pole' 
    with parse_name Parse_Name_GV164
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I492_flag
    with IK2_Count 49
    with IK2_Link I493_hardwood_floor
    with list_together 0
    with vector 0
    has concealed
    with short_name "flagpole"
    with description SC_54
;

Object -> I493_hardwood_floor ""
    class K2_thing
    with name 'hardwood' 'floor' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 52
    with IK2_Link I488_steeple
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "hardwood floor"
    with description SC_55
;

Object I488_steeple ""
    class K2_thing
    with name 'steeple' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I487_community_center_buildi
    with IK2_Count 47
    with IK2_Link I491_peeling_paint
    with list_together 0
    with vector 0
    with short_name "steeple"
    with description SC_56
;

Object I491_peeling_paint ""
    class K2_thing
    with name 'peeling' 'paint' 'paint' 
    with parse_name Parse_Name_GV163
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I489_large_painted_mural
    with IK2_Count 50
    with IK2_Link I492_flag
    with list_together 0
    with vector 0
    with short_name "peeling paint"
    with description SC_57
;

Object I492_flag ""
    class K2_thing
    with name 'flag' 
    with parse_name Parse_Name_GV167
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I490_flagpole
    with IK2_Count 51
    with IK2_Link I623_stone_steps
    with list_together 0
    with vector 0
    with short_name "flag"
    with description SC_58
;

Object I494_other_side_of_the_pond ""
    class K1_room
    with name 'other' 'side' 'of' 'the' 'pond' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 14
    with IK1_Link I501_small_clearing
    with list_together 0
    with cap_short_name "Other Side of the Pond"
    with vector 0
    with room_index -1
    has proper
    with short_name "Other Side of the Pond"
    with description text_routine_39
    with map_region I500_otherland
;

Object -> I623_stone_steps ""
    class K2_thing
    with name 'stone' 'steps' 
    with parse_name Parse_Name_GV229
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 155
    with IK2_Link I496_oval_indentations
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "stone steps"
    with description text_routine_40
;

Object I496_oval_indentations ""
    class K2_thing
    with name 'oval' 'indentations' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I495_real_crystal_spire
    with IK2_Count 54
    with IK2_Link I497_sunlight
    with list_together 0
    with vector 0
    with short_name "oval indentations"
    with description SC_59
;

Object I497_sunlight ""
    class K7_backdrop
    with name 'sunlight' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 55
    with IK2_Link I498_pondy_crystal_spire
    with IK7_Count 7
    with IK7_Link I613_small_rusty_pipe
    with list_together 0
    with vector 0
    with found_in FoundEverywhere
    has pluralname
    with short_name "sunlight"
    with description text_routine_41
;

Object I498_pondy_crystal_spire ""
    class K2_thing
    with name 'pondy' 'crystal' 'spire' 
    with parse_name Parse_Name_GV227
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 56
    with IK2_Link I499_buildings
    with list_together 0
    with vector 0
    with short_name SC_34
    with description text_routine_42
;

Object I499_buildings ""
    class K2_thing
    with name 'buildings' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I463_pond
    with IK2_Count 57
    with IK2_Link I629_large_boulder
    with list_together 0
    with vector 0
    has pluralname
    with short_name "buildings"
    with description SC_60
;

Object I500_otherland ""
    class K9_region
    with name 'otherland' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 9
    with IK9_Link I503_waterland
    with regional_found_in [; if (TestRegionalContainment(location, I500_otherland)) rtrue; rfalse; ],
    with IK9_Count 0
    with list_together 0
    with cap_short_name "Otherland"
    with vector 0
    has proper
    with short_name "Otherland"
;

Object I501_small_clearing ""
    class K1_room
    with name 'small' 'clearing' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 15
    with IK1_Link I502_large_clearing
    with list_together 0
    with cap_short_name "Small Clearing"
    with vector 0
    with room_index -1
    has proper
    with short_name "Small Clearing"
    with description text_routine_43
    with map_region I500_otherland
;

Object -> I629_large_boulder ""
    class K6_supporter
    with name 'large' 'boulder' 'lump' 'granite' 
    with parse_name Parse_Name_GV236
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with IK2_Count 161
    with IK2_Link I633_graffiti
    with IK6_Count 5
    with IK6_Link I518_desk
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "large boulder"
    with description text_routine_44
;

Object -> -> I633_graffiti ""
    class K2_thing
    with name 'graffiti' 'paint' 'splash' 'image' 
    with parse_name Parse_Name_GV237
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 165
    with IK2_Link I635_metal_plate
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "graffiti"
    with description text_routine_45
;

Object -> -> I635_metal_plate ""
    class K5_container
    with name 'metal' 'plate' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with IK2_Count 167
    with IK2_Link I644_keypad
    with IK5_Count 13
    with IK5_Link I667_emergency_supplies_box
    with list_together 0
    with vector 0
    has p81_metal
    has ~open
    has openable
    has lockable
    has locked
    has static
    has scenery
    with with_key I636_screwdriver
    with short_name "metal plate"
    with description text_routine_46
;

Object -> -> -> I644_keypad ""
    class K2_thing
    with name 'keypad' 'buttons' 'pad' 
    with parse_name Parse_Name_GV242
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 175
    with IK2_Link I630_cinderblock_hut
    with list_together 0
    with vector 0
    has static
    with short_name "keypad"
    with description SC_61
;

Object -> I630_cinderblock_hut ""
    class K2_thing
    with name 'cinderblock' 'hut' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I631_smooth_metal_door
    with IK2_Count 162
    with IK2_Link I634_moss
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "cinderblock hut"
    with description text_routine_47
;

Object -> I634_moss ""
    class K2_thing
    with name 'moss' 'carpet' 
    with parse_name Parse_Name_GV238
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 166
    with IK2_Link I647_lush_grass
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "moss"
    with description SC_62
;

Object I502_large_clearing ""
    class K1_room
    with name 'large' 'clearing' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 16
    with IK1_Link I504_weedy_island
    with list_together 0
    with cap_short_name "Large Clearing"
    with vector 0
    with room_index -1
    has proper
    with short_name "Large Clearing"
    with description text_routine_48
    with map_region I500_otherland
;

Object -> I647_lush_grass ""
    class K2_thing
    with name 'lush' 'grass' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 178
    with IK2_Link I648_suburban_house
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "lush grass"
    with description SC_63
;

Object -> I648_suburban_house ""
    class K2_thing
    with name 'suburban' 'house' 'house' 'window' 
    with parse_name Parse_Name_GV244
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I649_game
    with IK2_Count 179
    with IK2_Link I650_family
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "suburban house"
    with description text_routine_49
;

Object -> I650_family ""
    class K8_person
    with name 'family' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 8
    has mark_as_thing
    with IK2_Count 181
    with IK2_Link I651_father
    with IK8_Count 4
    with IK8_Link I651_father
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "family"
    with description SC_64
;

Object -> I651_father ""
    class K10_man
    with name 'father' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 10
    with IK10_Count 0
    with IK10_Link I688_douglas
    has mark_as_thing
    with IK2_Count 182
    with IK2_Link I652_daughter
    with IK8_Count 5
    with IK8_Link I652_daughter
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "father"
    with description SC_65
;

Object -> I652_daughter ""
    class K11_woman
    with name 'daughter' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 11
    with IK11_Count 1
    with IK11_Link I545_secretary_of_water
    has mark_as_thing
    with IK2_Count 183
    with IK2_Link I653_large_tank
    with IK8_Count 6
    with IK8_Link I545_secretary_of_water
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "daughter"
    with description SC_66
;

Object -> I653_large_tank ""
    class K2_thing
    with name 'large' 'tank' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I654_rungs
    with IK2_Count 184
    with IK2_Link I663_marsh_grasses
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "large tank"
    with description SC_67
;

Object I503_waterland ""
    class K9_region
    with name 'waterland' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 9
    with IK9_Link I505_regular_pondside
    with regional_found_in [; if (TestRegionalContainment(location, I503_waterland)) rtrue; rfalse; ],
    with IK9_Count 1
    with list_together 0
    with cap_short_name "Waterland"
    with vector 0
    has proper
    with short_name "Waterland"
;

Object I504_weedy_island ""
    class K1_room
    with name 'weedy' 'island' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 17
    with IK1_Link I506_inside_waterworks
    with list_together 0
    with cap_short_name "Weedy Island"
    with vector 0
    with room_index -1
    has proper
    with short_name "Weedy Island"
    with description SC_68
    with map_region I503_waterland
;

Object -> I663_marsh_grasses ""
    class K2_thing
    with name 'marsh' 'grasses' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 194
    with IK2_Link I664_seaweed
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "marsh grasses"
    with description SC_69
;

Object -> I664_seaweed ""
    class K2_thing
    with name 'seaweed' 'weed' 
    with parse_name Parse_Name_GV247
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 195
    with IK2_Link I665_lumps
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "seaweed"
    with description SC_70
;

Object -> I665_lumps ""
    class K2_thing
    with name 'lumps' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 196
    with IK2_Link I667_emergency_supplies_box
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "lumps"
    with description SC_71
;

Object -> I667_emergency_supplies_box ""
    class K5_container
    with name 'emergency' 'supplies' 'box' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with IK2_Count 198
    with IK2_Link I666_diving_mask
    with IK5_Count 16
    with IK5_Link I522_tall_cylinder
    with list_together 0
    with vector 0
    has transparent
    has ~open
    has openable
    with short_name "emergency supplies box"
    with description SC_72
;

Object -> -> I666_diving_mask ""
    class K2_thing
    with name 'diving' 'mask' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I668_tank_of_air
    with IK2_Count 197
    with IK2_Link I518_desk
    with list_together 0
    with vector 0
    with p86_soft true
    has clothing
    with short_name "diving mask"
    with description SC_73
;

Object I505_regular_pondside ""
    class K9_region
    with name 'regular' 'pondside' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 9
    with IK9_Link I513_pathland
    with regional_found_in [; if (TestRegionalContainment(location, I505_regular_pondside)) rtrue; rfalse; ],
    with IK9_Count 2
    with list_together 0
    with cap_short_name "Regular Pondside"
    with vector 0
    has proper
    with short_name "Regular Pondside"
;

Object -> I513_pathland ""
    class K9_region
    with name 'pathland' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 9
    with IK9_Link I512_trainland
    with regional_found_in [; if (TestRegionalContainment(location, I513_pathland)) rtrue; rfalse; ],
    with IK9_Count 4
    with list_together 0
    with cap_short_name "Pathland"
    with vector 0
    has proper
    with short_name "Pathland"
;

Object I506_inside_waterworks ""
    class K1_room
    with name 'inside' 'waterworks' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 18
    with IK1_Link I507_freshwater_crossing
    with list_together 0
    with cap_short_name "Inside Waterworks"
    with vector 0
    with room_index -1
    has p77_indoors
    has proper
    with short_name "Inside Waterworks"
    with description text_routine_50
    with map_region I505_regular_pondside
;

Object -> I518_desk ""
    class K6_supporter
    with name 'desk' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with component_child I517_nameplate
    with IK2_Count 62
    with IK2_Link I519_metal_girder
    with IK6_Count 1
    with IK6_Link I486_red_foam_keychain
    with list_together 0
    with vector 0
    has p81_metal
    has static
    has scenery
    with short_name "desk"
    with description SC_74
;

Object -> I519_metal_girder ""
    class K2_thing
    with name 'metal' 'girder' 'girders' 
    with parse_name Parse_Name_GV171
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 63
    with IK2_Link I520_brick
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "metal girder"
    with description SC_75
;

Object -> I520_brick ""
    class K2_thing
    with name 'brick' 'walls' 
    with parse_name Parse_Name_GV170
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 64
    with IK2_Link I522_tall_cylinder
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "brick"
    with description SC_76
;

Object -> I522_tall_cylinder ""
    class K5_container
    with name 'tall' 'cylinder' 
    with parse_name Parse_Name_GV172
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with IK2_Count 66
    with IK2_Link I486_red_foam_keychain
    with IK5_Count 6
    with IK5_Link I580_vending_machine
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "tall cylinder"
    with description text_routine_51
;

Object -> -> I486_red_foam_keychain ""
    class K19_keychain
    with name 'red' 'foam' 'keychain' 'red' 'keys' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 19
    with IK19_Count 0
    with IK19_Link nothing
    has mark_as_thing
    with IK2_Count 45
    with IK2_Link I485_brass_key
    with IK6_Count 0
    with IK6_Link I582_shelf
    with list_together 0
    with vector 0
    has concealed
    with short_name "red foam keychain"
    with description SC_77
;

Object -> -> -> I485_brass_key ""
    class K18_passkey
    with name 'brass' 'key' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 18
    with IK18_Count 0
    with IK18_Link I537_small_shiny_key
    has mark_as_thing
    with IK2_Count 44
    with IK2_Link I545_secretary_of_water
    with list_together 0
    with vector 0
    with short_name "brass key"
    with description SC_78
;

Object -> I545_secretary_of_water ""
    class K11_woman
    with name 'secretary' 'of' 'water' 'woman' 'adriana' 
    with parse_name Parse_Name_GV175
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 11
    with IK11_Count 0
    with IK11_Link I671_vivian
    has mark_as_thing
    with component_child I547_hair
    with IK2_Count 86
    with IK2_Link I543_notebook
    with IK8_Count 2
    with IK8_Link I588_gull
    with list_together 0
    with vector 0
    has concealed
    with short_name "Secretary of Water"
    with description text_routine_52
;

Object -> -> I543_notebook ""
    class K2_thing
    with name 'notebook' 
    with parse_name Parse_Name_GV187
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I544_notes
    with IK2_Count 84
    with IK2_Link I546_flowy_dress
    with list_together 0
    with vector 0
    has concealed
    with short_name "notebook"
    with description text_routine_53
;

Object -> -> I546_flowy_dress ""
    class K2_thing
    with name 'flowy' 'dress' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 87
    with IK2_Link I606_birch_trees
    with list_together 0
    with vector 0
    has worn
    with p86_soft true
    has clothing
    has concealed
    with short_name "flowy dress"
    with description SC_79
;

Object I507_freshwater_crossing ""
    class K1_room
    with name 'freshwater' 'crossing' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 19
    with IK1_Link I508_visitor_center
    with list_together 0
    with cap_short_name "Freshwater Crossing"
    with vector 0
    with room_index -1
    has proper
    with short_name "Freshwater Crossing"
    with description text_routine_54
    with map_region I505_regular_pondside
;

Object -> I606_birch_trees ""
    class K2_thing
    with name 'birch' 'trees' 'tree' 
    with parse_name Parse_Name_GV217
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I605_sign
    with IK2_Count 139
    with IK2_Link I577_slabs_of_wood
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "birch trees"
    with description SC_80
;

Object I508_visitor_center ""
    class K1_room
    with name 'visitor' 'center' 
    with parse_name Parse_Name_GV190
    with KD_Count 1
    has mark_as_room
    with IK1_Count 20
    with IK1_Link I509_grassy_area
    with list_together 0
    with vector 0
    with room_index -1
    has p77_indoors
    with short_name "Visitor Center"
    with description SC_81
    with map_region I505_regular_pondside
;

Object -> I577_slabs_of_wood ""
    class K2_thing
    with name 'slabs' 'of' 'wood' 'panels' 
    with parse_name Parse_Name_GV203
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 111
    with IK2_Link I578_window
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "slabs of wood"
    with description SC_82
;

Object -> I578_window ""
    class K2_thing
    with name 'window' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 112
    with IK2_Link I580_vending_machine
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "window"
    with description text_routine_55
;

Object -> I580_vending_machine ""
    class K5_container
    with name 'vending' 'machine' 'plexiglass' 'door' 
    with parse_name Parse_Name_GV205
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_child I581_slot
    with IK2_Count 114
    with IK2_Link I584_ticket
    with IK5_Count 8
    with IK5_Link I521_metal_drawer
    with list_together 0
    with vector 0
    has p81_metal
    has transparent
    has ~open
    has openable
    has lockable
    has locked
    has static
    has scenery
    with short_name "vending machine"
    with description text_routine_56
;

Object -> -> I584_ticket ""
    class K2_thing
    with name 'ticket' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 118
    with IK2_Link I585_newspaper
    with list_together 0
    with vector 0
    with short_name "ticket"
    with description SC_83
;

Object -> -> I585_newspaper ""
    class K31_flat_paper
    with name 'newspaper' 'ads' 'paper' 
    with parse_name Parse_Name_GV206
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK31_Count 3
    with IK31_Link I579_pamphlet
    with KD_Count 31
    has mark_as_thing
    with component_child I586_honor_roll
    with IK2_Count 119
    with IK2_Link I582_shelf
    with list_together 0
    with vector 0
    with short_name "newspaper"
    with description text_routine_57
;

Object -> I582_shelf ""
    class K6_supporter
    with name 'shelf' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with IK2_Count 116
    with IK2_Link I579_pamphlet
    with IK6_Count 3
    with IK6_Link I590_drawer_bottom
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "shelf"
    with description SC_84
;

Object -> -> I579_pamphlet ""
    class K31_flat_paper
    with name 'pamphlet' 'paper' 
    with parse_name Parse_Name_GV204
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK31_Count 1
    with IK31_Link I583_train_schedule
    with KD_Count 31
    has mark_as_thing
    with IK2_Count 113
    with IK2_Link I583_train_schedule
    with list_together 0
    with vector 0
    with short_name "pamphlet"
    with description SC_85
;

Object -> -> I583_train_schedule ""
    class K31_flat_paper
    with name 'train' 'schedule' 'paper' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK31_Count 2
    with IK31_Link I592_engineer_s_blueprint
    with KD_Count 31
    has mark_as_thing
    with IK2_Count 117
    with IK2_Link I613_small_rusty_pipe
    with list_together 0
    with vector 0
    with short_name "train schedule"
    with description SC_86
;

Object I509_grassy_area ""
    class K1_room
    with name 'grassy' 'area' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 21
    with IK1_Link I510_pump_room
    with list_together 0
    with cap_short_name "Grassy Area"
    with vector 0
    with room_index -1
    has proper
    with short_name "Grassy Area"
    with description text_routine_58
    with map_region I505_regular_pondside
;

Object -> I613_small_rusty_pipe ""
    class K26_liquid_source
    with name 'small' 'rusty' 'pipe' 'pipes' 
    with parse_name Parse_Name_GV222
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK26_Count 3
    with IK26_Link I614_metal_pipe
    with KD_Count 26
    has mark_as_thing
    with IK2_Count 145
    with IK2_Link I614_metal_pipe
    with IK7_Count 16
    with IK7_Link I614_metal_pipe
    with list_together 0
    with vector 0
    with found_in I509_grassy_area 
    with p85_liquid I437_pond_water
    has scenery
    with short_name "small rusty pipe"
    with description text_routine_59
;

Object -> I614_metal_pipe ""
    class K26_liquid_source
    with name 'metal' 'pipe' 'pipes' 
    with parse_name Parse_Name_GV223
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK26_Count 4
    with IK26_Link I523_bubbling_water
    with KD_Count 26
    has mark_as_thing
    with IK2_Count 146
    with IK2_Link I615_distant_forest
    with IK7_Count 17
    with IK7_Link I514_moon
    with list_together 0
    with vector 0
    with found_in I509_grassy_area 
    with p85_liquid I437_pond_water
    has scenery
    with short_name "metal pipe"
    with article SC_6
    with description text_routine_60
;

Object -> I615_distant_forest ""
    class K2_thing
    with name 'distant' 'forest' 'trees' 
    with parse_name Parse_Name_GV224
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 147
    with IK2_Link I616_ark
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "distant forest"
    with description SC_87
;

Object -> I616_ark ""
    class K2_thing
    with name 'ark' 
    with parse_name Parse_Name_GV225
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I617_masts
    with IK2_Count 148
    with IK2_Link I621_grasses
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name SC_88
    with description SC_89
;

Object -> I621_grasses ""
    class K2_thing
    with name 'grasses' 'grass' 
    with parse_name Parse_Name_GV226
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 153
    with IK2_Link I622_mud
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "grasses"
    with description SC_90
;

Object -> I622_mud ""
    class K2_thing
    with name 'mud' 'marsh' 
    with parse_name Parse_Name_GV189
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 154
    with IK2_Link I416_complicated_pump
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "mud"
    with description SC_91
;

Object I510_pump_room ""
    class K1_room
    with name 'pump' 'room' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 22
    with IK1_Link I511_pine_forest
    with list_together 0
    with cap_short_name "Pump Room"
    with vector 0
    with room_index -1
    has p77_indoors
    has proper
    with short_name "Pump Room"
    with description text_routine_61
    with map_region I505_regular_pondside
;

Object -> I416_complicated_pump ""
    class K23_pump
    with name 'complicated' 'pump' 'device' 
    with parse_name Parse_Name_GV179
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK23_Count 0
    with IK23_Link I417_underground_pump
    with KD_Count 23
    with IK13_Count 1
    with IK13_Link I421_small_metal_detector
    has mark_as_thing
    with component_child I524_nest_of_wires
    with IK2_Count 5
    with IK2_Link X566
    with list_together 0
    with vector 0
    has concealed
    with short_name "complicated pump"
    with description SC_92
;

Object I511_pine_forest ""
    class K1_room
    with name 'pine' 'forest' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 23
    with IK1_Link I637_inside_the_cinderblock_
    with list_together 0
    with cap_short_name "Pine Forest"
    with vector 0
    with room_index -1
    has proper
    with short_name "Pine Forest"
    with description text_routine_62
    with map_region I505_regular_pondside
;

Object -> X566 ""
    class K30_pinecone
    with name 'pinecone' 'pinecones//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK30_Count 0
    with IK30_Link X567
    with KD_Count 30
    has mark_as_thing
    with IK2_Count 100
    with IK2_Link X567
    with list_together 0
    with vector 0
    with short_name "pinecone"
;

Object -> X567 ""
    class K30_pinecone
    with name 'pinecone' 'pinecones//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK30_Count 1
    with IK30_Link X568
    with KD_Count 30
    has mark_as_thing
    with IK2_Count 101
    with IK2_Link X568
    with list_together 0
    with vector 0
    with short_name "pinecone"
;

Object -> X568 ""
    class K30_pinecone
    with name 'pinecone' 'pinecones//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK30_Count 2
    with IK30_Link X569
    with KD_Count 30
    has mark_as_thing
    with IK2_Count 102
    with IK2_Link X569
    with list_together 0
    with vector 0
    with short_name "pinecone"
;

Object -> X569 ""
    class K30_pinecone
    with name 'pinecone' 'pinecones//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK30_Count 3
    with IK30_Link X570
    with KD_Count 30
    has mark_as_thing
    with IK2_Count 103
    with IK2_Link X570
    with list_together 0
    with vector 0
    with short_name "pinecone"
;

Object -> X570 ""
    class K30_pinecone
    with name 'pinecone' 'pinecones//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK30_Count 4
    with IK30_Link X571
    with KD_Count 30
    has mark_as_thing
    with IK2_Count 104
    with IK2_Link X571
    with list_together 0
    with vector 0
    with short_name "pinecone"
;

Object -> X571 ""
    class K30_pinecone
    with name 'pinecone' 'pinecones//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK30_Count 5
    with IK30_Link nothing
    with KD_Count 30
    has mark_as_thing
    with IK2_Count 105
    with IK2_Link I573_pine_needles
    with list_together 0
    with vector 0
    with short_name "pinecone"
;

Object -> I573_pine_needles ""
    class K2_thing
    with name 'pine' 'needles' 'carpet' 
    with parse_name Parse_Name_GV201
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 107
    with IK2_Link I574_tall_pine_trees
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "pine needles"
    with description SC_93
;

Object -> I574_tall_pine_trees ""
    class K2_thing
    with name 'tall' 'pine' 'trees' 'forest' 'grove' 'tree' 
    with parse_name Parse_Name_GV200
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I575_pine_sap
    with IK2_Count 108
    with IK2_Link I514_moon
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "tall pine trees"
    with description SC_94
;

Object I512_trainland ""
    class K9_region
    with name 'trainland' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 9
    with IK9_Link I676_underwaterland
    with regional_found_in [; if (TestRegionalContainment(location, I512_trainland)) rtrue; rfalse; ],
    with IK9_Count 3
    with list_together 0
    with cap_short_name "Trainland"
    with vector 0
    has proper
    with short_name "Trainland"
;

Object I514_moon ""
    class K7_backdrop
    with name 'moon' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 58
    with IK2_Link I515_sky
    with IK7_Count 8
    with IK7_Link I515_sky
    with list_together 0
    with vector 0
    with found_in FoundEverywhere
    with short_name "moon"
    with description SC_95
;

Object I515_sky ""
    class K7_backdrop
    with name 'sky' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 59
    with IK2_Link I516_door_to_the_waterworks
    with IK7_Count 9
    with IK7_Link I523_bubbling_water
    with list_together 0
    with vector 0
    with found_in FoundEverywhere
    with short_name "sky"
    with description text_routine_63
;

Object I516_door_to_the_waterworks ""
    class K4_door
    with name 'door' 'to' 'the' 'waterworks' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 4
    has mark_as_thing
    with IK2_Count 60
    with IK2_Link I517_nameplate
    with IK4_Count 3
    with IK4_Link nothing
    with list_together 0
    with vector 0
    with door_dir [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I447_outside_waterworks) return I52_east; return I53_west; ],
    with door_to [ loc; loc = location;
            if (loc == thedark) loc = real_location;
            if (loc == I447_outside_waterworks) return I506_inside_waterworks; return I447_outside_waterworks; ],
    with found_in I447_outside_waterworks I506_inside_waterworks
    has concealed
    with short_name "door to the Waterworks"
    with article SC_6
    with description SC_96
;

Object I517_nameplate ""
    class K2_thing
    with name 'nameplate' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I518_desk
    with component_sibling I521_metal_drawer
    with IK2_Count 61
    with IK2_Link I521_metal_drawer
    with list_together 0
    with vector 0
    with short_name "nameplate"
    with description SC_97
;

Object I521_metal_drawer ""
    class K5_container
    with name 'metal' 'drawer' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I518_desk
    with IK2_Count 65
    with IK2_Link I421_small_metal_detector
    with IK5_Count 5
    with IK5_Link I536_keyhole_on_the_security
    with list_together 0
    with vector 0
    has ~open
    has openable
    with short_name "metal drawer"
    with description SC_98
;

Object -> I421_small_metal_detector ""
    class K13_device
    with name 'small' 'metal' 'detector' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 13
    with IK13_Count 5
    with IK13_Link I531_triangular_gizmo
    has mark_as_thing
    with component_child I422_small_blue_light
    with IK2_Count 9
    with IK2_Link I537_small_shiny_key
    with list_together 0
    with vector 0
    with short_name "small metal detector"
    with description text_routine_64
;

Object -> I537_small_shiny_key ""
    class K18_passkey
    with name 'small' 'shiny' 'key' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 18
    with IK18_Count 1
    with IK18_Link I640_old_key
    has mark_as_thing
    with IK2_Count 79
    with IK2_Link I523_bubbling_water
    with list_together 0
    with vector 0
    with short_name "small shiny key"
    with description SC_99
;

Object I523_bubbling_water ""
    class K26_liquid_source
    with name 'bubbling' 'water' 'bubbles' 
    with parse_name Parse_Name_GV174
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK26_Count 2
    with IK26_Link nothing
    with KD_Count 26
    has mark_as_thing
    with IK2_Count 67
    with IK2_Link I524_nest_of_wires
    with IK7_Count 10
    with IK7_Link I527_spiral_staircase
    with list_together 0
    with vector 0
    with found_in I522_tall_cylinder 
    has pluralname
    has concealed
    with short_name "bubbling water"
;

Object I524_nest_of_wires ""
    class K2_thing
    with name 'nest' 'of' 'wires' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_sibling I525_nest_of_hoses
    with IK2_Count 68
    with IK2_Link I525_nest_of_hoses
    with list_together 0
    with vector 0
    with short_name "nest of wires"
    with description SC_100
;

Object I525_nest_of_hoses ""
    class K2_thing
    with name 'nest' 'of' 'hoses' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_child I526_leaky_hose
    with component_sibling I531_triangular_gizmo
    with IK2_Count 69
    with IK2_Link I526_leaky_hose
    with list_together 0
    with vector 0
    with short_name "nest of hoses"
    with description SC_101
;

Object I526_leaky_hose ""
    class K2_thing
    with name 'leaky' 'hose' 'hole' 
    with parse_name Parse_Name_GV176
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I525_nest_of_hoses
    with IK2_Count 70
    with IK2_Link I527_spiral_staircase
    with list_together 0
    with vector 0
    with p96_plugged false
    with short_name "leaky hose"
    with description text_routine_65
;

Object I527_spiral_staircase ""
    class K7_backdrop
    with name 'spiral' 'staircase' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with component_child I528_railing
    with IK2_Count 71
    with IK2_Link I528_railing
    with IK7_Count 11
    with IK7_Link I553_twisty_stairs
    with list_together 0
    with vector 0
    with found_in I506_inside_waterworks I510_pump_room 
    has p81_metal
    with short_name "spiral staircase"
    with description SC_102
;

Object I528_railing ""
    class K2_thing
    with name 'railing' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I527_spiral_staircase
    with IK2_Count 72
    with IK2_Link I531_triangular_gizmo
    with list_together 0
    with vector 0
    with short_name "railing"
    with description SC_103
;

Object I531_triangular_gizmo ""
    class K28_gizmo
    with name 'triangular' 'gizmo' 'gizmos' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK28_Count 0
    with IK28_Link I532_square_gizmo
    with KD_Count 28
    with IK13_Count 7
    with IK13_Link I532_square_gizmo
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_sibling I532_square_gizmo
    with IK2_Count 73
    with IK2_Link I532_square_gizmo
    with list_together 0
    with vector 0
    with p98_fixed true
    with short_name "triangular gizmo"
    with description SC_104
;

Object I532_square_gizmo ""
    class K28_gizmo
    with name 'square' 'gizmo' 'gizmos' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK28_Count 1
    with IK28_Link nothing
    with KD_Count 28
    with IK13_Count 8
    with IK13_Link I417_underground_pump
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_child I533_janky_bolt
    with component_sibling I534_security_gadget
    with IK2_Count 74
    with IK2_Link I533_janky_bolt
    with list_together 0
    with vector 0
    with p98_fixed false
    with short_name "square gizmo"
    with description text_routine_66
;

Object I533_janky_bolt ""
    class K2_thing
    with name 'janky' 'bolt' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I532_square_gizmo
    with IK2_Count 75
    with IK2_Link I534_security_gadget
    with list_together 0
    with vector 0
    with short_name "janky bolt"
    with description text_routine_67
;

Object I534_security_gadget ""
    class K2_thing
    with name 'security' 'gadget' 'gadgets' 
    with parse_name Parse_Name_GV185
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_child I535_small_warning_lights
    with component_sibling I538_blue_lever
    with IK2_Count 76
    with IK2_Link I535_small_warning_lights
    with list_together 0
    with vector 0
    with p100_secure true
    with short_name "security gadget"
    with description text_routine_68
;

Object I535_small_warning_lights ""
    class K2_thing
    with name 'small' 'warning' 'lights' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I534_security_gadget
    with component_sibling I536_keyhole_on_the_security
    with IK2_Count 77
    with IK2_Link I536_keyhole_on_the_security
    with list_together 0
    with vector 0
    with short_name "small warning lights"
    with description text_routine_69
;

Object I536_keyhole_on_the_security ""
    class K5_container
    with name 'keyhole' 'on' 'the' 'security' 'gadget' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I534_security_gadget
    with IK2_Count 78
    with IK2_Link I538_blue_lever
    with IK5_Count 7
    with IK5_Link I581_slot
    with list_together 0
    with vector 0
    has ~open
    has openable
    has lockable
    has locked
    with with_key I537_small_shiny_key
    with short_name "keyhole on the security gadget"
    with description SC_105
;

Object I538_blue_lever ""
    class K27_lever
    with name 'blue' 'lever' 'blue' 
    with parse_name Parse_Name_GV183
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK27_Count 0
    with IK27_Link I539_green_lever
    with KD_Count 27
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_sibling I539_green_lever
    with IK2_Count 80
    with IK2_Link I539_green_lever
    with list_together 0
    with vector 0
    with short_name "blue lever"
;

Object I539_green_lever ""
    class K27_lever
    with name 'green' 'lever' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK27_Count 1
    with IK27_Link I540_purple_lever
    with KD_Count 27
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_sibling I540_purple_lever
    with IK2_Count 81
    with IK2_Link I540_purple_lever
    with list_together 0
    with vector 0
    with short_name "green lever"
;

Object I540_purple_lever ""
    class K27_lever
    with name 'purple' 'lever' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK27_Count 2
    with IK27_Link I541_yellow_lever
    with KD_Count 27
    has mark_as_thing
    with component_parent I416_complicated_pump
    with component_sibling I541_yellow_lever
    with IK2_Count 82
    with IK2_Link I541_yellow_lever
    with list_together 0
    with vector 0
    with short_name "purple lever"
;

Object I541_yellow_lever ""
    class K27_lever
    with name 'yellow' 'lever' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK27_Count 3
    with IK27_Link nothing
    with KD_Count 27
    has mark_as_thing
    with component_parent I416_complicated_pump
    with IK2_Count 83
    with IK2_Link I544_notes
    with list_together 0
    with vector 0
    with short_name "yellow lever"
;

Object I544_notes ""
    class K2_thing
    with name 'notes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I543_notebook
    with IK2_Count 85
    with IK2_Link I547_hair
    with list_together 0
    with vector 0
    with short_name "notes"
;

Object I547_hair ""
    class K2_thing
    with name 'hair' 'braid' 
    with parse_name Parse_Name_GV188
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I545_secretary_of_water
    with IK2_Count 88
    with IK2_Link I553_twisty_stairs
    with list_together 0
    with vector 0
    has concealed
    with short_name "hair"
    with description SC_106
;

Object I553_twisty_stairs ""
    class K7_backdrop
    with name 'twisty' 'stairs' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 94
    with IK2_Link I561_lone_sweetgum_tree
    with IK7_Count 12
    with IK7_Link I561_lone_sweetgum_tree
    with list_together 0
    with vector 0
    with found_in I507_freshwater_crossing I441_hill 
    with short_name "twisty stairs"
    with description SC_107
;

Object I561_lone_sweetgum_tree ""
    class K7_backdrop
    with name 'lone' 'sweetgum' 'tree' 
    with parse_name Parse_Name_GV193
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with component_child I562_branch
    with IK2_Count 96
    with IK2_Link I562_branch
    with IK7_Count 13
    with IK7_Link I564_twinkling_lights
    with list_together 0
    with vector 0
    with found_in I441_hill I442_in_the_sweetgum_tree 
    with short_name "lone sweetgum tree"
    with description text_routine_70
;

Object I562_branch ""
    class K2_thing
    with name 'branch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I561_lone_sweetgum_tree
    with IK2_Count 97
    with IK2_Link I564_twinkling_lights
    with list_together 0
    with vector 0
    with short_name "branch"
    with description SC_108
;

Object I564_twinkling_lights ""
    class K7_backdrop
    with name 'twinkling' 'lights' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 99
    with IK2_Link I572_pine_bark
    with IK7_Count 14
    with IK7_Link I587_tracks
    with list_together 0
    with vector 0
    with found_in I441_hill I442_in_the_sweetgum_tree 
    has pluralname
    with short_name "twinkling lights"
    with description SC_109
;

Object I572_pine_bark ""
    class K2_thing
    with name 'pine' 'bark' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I548_grove_of_pine_trees
    with IK2_Count 106
    with IK2_Link I575_pine_sap
    with list_together 0
    with vector 0
    has pluralname
    with short_name "pine bark"
    with description SC_110
;

Object I575_pine_sap ""
    class K2_thing
    with name 'pine' 'sap' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I574_tall_pine_trees
    with IK2_Count 109
    with IK2_Link I576_clump_of_sap
    with list_together 0
    with vector 0
    has ~pluralname
    has concealed
    with short_name "pine sap"
    with description SC_111
;

Object I576_clump_of_sap ""
    class K2_thing
    with name 'clump' 'of' 'sap' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 110
    with IK2_Link I581_slot
    with list_together 0
    with vector 0
    with short_name "clump of sap"
    with description SC_112
;

Object I581_slot ""
    class K5_container
    with name 'slot' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I580_vending_machine
    with IK2_Count 115
    with IK2_Link I586_honor_roll
    with IK5_Count 9
    with IK5_Link I591_secret_panel
    with list_together 0
    with vector 0
    with short_name "slot"
    with description text_routine_71
;

Object I586_honor_roll ""
    class K2_thing
    with name 'honor' 'roll' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I585_newspaper
    with IK2_Count 120
    with IK2_Link I587_tracks
    with list_together 0
    with vector 0
    with short_name "honor roll"
    with description text_routine_72
;

Object I587_tracks ""
    class K7_backdrop
    with name 'tracks' 'track' 
    with parse_name Parse_Name_GV219
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 121
    with IK2_Link I588_gull
    with IK7_Count 15
    with IK7_Link I624_vines
    with list_together 0
    with vector 0
    with found_in I507_freshwater_crossing I509_grassy_area I511_pine_forest I494_other_side_of_the_pond 
    has p81_metal
    with short_name "tracks"
    with description text_routine_73
;

Object I588_gull ""
    class K12_animal
    with name 'gull' 'bird' 
    with parse_name Parse_Name_GV207
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 12
    with IK12_Count 1
    with IK12_Link nothing
    has mark_as_thing
    with IK2_Count 122
    with IK2_Link I590_drawer_bottom
    with IK8_Count 3
    with IK8_Link I671_vivian
    with list_together 0
    with vector 0
    with short_name "gull"
    with description SC_113
;

Object I590_drawer_bottom ""
    class K6_supporter
    with name 'drawer' 'bottom' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 6
    has mark_as_thing
    with component_parent I589_wooden_drawer
    with component_sibling I591_secret_panel
    with IK2_Count 124
    with IK2_Link I591_secret_panel
    with IK6_Count 4
    with IK6_Link nothing
    with list_together 0
    with vector 0
    has enterable
    with short_name SC_114
;

Object I591_secret_panel ""
    class K5_container
    with name 'secret' 'panel' 'outline' 'square' 'grooves' 'pattern' 'space' 'wood' 'raised' 
    with parse_name Parse_Name_GV208
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I589_wooden_drawer
    with IK2_Count 125
    with IK2_Link I592_engineer_s_blueprint
    with IK5_Count 11
    with IK5_Link I595_rock_limbo
    with list_together 0
    with vector 0
    has ~open
    has openable
    with short_name SC_115
    with description text_routine_74
;

Object -> I592_engineer_s_blueprint ""
    class K31_flat_paper
    with name 'engineer^s' 'blueprint' 'paper' 
    with parse_name Parse_Name_GV210
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK31_Count 4
    with IK31_Link nothing
    with KD_Count 31
    has mark_as_thing
    with component_child I593_sketch_on_the_blueprint
    with IK2_Count 126
    with IK2_Link I593_sketch_on_the_blueprint
    with list_together 0
    with vector 0
    with short_name "engineer's blueprint"
    with description text_routine_75
;

Object I593_sketch_on_the_blueprint ""
    class K2_thing
    with name 'sketch' 'on' 'the' 'blueprint' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I592_engineer_s_blueprint
    with IK2_Count 127
    with IK2_Link I595_rock_limbo
    with list_together 0
    with vector 0
    with short_name "sketch on the blueprint"
    with article SC_6
    with description SC_116
;

Object I595_rock_limbo ""
    class K5_container
    with name 'rock' 'limbo' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with IK2_Count 128
    with IK2_Link X596
    with IK5_Count 12
    with IK5_Link I639_deep_crack
    with list_together 0
    with cap_short_name "Rock Limbo"
    with vector 0
    has proper
    with short_name "Rock Limbo"
;

Object -> X596 ""
    class K24_small_rock
    with name 'small' 'rock'  'rocks//p' 'disk' 'disc' 'disklike' 'disclike' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK24_Count 0
    with IK24_Link X597
    with KD_Count 24
    has mark_as_thing
    with IK2_Count 129
    with IK2_Link X597
    with list_together 0
    with vector 0
    with short_name "small rock"
;

Object -> X597 ""
    class K24_small_rock
    with name 'small' 'rock'  'rocks//p' 'disk' 'disc' 'disklike' 'disclike' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK24_Count 1
    with IK24_Link X598
    with KD_Count 24
    has mark_as_thing
    with IK2_Count 130
    with IK2_Link X598
    with list_together 0
    with vector 0
    with short_name "small rock"
;

Object -> X598 ""
    class K24_small_rock
    with name 'small' 'rock'  'rocks//p' 'disk' 'disc' 'disklike' 'disclike' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK24_Count 2
    with IK24_Link X599
    with KD_Count 24
    has mark_as_thing
    with IK2_Count 131
    with IK2_Link X599
    with list_together 0
    with vector 0
    with short_name "small rock"
;

Object -> X599 ""
    class K24_small_rock
    with name 'small' 'rock'  'rocks//p' 'disk' 'disc' 'disklike' 'disclike' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK24_Count 3
    with IK24_Link X600
    with KD_Count 24
    has mark_as_thing
    with IK2_Count 132
    with IK2_Link X600
    with list_together 0
    with vector 0
    with short_name "small rock"
;

Object -> X600 ""
    class K24_small_rock
    with name 'small' 'rock'  'rocks//p' 'disk' 'disc' 'disklike' 'disclike' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK24_Count 4
    with IK24_Link nothing
    with KD_Count 24
    has mark_as_thing
    with IK2_Count 133
    with IK2_Link I603_particular_spot
    with list_together 0
    with vector 0
    with short_name "small rock"
;

Object I603_particular_spot ""
    class K2_thing
    with name 'particular' 'spot' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I602_sand
    with IK2_Count 136
    with IK2_Link I604_large_magnet
    with list_together 0
    with vector 0
    with short_name "particular spot"
    with description SC_117
;

Object I604_large_magnet ""
    class K2_thing
    with name 'large' 'magnet' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 137
    with IK2_Link I605_sign
    with list_together 0
    with vector 0
    with short_name "large magnet"
    with description SC_118
;

Object I605_sign ""
    class K2_thing
    with name 'sign' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I606_birch_trees
    with component_sibling I609_birch_bark
    with IK2_Count 138
    with IK2_Link I607_yellow_leaves
    with list_together 0
    with vector 0
    with short_name "sign"
    with description SC_119
;

Object I607_yellow_leaves ""
    class K2_thing
    with name 'yellow' 'leaves' 'leaf' 
    with parse_name Parse_Name_GV218
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I608_birch_tree
    with IK2_Count 140
    with IK2_Link I608_birch_tree
    with list_together 0
    with vector 0
    with short_name "yellow leaves"
    with description SC_120
;

Object I608_birch_tree ""
    class K2_thing
    with name 'birch' 'tree' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I607_yellow_leaves
    with IK2_Count 141
    with IK2_Link I609_birch_bark
    with list_together 0
    with vector 0
    with short_name "birch tree"
;

Object I609_birch_bark ""
    class K2_thing
    with name 'birch' 'bark' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I606_birch_trees
    with IK2_Count 142
    with IK2_Link I610_large_bag
    with list_together 0
    with vector 0
    with short_name "birch bark"
    with description SC_121
;

Object I610_large_bag ""
    class K2_thing
    with name 'large' 'bag' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 143
    with IK2_Link I612_rope
    with list_together 0
    with vector 0
    with short_name "large bag"
    with description SC_122
;

Object I612_rope ""
    class K2_thing
    with name 'rope' 'length' 'nylon' 'cord' 
    with parse_name Parse_Name_GV220
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 144
    with IK2_Link I617_masts
    with list_together 0
    with vector 0
    with short_name "rope"
    with description SC_123
;

Object I617_masts ""
    class K2_thing
    with name 'masts' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I616_ark
    with component_sibling I618_sails
    with IK2_Count 149
    with IK2_Link I618_sails
    with list_together 0
    with vector 0
    with short_name "masts"
    with description SC_124
;

Object I618_sails ""
    class K2_thing
    with name 'sails' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I616_ark
    with component_sibling I619_anchor
    with IK2_Count 150
    with IK2_Link I619_anchor
    with list_together 0
    with vector 0
    with short_name "sails"
    with description SC_125
;

Object I619_anchor ""
    class K2_thing
    with name 'anchor' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I616_ark
    with component_child I620_anchor_chain
    with IK2_Count 151
    with IK2_Link I620_anchor_chain
    with list_together 0
    with vector 0
    has p81_metal
    with short_name "anchor"
    with description SC_126
;

Object I620_anchor_chain ""
    class K2_thing
    with name 'anchor' 'chain' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I619_anchor
    with IK2_Count 152
    with IK2_Link I624_vines
    with list_together 0
    with vector 0
    has p81_metal
    with short_name "anchor chain"
    with description SC_127
;

Object I624_vines ""
    class K7_backdrop
    with name 'vines' 'viburnum' 'tendrils' 'viburnum' 
    with parse_name Parse_Name_GV228
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 156
    with IK2_Link I625_mist
    with IK7_Count 18
    with IK7_Link I625_mist
    with list_together 0
    with vector 0
    with found_in I507_freshwater_crossing I509_grassy_area I511_pine_forest I494_other_side_of_the_pond 
    with short_name "vines"
    with description SC_128
;

Object I625_mist ""
    class K7_backdrop
    with name 'mist' 'fog' 
    with parse_name Parse_Name_GV230
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 157
    with IK2_Link I628_colorful_trees
    with IK7_Count 19
    with IK7_Link I628_colorful_trees
    with list_together 0
    with vector 0
    with found_in I494_other_side_of_the_pond 
    with short_name "mist"
    with description SC_129
;

Object I628_colorful_trees ""
    class K7_backdrop
    with name 'colorful' 'trees' 'birch' 'maple' 'sweetgum' 'oak' 'spruce' 'woods' 'forest' 'tree' 
    with parse_name Parse_Name_GV234
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 160
    with IK2_Link I631_smooth_metal_door
    with IK7_Count 20
    with IK7_Link I641_dirt_floor
    with list_together 0
    with vector 0
    with found_in I501_small_clearing I502_large_clearing I494_other_side_of_the_pond I444_woods 
    has pluralname
    with short_name "colorful trees"
    with description text_routine_76
;

Object I631_smooth_metal_door ""
    class K2_thing
    with name 'smooth' 'metal' 'door' 'sheet' 
    with parse_name Parse_Name_GV235
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I630_cinderblock_hut
    with component_sibling I632_hut_s_wall
    with IK2_Count 163
    with IK2_Link I632_hut_s_wall
    with list_together 0
    with vector 0
    has p81_metal
    with short_name "smooth metal door"
    with description text_routine_77
;

Object I632_hut_s_wall ""
    class K2_thing
    with name 'hut^s' 'wall' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I630_cinderblock_hut
    with IK2_Count 164
    with IK2_Link I417_underground_pump
    with list_together 0
    with vector 0
    with short_name "hut's wall"
    with description SC_130
;

Object I637_inside_the_cinderblock_ ""
    class K1_room
    with name 'inside' 'the' 'cinderblock' 'hut' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 24
    with IK1_Link I669_underwater
    with list_together 0
    with cap_short_name "Inside The Cinderblock Hut"
    with vector 0
    with room_index -1
    with p112_keyed true
    has p77_indoors
    has proper
    with short_name "Inside The Cinderblock Hut"
    with description text_routine_78
    with map_region I500_otherland
;

Object -> I417_underground_pump ""
    class K23_pump
    with name 'underground' 'pump' 'machine' 
    with parse_name Parse_Name_GV239
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK23_Count 1
    with IK23_Link I419_underwater_pump
    with KD_Count 23
    with IK13_Count 2
    with IK13_Link I419_underwater_pump
    has mark_as_thing
    with component_child I642_large_metal_wheel
    with IK2_Count 6
    with IK2_Link I638_cinderblock_walls
    with list_together 0
    with vector 0
    has concealed
    with short_name "underground pump"
    with description SC_131
;

Object -> I638_cinderblock_walls ""
    class K2_thing
    with name 'cinderblock' 'walls' 
    with parse_name Parse_Name_GV240
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_child I639_deep_crack
    with IK2_Count 169
    with IK2_Link I639_deep_crack
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "cinderblock walls"
    with description SC_132
;

Object I639_deep_crack ""
    class K5_container
    with name 'deep' 'crack' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I638_cinderblock_walls
    with IK2_Count 170
    with IK2_Link I640_old_key
    with IK5_Count 14
    with IK5_Link I662_pipe_holes
    with list_together 0
    with vector 0
    with short_name "deep crack"
    with description text_routine_79
;

Object -> I640_old_key ""
    class K18_passkey
    with name 'old' 'key' 
    with parse_name Parse_Name_GV260
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 18
    with IK18_Count 2
    with IK18_Link nothing
    has mark_as_thing
    with IK2_Count 171
    with IK2_Link I641_dirt_floor
    with list_together 0
    with vector 0
    has p81_metal
    with short_name "old key"
    with description SC_133
;

Object I641_dirt_floor ""
    class K7_backdrop
    with name 'dirt' 'floor' 'ground' 
    with parse_name Parse_Name_GV241
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 7
    has mark_as_thing
    with IK2_Count 172
    with IK2_Link I642_large_metal_wheel
    with IK7_Count 21
    with IK7_Link nothing
    with list_together 0
    with vector 0
    with found_in I637_inside_the_cinderblock_ I479_boat_house I439_steam_train 
    with short_name "dirt floor"
    with description text_routine_80
;

Object I642_large_metal_wheel ""
    class K2_thing
    with name 'large' 'metal' 'wheel' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I417_underground_pump
    with component_sibling I643_plastic_hoses
    with IK2_Count 173
    with IK2_Link I643_plastic_hoses
    with list_together 0
    with vector 0
    with short_name "large metal wheel"
    with description SC_134
;

Object I643_plastic_hoses ""
    class K2_thing
    with name 'plastic' 'hoses' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I417_underground_pump
    with IK2_Count 174
    with IK2_Link I645_dirty_puddle
    with list_together 0
    with vector 0
    has pluralname
    with short_name "plastic hoses"
    with description text_routine_81
;

Object I645_dirty_puddle ""
    class K2_thing
    with name 'dirty' 'puddle' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 176
    with IK2_Link I646_stain
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "dirty puddle"
    with description SC_135
;

Object I646_stain ""
    class K2_thing
    with name 'stain' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 177
    with IK2_Link I649_game
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "stain"
    with description SC_136
;

Object I649_game ""
    class K2_thing
    with name 'game' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I648_suburban_house
    with IK2_Count 180
    with IK2_Link I654_rungs
    with list_together 0
    with vector 0
    with short_name "game"
    with description SC_137
;

Object I654_rungs ""
    class K2_thing
    with name 'rungs' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I653_large_tank
    with IK2_Count 185
    with IK2_Link I661_wheel_holes
    with list_together 0
    with vector 0
    with short_name "rungs"
    with description SC_138
;

Object I661_wheel_holes ""
    class K2_thing
    with name 'wheel' 'holes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I660_medium_sized_wheel
    with IK2_Count 192
    with IK2_Link I662_pipe_holes
    with list_together 0
    with vector 0
    with short_name "wheel holes"
    with description SC_139
;

Object I662_pipe_holes ""
    class K5_container
    with name 'pipe' 'holes' 'hole' 
    with parse_name Parse_Name_GV154
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I657_brass_metal_pipe
    with IK2_Count 193
    with IK2_Link I668_tank_of_air
    with IK5_Count 15
    with IK5_Link I701_cavity
    with list_together 0
    with vector 0
    has pluralname
    with short_name "pipe holes"
    with description SC_140
;

Object I668_tank_of_air ""
    class K2_thing
    with name 'tank' 'of' 'air' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I666_diving_mask
    with IK2_Count 199
    with IK2_Link I670_view_of_the_crystal_cit
    with list_together 0
    with vector 0
    with short_name "tank of air"
    with description SC_141
;

Object I669_underwater ""
    class K1_room
    with name 'underwater' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 25
    with IK1_Link I677_the_crystal_city
    with list_together 0
    with cap_short_name "Underwater"
    with vector 0
    with room_index -1
    has p77_indoors
    has proper
    with short_name "Underwater"
    with description SC_142
    with map_region I676_underwaterland
;

Object -> I670_view_of_the_crystal_cit ""
    class K2_thing
    with name 'view' 'of' 'the' 'crystal' 'city' 'spire' 
    with parse_name Parse_Name_GV248
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 200
    with IK2_Link I675_funny_people
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "view of the Crystal City"
    with description text_routine_82
;

Object -> I675_funny_people ""
    class K2_thing
    with name 'funny' 'people' 'people' 
    with parse_name Parse_Name_GV252
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 204
    with IK2_Link I671_vivian
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "funny people"
    with description SC_143
;

Object I671_vivian ""
    class K11_woman
    with name 'vivian' 'viv' 
    with parse_name Parse_Name_GV249
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 11
    with IK11_Count 2
    with IK11_Link I687_cordelia
    has mark_as_thing
    with IK2_Count 201
    with IK2_Link I672_green_and_clingy_garmen
    with IK8_Count 7
    with IK8_Link I687_cordelia
    with list_together 0
    with cap_short_name "Vivian"
    with vector 0
    has proper
    has concealed
    with p17_apology text_routine_83
    with short_name "Vivian"
    with description SC_144
;

Object -> I672_green_and_clingy_garmen ""
    class K2_thing
    with name 'green' 'and' 'clingy' 'garment' 
    with parse_name Parse_Name_GV250
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 202
    with IK2_Link I673_vivian_s_tangle_of_tube
    with list_together 0
    with vector 0
    has worn
    with p86_soft true
    has clothing
    with short_name "green and clingy garment"
    with description SC_145
;

Object -> I673_vivian_s_tangle_of_tube ""
    class K2_thing
    with name 'vivian^s' 'tangle' 'of' 'tubes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 203
    with IK2_Link I419_underwater_pump
    with list_together 0
    with cap_short_name "Vivian's tangle of tubes"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "Vivian's tangle of tubes"
    with description SC_146
;

Object I676_underwaterland ""
    class K9_region
    with name 'underwaterland' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 9
    with IK9_Link nothing
    with regional_found_in [; if (TestRegionalContainment(location, I676_underwaterland)) rtrue; rfalse; ],
    with IK9_Count 5
    with list_together 0
    with cap_short_name "Underwaterland"
    with vector 0
    has proper
    with short_name "Underwaterland"
;

Object I677_the_crystal_city ""
    class K1_room
    with name 'the' 'crystal' 'city' 
    with KD_Count 1
    has mark_as_room
    with IK1_Count 26
    with IK1_Link nothing
    with list_together 0
    with cap_short_name "The Crystal City"
    with vector 0
    with room_index -1
    has p77_indoors
    has proper
    with short_name "The Crystal City"
    with description text_routine_84
    with map_region I676_underwaterland
;

Object -> I419_underwater_pump ""
    class K23_pump
    with name 'underwater' 'pump' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK23_Count 3
    with IK23_Link X703
    with KD_Count 23
    with IK13_Count 4
    with IK13_Link X703
    has mark_as_thing
    with component_child I691_blue_switch
    with IK2_Count 8
    with IK2_Link I678_tall_spire
    with list_together 0
    with vector 0
    has concealed
    with short_name "underwater pump"
    with description text_routine_85
;

Object -> I678_tall_spire ""
    class K2_thing
    with name 'tall' 'spire' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 205
    with IK2_Link I679_figures
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "tall spire"
    with description SC_147
;

Object -> I679_figures ""
    class K2_thing
    with name 'figures' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 206
    with IK2_Link I680_coatings_of_algae
    with list_together 0
    with vector 0
    has static
    has scenery
    with short_name "figures"
    with description SC_148
;

Object -> I680_coatings_of_algae ""
    class K2_thing
    with name 'coatings' 'of' 'algae' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 207
    with IK2_Link I681_kelp_twisted_into_ropy_
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "coatings of algae"
    with description SC_149
;

Object -> I681_kelp_twisted_into_ropy_ ""
    class K2_thing
    with name 'kelp' 'twisted' 'into' 'ropy' 'trees' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 208
    with IK2_Link I682_ribbons_of_pondweed
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "kelp twisted into ropy trees"
    with description SC_150
;

Object -> I682_ribbons_of_pondweed ""
    class K2_thing
    with name 'ribbons' 'of' 'pondweed' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 209
    with IK2_Link I683_glass_pebble_turrets
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "ribbons of pondweed"
    with description SC_151
;

Object -> I683_glass_pebble_turrets ""
    class K2_thing
    with name 'glass-pebble' 'turrets' 'buildings' 
    with parse_name Parse_Name_GV259
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 210
    with IK2_Link I684_tall_cylindrical_towers
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "glass-pebble turrets"
    with description SC_152
;

Object -> I684_tall_cylindrical_towers ""
    class K2_thing
    with name 'tall' 'cylindrical' 'towers' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 211
    with IK2_Link I685_city_people
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "tall cylindrical towers"
    with description SC_153
;

Object -> I685_city_people ""
    class K2_thing
    with name 'city' 'people' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 212
    with IK2_Link I686_smooth_crystal_streets
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "city people"
    with description SC_154
;

Object -> I686_smooth_crystal_streets ""
    class K2_thing
    with name 'smooth' 'crystal' 'streets' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 213
    with IK2_Link I687_cordelia
    with list_together 0
    with vector 0
    has pluralname
    has static
    has scenery
    with short_name "smooth crystal streets"
    with description SC_155
;

Object -> I687_cordelia ""
    class K11_woman
    with name 'cordelia' 'cord' 
    with parse_name Parse_Name_GV256
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 11
    with IK11_Count 3
    with IK11_Link nothing
    has mark_as_thing
    with IK2_Count 214
    with IK2_Link I689_cordelia_s_tangle_of_tu
    with IK8_Count 8
    with IK8_Link I688_douglas
    with list_together 0
    with cap_short_name "Cordelia"
    with vector 0
    has proper
    has concealed
    with p17_apology text_routine_86
    with short_name "Cordelia"
    with description SC_156
;

Object -> -> I689_cordelia_s_tangle_of_tu ""
    class K2_thing
    with name 'cordelia^s' 'tangle' 'of' 'tubes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 216
    with IK2_Link I688_douglas
    with list_together 0
    with cap_short_name "Cordelia's tangle of tubes"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "Cordelia's tangle of tubes"
    with description SC_157
;

Object -> I688_douglas ""
    class K10_man
    with name 'douglas' 'doug' 
    with parse_name Parse_Name_GV257
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 10
    with IK10_Count 1
    with IK10_Link nothing
    has mark_as_thing
    with IK2_Count 215
    with IK2_Link I690_douglas_s_tangle_of_tub
    with IK8_Count 9
    with IK8_Link nothing
    with list_together 0
    with cap_short_name "Douglas"
    with vector 0
    has proper
    has concealed
    with p17_apology text_routine_87
    with short_name "Douglas"
    with description SC_158
;

Object -> -> I690_douglas_s_tangle_of_tub ""
    class K2_thing
    with name 'douglas^s' 'tangle' 'of' 'tubes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with IK2_Count 217
    with IK2_Link I691_blue_switch
    with list_together 0
    with cap_short_name "Douglas's tangle of tubes"
    with vector 0
    has worn
    with p86_soft true
    has proper
    has clothing
    with short_name "Douglas's tangle of tubes"
    with description SC_157
;

Object I691_blue_switch ""
    class K29_switch
    with name 'blue' 'switch' 'blue' 
    with parse_name Parse_Name_GV184
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK29_Count 0
    with IK29_Link I692_yellow_switch
    with KD_Count 29
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_sibling I692_yellow_switch
    with IK2_Count 218
    with IK2_Link I692_yellow_switch
    with list_together 0
    with vector 0
    with short_name "blue switch"
;

Object I692_yellow_switch ""
    class K29_switch
    with name 'yellow' 'switch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK29_Count 1
    with IK29_Link I693_green_switch
    with KD_Count 29
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_sibling I693_green_switch
    with IK2_Count 219
    with IK2_Link I693_green_switch
    with list_together 0
    with vector 0
    with short_name "yellow switch"
;

Object I693_green_switch ""
    class K29_switch
    with name 'green' 'switch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK29_Count 2
    with IK29_Link I694_purple_switch
    with KD_Count 29
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_sibling I694_purple_switch
    with IK2_Count 220
    with IK2_Link I694_purple_switch
    with list_together 0
    with vector 0
    with short_name "green switch"
;

Object I694_purple_switch ""
    class K29_switch
    with name 'purple' 'switch' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK29_Count 3
    with IK29_Link nothing
    with KD_Count 29
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_sibling I696_opening
    with IK2_Count 221
    with IK2_Link I696_opening
    with list_together 0
    with vector 0
    with short_name "purple switch"
;

Object I696_opening ""
    class K2_thing
    with name 'opening' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_sibling I697_tangle_of_metal_pipes
    with IK2_Count 222
    with IK2_Link I697_tangle_of_metal_pipes
    with list_together 0
    with vector 0
    with short_name "opening"
    with description text_routine_88
;

Object I697_tangle_of_metal_pipes ""
    class K2_thing
    with name 'tangle' 'of' 'metal' 'pipes' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_sibling I698_giant_metal_wheel
    with IK2_Count 223
    with IK2_Link I698_giant_metal_wheel
    with list_together 0
    with vector 0
    with short_name "tangle of metal pipes"
    with description SC_159
;

Object I698_giant_metal_wheel ""
    class K20_wheel
    with name 'giant' 'metal' 'wheel' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 20
    with IK20_Count 0
    with IK20_Link I699_large_crystal_gear
    has mark_as_thing
    with component_parent I419_underwater_pump
    with component_child I700_spike
    with component_sibling I699_large_crystal_gear
    with IK2_Count 224
    with IK2_Link I699_large_crystal_gear
    with list_together 0
    with vector 0
    with p116_spinning true
    with short_name "giant metal wheel"
    with description SC_160
;

Object I699_large_crystal_gear ""
    class K20_wheel
    with name 'large' 'crystal' 'gear' 
    with parse_name Parse_Name_GV255
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 20
    with IK20_Count 1
    with IK20_Link nothing
    has mark_as_thing
    with component_parent I419_underwater_pump
    with IK2_Count 225
    with IK2_Link I700_spike
    with list_together 0
    with vector 0
    with short_name "large crystal gear"
    with description text_routine_89
;

Object I700_spike ""
    class K2_thing
    with name 'spike' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I698_giant_metal_wheel
    with component_sibling I701_cavity
    with IK2_Count 226
    with IK2_Link I701_cavity
    with list_together 0
    with vector 0
    with short_name "spike"
    with description SC_161
;

Object I701_cavity ""
    class K5_container
    with name 'cavity' 
    with parse_name Parse_Name_GV253
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 5
    has mark_as_thing
    with component_parent I698_giant_metal_wheel
    with IK2_Count 227
    with IK2_Link I702_crystal_shell
    with IK5_Count 17
    with IK5_Link nothing
    with list_together 0
    with vector 0
    with p118_accessible false
    with capacity 1
    with short_name "cavity"
    with description SC_162
;

Object I702_crystal_shell ""
    class K2_thing
    with name 'crystal' 'shell' 'exterior' 
    with parse_name Parse_Name_GV254
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent X703
    with IK2_Count 228
    with IK2_Link X703
    with list_together 0
    with vector 0
    with short_name "crystal shell"
    with description SC_163
;

Object X703 ""
    class K23_pump
    with name 'pump' 'pumps//p' 
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with IK23_Count 4
    with IK23_Link nothing
    with KD_Count 23
    with IK13_Count 9
    with IK13_Link nothing
    has mark_as_thing
    with component_child I702_crystal_shell
    with IK2_Count 229
    with IK2_Link I705_structure_lock
    with list_together 0
    with vector 0
    with short_name "pump"
;

Object I705_structure_lock ""
    class K2_thing
    with name 'structure' 'lock' 'keyhole' 
    with parse_name Parse_Name_GV261
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I480_door_to_the_structure
    with IK2_Count 230
    with IK2_Link I706_center_lock
    with list_together 0
    with vector 0
    with short_name "structure lock"
    with description SC_164
;

Object I706_center_lock ""
    class K2_thing
    with name 'center' 'lock' 'keyhole' 
    with parse_name Parse_Name_GV262
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I483_community_center_door
    with IK2_Count 231
    with IK2_Link I715_mustache
    with list_together 0
    with vector 0
    with short_name "center lock"
    with description SC_164
;

Object I715_mustache ""
    class K2_thing
    with name 'mustache' 'moustache' 'stache' 
    with parse_name Parse_Name_GV268
    with action_bitmap 0 0 0 0 0 0 0 0 0 
    with KD_Count 2
    has mark_as_thing
    with component_parent I711_conductor
    with IK2_Count 240
    with IK2_Link nothing
    with list_together 0
    with vector 0
    with short_name "mustache"
    with description SC_165
;

Constant I65_figure_of_cover = 1;
Constant I66_entire_game = 1;
Constant I68_didn_t_understand_error = 1;
Constant I69_only_understood_as_far_a = 2;
Constant I70_didn_t_understand_that_n = 3;
Constant I71_can_only_do_that_to_some = 4;
Constant I72_can_t_see_any_such_thing = 5;
Constant I73_said_too_little_error = 6;
Constant I74_aren_t_holding_that_erro = 7;
Constant I75_can_t_use_multiple_objec = 8;
Constant I76_can_only_use_multiple_ob = 9;
Constant I77_not_sure_what_it_refers_ = 10;
Constant I78_excepted_something_not_i = 11;
Constant I79_not_a_verb_i_recognise_e = 12;
Constant I80_not_something_you_need_t = 13;
Constant I81_can_t_see_it_at_the_mome = 14;
Constant I82_didn_t_understand_the_wa = 15;
Constant I83_not_enough_of_those_avai = 16;
Constant I84_nothing_to_do_error = 17;
Constant I85_noun_did_not_make_sense_ = 18;
Constant I86_referred_to_a_determinat = 19;
Constant I87_i_beg_your_pardon_error = 20;
Constant I94_libmsg__you_have_died_ = 1;
Constant I95_libmsg__you_have_won_ = 2;
Constant I96_libmsg__player_self_desc = 3;
Constant I97_libmsg__unimportant_obje = 4;
Constant I98_libmsg__empty_line_ = 5;
Constant I99_libmsg__confirm_quit_ = 6;
Constant I100_libmsg__yes_or_no_promp = 7;
Constant I101_libmsg__restrict_answer = 8;
Constant I102_libmsg__page_prompt_ = 9;
Constant I103_libmsg__menu_prompt_ = 10;
Constant I104_libmsg__comment_recorde = 11;
Constant I105_libmsg__comment_not_rec = 12;
Constant I106_libmsg__undo_succeeded_ = 13;
Constant I107_libmsg__undo_failed_ = 14;
Constant I108_libmsg__undo_not_provid = 15;
Constant I109_libmsg__cannot_undo_not = 16;
Constant I110_libmsg__cannot_undo_twi = 17;
Constant I111_libmsg__undo_forbidden_ = 18;
Constant I112_libmsg__oops_failed_ = 19;
Constant I113_libmsg__oops_too_many_a = 20;
Constant I114_libmsg__oops_no_argumen = 21;
Constant I115_libmsg__cannot_do_again = 22;
Constant I116_libmsg__again_usage_ = 23;
Constant I117_libmsg__command_not_und = 24;
Constant I118_libmsg__command_partly_ = 25;
Constant I119_libmsg__command_badly_e = 26;
Constant I120_libmsg__command_incompl = 27;
Constant I121_libmsg__command_cut_sho = 28;
Constant I122_libmsg__number_not_unde = 29;
Constant I123_libmsg__cannot_begin_at = 30;
Constant I124_libmsg__extra_words_bef = 31;
Constant I125_libmsg__unknown_object_ = 32;
Constant I126_libmsg__object_not_held = 33;
Constant I127_libmsg__unknown_verb_ = 34;
Constant I128_libmsg__verb_cannot_hav = 35;
Constant I129_libmsg__noun_needed_ = 36;
Constant I130_libmsg__noun_not_needed = 37;
Constant I131_libmsg__object_needed_ = 38;
Constant I132_libmsg__object_not_need = 39;
Constant I133_libmsg__second_object_n = 40;
Constant I134_libmsg__second_object_n = 41;
Constant I135_libmsg__second_noun_nee = 42;
Constant I136_libmsg__second_noun_not = 43;
Constant I137_libmsg__something_more_ = 44;
Constant I138_libmsg__verb_cannot_hav = 45;
Constant I139_libmsg__too_many_multip = 46;
Constant I140_libmsg__not_that_many_a = 47;
Constant I141_libmsg__no_objects_avai = 48;
Constant I142_libmsg__zero_multiple_o = 49;
Constant I143_libmsg__first_n_objects = 50;
Constant I144_libmsg__excepted_object = 51;
Constant I145_libmsg__report_implicit = 52;
Constant I146_libmsg__report_npc_impl = 53;
Constant I147_libmsg__use_holdall_to_ = 54;
Constant I148_libmsg__cannot_put_if_t = 55;
Constant I149_libmsg__who_disambiguat = 56;
Constant I150_libmsg__which_disambigu = 57;
Constant I151_libmsg__whom_disambigua = 58;
Constant I152_libmsg__what_disambigua = 59;
Constant I153_libmsg__single_object_d = 60;
Constant I154_libmsg__pronoun_not_set = 61;
Constant I155_libmsg__pronoun_absent_ = 62;
Constant I156_libmsg__pronouns_initia = 63;
Constant I157_libmsg__pronouns__means = 64;
Constant I158_libmsg__pronouns__unset = 65;
Constant I159_libmsg__no_pronouns_kno = 66;
Constant I160_libmsg__person_ignores_ = 67;
Constant I161_libmsg__cannot_talk_to_ = 68;
Constant I162_libmsg__cannot_talk_to_ = 69;
Constant I163_libmsg__npc_unable_to_d = 70;
Constant I164_libmsg__confirm_restart = 71;
Constant I165_libmsg__restart_failed_ = 72;
Constant I166_libmsg__restore_failed_ = 73;
Constant I167_libmsg__restore_succeed = 74;
Constant I168_libmsg__save_failed_ = 75;
Constant I169_libmsg__save_succeeded_ = 76;
Constant I170_libmsg__verify_succeede = 77;
Constant I171_libmsg__verify_failed_ = 78;
Constant I172_libmsg__transcript_alre = 79;
Constant I173_libmsg__transcript_alre = 80;
Constant I174_libmsg__start_of_transc = 81;
Constant I175_libmsg__end_of_transcri = 82;
Constant I176_libmsg__transcript_fail = 83;
Constant I177_libmsg__end_transcript_ = 84;
Constant I178_libmsg__score_command_ = 85;
Constant I179_libmsg__score_changed_ = 86;
Constant I180_libmsg__score_notificat = 87;
Constant I181_libmsg__score_notificat = 88;
Constant I182_libmsg__no_scoring_ = 89;
Constant I183_libmsg__score_rank_ = 90;
Constant I184_libmsg__report_npc_taki = 91;
Constant I185_libmsg__inventory_initi = 92;
Constant I186_libmsg__inventory_no_po = 93;
Constant I187_libmsg__entering_darkne = 94;
Constant I188_libmsg__dark_descriptio = 95;
Constant I189_libmsg__examine_while_d = 96;
Constant I190_libmsg__search_while_da = 97;
Constant I191_libmsg__look_under_whil = 98;
Constant I192_libmsg__dark_room_name_ = 99;
Constant I193_libmsg__report_player_t = 100;
Constant I194_libmsg__report_npc_taki = 101;
Constant I195_libmsg__cannot_take_you = 102;
Constant I196_libmsg__cannot_take_oth = 103;
Constant I197_libmsg__cannot_take_som = 104;
Constant I198_libmsg__cannot_take_som = 105;
Constant I199_libmsg__cannot_take_pos = 106;
Constant I200_libmsg__cannot_take_com = 107;
Constant I201_libmsg__cannot_take_hid = 108;
Constant I202_libmsg__cannot_reach_wi = 109;
Constant I203_libmsg__cannot_take_sce = 110;
Constant I204_libmsg__cannot_take_som = 111;
Constant I205_libmsg__cannot_reach_wi = 112;
Constant I206_libmsg__cannot_exceed_c = 113;
Constant I207_libmsg__report_player_r = 114;
Constant I208_libmsg__report_npc_remo = 115;
Constant I209_libmsg__cannot_remove_f = 116;
Constant I210_libmsg__cannot_remove_s = 117;
Constant I211_libmsg__report_player_d = 118;
Constant I212_libmsg__report_npc_drop = 119;
Constant I213_libmsg__cannot_drop_som = 120;
Constant I214_libmsg__cannot_drop_not = 121;
Constant I215_libmsg__cannot_drop_if_ = 122;
Constant I216_libmsg__cannot_drop_clo = 123;
Constant I217_libmsg__report_player_i = 124;
Constant I218_libmsg__report_npc_inse = 125;
Constant I219_libmsg__cannot_insert_s = 126;
Constant I220_libmsg__cannot_insert_i = 127;
Constant I221_libmsg__cannot_insert_i = 128;
Constant I222_libmsg__need_to_take_of = 129;
Constant I223_libmsg__cannot_insert_s = 130;
Constant I224_libmsg__cannot_insert_i = 131;
Constant I225_libmsg__cannot_insert_c = 132;
Constant I226_libmsg__report_player_p = 133;
Constant I227_libmsg__report_npc_putt = 134;
Constant I228_libmsg__cannot_put_some = 135;
Constant I229_libmsg__cannot_put_some = 136;
Constant I230_libmsg__cannot_put_onto = 137;
Constant I231_libmsg__cannot_put_onto = 138;
Constant I232_libmsg__cannot_put_clot = 139;
Constant I233_libmsg__report_player_g = 140;
Constant I234_libmsg__report_npc_givi = 141;
Constant I235_libmsg__report_npc_givi = 142;
Constant I236_libmsg__cannot_give_wha = 143;
Constant I237_libmsg__cannot_give_to_ = 144;
Constant I238_libmsg__block_giving_ = 145;
Constant I239_libmsg__unable_to_recei = 146;
Constant I240_libmsg__cannot_show_wha = 147;
Constant I241_libmsg__block_showing_ = 148;
Constant I242_libmsg__report_player_e = 149;
Constant I243_libmsg__report_npc_ente = 150;
Constant I244_libmsg__cannot_enter_so = 151;
Constant I245_libmsg__cannot_enter_so = 152;
Constant I246_libmsg__cannot_enter_cl = 153;
Constant I247_libmsg__cannot_enter_so = 154;
Constant I248_libmsg__implicitly_pass = 155;
Constant I249_libmsg__implicitly_pass = 156;
Constant I250_libmsg__report_player_e = 157;
Constant I251_libmsg__report_npc_exit = 158;
Constant I252_libmsg__cannot_exit_whe = 159;
Constant I253_libmsg__cannot_exit_clo = 160;
Constant I254_libmsg__cannot_get_off_ = 161;
Constant I255_libmsg__cannot_exit_thi = 162;
Constant I256_libmsg__cannot_go_that_ = 163;
Constant I257_libmsg__cannot_travel_i = 164;
Constant I258_libmsg__cannot_go_throu = 165;
Constant I259_libmsg__cannot_go_up_th = 166;
Constant I260_libmsg__cannot_go_down_ = 167;
Constant I261_libmsg__cannot_go_throu = 168;
Constant I262_libmsg__nothing_through = 169;
Constant I263_libmsg__block_vaguely_g = 170;
Constant I264_libmsg__say_npc_goes_ = 171;
Constant I265_libmsg__say_npc_arrives = 172;
Constant I266_libmsg__say_npc_arrives = 173;
Constant I267_libmsg__say_npc_arrives = 174;
Constant I268_libmsg__say_npc_goes_th = 175;
Constant I269_libmsg__say_npc_arrives = 176;
Constant I270_libmsg__say_npc_vehicle = 177;
Constant I271_libmsg__say_npc_pushing = 178;
Constant I272_libmsg__say_npc_pushing = 179;
Constant I273_libmsg__say_npc_pushing = 180;
Constant I274_libmsg__say_npc_pushing = 181;
Constant I275_libmsg__say_npc_taking_ = 182;
Constant I276_libmsg__brief_look_mode = 183;
Constant I277_libmsg__superbrief_look = 184;
Constant I278_libmsg__verbose_look_mo = 185;
Constant I279_libmsg__report_npc_look = 186;
Constant I280_libmsg__top_line_what_o = 187;
Constant I281_libmsg__top_line_what_i = 188;
Constant I282_libmsg__top_line_what_a = 189;
Constant I283_libmsg__say_things_with = 190;
Constant I284_libmsg__say_things_also = 191;
Constant I285_libmsg__say_things_on_ = 192;
Constant I286_libmsg__report_npc_exam = 193;
Constant I287_libmsg__examine_undescr = 194;
Constant I288_libmsg__examine_directi = 195;
Constant I289_libmsg__examine_devices = 196;
Constant I290_libmsg__examine_in_dark = 197;
Constant I291_libmsg__report_npc_sear = 198;
Constant I292_libmsg__cannot_search_u = 199;
Constant I293_libmsg__cannot_search_c = 200;
Constant I294_libmsg__nothing_found_w = 201;
Constant I295_libmsg__nothing_found_o = 202;
Constant I296_libmsg__search_in_darkn = 203;
Constant I297_libmsg__report_npc_look = 204;
Constant I298_libmsg__look_under_ = 205;
Constant I299_libmsg__look_under_in_d = 206;
Constant I300_libmsg__report_player_o = 207;
Constant I301_libmsg__report_npc_open = 208;
Constant I302_libmsg__report_unseen_n = 209;
Constant I303_libmsg__cannot_open_unl = 210;
Constant I304_libmsg__cannot_open_som = 211;
Constant I305_libmsg__cannot_open_som = 212;
Constant I306_libmsg__reveal_any_newl = 213;
Constant I307_libmsg__no_newly_visibl = 214;
Constant I308_libmsg__report_player_c = 215;
Constant I309_libmsg__report_npc_clos = 216;
Constant I310_libmsg__report_unseen_n = 217;
Constant I311_libmsg__cannot_close_un = 218;
Constant I312_libmsg__cannot_close_so = 219;
Constant I313_libmsg__report_player_l = 220;
Constant I314_libmsg__report_npc_lock = 221;
Constant I315_libmsg__cannot_lock_wit = 222;
Constant I316_libmsg__cannot_lock_som = 223;
Constant I317_libmsg__cannot_lock_som = 224;
Constant I318_libmsg__cannot_lock_wit = 225;
Constant I319_libmsg__report_player_u = 226;
Constant I320_libmsg__report_npc_unlo = 227;
Constant I321_libmsg__cannot_unlock_w = 228;
Constant I322_libmsg__cannot_unlock_s = 229;
Constant I323_libmsg__cannot_unlock_w = 230;
Constant I324_libmsg__report_player_s = 231;
Constant I325_libmsg__report_npc_swit = 232;
Constant I326_libmsg__cannot_switch_o = 233;
Constant I327_libmsg__cannot_switch_o = 234;
Constant I328_libmsg__report_player_s = 235;
Constant I329_libmsg__report_npc_swit = 236;
Constant I330_libmsg__cannot_switch_o = 237;
Constant I331_libmsg__cannot_switch_o = 238;
Constant I332_libmsg__report_player_w = 239;
Constant I333_libmsg__report_npc_wear = 240;
Constant I334_libmsg__cannot_wear_som = 241;
Constant I335_libmsg__cannot_wear_not = 242;
Constant I336_libmsg__cannot_wear_som = 243;
Constant I337_libmsg__report_player_t = 244;
Constant I338_libmsg__report_npc_taki = 245;
Constant I339_libmsg__cannot_take_off = 246;
Constant I340_libmsg__report_player_e = 247;
Constant I341_libmsg__report_npc_eati = 248;
Constant I342_libmsg__cannot_eat_unle = 249;
Constant I343_libmsg__block_drinking_ = 250;
Constant I344_libmsg__block_tasting_ = 251;
Constant I345_libmsg__block_smelling_ = 252;
Constant I346_libmsg__block_listening = 253;
Constant I347_libmsg__report_player_t = 254;
Constant I348_libmsg__report_npc_touc = 255;
Constant I349_libmsg__report_player_t = 256;
Constant I350_libmsg__report_npc_touc = 257;
Constant I351_libmsg__report_player_t = 258;
Constant I352_libmsg__report_npc_touc = 259;
Constant I353_libmsg__block_saying_ye = 260;
Constant I354_libmsg__block_saying_no = 261;
Constant I355_libmsg__block_saying_so = 262;
Constant I356_libmsg__block_swearing_ = 263;
Constant I357_libmsg__block_swearing_ = 264;
Constant I358_libmsg__block_climbing_ = 265;
Constant I359_libmsg__block_jumping_ = 266;
Constant I360_libmsg__block_swinging_ = 267;
Constant I361_libmsg__block_waving_ha = 268;
Constant I362_libmsg__block_attacking = 269;
Constant I363_libmsg__block_burning_ = 270;
Constant I364_libmsg__block_cutting_ = 271;
Constant I365_libmsg__block_rubbing_ = 272;
Constant I366_libmsg__block_setting_t = 273;
Constant I367_libmsg__block_tying_ = 274;
Constant I368_libmsg__report_player_w = 275;
Constant I369_libmsg__report_npc_wavi = 276;
Constant I370_libmsg__cannot_wave_som = 277;
Constant I371_libmsg__squeezing_peopl = 278;
Constant I372_libmsg__report_player_s = 279;
Constant I373_libmsg__report_npc_sque = 280;
Constant I374_libmsg__block_throwing_ = 281;
Constant I375_libmsg__throw_at_inanim = 282;
Constant I376_libmsg__report_player_p = 283;
Constant I377_libmsg__report_npc_push = 284;
Constant I378_libmsg__report_player_p = 285;
Constant I379_libmsg__report_npc_pull = 286;
Constant I380_libmsg__report_player_t = 287;
Constant I381_libmsg__report_npc_turn = 288;
Constant I382_libmsg__block_pushing_i = 289;
Constant I383_libmsg__not_pushed_in_a = 290;
Constant I384_libmsg__pushed_in_illeg = 291;
Constant I385_libmsg__cannot_push_som = 292;
Constant I386_libmsg__cannot_pull_som = 293;
Constant I387_libmsg__cannot_turn_som = 294;
Constant I388_libmsg__cannot_push_sce = 295;
Constant I389_libmsg__cannot_pull_sce = 296;
Constant I390_libmsg__cannot_turn_sce = 297;
Constant I391_libmsg__cannot_push_peo = 298;
Constant I392_libmsg__cannot_pull_peo = 299;
Constant I393_libmsg__cannot_turn_peo = 300;
Constant I394_libmsg__block_answering = 301;
Constant I395_libmsg__block_asking_ = 302;
Constant I396_libmsg__block_buying_ = 303;
Constant I397_libmsg__block_kissing_ = 304;
Constant I398_libmsg__block_singing_ = 305;
Constant I399_libmsg__block_telling_ = 306;
Constant I400_libmsg__telling_yoursel = 307;
Constant I401_libmsg__block_thinking_ = 308;
Constant I402_libmsg__block_player_co = 309;
Constant I403_libmsg__block_npc_consu = 310;
Constant I404_libmsg__block_sleeping_ = 311;
Constant I405_libmsg__block_waking_up = 312;
Constant I406_libmsg__block_waking_ot = 313;
Constant I407_libmsg__report_player_w = 314;
Constant I408_libmsg__report_npc_wait = 315;
Constant I424_first_pump = 2;
Constant I425_lever_action = 3;
Constant I426_gizmo_action = 4;
Constant I427_gadget_action = 5;
Constant I428_hose_action = 6;
Constant I429_second_pump = 7;
Constant I430_third_pump = 8;
Constant I431_conductor_s_story = 9;
Constant I432_fourth_pump = 10;
Constant I436_clean_water = 1;
Constant I437_pond_water = 2;
Constant I556_indigo = 1;
Constant I557_crimson = 2;
Constant I558_ochre = 3;
Constant I559_saffron = 4;
Constant I560_tyrian_purple = 5;
Constant I611_secretary_s_story = 11;
Constant I674_vivian_s_story = 12;
Constant I695_endgame = 13;
Constant I704_switch_action = 14;
Array Global_Vars -->
  (false) ! 7
  (SC_166) ! 24
  (SC_3) ! 29
  (SC_2) ! 30
  (SC_167) ! 31
  (SC_168) ! 32
  (1) ! 33
  (2011) ! 34
  (0) ! 43
  (I439_steam_train) ! 51
  (selfobj) ! 52
  (selfobj) ! 53
  (0) ! 54
  (false) ! 55
  (false) ! 56
  (I94_libmsg__you_have_died_) ! 57
  (0) ! 58
  (nothing) ! 59
  (nothing) ! 60
  (selfobj) ! 61
  (T8_ordinary_status) ! 62
  (14) ! 63
  (EMPTY_TEXT_VALUE) ! 64
;
Array V2V_Bitmap_69 --> IK1_Count IK1_Count 
  27 ! Number of left instances
  27 ! Number of right instances
    PrintShortName ! To print left instances
  PrintShortName ! To print right instances
  true ! Cache broken flag
  V2V_Route_Cache_69 ! Cache array (if any)
$0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 $0000 ;
Constant V2V_Route_Cache_69 = 0;



Array T0_final_question_options table  tab_0_0 tab_0_1 tab_0_2 tab_0_3 tab_0_4;
Array tab_0_0 table $0064 0  (SC_169)  (SC_170)  (SC_171)  (SC_172)  (SC_173) ;
Array tab_0_1 table $0465 1  (0)  (0)  (1)  (0)  (0) ;
Array tab_0_2 table $2066 2  (Consult_Grammar_270)  (Consult_Grammar_271)  (Consult_Grammar_272)  (Consult_Grammar_273)  (Consult_Grammar_274) ;
Array tab_0_3 table $0067 3  (IMMEDIATELY_RESTART_VM_R)  (IMMEDIATELY_RESTORE_SAVED_R)  TABLE_NOVALUE (IMMEDIATELY_QUIT_R)  (IMMEDIATELY_UNDO_R) ;
Array tab_0_4 table $0068 4  TABLE_NOVALUE TABLE_NOVALUE (V26_amusing_a_victorious_pla)  TABLE_NOVALUE TABLE_NOVALUE;
Array T1_locale_priorities table  tab_1_0 tab_1_1;
Array tab_1_0 table $0869 NULL  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_1_1 table $446a 5  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T2_small_kindnesses_response table  tab_2_0 tab_2_1;
Array tab_2_0 table $006b 36  (R_762)  (R_755)  (R_756)  (R_757) ;
Array tab_2_1 table $006c 37  (text_routine_90)  (text_routine_91)  (text_routine_92)  (text_routine_93) ;
Array T4_recent_items table  tab_4_0 tab_4_1;
Array tab_4_0 table $086d NULL  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array tab_4_1 table $446e 38  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T5_disambiguation_messages table  tab_5_0 tab_5_1;
Array tab_5_0 table $446f 40  (1)  (2)  (3)  (4)  (5)  (6)  (7)  (8)  (9)  (10)  (11)  (12)  (20)  (21)  (22) ;
Array tab_5_1 table $0070 42  (SC_174)  (text_routine_94)  (text_routine_95)  (text_routine_96)  (text_routine_97)  (text_routine_98)  (text_routine_99)  (text_routine_100)  (text_routine_101)  (text_routine_102)  (text_routine_103)  (SC_175)  (SC_176)  (SC_177)  (SC_178) ;
Array T6_custom_library_messages table  tab_6_0 tab_6_1;
Array tab_6_0 table $4c71 NULL  TABLE_NOVALUE (I97_libmsg__unimportant_obje)  (I98_libmsg__empty_line_)  (I125_libmsg__unknown_object_)  (I206_libmsg__cannot_exceed_c)  (I160_libmsg__person_ignores_)  (I187_libmsg__entering_darkne)  (I188_libmsg__dark_descriptio)  (I189_libmsg__examine_while_d)  (I190_libmsg__search_while_da)  (I191_libmsg__look_under_whil)  (I192_libmsg__dark_room_name_)  (I195_libmsg__cannot_take_you)  (I342_libmsg__cannot_eat_unle)  (I358_libmsg__block_climbing_)  (I405_libmsg__block_waking_up)  (I407_libmsg__report_player_w)  (I355_libmsg__block_saying_so)  (I362_libmsg__block_attacking)  (I204_libmsg__cannot_take_som)  (I203_libmsg__cannot_take_sce)  (I358_libmsg__block_climbing_)  (I365_libmsg__block_rubbing_)  (I372_libmsg__report_player_s)  (I230_libmsg__cannot_put_onto) ;
Array tab_6_1 table $0070 44  TABLE_NOVALUE (text_routine_104)  (text_routine_105)  (text_routine_106)  (text_routine_107)  (text_routine_108)  (text_routine_109)  (text_routine_110)  (text_routine_111)  (text_routine_112)  (text_routine_113)  (SC_179)  (text_routine_114)  (text_routine_115)  (text_routine_116)  (text_routine_117)  (text_routine_118)  (text_routine_119)  (text_routine_120)  (text_routine_121)  (text_routine_122)  (text_routine_123)  (SC_180)  (SC_180)  (text_routine_124) ;
Array T7_library_messages table  tab_7_0 tab_7_1;
Array tab_7_0 table $5c71 NULL  (I94_libmsg__you_have_died_)  (I95_libmsg__you_have_won_)  (I96_libmsg__player_self_desc)  (I97_libmsg__unimportant_obje)  (I98_libmsg__empty_line_)  (I99_libmsg__confirm_quit_)  (I100_libmsg__yes_or_no_promp)  (I101_libmsg__restrict_answer)  (I102_libmsg__page_prompt_)  (I103_libmsg__menu_prompt_)  (I104_libmsg__comment_recorde)  (I105_libmsg__comment_not_rec)  (I106_libmsg__undo_succeeded_)  (I107_libmsg__undo_failed_)  (I108_libmsg__undo_not_provid)  (I109_libmsg__cannot_undo_not)  (I110_libmsg__cannot_undo_twi)  (I111_libmsg__undo_forbidden_)  (I112_libmsg__oops_failed_)  (I113_libmsg__oops_too_many_a)  (I114_libmsg__oops_no_argumen)  (I115_libmsg__cannot_do_again)  (I116_libmsg__again_usage_)  (I117_libmsg__command_not_und)  (I118_libmsg__command_partly_)  (I119_libmsg__command_badly_e)  (I120_libmsg__command_incompl)  (I121_libmsg__command_cut_sho)  (I122_libmsg__number_not_unde)  (I123_libmsg__cannot_begin_at)  (I124_libmsg__extra_words_bef)  (I125_libmsg__unknown_object_)  (I126_libmsg__object_not_held)  (I127_libmsg__unknown_verb_)  (I128_libmsg__verb_cannot_hav)  (I129_libmsg__noun_needed_)  (I130_libmsg__noun_not_needed)  (I131_libmsg__object_needed_)  (I132_libmsg__object_not_need)  (I133_libmsg__second_object_n)  (I134_libmsg__second_object_n)  (I135_libmsg__second_noun_nee)  (I136_libmsg__second_noun_not)  (I137_libmsg__something_more_)  (I138_libmsg__verb_cannot_hav)  (I139_libmsg__too_many_multip)  (I140_libmsg__not_that_many_a)  (I141_libmsg__no_objects_avai)  (I142_libmsg__zero_multiple_o)  (I143_libmsg__first_n_objects)  (I144_libmsg__excepted_object)  (I145_libmsg__report_implicit)  (I146_libmsg__report_npc_impl)  (I147_libmsg__use_holdall_to_)  (I148_libmsg__cannot_put_if_t)  (I149_libmsg__who_disambiguat)  (I150_libmsg__which_disambigu)  (I151_libmsg__whom_disambigua)  (I152_libmsg__what_disambigua)  (I153_libmsg__single_object_d)  (I154_libmsg__pronoun_not_set)  (I155_libmsg__pronoun_absent_)  (I156_libmsg__pronouns_initia)  (I157_libmsg__pronouns__means)  (I158_libmsg__pronouns__unset)  (I159_libmsg__no_pronouns_kno)  (I160_libmsg__person_ignores_)  (I161_libmsg__cannot_talk_to_)  (I162_libmsg__cannot_talk_to_)  (I163_libmsg__npc_unable_to_d)  (I164_libmsg__confirm_restart)  (I165_libmsg__restart_failed_)  (I166_libmsg__restore_failed_)  (I167_libmsg__restore_succeed)  (I168_libmsg__save_failed_)  (I169_libmsg__save_succeeded_)  (I170_libmsg__verify_succeede)  (I171_libmsg__verify_failed_)  (I172_libmsg__transcript_alre)  (I173_libmsg__transcript_alre)  (I174_libmsg__start_of_transc)  (I175_libmsg__end_of_transcri)  (I176_libmsg__transcript_fail)  (I177_libmsg__end_transcript_)  (I178_libmsg__score_command_)  (I179_libmsg__score_changed_)  (I180_libmsg__score_notificat)  (I181_libmsg__score_notificat)  (I182_libmsg__no_scoring_)  (I183_libmsg__score_rank_)  (I184_libmsg__report_npc_taki)  (I185_libmsg__inventory_initi)  (I186_libmsg__inventory_no_po)  (I187_libmsg__entering_darkne)  (I188_libmsg__dark_descriptio)  (I189_libmsg__examine_while_d)  (I190_libmsg__search_while_da)  (I191_libmsg__look_under_whil)  (I192_libmsg__dark_room_name_)  (I193_libmsg__report_player_t)  (I194_libmsg__report_npc_taki)  (I195_libmsg__cannot_take_you)  (I196_libmsg__cannot_take_oth)  (I197_libmsg__cannot_take_som)  (I198_libmsg__cannot_take_som)  (I199_libmsg__cannot_take_pos)  (I200_libmsg__cannot_take_com)  (I201_libmsg__cannot_take_hid)  (I202_libmsg__cannot_reach_wi)  (I203_libmsg__cannot_take_sce)  (I204_libmsg__cannot_take_som)  (I205_libmsg__cannot_reach_wi)  (I206_libmsg__cannot_exceed_c)  (I207_libmsg__report_player_r)  (I208_libmsg__report_npc_remo)  (I209_libmsg__cannot_remove_f)  (I210_libmsg__cannot_remove_s)  (I211_libmsg__report_player_d)  (I212_libmsg__report_npc_drop)  (I213_libmsg__cannot_drop_som)  (I214_libmsg__cannot_drop_not)  (I215_libmsg__cannot_drop_if_)  (I216_libmsg__cannot_drop_clo)  (I217_libmsg__report_player_i)  (I218_libmsg__report_npc_inse)  (I219_libmsg__cannot_insert_s)  (I220_libmsg__cannot_insert_i)  (I221_libmsg__cannot_insert_i)  (I222_libmsg__need_to_take_of)  (I223_libmsg__cannot_insert_s)  (I224_libmsg__cannot_insert_i)  (I225_libmsg__cannot_insert_c)  (I226_libmsg__report_player_p)  (I227_libmsg__report_npc_putt)  (I228_libmsg__cannot_put_some)  (I229_libmsg__cannot_put_some)  (I230_libmsg__cannot_put_onto)  (I231_libmsg__cannot_put_onto)  (I232_libmsg__cannot_put_clot)  (I233_libmsg__report_player_g)  (I234_libmsg__report_npc_givi)  (I235_libmsg__report_npc_givi)  (I236_libmsg__cannot_give_wha)  (I237_libmsg__cannot_give_to_)  (I238_libmsg__block_giving_)  (I239_libmsg__unable_to_recei)  (I240_libmsg__cannot_show_wha)  (I241_libmsg__block_showing_)  (I242_libmsg__report_player_e)  (I243_libmsg__report_npc_ente)  (I244_libmsg__cannot_enter_so)  (I245_libmsg__cannot_enter_so)  (I246_libmsg__cannot_enter_cl)  (I247_libmsg__cannot_enter_so)  (I248_libmsg__implicitly_pass)  (I249_libmsg__implicitly_pass)  (I250_libmsg__report_player_e)  (I251_libmsg__report_npc_exit)  (I252_libmsg__cannot_exit_whe)  (I253_libmsg__cannot_exit_clo)  (I254_libmsg__cannot_get_off_)  (I255_libmsg__cannot_exit_thi)  (I256_libmsg__cannot_go_that_)  (I257_libmsg__cannot_travel_i)  (I258_libmsg__cannot_go_throu)  (I259_libmsg__cannot_go_up_th)  (I260_libmsg__cannot_go_down_)  (I261_libmsg__cannot_go_throu)  (I262_libmsg__nothing_through)  (I263_libmsg__block_vaguely_g)  (I264_libmsg__say_npc_goes_)  (I265_libmsg__say_npc_arrives)  (I266_libmsg__say_npc_arrives)  (I267_libmsg__say_npc_arrives)  (I268_libmsg__say_npc_goes_th)  (I269_libmsg__say_npc_arrives)  (I270_libmsg__say_npc_vehicle)  (I271_libmsg__say_npc_pushing)  (I272_libmsg__say_npc_pushing)  (I273_libmsg__say_npc_pushing)  (I274_libmsg__say_npc_pushing)  (I275_libmsg__say_npc_taking_)  (I276_libmsg__brief_look_mode)  (I277_libmsg__superbrief_look)  (I278_libmsg__verbose_look_mo)  (I279_libmsg__report_npc_look)  (I280_libmsg__top_line_what_o)  (I281_libmsg__top_line_what_i)  (I282_libmsg__top_line_what_a)  (I283_libmsg__say_things_with)  (I284_libmsg__say_things_also)  (I285_libmsg__say_things_on_)  (I286_libmsg__report_npc_exam)  (I287_libmsg__examine_undescr)  (I288_libmsg__examine_directi)  (I289_libmsg__examine_devices)  (I290_libmsg__examine_in_dark)  (I291_libmsg__report_npc_sear)  (I292_libmsg__cannot_search_u)  (I293_libmsg__cannot_search_c)  (I294_libmsg__nothing_found_w)  (I295_libmsg__nothing_found_o)  (I296_libmsg__search_in_darkn)  (I297_libmsg__report_npc_look)  (I298_libmsg__look_under_)  (I299_libmsg__look_under_in_d)  (I300_libmsg__report_player_o)  (I301_libmsg__report_npc_open)  (I302_libmsg__report_unseen_n)  (I303_libmsg__cannot_open_unl)  (I304_libmsg__cannot_open_som)  (I305_libmsg__cannot_open_som)  (I306_libmsg__reveal_any_newl)  (I307_libmsg__no_newly_visibl)  (I308_libmsg__report_player_c)  (I309_libmsg__report_npc_clos)  (I310_libmsg__report_unseen_n)  (I311_libmsg__cannot_close_un)  (I312_libmsg__cannot_close_so)  (I313_libmsg__report_player_l)  (I314_libmsg__report_npc_lock)  (I315_libmsg__cannot_lock_wit)  (I316_libmsg__cannot_lock_som)  (I317_libmsg__cannot_lock_som)  (I318_libmsg__cannot_lock_wit)  (I319_libmsg__report_player_u)  (I320_libmsg__report_npc_unlo)  (I321_libmsg__cannot_unlock_w)  (I322_libmsg__cannot_unlock_s)  (I323_libmsg__cannot_unlock_w)  (I324_libmsg__report_player_s)  (I325_libmsg__report_npc_swit)  (I326_libmsg__cannot_switch_o)  (I327_libmsg__cannot_switch_o)  (I328_libmsg__report_player_s)  (I329_libmsg__report_npc_swit)  (I330_libmsg__cannot_switch_o)  (I331_libmsg__cannot_switch_o)  (I332_libmsg__report_player_w)  (I333_libmsg__report_npc_wear)  (I334_libmsg__cannot_wear_som)  (I335_libmsg__cannot_wear_not)  (I336_libmsg__cannot_wear_som)  (I337_libmsg__report_player_t)  (I338_libmsg__report_npc_taki)  (I339_libmsg__cannot_take_off)  (I340_libmsg__report_player_e)  (I341_libmsg__report_npc_eati)  (I342_libmsg__cannot_eat_unle)  (I343_libmsg__block_drinking_)  (I344_libmsg__block_tasting_)  (I345_libmsg__block_smelling_)  (I346_libmsg__block_listening)  (I347_libmsg__report_player_t)  (I348_libmsg__report_npc_touc)  (I349_libmsg__report_player_t)  (I350_libmsg__report_npc_touc)  (I351_libmsg__report_player_t)  (I352_libmsg__report_npc_touc)  (I353_libmsg__block_saying_ye)  (I354_libmsg__block_saying_no)  (I355_libmsg__block_saying_so)  (I356_libmsg__block_swearing_)  (I357_libmsg__block_swearing_)  (I358_libmsg__block_climbing_)  (I359_libmsg__block_jumping_)  (I360_libmsg__block_swinging_)  (I361_libmsg__block_waving_ha)  (I362_libmsg__block_attacking)  (I363_libmsg__block_burning_)  (I364_libmsg__block_cutting_)  (I365_libmsg__block_rubbing_)  (I366_libmsg__block_setting_t)  (I367_libmsg__block_tying_)  (I368_libmsg__report_player_w)  (I369_libmsg__report_npc_wavi)  (I370_libmsg__cannot_wave_som)  (I371_libmsg__squeezing_peopl)  (I372_libmsg__report_player_s)  (I373_libmsg__report_npc_sque)  (I374_libmsg__block_throwing_)  (I375_libmsg__throw_at_inanim)  (I376_libmsg__report_player_p)  (I377_libmsg__report_npc_push)  (I378_libmsg__report_player_p)  (I379_libmsg__report_npc_pull)  (I380_libmsg__report_player_t)  (I381_libmsg__report_npc_turn)  (I382_libmsg__block_pushing_i)  (I383_libmsg__not_pushed_in_a)  (I384_libmsg__pushed_in_illeg)  (I385_libmsg__cannot_push_som)  (I386_libmsg__cannot_pull_som)  (I387_libmsg__cannot_turn_som)  (I388_libmsg__cannot_push_sce)  (I389_libmsg__cannot_pull_sce)  (I390_libmsg__cannot_turn_sce)  (I391_libmsg__cannot_push_peo)  (I392_libmsg__cannot_pull_peo)  (I393_libmsg__cannot_turn_peo)  (I394_libmsg__block_answering)  (I395_libmsg__block_asking_)  (I396_libmsg__block_buying_)  (I397_libmsg__block_kissing_)  (I398_libmsg__block_singing_)  (I399_libmsg__block_telling_)  (I400_libmsg__telling_yoursel)  (I401_libmsg__block_thinking_)  (I402_libmsg__block_player_co)  (I403_libmsg__block_npc_consu)  (I404_libmsg__block_sleeping_)  (I405_libmsg__block_waking_up)  (I406_libmsg__block_waking_ot)  (I407_libmsg__report_player_w)  (I408_libmsg__report_npc_wait) ;
Array tab_7_1 table $1070 48  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181)  (SC_181) ;
Array T8_ordinary_status table  tab_8_0 tab_8_1 tab_8_2;
Array tab_8_0 table $0072 88  (text_routine_125) ;
Array tab_8_1 table $0073 89  (EMPTY_TEXT_VALUE) ;
Array tab_8_2 table $0074 90  (text_routine_126) ;
Array T10_further_conductor_s_comm table  tab_10_0 tab_10_1;
Array tab_10_0 table $2066 91  (Consult_Grammar_275)  (Consult_Grammar_276)  (Consult_Grammar_277)  (Consult_Grammar_278)  (Consult_Grammar_279)  (Consult_Grammar_280)  (Consult_Grammar_281)  (Consult_Grammar_282)  (Consult_Grammar_283) ;
Array tab_10_1 table $0075 93  (text_routine_127)  (SC_182)  (text_routine_128)  (text_routine_129)  (text_routine_130)  (text_routine_131)  (text_routine_132)  (SC_183)  (text_routine_133) ;
Array T11_tasks_achieved table  tab_11_0 tab_11_1 tab_11_2;
Array tab_11_0 table $4476 95  (5)  (5)  (2)  (2)  (2)  (2)  (2)  (5)  (5)  (2)  (10)  (3)  (5)  (3)  (10)  (10)  (5)  (10)  (2)  (5)  (5) ;
Array tab_11_1 table $0077 98  (SC_184)  (SC_185)  (SC_186)  (SC_187)  (SC_188)  (SC_189)  (SC_190)  (SC_191)  (SC_192)  (SC_193)  (SC_194)  (SC_195)  (SC_196)  (SC_197)  (SC_198)  (SC_199)  (SC_200)  (SC_201)  (SC_202)  (SC_203)  (SC_204) ;
Array tab_11_2 table $446e 101  TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE TABLE_NOVALUE;
Array T12_pond_descriptions table  tab_12_0 tab_12_1;
Array tab_12_0 table $0878 NULL  (I447_outside_waterworks)  (I468_muddy_beach)  (I441_hill)  (I442_in_the_sweetgum_tree)  (I469_atop_the_tank)  (I474_sandy_beach)  (I470_rocky_beach)  (I494_other_side_of_the_pond)  (I504_weedy_island)  (I464_grassy_shore)  (I465_spireland)  (I466_floating_on_the_pond)  (I439_steam_train) ;
Array tab_12_1 table $0079 104  (SC_205)  (text_routine_134)  (text_routine_135)  (text_routine_136)  (SC_206)  (SC_207)  (SC_208)  (text_routine_137)  (SC_209)  (SC_210)  (SC_211)  (SC_212)  (SC_213) ;
Array T13_further_secretary_s_comm table  tab_13_0 tab_13_1 tab_13_2;
Array tab_13_0 table $447a 106  (1)  (1)  TABLE_NOVALUE (1)  (1)  (1) ;
Array tab_13_1 table $2066 107  (Consult_Grammar_284)  (Consult_Grammar_285)  (Consult_Grammar_286)  (Consult_Grammar_287)  (Consult_Grammar_288)  (Consult_Grammar_289) ;
Array tab_13_2 table $0075 108  (text_routine_138)  (text_routine_139)  (SC_214)  (text_routine_140)  (text_routine_141)  (text_routine_142) ;
Array T14_secretary_s_commentary table  tab_14_0 tab_14_1;
Array tab_14_0 table $2066 109  (Consult_Grammar_290)  (Consult_Grammar_291)  (Consult_Grammar_292)  (Consult_Grammar_293)  (Consult_Grammar_294)  (Consult_Grammar_295)  (Consult_Grammar_296)  (Consult_Grammar_297)  (Consult_Grammar_298)  (Consult_Grammar_299)  (Consult_Grammar_300)  (Consult_Grammar_301)  (Consult_Grammar_302)  (Consult_Grammar_303)  (Consult_Grammar_304)  (Consult_Grammar_305)  (Consult_Grammar_306)  (Consult_Grammar_307)  (Consult_Grammar_308)  (Consult_Grammar_309)  (Consult_Grammar_310)  (Consult_Grammar_311)  (Consult_Grammar_312)  (Consult_Grammar_313)  (Consult_Grammar_314)  (Consult_Grammar_315)  (Consult_Grammar_316)  (Consult_Grammar_317)  (Consult_Grammar_318)  (Consult_Grammar_319)  (Consult_Grammar_320)  (Consult_Grammar_321)  (Consult_Grammar_322)  (Consult_Grammar_323)  (Consult_Grammar_324)  (Consult_Grammar_325)  (Consult_Grammar_326)  (Consult_Grammar_327)  (Consult_Grammar_328)  (Consult_Grammar_329)  (Consult_Grammar_330)  (Consult_Grammar_331)  (Consult_Grammar_332)  (Consult_Grammar_333)  (Consult_Grammar_334)  (Consult_Grammar_335)  (Consult_Grammar_336) ;
Array tab_14_1 table $0075 115  (text_routine_143)  (text_routine_144)  (text_routine_145)  (text_routine_146)  (text_routine_147)  (text_routine_148)  (text_routine_149)  (text_routine_150)  (text_routine_151)  (text_routine_152)  (text_routine_153)  (text_routine_154)  (text_routine_155)  (SC_215)  (text_routine_156)  (SC_216)  (text_routine_157)  (text_routine_158)  (text_routine_159)  (text_routine_160)  (text_routine_161)  (text_routine_162)  (text_routine_163)  (text_routine_164)  (text_routine_165)  (text_routine_166)  (text_routine_167)  (text_routine_168)  (text_routine_169)  (text_routine_170)  (text_routine_171)  (text_routine_172)  (text_routine_173)  (text_routine_174)  (text_routine_175)  (text_routine_176)  (text_routine_177)  (text_routine_178)  (text_routine_179)  (text_routine_180)  (text_routine_181)  (text_routine_182)  (text_routine_183)  (text_routine_184)  (text_routine_185)  (text_routine_186)  (text_routine_187) ;
Array T15_vivian --> 1 tab_15_0;
Array tab_15_0 table $007b 121  (text_routine_188)  (SC_217)  (SC_218)  (text_routine_189)  (SC_219) ;
Array T16_endgame_events --> 1 tab_16_0;
Array tab_16_0 table $007b 122  (text_routine_190)  (SC_220)  (text_routine_191)  (text_routine_192)  (text_routine_193)  (SC_221)  (text_routine_194) ;
Array T17_conductor_s_commentary table  tab_17_0 tab_17_1;
Array tab_17_0 table $2066 123  (Consult_Grammar_337)  (Consult_Grammar_338)  (Consult_Grammar_339)  (Consult_Grammar_340)  (Consult_Grammar_341)  (Consult_Grammar_342)  (Consult_Grammar_343)  (Consult_Grammar_344)  (Consult_Grammar_345)  (Consult_Grammar_346)  (Consult_Grammar_347)  (Consult_Grammar_348)  (Consult_Grammar_349)  (Consult_Grammar_350)  (Consult_Grammar_351)  (Consult_Grammar_352)  (Consult_Grammar_353)  (Consult_Grammar_354)  (Consult_Grammar_355)  (Consult_Grammar_356)  (Consult_Grammar_357)  (Consult_Grammar_358)  (Consult_Grammar_359)  (Consult_Grammar_360)  (Consult_Grammar_361)  (Consult_Grammar_362)  (Consult_Grammar_363)  (Consult_Grammar_364)  (Consult_Grammar_365) ;
Array tab_17_1 table $0075 127  (text_routine_195)  (text_routine_196)  (text_routine_197)  (text_routine_198)  (text_routine_199)  (text_routine_200)  (text_routine_201)  (text_routine_202)  (text_routine_203)  (text_routine_204)  (text_routine_205)  (SC_222)  (text_routine_206)  (text_routine_207)  (text_routine_208)  (SC_223)  (text_routine_209)  (SC_224)  (text_routine_210)  (text_routine_211)  (text_routine_212)  (text_routine_213)  (text_routine_214)  (text_routine_215)  (text_routine_216)  (text_routine_217)  (text_routine_218)  (text_routine_219)  (text_routine_220) ;
Array TB_Blanks -> 
  ! For table T0_final_question_options
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  $04  ! Column 3
  $1b  ! Column 4
  
  ! For table T1_locale_priorities
  $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $ff $03  ! Column 1
  
  ! For table T2_small_kindnesses_response
  $00  ! Column 0
  $00  ! Column 1
  
  ! For table T4_recent_items
  $ff $ff  ! Column 1
  
  ! For table T5_disambiguation_messages
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T6_custom_library_messages
  $01 $00 $00 $00  ! Column 1
  
  ! For table T7_library_messages
  $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00  ! Column 1
  
  ! For table T8_ordinary_status
  $00  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T10_further_conductor_s_comm
  $00 $00  ! Column 0
  $00 $00  ! Column 1
  
  ! For table T11_tasks_achieved
  $00 $00 $00  ! Column 0
  $00 $00 $00  ! Column 1
  $ff $ff $1f  ! Column 2
  
  ! For table T12_pond_descriptions
  $00 $00  ! Column 1
  
  ! For table T13_further_secretary_s_comm
  $04  ! Column 0
  $00  ! Column 1
  $00  ! Column 2
  
  ! For table T14_secretary_s_commentary
  $00 $00 $00 $00 $00 $00  ! Column 0
  $00 $00 $00 $00 $00 $00  ! Column 1
  
  ! For table T15_vivian
  $00  ! Column 0
  
  ! For table T16_endgame_events
  $00  ! Column 0
  
  ! For table T17_conductor_s_commentary
  $00 $00 $00 $00  ! Column 0
  $00 $00 $00 $00  ! Column 1
  
  ! End of table
  NULL NULL;
[ TC_KOV tc;
    switch (tc) {
        100: return TEXT_TY; ! final question wording: text
        101: return TRUTH_STATE_TY; ! only if victorious: truth state
        102: return UNDERSTANDING_TY; ! topic: topic
        103: return KD1_values_based_rule_producin; ! final response rule: values based rule producing values
        104: return KD2_activity; ! final response activity: activity
        105: return OBJECT_TY; ! notable-object: object
        106: return NUMBER_TY; ! locale description priority: number
        107: return KD1_values_based_rule_producin; ! rule name: values based rule producing values
        108: return TEXT_TY; ! message: text
        109: return OBJECT_TY; ! recent item: object
        110: return TIME_TY; ! time: time
        111: return NUMBER_TY; ! message-id: number
        112: return TEXT_TY; ! message text: text
        113: return 44; ! message id: library message id
        114: return TEXT_TY; ! left: text
        115: return TEXT_TY; ! central: text
        116: return TEXT_TY; ! right: text
        117: return TEXT_TY; ! commentary: text
        118: return NUMBER_TY; ! points: number
        119: return TEXT_TY; ! citation: text
        120: return 9; ! room name: room
        121: return TEXT_TY; ! description: text
        122: return NUMBER_TY; ! say-value: number
        123: return TEXT_TY; ! event: text
    }
    return UNKNOWN_TY;
];

Array TableOfTables --> TheEmptyTable T0_final_question_options  T1_locale_priorities  T2_small_kindnesses_response  T4_recent_items  T5_disambiguation_messages  T6_custom_library_messages  T7_library_messages  T8_ordinary_status  T10_further_conductor_s_comm  T11_tasks_achieved  T12_pond_descriptions  T13_further_secretary_s_comm  T14_secretary_s_commentary  T15_vivian  T16_endgame_events  T17_conductor_s_commentary  0 0;






[ NAP_0;
    if ((action ==##Ask) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Tell) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##Answer) && ((noun ofclass K8_person)) && (true)) rtrue;
    if ((action ==##AskFor) && ((noun ofclass K8_person)) && ((second ofclass K2_thing))) rtrue;
    rfalse;
];


Array ActionData table
  ##Inv  $$00000000  OBJECT_TY OBJECT_TY  0 20000
  ##Take  $$00001001  OBJECT_TY OBJECT_TY  0 20001
  ##Remove  $$00011011  OBJECT_TY OBJECT_TY  0 20002
  ##Drop  $$00001001  OBJECT_TY OBJECT_TY  0 20003
  ##PutOn  $$00011011  OBJECT_TY OBJECT_TY  0 20004
  ##Insert  $$00011011  OBJECT_TY OBJECT_TY  0 20005
  ##Eat  $$01001001  OBJECT_TY OBJECT_TY  0 20006
  ##Go  $$00001000  OBJECT_TY OBJECT_TY  ANSTVC_7 20007
  ##Enter  $$00001001  OBJECT_TY OBJECT_TY  0 20008
  ##Exit  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_9 20009
  ##GetOff  $$00001001  OBJECT_TY OBJECT_TY  0 20010
  ##Look  $$00000000  OBJECT_TY OBJECT_TY  ANSTVC_11 20011
  ##Examine  $$00001100  OBJECT_TY OBJECT_TY  ANSTVC_12 20012
  ##LookUnder  $$00001100  OBJECT_TY OBJECT_TY  0 20013
  ##Search  $$00001101  OBJECT_TY OBJECT_TY  0 20014
  ##Consult  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20015
  ##Lock  $$10011011  OBJECT_TY OBJECT_TY  0 20016
  ##Unlock  $$10011011  OBJECT_TY OBJECT_TY  0 20017
  ##SwitchOn  $$00001001  OBJECT_TY OBJECT_TY  0 20018
  ##SwitchOff  $$00001001  OBJECT_TY OBJECT_TY  0 20019
  ##Open  $$00001001  OBJECT_TY OBJECT_TY  0 20020
  ##Close  $$00001001  OBJECT_TY OBJECT_TY  0 20021
  ##Wear  $$01001001  OBJECT_TY OBJECT_TY  0 20022
  ##Disrobe  $$01001001  OBJECT_TY OBJECT_TY  0 20023
  ##Give  $$01011011  OBJECT_TY OBJECT_TY  0 20024
  ##Show  $$01011001  OBJECT_TY OBJECT_TY  0 20025
  ##WakeOther  $$00001001  OBJECT_TY OBJECT_TY  0 20026
  ##ThrowAt  $$01011001  OBJECT_TY OBJECT_TY  0 20027
  ##Attack  $$00001001  OBJECT_TY OBJECT_TY  0 20028
  ##Kiss  $$00001001  OBJECT_TY OBJECT_TY  0 20029
  ##Answer  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20030
  ##Tell  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20031
  ##Ask  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20032
  ##AskFor  $$00011011  OBJECT_TY OBJECT_TY  0 20033
  ##Wait  $$00000000  OBJECT_TY OBJECT_TY  0 20034
  ##Touch  $$00001001  OBJECT_TY OBJECT_TY  0 20035
  ##Wave  $$00001001  OBJECT_TY OBJECT_TY  0 20036
  ##Pull  $$00001001  OBJECT_TY OBJECT_TY  0 20037
  ##Push  $$00001001  OBJECT_TY OBJECT_TY  0 20038
  ##Turn  $$00001001  OBJECT_TY OBJECT_TY  0 20039
  ##PushDir  $$00011001  OBJECT_TY OBJECT_TY  0 20040
  ##Squeeze  $$00001001  OBJECT_TY OBJECT_TY  0 20041
  ##Yes  $$00000000  OBJECT_TY OBJECT_TY  0 20042
  ##No  $$00000000  OBJECT_TY OBJECT_TY  0 20043
  ##Burn  $$00001001  OBJECT_TY OBJECT_TY  0 20044
  ##Wake  $$00000000  OBJECT_TY OBJECT_TY  0 20045
  ##Think  $$00000000  OBJECT_TY OBJECT_TY  0 20046
  ##Smell  $$00001001  OBJECT_TY OBJECT_TY  0 20047
  ##Listen  $$00001001  OBJECT_TY OBJECT_TY  0 20048
  ##Taste  $$00001001  OBJECT_TY OBJECT_TY  0 20049
  ##Cut  $$00001001  OBJECT_TY OBJECT_TY  0 20050
  ##Jump  $$00000000  OBJECT_TY OBJECT_TY  0 20051
  ##Tie  $$00011011  OBJECT_TY OBJECT_TY  0 20052
  ##Drink  $$00001001  OBJECT_TY OBJECT_TY  0 20053
  ##Sorry  $$00000000  OBJECT_TY OBJECT_TY  0 20054
  ##Strong  $$00000000  OBJECT_TY OBJECT_TY  0 20055
  ##Mild  $$00000000  OBJECT_TY OBJECT_TY  0 20056
  ##Swing  $$00001001  OBJECT_TY OBJECT_TY  0 20057
  ##Rub  $$00001001  OBJECT_TY OBJECT_TY  0 20058
  ##SetTo  $$00011001  OBJECT_TY UNDERSTANDING_TY  0 20059
  ##WaveHands  $$00000000  OBJECT_TY OBJECT_TY  0 20060
  ##Buy  $$00001001  OBJECT_TY OBJECT_TY  0 20061
  ##Sing  $$00000000  OBJECT_TY OBJECT_TY  0 20062
  ##Climb  $$00001001  OBJECT_TY OBJECT_TY  0 20063
  ##Sleep  $$00000000  OBJECT_TY OBJECT_TY  0 20064
  ##Quit  $$00100000  OBJECT_TY OBJECT_TY  0 20065
  ##Save  $$00100000  OBJECT_TY OBJECT_TY  0 20066
  ##Restore  $$00100000  OBJECT_TY OBJECT_TY  0 20067
  ##Restart  $$00100000  OBJECT_TY OBJECT_TY  0 20068
  ##Verify  $$00100000  OBJECT_TY OBJECT_TY  0 20069
  ##ScriptOn  $$00100000  OBJECT_TY OBJECT_TY  0 20070
  ##ScriptOff  $$00100000  OBJECT_TY OBJECT_TY  0 20071
  ##Version  $$00100000  OBJECT_TY OBJECT_TY  0 20072
  ##Score  $$00100000  OBJECT_TY OBJECT_TY  0 20073
  ##LMode3  $$00100000  OBJECT_TY OBJECT_TY  0 20074
  ##LMode2  $$00100000  OBJECT_TY OBJECT_TY  0 20075
  ##LMode1  $$00100000  OBJECT_TY OBJECT_TY  0 20076
  ##NotifyOn  $$00100000  OBJECT_TY OBJECT_TY  0 20077
  ##NotifyOff  $$00100000  OBJECT_TY OBJECT_TY  0 20078
  ##Pronouns  $$00100000  OBJECT_TY OBJECT_TY  0 20079
  ##A80_retreating  $$00000000  OBJECT_TY OBJECT_TY  0 20080
  ##A81_overly_elaborate_looking  $$00001001  OBJECT_TY OBJECT_TY  0 20081
  ##A82_listing_exits  $$00100000  OBJECT_TY OBJECT_TY  ANSTVC_82 20082
  ##A83_using  $$00001001  OBJECT_TY OBJECT_TY  0 20083
  ##A84_mounting  $$00001001  OBJECT_TY OBJECT_TY  0 20084
  ##A85_dismounting  $$00000000  OBJECT_TY OBJECT_TY  0 20085
  ##A86_unlocking_keylessly  $$00001001  OBJECT_TY OBJECT_TY  0 20086
  ##A87_locking_keylessly  $$00001001  OBJECT_TY OBJECT_TY  0 20087
  ##A88_universal_unlocking  $$00000000  OBJECT_TY OBJECT_TY  0 20088
  ##A89_commenting  $$00101000  UNDERSTANDING_TY OBJECT_TY  0 20089
  ##A90_greeting  $$00001001  OBJECT_TY OBJECT_TY  0 20090
  ##A91_praying  $$00000000  OBJECT_TY OBJECT_TY  0 20091
  ##A92_blowing  $$00001001  OBJECT_TY OBJECT_TY  0 20092
  ##A93_shouting  $$00000000  OBJECT_TY OBJECT_TY  0 20093
  ##A94_facing  $$00001000  OBJECT_TY OBJECT_TY  0 20094
  ##A95_looking_toward  $$00001000  OBJECT_TY OBJECT_TY  0 20095
  ##A96_following  $$00001000  OBJECT_TY OBJECT_TY  0 20096
  ##A97_vehicle_exiting  $$00001001  OBJECT_TY OBJECT_TY  0 20097
  ##A98_supporter_exiting  $$00001001  OBJECT_TY OBJECT_TY  0 20098
  ##A99_liquid_drinking  $$00011010  46 OBJECT_TY  0 20099
  ##A100_filling_it_with  $$00011011  OBJECT_TY OBJECT_TY  0 20100
  ##A101_pouring_it_into  $$00011011  OBJECT_TY OBJECT_TY  0 20101
  ##A102_swimming  $$00000000  OBJECT_TY OBJECT_TY  0 20102
  ##A103_spilling  $$00001001  OBJECT_TY OBJECT_TY  0 20103
  ##A104_boarding  $$00000000  OBJECT_TY OBJECT_TY  0 20104
  ##A105_train_waiting  $$00000000  OBJECT_TY OBJECT_TY  0 20105
  ##A106_waiting_more  $$00001000  NUMBER_TY OBJECT_TY  0 20106
  ##A107_asking_for_help  $$00100000  OBJECT_TY OBJECT_TY  0 20107
  ##A108_crediting  $$00100000  OBJECT_TY OBJECT_TY  0 20108
  ##A109_hinting  $$00100000  OBJECT_TY OBJECT_TY  0 20109
  ##A110_requesting_the_full_sco  $$00100000  OBJECT_TY OBJECT_TY  0 20110
  ##A111_xyzzy  $$00000000  OBJECT_TY OBJECT_TY  0 20111
  ##A112_knocking_on  $$00001001  OBJECT_TY OBJECT_TY  0 20112
  ##A113_wading  $$00000000  OBJECT_TY OBJECT_TY  0 20113
  ##A114_rowing  $$00011010  OBJECT_TY OBJECT_TY  0 20114
  ##A115_dancing  $$00000000  OBJECT_TY OBJECT_TY  0 20115
  ##A116_rowing_toward  $$00001001  OBJECT_TY OBJECT_TY  0 20116
  ##A117_looking_up  $$00000000  OBJECT_TY OBJECT_TY  0 20117
  ##A118_plugging_it_with  $$00011011  OBJECT_TY OBJECT_TY  0 20118
  ##A119_tightening  $$00011011  OBJECT_TY OBJECT_TY  0 20119
  ##A120_lever_examining  $$00000000  OBJECT_TY OBJECT_TY  0 20120
  ##A121_switch_examining  $$00000000  OBJECT_TY OBJECT_TY  0 20121
  ##A122_gizmo_examining  $$00000000  OBJECT_TY OBJECT_TY  0 20122
  ##A123_flipping  $$00001001  OBJECT_TY OBJECT_TY  0 20123
  ##A124_shaking  $$00001001  OBJECT_TY OBJECT_TY  0 20124
  ##A125_playing  $$00001001  OBJECT_TY OBJECT_TY  0 20125
  ##A126_prying_it_with  $$00011011  OBJECT_TY OBJECT_TY  0 20126
  ##A127_skipping  $$01001001  OBJECT_TY OBJECT_TY  0 20127
  ##A128_barking  $$00000000  OBJECT_TY OBJECT_TY  0 20128
  ##A129_thing_barking  $$00001001  OBJECT_TY OBJECT_TY  0 20129
  ##A130_taking_it_with  $$00011011  OBJECT_TY OBJECT_TY  0 20130
  ##A131_magnet_waving  $$00011011  OBJECT_TY OBJECT_TY  0 20131
  ##A132_typing  $$00011010  NUMBER_TY OBJECT_TY  0 20132
  ##A133_boat_examining  $$00000000  OBJECT_TY OBJECT_TY  0 20133
  ##A134_train_moving  $$00000000  OBJECT_TY OBJECT_TY  0 20134
  ##A135_train_examining  $$00000000  OBJECT_TY OBJECT_TY  0 20135
  ##A136_lock_picking  $$00001001  OBJECT_TY OBJECT_TY  0 20136
  ##A137_double_lock_picking  $$00011011  OBJECT_TY OBJECT_TY  0 20137
;
Constant AD_RECORDS = 138;
[ ANSTVC_7 pos state;
    if (state == 1) {
        MStack-->pos = I439_steam_train; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 5;
];
[ ANSTVC_9 pos state;
    if (state == 1) {
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_11 pos state;
    if (state == 1) {
        MStack-->pos = ##Wait; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = nothing; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 4;
];
[ ANSTVC_12 pos state;
    if (state == 1) {
        MStack-->pos = false; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ ANSTVC_82 pos state;
    if (state == 1) {
        MStack-->pos = 0; pos++;
    } else {
        pos++;
    }
    return 1;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
        ##Inv: print "taking inventory"; 
        ##Take: print "taking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Remove: print "removing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "from"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drop: print "dropping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PutOn: print "putting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "on"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Insert: print "inserting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Eat: print "eating"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Go: print "going"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Enter: print "entering"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Exit: print "exiting"; 
        ##GetOff: print "getting off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Look: print "looking"; 
        ##Examine: print "examining"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##LookUnder: print "looking under"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Search: print "searching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Consult: print "consulting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Lock: print "locking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Unlock: print "unlocking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##SwitchOn: print "switching on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SwitchOff: print "switching off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Open: print "opening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Close: print "closing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wear: print "wearing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Disrobe: print "taking off"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Give: print "giving"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Show: print "showing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##WakeOther: print "waking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##ThrowAt: print "throwing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "at"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Attack: print "attacking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Kiss: print "kissing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Answer: print "answering"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "that"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Tell: print "telling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##Ask: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "about"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##AskFor: print "asking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "for"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Wait: print "waiting"; 
        ##Touch: print "touching"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wave: print "waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Pull: print "pulling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Push: print "pushing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Turn: print "turning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##PushDir: print "pushing"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Squeeze: print "squeezing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Yes: print "saying yes"; 
        ##No: print "saying no"; 
        ##Burn: print "burning"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Wake: print "waking up"; 
        ##Think: print "thinking"; 
        ##Smell: print "smelling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Listen: print "listening to"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Taste: print "tasting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Cut: print "cutting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Jump: print "jumping"; 
        ##Tie: print "tying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##Drink: print "drinking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sorry: print "saying sorry"; 
        ##Strong: print "swearing obscenely"; 
        ##Mild: print "swearing mildly"; 
        ##Swing: print "swinging"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Rub: print "rubbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##SetTo: print "setting"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "to"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##WaveHands: print "waving hands"; 
        ##Buy: print "buying"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sing: print "singing"; 
        ##Climb: print "climbing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##Sleep: print "sleeping"; 
        ##Quit: print "quitting the game"; 
        ##Save: print "saving the game"; 
        ##Restore: print "restoring the game"; 
        ##Restart: print "restarting the game"; 
        ##Verify: print "verifying the story file"; 
        ##ScriptOn: print "switching the story transcript on"; 
        ##ScriptOff: print "switching the story transcript off"; 
        ##Version: print "requesting the story file version"; 
        ##Score: print "requesting the score"; 
        ##LMode3: print "preferring abbreviated room descriptions"; 
        ##LMode2: print "preferring unabbreviated room descriptions"; 
        ##LMode1: print "preferring sometimes abbreviated room descriptions"; 
        ##NotifyOn: print "switching score notification on"; 
        ##NotifyOff: print "switching score notification off"; 
        ##Pronouns: print "requesting the pronoun meanings"; 
        ##A80_retreating: print "retreating"; 
        ##A81_overly_elaborate_looking: print "overly elaborate looking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A82_listing_exits: print "listing exits"; 
        ##A83_using: print "using"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A84_mounting: print "mounting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A85_dismounting: print "dismounting"; 
        ##A86_unlocking_keylessly: print "unlocking keylessly"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A87_locking_keylessly: print "locking keylessly"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A88_universal_unlocking: print "universal unlocking"; 
        ##A89_commenting: print "commenting"; if (for_say ~= 2) { print " "; DA_Topic(parsed_number); }
        ##A90_greeting: print "greeting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A91_praying: print "praying"; 
        ##A92_blowing: print "blowing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A93_shouting: print "shouting"; 
        ##A94_facing: print "facing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A95_looking_toward: print "looking toward"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A96_following: print "following"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A97_vehicle_exiting: print "vehicle-exiting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A98_supporter_exiting: print "supporter-exiting"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A99_liquid_drinking: print "liquid-drinking"; if (for_say ~= 2) { print " "; T70(parsed_number); }
        ##A100_filling_it_with: print "filling"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A101_pouring_it_into: print "pouring"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "into"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A102_swimming: print "swimming"; 
        ##A103_spilling: print "spilling"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A104_boarding: print "boarding"; 
        ##A105_train_waiting: print "train-waiting"; 
        ##A106_waiting_more: print "waiting more"; if (for_say ~= 2) { print " "; DA_Number(parsed_number); }
        ##A107_asking_for_help: print "asking for help"; 
        ##A108_crediting: print "crediting"; 
        ##A109_hinting: print "hinting"; 
        ##A110_requesting_the_full_sco: print "requesting the full score"; 
        ##A111_xyzzy: print "xyzzy"; 
        ##A112_knocking_on: print "knocking on"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A113_wading: print "wading"; 
        ##A114_rowing: print "rowing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A115_dancing: print "dancing"; 
        ##A116_rowing_toward: print "rowing toward"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A117_looking_up: print "looking up"; 
        ##A118_plugging_it_with: print "plugging"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A119_tightening: print "tightening"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A120_lever_examining: print "lever-examining"; 
        ##A121_switch_examining: print "switch-examining"; 
        ##A122_gizmo_examining: print "gizmo-examining"; 
        ##A123_flipping: print "flipping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A124_shaking: print "shaking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A125_playing: print "playing"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A126_prying_it_with: print "prying"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A127_skipping: print "skipping"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A128_barking: print "barking"; 
        ##A129_thing_barking: print "thing-barking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A130_taking_it_with: print "taking"; print " "; if (for_say == 2) print "it"; else DA_Name(n); print " "; print "with"; if (for_say ~= 2) { print " "; DA_Name(s); }
        ##A131_magnet_waving: print "magnet-waving"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A132_typing: print "typing"; if (for_say ~= 2) { print " "; DA_Number(parsed_number); }
        ##A133_boat_examining: print "boat-examining"; 
        ##A134_train_moving: print "train-moving"; 
        ##A135_train_examining: print "train-examining"; 
        ##A136_lock_picking: print "lock-picking"; if (for_say ~= 2) { print " "; DA_Name(n); }
        ##A137_double_lock_picking: print "double-lock-picking"; if (for_say ~= 2) { print " "; DA_Name(n); }
    }
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Strong
    ##Mild ##Swing ##Rub ##SetTo ##WaveHands ##Buy ##Sing ##Climb
    ##Sleep ##Quit ##Save ##Restore ##Restart ##Verify ##ScriptOn ##ScriptOff
    ##Version ##Score ##LMode3 ##LMode2 ##LMode1 ##NotifyOn ##NotifyOff ##Pronouns
    ##A80_retreating ##A81_overly_elaborate_looking ##A82_listing_exits ##A83_using ##A84_mounting ##A85_dismounting ##A86_unlocking_keylessly ##A87_locking_keylessly
    ##A88_universal_unlocking ##A89_commenting ##A90_greeting ##A91_praying ##A92_blowing ##A93_shouting ##A94_facing ##A95_looking_toward
    ##A96_following ##A97_vehicle_exiting ##A98_supporter_exiting ##A99_liquid_drinking ##A100_filling_it_with ##A101_pouring_it_into ##A102_swimming ##A103_spilling
    ##A104_boarding ##A105_train_waiting ##A106_waiting_more ##A107_asking_for_help ##A108_crediting ##A109_hinting ##A110_requesting_the_full_sco ##A111_xyzzy
    ##A112_knocking_on ##A113_wading ##A114_rowing ##A115_dancing ##A116_rowing_toward ##A117_looking_up ##A118_plugging_it_with ##A119_tightening
    ##A120_lever_examining ##A121_switch_examining ##A122_gizmo_examining ##A123_flipping ##A124_shaking ##A125_playing ##A126_prying_it_with ##A127_skipping
    ##A128_barking ##A129_thing_barking ##A130_taking_it_with ##A131_magnet_waving ##A132_typing ##A133_boat_examining ##A134_train_moving ##A135_train_examining
    ##A136_lock_picking ##A137_double_lock_picking;


Array ActionHappened --> 0 0 0 0 0 0 0 0 0;


[ InvSub; return GenericVerbSub(125,126,127); ];
[ TakeSub; return GenericVerbSub(128,129,130); ];
[ RemoveSub; return GenericVerbSub(131,132,133); ];
[ DropSub; return GenericVerbSub(134,135,136); ];
[ PutOnSub; return GenericVerbSub(137,138,139); ];
[ InsertSub; return GenericVerbSub(140,141,142); ];
[ EatSub; return GenericVerbSub(143,144,145); ];
[ GoSub; return GenericVerbSub(146,147,148); ];
[ EnterSub; return GenericVerbSub(149,150,151); ];
[ ExitSub; return GenericVerbSub(152,153,154); ];
[ GetOffSub; return GenericVerbSub(155,156,157); ];
[ LookSub; return GenericVerbSub(158,159,160); ];
[ ExamineSub; return GenericVerbSub(161,162,163); ];
[ LookUnderSub; return GenericVerbSub(164,165,166); ];
[ SearchSub; return GenericVerbSub(167,168,169); ];
[ ConsultSub; return GenericVerbSub(170,171,172); ];
[ LockSub; return GenericVerbSub(173,174,175); ];
[ UnlockSub; return GenericVerbSub(176,177,178); ];
[ SwitchOnSub; return GenericVerbSub(179,180,181); ];
[ SwitchOffSub; return GenericVerbSub(182,183,184); ];
[ OpenSub; return GenericVerbSub(185,186,187); ];
[ CloseSub; return GenericVerbSub(188,189,190); ];
[ WearSub; return GenericVerbSub(191,192,193); ];
[ DisrobeSub; return GenericVerbSub(194,195,196); ];
[ GiveSub; return GenericVerbSub(197,198,199); ];
[ ShowSub; return GenericVerbSub(200,201,202); ];
[ WakeOtherSub; return GenericVerbSub(203,204,205); ];
[ ThrowAtSub; return GenericVerbSub(206,207,208); ];
[ AttackSub; return GenericVerbSub(209,210,211); ];
[ KissSub; return GenericVerbSub(212,213,214); ];
[ AnswerSub; return GenericVerbSub(215,216,217); ];
[ TellSub; return GenericVerbSub(218,219,220); ];
[ AskSub; return GenericVerbSub(221,222,223); ];
[ AskForSub; return GenericVerbSub(224,225,226); ];
[ WaitSub; return GenericVerbSub(227,228,229); ];
[ TouchSub; return GenericVerbSub(230,231,232); ];
[ WaveSub; return GenericVerbSub(233,234,235); ];
[ PullSub; return GenericVerbSub(236,237,238); ];
[ PushSub; return GenericVerbSub(239,240,241); ];
[ TurnSub; return GenericVerbSub(242,243,244); ];
[ PushDirSub; return GenericVerbSub(245,246,247); ];
[ SqueezeSub; return GenericVerbSub(248,249,250); ];
[ YesSub; return GenericVerbSub(251,252,253); ];
[ NoSub; return GenericVerbSub(254,255,256); ];
[ BurnSub; return GenericVerbSub(257,258,259); ];
[ WakeSub; return GenericVerbSub(260,261,262); ];
[ ThinkSub; return GenericVerbSub(263,264,265); ];
[ SmellSub; return GenericVerbSub(266,267,268); ];
[ ListenSub; return GenericVerbSub(269,270,271); ];
[ TasteSub; return GenericVerbSub(272,273,274); ];
[ CutSub; return GenericVerbSub(275,276,277); ];
[ JumpSub; return GenericVerbSub(278,279,280); ];
[ TieSub; return GenericVerbSub(281,282,283); ];
[ DrinkSub; return GenericVerbSub(284,285,286); ];
[ SorrySub; return GenericVerbSub(287,288,289); ];
[ StrongSub; return GenericVerbSub(290,291,292); ];
[ MildSub; return GenericVerbSub(293,294,295); ];
[ SwingSub; return GenericVerbSub(296,297,298); ];
[ RubSub; return GenericVerbSub(299,300,301); ];
[ SetToSub; return GenericVerbSub(302,303,304); ];
[ WaveHandsSub; return GenericVerbSub(305,306,307); ];
[ BuySub; return GenericVerbSub(308,309,310); ];
[ SingSub; return GenericVerbSub(311,312,313); ];
[ ClimbSub; return GenericVerbSub(314,315,316); ];
[ SleepSub; return GenericVerbSub(317,318,319); ];
[ QuitSub; return GenericVerbSub(320,321,322); ];
[ SaveSub; return GenericVerbSub(323,324,325); ];
[ RestoreSub; return GenericVerbSub(326,327,328); ];
[ RestartSub; return GenericVerbSub(329,330,331); ];
[ VerifySub; return GenericVerbSub(332,333,334); ];
[ ScriptOnSub; return GenericVerbSub(335,336,337); ];
[ ScriptOffSub; return GenericVerbSub(338,339,340); ];
[ VersionSub; return GenericVerbSub(341,342,343); ];
[ ScoreSub; return GenericVerbSub(344,345,346); ];
[ LMode3Sub; return GenericVerbSub(347,348,349); ];
[ LMode2Sub; return GenericVerbSub(350,351,352); ];
[ LMode1Sub; return GenericVerbSub(353,354,355); ];
[ NotifyOnSub; return GenericVerbSub(356,357,358); ];
[ NotifyOffSub; return GenericVerbSub(359,360,361); ];
[ PronounsSub; return GenericVerbSub(362,363,364); ];
[ A80_retreatingSub; return GenericVerbSub(365,366,367); ];
[ A81_overly_elaborate_lookingSub; return GenericVerbSub(368,369,370); ];
[ A82_listing_exitsSub; return GenericVerbSub(371,372,373); ];
[ A83_usingSub; return GenericVerbSub(374,375,376); ];
[ A84_mountingSub; return GenericVerbSub(379,380,381); ];
[ A85_dismountingSub; return GenericVerbSub(382,383,384); ];
[ A86_unlocking_keylesslySub; return GenericVerbSub(388,389,390); ];
[ A87_locking_keylesslySub; return GenericVerbSub(391,392,393); ];
[ A88_universal_unlockingSub; return GenericVerbSub(394,395,396); ];
[ A89_commentingSub; return GenericVerbSub(400,401,402); ];
[ A90_greetingSub; return GenericVerbSub(403,404,405); ];
[ A91_prayingSub; return GenericVerbSub(406,407,408); ];
[ A92_blowingSub; return GenericVerbSub(409,410,411); ];
[ A93_shoutingSub; return GenericVerbSub(412,413,414); ];
[ A94_facingSub; return GenericVerbSub(415,416,417); ];
[ A95_looking_towardSub; return GenericVerbSub(418,419,420); ];
[ A96_followingSub; return GenericVerbSub(421,422,423); ];
[ A97_vehicle_exitingSub; return GenericVerbSub(424,425,426); ];
[ A98_supporter_exitingSub; return GenericVerbSub(427,428,429); ];
[ A99_liquid_drinkingSub; return GenericVerbSub(448,449,450); ];
[ A100_filling_it_withSub; return GenericVerbSub(451,452,453); ];
[ A101_pouring_it_intoSub; return GenericVerbSub(454,455,456); ];
[ A102_swimmingSub; return GenericVerbSub(457,458,459); ];
[ A103_spillingSub; return GenericVerbSub(460,461,462); ];
[ A104_boardingSub; return GenericVerbSub(463,464,465); ];
[ A105_train_waitingSub; return GenericVerbSub(466,467,468); ];
[ A106_waiting_moreSub; return GenericVerbSub(469,470,471); ];
[ A107_asking_for_helpSub; return GenericVerbSub(472,473,474); ];
[ A108_creditingSub; return GenericVerbSub(475,476,477); ];
[ A109_hintingSub; return GenericVerbSub(478,479,480); ];
[ A110_requesting_the_full_scoSub; return GenericVerbSub(481,482,483); ];
[ A111_xyzzySub; return GenericVerbSub(484,485,486); ];
[ A112_knocking_onSub; return GenericVerbSub(487,488,489); ];
[ A113_wadingSub; return GenericVerbSub(490,491,492); ];
[ A114_rowingSub; return GenericVerbSub(493,494,495); ];
[ A115_dancingSub; return GenericVerbSub(496,497,498); ];
[ A116_rowing_towardSub; return GenericVerbSub(499,500,501); ];
[ A117_looking_upSub; return GenericVerbSub(502,503,504); ];
[ A118_plugging_it_withSub; return GenericVerbSub(505,506,507); ];
[ A119_tighteningSub; return GenericVerbSub(508,509,510); ];
[ A120_lever_examiningSub; return GenericVerbSub(511,512,513); ];
[ A121_switch_examiningSub; return GenericVerbSub(514,515,516); ];
[ A122_gizmo_examiningSub; return GenericVerbSub(517,518,519); ];
[ A123_flippingSub; return GenericVerbSub(520,521,522); ];
[ A124_shakingSub; return GenericVerbSub(523,524,525); ];
[ A125_playingSub; return GenericVerbSub(526,527,528); ];
[ A126_prying_it_withSub; return GenericVerbSub(529,530,531); ];
[ A127_skippingSub; return GenericVerbSub(532,533,534); ];
[ A128_barkingSub; return GenericVerbSub(537,538,539); ];
[ A129_thing_barkingSub; return GenericVerbSub(540,541,542); ];
[ A130_taking_it_withSub; return GenericVerbSub(543,544,545); ];
[ A131_magnet_wavingSub; return GenericVerbSub(546,547,548); ];
[ A132_typingSub; return GenericVerbSub(549,550,551); ];
[ A133_boat_examiningSub; return GenericVerbSub(552,553,554); ];
[ A134_train_movingSub; return GenericVerbSub(561,562,563); ];
[ A135_train_examiningSub; return GenericVerbSub(564,565,566); ];
[ A136_lock_pickingSub; return GenericVerbSub(567,568,569); ];
[ A137_double_lock_pickingSub; return GenericVerbSub(570,571,572); ];

[ MistakeActionSub;
    switch(understand_as_mistake_number) {
        335: ParserError(SC_225);
        336: ParserError(SC_225);
        337: ParserError(SC_225);
        338: ParserError(SC_225);
        339: ParserError(SC_225);
        370: ParserError(text_routine_221);
        371: ParserError(text_routine_222);
        372: ParserError(text_routine_223);
        431: ParserError(text_routine_224);
        432: ParserError(text_routine_225);
        433: ParserError(text_routine_226);
        434: ParserError(SC_226);
        435: ParserError(SC_226);
        436: ParserError(SC_226);
        446: ParserError(SC_227);
        454: ParserError(SC_228);
        455: ParserError(SC_228);
        456: ParserError(SC_228);
        457: ParserError(SC_229);
        458: ParserError(SC_229);
        459: ParserError(SC_229);
        460: ParserError(text_routine_227);
        461: ParserError(text_routine_228);
        462: ParserError(text_routine_229);
        463: ParserError(text_routine_230);
        464: ParserError(text_routine_231);
        465: ParserError(text_routine_232);
        466: ParserError(text_routine_233);
        467: ParserError(text_routine_234);
        478: ParserError(SC_230);
        493: ParserError(SC_231);
        494: ParserError(SC_231);
        495: ParserError(SC_231);
        513: ParserError(SC_232);
        539: ParserError(SC_233);
        540: ParserError(SC_233);
        541: ParserError(SC_233);
        590: ParserError(SC_234);
        591: ParserError(SC_234);
        636: ParserError(SC_235);
        643: ParserError(SC_236);
        715: ParserError(SC_237);
        716: ParserError(SC_237);
        default: "I didn't understand that sentence.";
    }
    say__p = 1;
];



! Definitions of rule phrases


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Startup (B1_startup)
! ----------------------------------------------------------------------------------------------------
! Rule 1/10: INITIALISE_MEMORY_R
!   === which is equally specific with ===
! Rule 2/10: VIRTUAL_MACHINE_STARTUP_R
!   === which is equally specific with ===
! Rule 3/10: SEED_RANDOM_NUMBER_GENERATOR_R
!   === which is equally specific with ===
! Rule 4/10: UPDATE_CHRONOLOGICAL_RECORDS_R
!   === which is equally specific with ===
! Rule 5/10: POSITION_PLAYER_IN_MODEL_R
!   === which is equally specific with ===
! Rule 6/10 ! This is the start in the correct scenes rule:
! --- now the mid-placed rules ---
! Rule 7/10 ! This is the when play begins stage rule:
!   === which is equally specific with ===
! Rule 8/10 ! This is the fix baseline scoring rule:
!   === which is equally specific with ===
! Rule 9/10 ! This is the display banner rule:
!   === which is equally specific with ===
! Rule 10/10 ! This is the initial room description rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the start in the correct scenes rule:
[ R_8 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the when play begins stage rule:
[ R_9 ;
      ! phrase 1
      ! [1: follow the when play begins rulebook]
       FollowRulebook(5); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the fix baseline scoring rule:
[ R_10 ;
      ! phrase 1
      ! [1: now the last notified score is the score]
       last_score = score; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the display banner rule:
[ R_11 ;
      ! phrase 1
      ! [1: say ~[banner text]~]
      say__p=1;ParaContent();  Banner();  .L_Say0; .L_SayX0;
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the initial room description rule:
[ R_12 ;
      ! phrase 1
      ! [1: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B2_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11: PARSE_COMMAND_R
!   === which is equally specific with ===
! Rule 2/11: GENERATE_ACTION_R
!   === which is equally specific with ===
! Rule 3/11 ! A first turn sequence rule:
!   === which is equally specific with ===
! Rule 4/11 ! A first turn sequence rule ( this is the every turn stage rule ):
! --- now the mid-placed rules ---
! Rule 5/11: TIMED_EVENTS_R
!   === which is equally specific with ===
! Rule 6/11: ADVANCE_TIME_R
!   === which is equally specific with ===
! Rule 7/11: UPDATE_CHRONOLOGICAL_RECORDS_R
! --- now the last-placed rules ---
! Rule 8/11 ! A last turn sequence rule:
!   === which is equally specific with ===
! Rule 9/11: ADJUST_LIGHT_R
!   === which is equally specific with ===
! Rule 10/11: NOTE_OBJECT_ACQUISITIONS_R
!   === which is equally specific with ===
! Rule 11/11 ! This is the notify score changes rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A first turn sequence rule:
[ R_14 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A first turn sequence rule ( this is the every turn stage rule ):
[ R_13 ;
      ! phrase 1
      ! [1: follow the every turn rules]
       FollowRulebook(9); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A last turn sequence rule:
[ R_15 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
       ProcessRulebook(4); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the notify score changes rule:
[ R_16 ;
      ! phrase 1
      ! [1: if the score is not the last notified score begin]
       if (((~~((score == last_score)))))  {
         ! phrase 2
         ! [2: issue score notification message]
          NotifyTheScore(); 
         ! phrase 3
         ! [3: now the last notified score is the score]
          last_score = score; 
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Shutdown (B3_shutdown)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! This is the when play ends stage rule:
! --- now the last-placed rules ---
! Rule 2/4: RESURRECT_PLAYER_IF_ASKED_R
!   === which is equally specific with ===
! Rule 3/4 ! This is the print player's obituary rule:
!   === which is equally specific with ===
! Rule 4/4: ASK_FINAL_QUESTION_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the when play ends stage rule:
[ R_17 ;
      ! phrase 1
      ! [1: follow the when play ends rulebook]
       FollowRulebook(6); 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the print player's obituary rule:
[ R_18 ;
      ! phrase 1
      ! [1: carry out the printing the player's obituary activity]
       CarryOutActivity(V27_printing_the_player_s_ob); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B5_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! When play begins:
!   === which is equally specific with ===
! Rule 2/3 ! When play begins:
!   === which is equally specific with ===
! Rule 3/3 ! When play begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Default Messages" by David Fisher
! When play begins:
[ R_915 ;
      ! phrase 1
      ! [1: init library messages]
       InitLibraryMessages(); 
      ! phrase 2
      ! [2: add the custom library messages]
      (PHR_916_r3 ());
   rfalse;
];
! No specific request
! When play begins:
[ R_1199 ;
      ! phrase 1
      ! [1: change the wetness level to ~dry land~]
       (Global_Vars-->22) = SC_238; 
   rfalse;
];
! No specific request
! When play begins:
[ R_1200 ;
      ! phrase 1
      ! [1: say ~The [bold type]real[roman type] Crystal City; well, is there such a thing? It's just something you read about in a children's book -- a real city couldn't cure and prevent illness in those who lived there, or keep its glass towers maintained with no one working on them. Even if there is something here, it's just an ordinary city -- nothing to justify your ever-increasing obsession. Nothing to justify coming so far from your home just to look for it.[paragraph break]Still, that's what you've done so far.~]
      say__p=1;ParaContent();  print (PrintText) SC_239; ParaContent();  style bold; ParaContent();  print (PrintText) SC_240; ParaContent();  style roman; ParaContent();  print (PrintText) SC_241; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_242;  new_line; .L_Say1; .L_SayX1;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When scene begins (B7_when_scene_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When a scene ( called the event ) begins ( this is the scene description text rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! When a scene ( called the event ) begins ( this is the scene description text rule ):
[ R_57 
    t_0 ! Local variable e.g. 'event' = scene
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (true))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_57, 57);
      ! phrase 1
      ! [1: if the description of the event is not ~~ , say ~[the description of the event][paragraph break]~]
       if (((~~((GProperty(SCENE_TY, t_0,description) == EMPTY_TEXT_VALUE))))) { say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(SCENE_TY, self=t_0,description); @pull self; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say2; .L_SayX2;  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_57, 57, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Every turn (B9_every_turn)
! ----------------------------------------------------------------------------------------------------
! Rule 1/55 ! Every turn when the player is in the Hill or the player is in In The Sweetgum Tree:
!   >>> II - When/while requirement >>>
! Rule 2/55 ! Every turn when the small metal detector is switched on and the small metal detector is visible and at least one metal thing is visible:
!   >>> II - When/while requirement >>>
! Rule 3/55 ! Every turn when the magnet has not been visible and the metal detector is visible and the location is Sandy Beach and the metal detector is switched on:
!   === which is equally specific with ===
! Rule 4/55 ! Every turn when the dog is visible and the dog is not in the rowboat and a random chance of 1 in 2 succeeds and we are not doing something to the dog:
!   >>> II - When/while requirement >>>
! Rule 5/55 ! Every turn when the player is in Rocky Beach and a random chance of 1 in 2 succeeds and the gull is not in Rocky Beach:
!   === which is equally specific with ===
! Rule 6/55 ! Every turn when the dog is roaming and the player is not in the Woods and a random chance of 1 in 3 succeeds:
!   === which is equally specific with ===
! Rule 7/55 ! Every turn when the player is in The Woods and the dog is roaming and the dog is not in the Woods:
!   >>> II - When/while requirement >>>
! Rule 8/55 ! Every turn when the dog is visible and the dog is in the rowboat and a random chance of 1 in 2 succeeds and we are not doing something to the dog:
!   === which is equally specific with ===
! Rule 9/55 ! Every turn when the player is in Underwater and the player has been in Underwater less than eight turns and Vivian is off-stage and a random chance of one in two succeeds:
!   === which is equally specific with ===
! Rule 10/55 ! Every turn when the player is in Underwater and the player has been in Underwater at least eight turns and Vivian is off-stage and a random chance of one in two succeeds:
!   >>> II - When/while requirement >>>
! Rule 11/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 12/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 13/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 14/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 15/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 16/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 17/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 18/55 ! Every turn when Other Side of the Pond is not flooded:
!   === which is equally specific with ===
! Rule 19/55 ! Every turn when the player is in the Pump Room and the Secretary is in Inside Waterworks and a random chance of 1 in 3 succeeds:
!   === which is equally specific with ===
! Rule 20/55 ! Every turn when the player is in Rocky Beach and the gull is in Rocky Beach and a random chance of 1 in 5 succeeds:
!   === which is equally specific with ===
! Rule 21/55 ! Every turn when the secretary's story is happening and the player is free and a random chance of 1 in 3 succeeds:
!   === which is equally specific with ===
! Rule 22/55 ! Every turn when Second Pump is happening and the player is in Outside Waterworks and the puddle is off-stage:
!   >>> II - When/while requirement >>>
! Rule 23/55 ! Every turn when the player is in Other Side of the Pond and the wetness level is ~just beachy~:
!   === which is equally specific with ===
! Rule 24/55 ! Every turn when the player is in the Woods and a random chance of 2 in 3 succeeds:
!   === which is equally specific with ===
! Rule 25/55 ! Every turn while the player is in Underwater and Vivian is in Underwater:
!   === which is equally specific with ===
! Rule 26/55 ! Every turn while Endgame is happening and we are not speech:
!   === which is equally specific with ===
! Rule 27/55 ! Every turn when the player is in the Crystal City and switch-action is happening:
!   === which is equally specific with ===
! Rule 28/55 ! Every turn when the crystal gear has been spinning for at least one turn and switch-action is happening:
!   >>> II - When/while requirement >>>
! Rule 29/55 ! Every turn when the small metal detector has been switched on for three turns:
!   === which is equally specific with ===
! Rule 30/55 ! Every turn when the conductor's story is happening:
!   === which is equally specific with ===
! Rule 31/55 ! Every turn when the conductor's story has been happening for exactly eight turns:
!   === which is equally specific with ===
! Rule 32/55 ! Every turn when the conductor's story has been happening for exactly one turn:
!   === which is equally specific with ===
! Rule 33/55 ! Every turn when the player is in Other Side of the Pond:
!   === which is equally specific with ===
! Rule 34/55 ! Every turn when the player is in Atop the Tank:
!   === which is equally specific with ===
! Rule 35/55 ! Every turn when a random chance of 1 in 10 succeeds:
!   === which is equally specific with ===
! Rule 36/55 ! Every turn when a random chance of 1 in 12 succeeds:
!   === which is equally specific with ===
! Rule 37/55 ! Every turn when the player is in Inside Waterworks:
!   === which is equally specific with ===
! Rule 38/55 ! Every turn when the player is in the Pump Room:
!   === which is equally specific with ===
! Rule 39/55 ! Every turn when the secretary's story has been happening for at least one turn:
!   === which is equally specific with ===
! Rule 40/55 ! Every turn when the player has been trapped for exactly one turn:
!   === which is equally specific with ===
! Rule 41/55 ! Every turn when the player is in Other Side of the Pond:
!   === which is equally specific with ===
! Rule 42/55 ! Every turn when Inside Waterworks has been flooded for exactly one turn:
!   === which is equally specific with ===
! Rule 43/55 ! Every turn when the player is in Pump Room:
!   === which is equally specific with ===
! Rule 44/55 ! Every turn when the player is in Inside Waterworks:
!   === which is equally specific with ===
! Rule 45/55 ! Every turn when Endgame is happening:
!   >>> II - When/while requirement >>>
! Rule 46/55 ! Every turn during Second Pump:
!   === which is equally specific with ===
! Rule 47/55 ! Every turn during Third Pump:
!   === which is equally specific with ===
! Rule 48/55 ! Every turn during First Pump:
!   >>> I - Number of aspects constrained >>>
! Rule 49/55 ! Every turn:
!   === which is equally specific with ===
! Rule 50/55 ! Every turn:
!   === which is equally specific with ===
! Rule 51/55 ! Every turn:
!   === which is equally specific with ===
! Rule 52/55 ! Every turn:
!   === which is equally specific with ===
! Rule 53/55 ! Every turn:
!   === which is equally specific with ===
! Rule 54/55 ! Every turn:
!   === which is equally specific with ===
! Rule 55/55 ! Every turn:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Every turn when the player is in the Hill or the player is in In The Sweetgum Tree:
[ R_1187 ;
   if ((((((I441_hill == ContainerOf(player))))) || ((((I442_in_the_sweetgum_tree == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1187, 1187);
      ! phrase 1
      ! [1: if the wind chimes are in in the sweetgum tree and a random chance of 1 in 2 succeeds , say ~[one of]You hear a faint tinkling sound[or]A series of indistinct [if the lone sweetgum tree has been examined or the player has been in In The Sweetgum Tree]notes[otherwise]chimes[end if] sound[or]A single 'tink!' breaks the silence[at random][if the lone sweetgum tree has been examined or the player has been in In The Sweetgum Tree] from the wind chimes[end if].~]
       if ((((I442_in_the_sweetgum_tree == ContainerOf(I563_metal_wind_chimes)))) && (( (GenerateRandomNumber(1, 2) <= 1) ))) { say__p=1;ParaContent();  I7_ST_say_one_of-->0 =
	i7_soo_ran(I7_ST_say_one_of-->0, 3);
	switch((I7_ST_say_one_of-->0)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_243; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_244; 
	if (~~(((TestSinglePastState(0, 0, false, 5)) || (TestSinglePastState(0, 1, false, 5))))) jump L_Say3;
		ParaContent();  print (PrintText) SC_245; 
	jump L_SayX3; .L_Say3;
		ParaContent();  print (PrintText) SC_246; 
	.L_Say4; .L_SayX3;
		ParaContent();  print (PrintText) SC_247; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_248; ParaContent();  } 
	if (~~(((TestSinglePastState(0, 2, false, 5)) || (TestSinglePastState(0, 3, false, 5))))) jump L_Say5;
		ParaContent();  print (PrintText) SC_249; 
	.L_Say5; .L_SayX4;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say6; .L_SayX5;  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1187, 1187, true);
   rfalse;
];
! No specific request
! Every turn when the small metal detector is switched on and the small metal detector is visible and at least one metal thing is visible:
[ R_1077 ;
   if ((((((((Adj_80_t1_v9(I421_small_metal_detector))))) && (((((Adj_3_t1_v9(I421_small_metal_detector))))) && ((Prop_0()))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1077, 1077);
      ! phrase 1
      ! [1: say ~The metal detector beeps a little in response to [the random metal visible thing].~]
      say__p=1;ParaContent();  print (PrintText) SC_251; ParaContent();  print (the)  (Prop_1()) ; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say7; .L_SayX6;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1077, 1077, true);
   rfalse;
];
! No specific request
! Every turn when the magnet has not been visible and the metal detector is visible and the location is Sandy Beach and the metal detector is switched on:
[ R_1079 ;
   if (((((~~(TestSinglePastState(0, 4, false, 5))) && (((((Adj_3_t1_v9(I421_small_metal_detector))))) && ((((real_location == I474_sandy_beach))) && ((((Adj_80_t1_v9(I421_small_metal_detector))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1079, 1079);
      ! phrase 1
      ! [1: say ~The metal detector seems to beep when you hold it near a particular spot in the sand.~]
      say__p=1;ParaContent();  print (PrintText) SC_252;  new_line; .L_Say8; .L_SayX7;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1079, 1079, true);
   rfalse;
];
! No specific request
! Every turn when the dog is visible and the dog is not in the rowboat and a random chance of 1 in 2 succeeds and we are not doing something to the dog:
[ R_1553 ;
   if ((((((((Adj_3_t1_v9(I443_dog))))) && ((((~~((I481_rowboat == ContainerOf(I443_dog)))))) && ((( (GenerateRandomNumber(1, 2) <= 1) )) && ((~~( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I443_dog) && (true))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1553, 1553);
      ! phrase 1
      ! [1: say the dog-action]
      say__p=1;ParaContent(); (PHR_1554_r4 ()); .L_Say9; .L_SayX8;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1553, 1553, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Rocky Beach and a random chance of 1 in 2 succeeds and the gull is not in Rocky Beach:
[ R_1453 ;
   if (((((((I470_rocky_beach == ContainerOf(player)))) && ((( (GenerateRandomNumber(1, 2) <= 1) )) && (((~~((I470_rocky_beach == ContainerOf(I588_gull))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1453, 1453);
      ! phrase 1
      ! [1: say ~A gull swoops down and pecks at [if the drawer is handled and Rocky Beach is flooded]the top of your wet boot[otherwise if the drawer is handled]the rocky beach[otherwise]the drawer[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_253; 
	if (~~((((((Adj_60_t1_v9(I589_wooden_drawer))))) && ((((Adj_136_t1_v9(I470_rocky_beach)))))))) jump L_Say10;
		ParaContent();  print (PrintText) SC_254; ParaContent(); 
	jump L_SayX9; .L_Say10; if (~~(((((Adj_60_t1_v9(I589_wooden_drawer))))))) jump L_Say11;
		ParaContent();  print (PrintText) SC_255; 
	jump L_SayX9; .L_Say11;
		ParaContent();  print (PrintText) SC_256; 
	.L_Say12; .L_SayX9;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say13; .L_SayX10;
      ! phrase 2
      ! [2: now a gull is in rocky beach]
       MoveObject(I588_gull,I470_rocky_beach); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1453, 1453, true);
   rfalse;
];
! No specific request
! Every turn when the dog is roaming and the player is not in the Woods and a random chance of 1 in 3 succeeds:
[ R_1546 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((((((((Adj_132_t1_v9(I443_dog))))) && ((((~~((I444_woods == ContainerOf(player)))))) && (( (GenerateRandomNumber(1, 3) <= 1) ))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1546, 1546);
      ! phrase 1
      ! [1: if the dog is not in the rowboat begin]
       if (((~~((I481_rowboat == ContainerOf(I443_dog))))))  {
         ! phrase 2
         ! [2: let next location be a random room which is adjacent to a random room containing the dog]
          t_0 =  (Prop_2(, (Prop_3()) )) ; 
         ! phrase 3
         ! [3: let the way be the best route from the location of the dog to next location , using doors]
          t_1 =  MapRouteTo( LocationOf(I443_dog) ,t_0,0,1) ; 
         ! phrase 4
         ! [4: if the way is nothing , try the dog going a random direction]
          if (((t_1 == nothing))) {  TryAction(0, I443_dog, ##Go,  (Prop_4()) , 0);;   }
         ! phrase 5
         ! [5: otherwise try the dog going the way]
          else {  TryAction(0, I443_dog, ##Go, t_1, 0);;   }
         ! phrase 6
         ! [6: otherwise if the dog is in the rowboat and the rowboat is in other side of the pond or the rowboat is in boat house]
          } else if ((((I481_rowboat == ContainerOf(I443_dog)))) && ((((I494_other_side_of_the_pond == ContainerOf(I481_rowboat)))) || (((I479_boat_house == ContainerOf(I481_rowboat)))))) { 
         ! phrase 7
         ! [7: if a random chance of 1 in 2 succeeds begin]
          if (( (GenerateRandomNumber(1, 2) <= 1) ))  {
            ! phrase 8
            ! [8: try the dog exiting]
             TryAction(0, I443_dog, ##Exit, 0, 0);; 
            ! phrase 9
            ! [9: end if]
            }

         ! phrase 10
         ! [10: otherwise]
         } else {

         ! phrase 11
         ! [11: do nothing]
          ; 
         ! phrase 12
         ! [12: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1546, 1546, true);
   rfalse;
];
! No specific request
! Every turn when the player is in The Woods and the dog is roaming and the dog is not in the Woods:
[ R_1565 
    t_0 ! Local variable e.g. 'way' = object
    ;
   if (((((((I444_woods == ContainerOf(player)))) && (((((Adj_132_t1_v9(I443_dog))))) && (((~~((I444_woods == ContainerOf(I443_dog))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1565, 1565);
      ! phrase 1
      ! [1: let the way be the best route from the location of the dog to the location of the player , using doors]
       t_0 =  MapRouteTo( LocationOf(I443_dog) , LocationOf(player) ,0,1) ; 
      ! phrase 2
      ! [2: try the dog going the way]
       TryAction(0, I443_dog, ##Go, t_0, 0);; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1565, 1565, true);
   rfalse;
];
! No specific request
! Every turn when the dog is visible and the dog is in the rowboat and a random chance of 1 in 2 succeeds and we are not doing something to the dog:
[ R_1555 ;
   if ((((((((Adj_3_t1_v9(I443_dog))))) && ((((I481_rowboat == ContainerOf(I443_dog)))) && ((( (GenerateRandomNumber(1, 2) <= 1) )) && ((~~( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I443_dog) && (true))))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1555, 1555);
      ! phrase 1
      ! [1: say ~[one of]The dog's tongue lolls out, panting[or]The dog wags its tail[purely at random].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->1 =
	i7_soo_par(I7_ST_say_one_of-->1, 2);
	switch((I7_ST_say_one_of-->1)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_257; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_258; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say14; .L_SayX11;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1555, 1555, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Underwater and the player has been in Underwater less than eight turns and Vivian is off-stage and a random chance of one in two succeeds:
[ R_1679 ;
   if (((((((I669_underwater == ContainerOf(player)))) && ((TestSinglePastState(0, 5, false, 6) < 8 ) && (((((~~Adj_9_t1_v9(I671_vivian))))) && (( (GenerateRandomNumber(1, 2) <= 1) )))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1679, 1679);
      ! phrase 1
      ! [1: say ~[one of]The pond is still, and quiet.[or]You tread water in the almost eerie silence.[at random]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->2 =
	i7_soo_ran(I7_ST_say_one_of-->2, 2);
	switch((I7_ST_say_one_of-->2)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_259;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_260;  new_line;ParaContent();  }  .L_Say15; .L_SayX12;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1679, 1679, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Underwater and the player has been in Underwater at least eight turns and Vivian is off-stage and a random chance of one in two succeeds:
[ R_1680 ;
   if (((((((I669_underwater == ContainerOf(player)))) && ((TestSinglePastState(0, 6, false, 6) >= 8 ) && (((((~~Adj_9_t1_v9(I671_vivian))))) && (( (GenerateRandomNumber(1, 2) <= 1) )))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1680, 1680);
      ! phrase 1
      ! [1: say ~[one of]The pond is still, and quiet.[or]The people below seem unaware of your presence.[or]You think about how to alert the people of the Crystal City that you're here.[or]You tread water in the almost eerie silence.[at random]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->3 =
	i7_soo_ran(I7_ST_say_one_of-->3, 4);
	switch((I7_ST_say_one_of-->3)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_259;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_261;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_262;  new_line;ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_260;  new_line;ParaContent();  }  .L_Say16; .L_SayX13;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1680, 1680, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1147 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1147, 1147);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 5 or the minutes part of the time of day is 25 or the minutes part of the time of day is 45 begin]
       if (((( (the_time%ONE_HOUR)  == 5))) || (((( (the_time%ONE_HOUR)  == 25))) || ((( (the_time%ONE_HOUR)  == 45)))))  {
         ! phrase 2
         ! [2: if the location is freshwater crossing , say ~A steam train comes barreling down the tracks in your direction.~]
          if (((real_location == I507_freshwater_crossing))) { say__p=1;ParaContent();  print (PrintText) SC_263;  new_line; .L_Say17; .L_SayX14;  }
         ! phrase 3
         ! [3: now the steam train approaches freshwater crossing]
          (Relation_NowVtoV(I439_steam_train,Rel_Record_69,I507_freshwater_crossing,false)); 
         ! phrase 4
         ! [4: if the player is in the steam train , say ~The train starts to slow down.~]
          if (((I439_steam_train == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_264;  new_line; .L_Say18; .L_SayX15;  }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1147, 1147, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1148 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1148, 1148);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 3 or the minutes part of the time of day is 23 or the minutes part of the time of day is 43 begin]
       if (((( (the_time%ONE_HOUR)  == 3))) || (((( (the_time%ONE_HOUR)  == 23))) || ((( (the_time%ONE_HOUR)  == 43)))))  {
         ! phrase 2
         ! [2: if the player is in a room that is outdoors and the player is not in otherland and the player is awake begin]
          if ((((ContainerOf(player) ofclass K1_room) && ((Adj_99_t1_v9(ContainerOf(player)))))) && ((((~~((TestRegionalContainment(player,I500_otherland)))))) && ((((Adj_147_t1_v9(player)))))))  {
            ! phrase 3
            ! [3: say ~You hear a[if the player is in Freshwater Crossing]n approaching[otherwise] distant[end if] train whistle.~]
            say__p=1;ParaContent();  print (PrintText) SC_265; 
	if (~~((((I507_freshwater_crossing == ContainerOf(player)))))) jump L_Say19;
		ParaContent();  print (PrintText) SC_266; 
	jump L_SayX16; .L_Say19;
		ParaContent();  print (PrintText) SC_267; 
	.L_Say20; .L_SayX16;
		ParaContent();  print (PrintText) SC_268;  new_line; .L_Say21; .L_SayX17;
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1148, 1148, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1149 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1149, 1149);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 6 or the minutes part of the time of day is 26 or the minutes part of the time of day is 46 begin]
       if (((( (the_time%ONE_HOUR)  == 6))) || (((( (the_time%ONE_HOUR)  == 26))) || ((( (the_time%ONE_HOUR)  == 46)))))  {
         ! phrase 2
         ! [2: now the station of the steam train is freshwater crossing]
          WriteGProperty(9, I439_steam_train,p16_station,I507_freshwater_crossing); 
         ! phrase 3
         ! [3: now the steam train does not approach freshwater crossing]
          (Relation_NowNVtoV(I439_steam_train,Rel_Record_69,I507_freshwater_crossing,false)); 
         ! phrase 4
         ! [4: if the location is freshwater crossing , say ~A train pulls up and stops in front of you.~]
          if (((real_location == I507_freshwater_crossing))) { say__p=1;ParaContent();  print (PrintText) SC_269;  new_line; .L_Say22; .L_SayX18;  }
         ! phrase 5
         ! [5: if the location is the steam train , say ~The train comes to a halt.~]
          if (((real_location == I439_steam_train))) { say__p=1;ParaContent();  print (PrintText) SC_270;  new_line; .L_Say23; .L_SayX19;  }
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1149, 1149, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1150 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1150, 1150);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 10 or the minutes part of the time of day is 30 or the minutes part of the time of day is 50 begin]
       if (((( (the_time%ONE_HOUR)  == 10))) || (((( (the_time%ONE_HOUR)  == 30))) || ((( (the_time%ONE_HOUR)  == 50)))))  {
         ! phrase 2
         ! [2: now the station of the steam train is the steam train]
          WriteGProperty(9, I439_steam_train,p16_station,I439_steam_train); 
         ! phrase 3
         ! [3: if the location is freshwater crossing begin]
          if (((real_location == I507_freshwater_crossing)))  {
            ! phrase 4
            ! [4: say ~The train hurtles away, leaving you behind.~]
            say__p=1;ParaContent();  print (PrintText) SC_271;  new_line; .L_Say24; .L_SayX20;
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: if the location is the steam train begin]
          if (((real_location == I439_steam_train)))  {
            ! phrase 7
            ! [7: say ~The train rolls away, taking you with it.~]
            say__p=1;ParaContent();  print (PrintText) SC_272;  new_line; .L_Say25; .L_SayX21;
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1150, 1150, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1151 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1151, 1151);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 14 or the minutes part of the time of day is 34 or the minutes part of the time of day is 54 begin]
       if (((( (the_time%ONE_HOUR)  == 14))) || (((( (the_time%ONE_HOUR)  == 34))) || ((( (the_time%ONE_HOUR)  == 54)))))  {
         ! phrase 2
         ! [2: if the location is the steam train begin]
          if (((real_location == I439_steam_train)))  {
            ! phrase 3
            ! [3: say ~The train starts to slow down.~]
            say__p=1;ParaContent();  print (PrintText) SC_264;  new_line; .L_Say26; .L_SayX22;
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: if the location is other side of the pond begin]
          if (((real_location == I494_other_side_of_the_pond)))  {
            ! phrase 6
            ! [6: say ~A steam train is barreling toward you along the tracks.~]
            say__p=1;ParaContent();  print (PrintText) SC_273;  new_line; .L_Say27; .L_SayX23;
            ! phrase 7
            ! [7: now the steam train approaches other side of the pond]
             (Relation_NowVtoV(I439_steam_train,Rel_Record_69,I494_other_side_of_the_pond,false)); 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1151, 1151, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1152 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1152, 1152);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 12 or the minutes part of the time of day is 22 or the minutes part of the time of day is 52 begin]
       if (((( (the_time%ONE_HOUR)  == 12))) || (((( (the_time%ONE_HOUR)  == 22))) || ((( (the_time%ONE_HOUR)  == 52)))))  {
         ! phrase 2
         ! [2: if the player is in otherland begin]
          if (((TestRegionalContainment(player,I500_otherland))))  {
            ! phrase 3
            ! [3: say ~You hear a[if the player is in Other Side of the Pond]n approaching[otherwise] distant[end if] train whistle.~]
            say__p=1;ParaContent();  print (PrintText) SC_265; 
	if (~~((((I494_other_side_of_the_pond == ContainerOf(player)))))) jump L_Say28;
		ParaContent();  print (PrintText) SC_266; 
	jump L_SayX24; .L_Say28;
		ParaContent();  print (PrintText) SC_267; 
	.L_Say29; .L_SayX24;
		ParaContent();  print (PrintText) SC_268;  new_line; .L_Say30; .L_SayX25;
            ! phrase 4
            ! [4: end if]
            }

         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1152, 1152, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1153 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1153, 1153);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 15 or the minutes part of the time of day is 35 or the minutes part of the time of day is 55 begin]
       if (((( (the_time%ONE_HOUR)  == 15))) || (((( (the_time%ONE_HOUR)  == 35))) || ((( (the_time%ONE_HOUR)  == 55)))))  {
         ! phrase 2
         ! [2: now the station of the steam train is other side of the pond]
          WriteGProperty(9, I439_steam_train,p16_station,I494_other_side_of_the_pond); 
         ! phrase 3
         ! [3: if the location is the steam train begin]
          if (((real_location == I439_steam_train)))  {
            ! phrase 4
            ! [4: say ~The train comes to a halt.~]
            say__p=1;ParaContent();  print (PrintText) SC_270;  new_line; .L_Say31; .L_SayX26;
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: if the location is other side of the pond begin]
          if (((real_location == I494_other_side_of_the_pond)))  {
            ! phrase 7
            ! [7: say ~The steam train pulls up, and comes to a halt.~]
            say__p=1;ParaContent();  print (PrintText) SC_274;  new_line; .L_Say32; .L_SayX27;
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: now the steam train does not approach other side of the pond]
          (Relation_NowNVtoV(I439_steam_train,Rel_Record_69,I494_other_side_of_the_pond,false)); 
         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1153, 1153, true);
   rfalse;
];
! No specific request
! Every turn when Other Side of the Pond is not flooded:
[ R_1154 ;
   if ((((((~~(((Adj_136_t1_v9(I494_other_side_of_the_pond)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1154, 1154);
      ! phrase 1
      ! [1: if the minutes part of the time of day is 20 or the minutes part of the time of day is 40 or the minutes part of the time of day is 0 begin]
       if (((( (the_time%ONE_HOUR)  == 20))) || (((( (the_time%ONE_HOUR)  == 40))) || ((( (the_time%ONE_HOUR)  == 0)))))  {
         ! phrase 2
         ! [2: now the station of the steam train is the steam train]
          WriteGProperty(9, I439_steam_train,p16_station,I439_steam_train); 
         ! phrase 3
         ! [3: if the location is the steam train begin]
          if (((real_location == I439_steam_train)))  {
            ! phrase 4
            ! [4: say ~The train rolls away, taking you with it.~]
            say__p=1;ParaContent();  print (PrintText) SC_272;  new_line; .L_Say33; .L_SayX28;
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: if the location is other side of the pond begin]
          if (((real_location == I494_other_side_of_the_pond)))  {
            ! phrase 7
            ! [7: say ~The train hurtles away, leaving you behind.~]
            say__p=1;ParaContent();  print (PrintText) SC_271;  new_line; .L_Say34; .L_SayX29;
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1154, 1154, true);
   rfalse;
];
! No specific request
! Every turn when the player is in the Pump Room and the Secretary is in Inside Waterworks and a random chance of 1 in 3 succeeds:
[ R_1343 ;
   if (((((((I510_pump_room == ContainerOf(player)))) && ((((I506_inside_waterworks == ContainerOf(I545_secretary_of_water)))) && (( (GenerateRandomNumber(1, 3) <= 1) ))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1343, 1343);
      ! phrase 1
      ! [1: say ~[The secretary] leans down over the top of the staircase and looks at you.[paragraph break][one of]'Um, could you...?' says [the secretary] anxiously.[or]She looks nervous.[or]She is biting her fingernails.[or]She drums her fingers on the railing. 'I[']m really not supposed to let you mess with the pump!'[or][The secretary] peers at what you are doing. 'Could you please leave that thing to the technicians?'[at random]~]
      say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_275; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  I7_ST_say_one_of-->4 =
	i7_soo_ran(I7_ST_say_one_of-->4, 5);
	switch((I7_ST_say_one_of-->4)%(5+1)-1) {
		0: ParaContent();  print (PrintText) SC_276; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_277;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_278;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_279;  new_line;ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_280; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_281;  new_line;ParaContent();  @nop; 4: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_282;  new_line;ParaContent();  }  .L_Say35; .L_SayX30;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1343, 1343, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Rocky Beach and the gull is in Rocky Beach and a random chance of 1 in 5 succeeds:
[ R_1454 ;
   if (((((((I470_rocky_beach == ContainerOf(player)))) && ((((I470_rocky_beach == ContainerOf(I588_gull)))) && (( (GenerateRandomNumber(1, 5) <= 1) ))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1454, 1454);
      ! phrase 1
      ! [1: say ~The gull tires of [if the drawer is handled]the beach[otherwise]the drawer[end if] and flaps up and away.~]
      say__p=1;ParaContent();  print (PrintText) SC_283; 
	if (~~(((((Adj_60_t1_v9(I589_wooden_drawer))))))) jump L_Say36;
		ParaContent();  print (PrintText) SC_284; 
	jump L_SayX31; .L_Say36;
		ParaContent();  print (PrintText) SC_256; 
	.L_Say37; .L_SayX31;
		ParaContent();  print (PrintText) SC_285;  new_line; .L_Say38; .L_SayX32;
      ! phrase 2
      ! [2: now the gull is off-stage]
       (Adj_9_t3_v9(I588_gull)); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1454, 1454, true);
   rfalse;
];
! No specific request
! Every turn when the secretary's story is happening and the player is free and a random chance of 1 in 3 succeeds:
[ R_1526 ;
   if ((((((((scene_status-->(I611_secretary_s_story-1)==1)))) && (((((Adj_131_t1_v9(player))))) && (( (GenerateRandomNumber(1, 3) <= 1) ))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1526, 1526);
      ! phrase 1
      ! [1: say ~Suddenly the unstable ground gives way to sinking mud beneath you, and you're encircled in the marsh to the waist, trapped and unable to move!~]
      say__p=1;ParaContent();  print (PrintText) SC_286;  new_line; .L_Say39; .L_SayX33;
      ! phrase 2
      ! [2: now the player is trapped]
       (Adj_130_t2_v9(player)); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1526, 1526, true);
   rfalse;
];
! No specific request
! Every turn when Second Pump is happening and the player is in Outside Waterworks and the puddle is off-stage:
[ R_1608 ;
   if ((((((((scene_status-->(I429_second_pump-1)==1)))) && ((((I447_outside_waterworks == ContainerOf(player)))) && ((((~~Adj_9_t1_v9(I645_dirty_puddle)))))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1608, 1608);
      ! phrase 1
      ! [1: say ~You hear a loud crack from the Waterworks --[paragraph break]Then a rush of water. A large gush of water erupts [if the door to the waterworks is open]out the door[otherwise]under the door[end if], [if the red keychain has not been handled]carrying the red keychain with it and [end if]leaving a dirty puddle on the path.~]
      say__p=1;ParaContent();  print (PrintText) SC_287; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_288; 
	if (~~(((((Adj_70_t1_v9(I516_door_to_the_waterworks))))))) jump L_Say40;
		ParaContent();  print (PrintText) SC_289; 
	jump L_SayX34; .L_Say40;
		ParaContent();  print (PrintText) SC_290; 
	.L_Say41; .L_SayX34;
		ParaContent();  print (PrintText) SC_291; 
	if (~~((~~(TestSinglePastState(0, 7, false, 5))))) jump L_Say42;
		ParaContent();  print (PrintText) SC_292; 
	.L_Say42; .L_SayX35;
		ParaContent();  print (PrintText) SC_293;  new_line; .L_Say43; .L_SayX36;
      ! phrase 2
      ! [2: now the dirty puddle is in outside waterworks]
       MoveObject(I645_dirty_puddle,I447_outside_waterworks); 
      ! phrase 3
      ! [3: if the red keychain has not been handled , now the red keychain is in outside waterworks]
       if (~~(TestSinglePastState(0, 8, false, 5))) {  MoveObject(I486_red_foam_keychain,I447_outside_waterworks);   }
      ! phrase 4
      ! [4: now the red keychain is described]
       (Adj_61_t2_v9(I486_red_foam_keychain)); 
      ! phrase 5
      ! [5: now inside waterworks is flooded]
       (Adj_136_t2_v9(I506_inside_waterworks)); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1608, 1608, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Other Side of the Pond and the wetness level is ~just beachy~:
[ R_1083 ;
   if (((((((I494_other_side_of_the_pond == ContainerOf(player)))) && ((((Global_Vars-->22) == SC_294))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1083, 1083);
      ! phrase 1
      ! [1: change the wetness level to ~starting to trickle~]
       (Global_Vars-->22) = SC_295; 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1083, 1083, true);
   rfalse;
];
! No specific request
! Every turn when the player is in the Woods and a random chance of 2 in 3 succeeds:
[ R_1557 ;
   if (((((((I444_woods == ContainerOf(player)))) && (( (GenerateRandomNumber(1, 3) <= 2) )))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1557, 1557);
      ! phrase 1
      ! [1: say ~[one of]From the east, you can feel a misty chill[or]To the east you think you can hear the faint lapping of the pond[at random].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->5 =
	i7_soo_ran(I7_ST_say_one_of-->5, 2);
	switch((I7_ST_say_one_of-->5)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_296; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_297; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say44; .L_SayX37;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1557, 1557, true);
   rfalse;
];
! No specific request
! Every turn while the player is in Underwater and Vivian is in Underwater:
[ R_1686 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
   if (((((((I669_underwater == ContainerOf(player)))) && (((I669_underwater == ContainerOf(I671_vivian)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1686, 1686);
      ! phrase 1
      ! [1: repeat through table of vivian begin]
       @push ct_0; @push ct_1;
		for (t_0=T15_vivian,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
           if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
         ! phrase 2
         ! [2: say ~[event entry][paragraph break]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,123,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say45; .L_SayX38;
         ! phrase 3
         ! [3: blank out the whole row]
          TableBlankOutRow(ct_0, ct_1); 
         ! phrase 4
         ! [4: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 5
         ! [5: end repeat]
         }
@pull ct_1; @pull ct_0;
        if (debug_rules>1) print "  [5: end repeat]^";
      ! phrase 6
      ! [6: say ~'OK, let's go!' She takes your hand, and pulls you downward with surprising force. Once you reach the bottom, you realize that though you're still underwater, you're no longer being pulled buoyantly upward, and your feet touch solid ground as Vivian leads you expertly through the shining streets.~]
      say__p=1;ParaContent();  print (PrintText) SC_298;  new_line; .L_Say46; .L_SayX39;
      ! phrase 7
      ! [7: move vivian to the crystal city]
       MoveObject(I671_vivian, I677_the_crystal_city, 0, false); 
      ! phrase 8
      ! [8: move the player to the crystal city]
       MoveObject(player, I677_the_crystal_city, 0, false); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1686, 1686, true);
   rfalse;
];
! No specific request
! Every turn while Endgame is happening and we are not speech:
[ R_1711 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
   if ((((((((scene_status-->(I695_endgame-1)==1)))) && ((~~((NAP_0()) &&  (actor==player)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1711, 1711);
      ! phrase 1
      ! [1: repeat through table of endgame events begin]
       @push ct_0; @push ct_1;
		for (t_0=T16_endgame_events,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
           if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
         ! phrase 2
         ! [2: say ~[event entry][paragraph break]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,123,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say47; .L_SayX40;
         ! phrase 3
         ! [3: blank out the whole row]
          TableBlankOutRow(ct_0, ct_1); 
         ! phrase 4
         ! [4: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 5
         ! [5: end repeat]
         }
@pull ct_1; @pull ct_0;
        if (debug_rules>1) print "  [5: end repeat]^";
      ! phrase 6
      ! [6: if a random chance of 1 in 6 succeeds , say ~[one of]Vivian dances impatiently[or]Cordelia looks at you, outwardly calm, but something about her eyes gives away tension[or]Doug is looking intently at the pump[at random].~]
       if (( (GenerateRandomNumber(1, 6) <= 1) )) { say__p=1;ParaContent();  I7_ST_say_one_of-->6 =
	i7_soo_ran(I7_ST_say_one_of-->6, 3);
	switch((I7_ST_say_one_of-->6)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_299; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_300; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_301; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say48; .L_SayX41;  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1711, 1711, true);
   rfalse;
];
! No specific request
! Every turn when the player is in the Crystal City and switch-action is happening:
[ R_1715 ;
   if (((((((I677_the_crystal_city == ContainerOf(player)))) && ((((scene_status-->(I704_switch_action-1)==1)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1715, 1715);
      ! phrase 1
      ! [1: say ~The pump is rumbling[if the crystal gear is not spinning], but not on yet[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_302; 
	if (~~((((~~(((Adj_138_t1_v9(I699_large_crystal_gear))))))))) jump L_Say49;
		ParaContent();  print (PrintText) SC_303; 
	.L_Say49; .L_SayX42;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say50; .L_SayX43;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1715, 1715, true);
   rfalse;
];
! No specific request
! Every turn when the crystal gear has been spinning for at least one turn and switch-action is happening:
[ R_1716 ;
   if (((((TestSinglePastState(0, 9, false, 6) >= 1 ) && ((((scene_status-->(I704_switch_action-1)==1)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1716, 1716);
      ! phrase 1
      ! [1: say ~The pump is vibrating[if switch-action is not happening], but not on yet[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_304; 
	if (~~((((~~(((scene_status-->(I704_switch_action-1)==1)))))))) jump L_Say51;
		ParaContent();  print (PrintText) SC_303; 
	.L_Say51; .L_SayX44;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say52; .L_SayX45;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1716, 1716, true);
   rfalse;
];
! No specific request
! Every turn when the small metal detector has been switched on for three turns:
[ R_1078 ;
   if ((((TestSinglePastState(0, 10, false, 6) >= 3 )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1078, 1078);
      ! phrase 1
      ! [1: say ~The metal detector powers down with a whirr.~]
      say__p=1;ParaContent();  print (PrintText) SC_305;  new_line; .L_Say53; .L_SayX46;
      ! phrase 2
      ! [2: now the metal detector is switched off]
       (Adj_81_t2_v9(I421_small_metal_detector)); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1078, 1078, true);
   rfalse;
];
! No specific request
! Every turn when the conductor's story is happening:
[ R_1094 ;
   if (((((((scene_status-->(I431_conductor_s_story-1)==1))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1094, 1094);
      ! phrase 1
      ! [1: if we are not speech , continue the conductor's story]
       if ((~~((NAP_0()) &&  (actor==player)))) { (PHR_1092_r5 ());  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1094, 1094, true);
   rfalse;
];
! No specific request
! Every turn when the conductor's story has been happening for exactly eight turns:
[ R_1095 ;
   if ((((TestSinglePastState(0, 11, false, 6) == 8 )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1095, 1095);
      ! phrase 1
      ! [1: say ~The train starts to slow down.~]
      say__p=1;ParaContent();  print (PrintText) SC_264;  new_line; .L_Say54; .L_SayX47;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1095, 1095, true);
   rfalse;
];
! No specific request
! Every turn when the conductor's story has been happening for exactly one turn:
[ R_1096 ;
   if ((((TestSinglePastState(0, 12, false, 6) == 1 )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1096, 1096);
      ! phrase 1
      ! [1: say ~The train hurtles away, taking you with it.~]
      say__p=1;ParaContent();  print (PrintText) SC_306;  new_line; .L_Say55; .L_SayX48;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1096, 1096, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Other Side of the Pond:
[ R_1173 ;
   if ((((((I494_other_side_of_the_pond == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1173, 1173);
      ! phrase 1
      ! [1: record ~traveling to other parts of the pond~ as achieved]
      (PHR_1164_r6 (SC_192));
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1173, 1173, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Atop the Tank:
[ R_1174 ;
   if ((((((I469_atop_the_tank == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1174, 1174);
      ! phrase 1
      ! [1: record ~climbing the tank~ as achieved]
      (PHR_1164_r6 (SC_195));
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1174, 1174, true);
   rfalse;
];
! No specific request
! Every turn when a random chance of 1 in 10 succeeds:
[ R_1201 ;
   if ((((( (GenerateRandomNumber(1, 10) <= 1) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1201, 1201);
      ! phrase 1
      ! [1: if the player is in a room that is outdoors and the player is not in otherland and the player is not in waterland and the player is not in a room that is dark and the player is awake , say ~[one of]Leaves waft intermittently to the ground[or]A skein of geese passes overhead[or]A murmuration of starlings flies by you[or]An exultation of larks soars past you[or]A siege of bitterns passes in the sky[purely at random].~]
       if ((((ContainerOf(player) ofclass K1_room) && ((Adj_99_t1_v9(ContainerOf(player)))))) && ((((~~((TestRegionalContainment(player,I500_otherland)))))) && ((((~~((TestRegionalContainment(player,I503_waterland)))))) && ((((~~((ContainerOf(player) ofclass K1_room) && ((Adj_48_t1_v9(ContainerOf(player)))))))) && ((((Adj_147_t1_v9(player))))))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->7 =
	i7_soo_par(I7_ST_say_one_of-->7, 5);
	switch((I7_ST_say_one_of-->7)%(5+1)-1) {
		0: ParaContent();  print (PrintText) SC_307; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_308; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_309; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_310; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_311; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say56; .L_SayX49;  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1201, 1201, true);
   rfalse;
];
! No specific request
! Every turn when a random chance of 1 in 12 succeeds:
[ R_1202 ;
   if ((((( (GenerateRandomNumber(1, 12) <= 1) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1202, 1202);
      ! phrase 1
      ! [1: if the player is in otherland and the player is in a room that is outdoors , say ~[one of]Leaves swirl purposelessly around in the air[or]You feel the wind ruffle your hair[or]A sord of mallards appears above you and then disappears into the distance[or]A spring of teal passes in the sky[or]A tidings of magpies soars past you[or]A dissimulation of tiny birds settles in a tree, then flutters off again[purely at random].~]
       if ((((TestRegionalContainment(player,I500_otherland)))) && (((ContainerOf(player) ofclass K1_room) && ((Adj_99_t1_v9(ContainerOf(player))))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->8 =
	i7_soo_par(I7_ST_say_one_of-->8, 6);
	switch((I7_ST_say_one_of-->8)%(6+1)-1) {
		0: ParaContent();  print (PrintText) SC_312; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_313; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_314; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_315; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_316; ParaContent();  @nop; 5: ParaContent();  print (PrintText) SC_317; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say57; .L_SayX50;  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1202, 1202, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Inside Waterworks:
[ R_1331 ;
   if ((((((I506_inside_waterworks == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1331, 1331);
      ! phrase 1
      ! [1: if the secretary is in inside waterworks and the secretary is curious and the secretary is calm and the player is holding the page and a random chance of 1 in 3 succeeds begin]
       if ((((I506_inside_waterworks == ContainerOf(I545_secretary_of_water)))) && (((((Adj_116_t1_v9(I545_secretary_of_water))))) && (((((Adj_115_t1_v9(I545_secretary_of_water))))) && ((((player == HolderOf(I448_page_torn_out_of_a_chil)))) && (( (GenerateRandomNumber(1, 3) <= 1) ))))))  {
         ! phrase 2
         ! [2: say ~[The secretary] steals a glance at the page you are holding, then turns back to her notebook, blushing.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_318;  new_line; .L_Say58; .L_SayX51;
         ! phrase 3
         ! [3: now the secretary is incurious]
          (Adj_117_t2_v9(I545_secretary_of_water)); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1331, 1331, true);
   rfalse;
];
! No specific request
! Every turn when the player is in the Pump Room:
[ R_1342 ;
   if ((((((I510_pump_room == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1342, 1342);
      ! phrase 1
      ! [1: if gadget-action is happening or gizmo-action is happening or lever-action is happening begin]
       if (((((scene_status-->(I427_gadget_action-1)==1)))) || (((((scene_status-->(I426_gizmo_action-1)==1)))) || ((((scene_status-->(I425_lever_action-1)==1))))))  {
         ! phrase 2
         ! [2: if gadget-action is happening and gizmo-action is happening begin]
          if (((((scene_status-->(I427_gadget_action-1)==1)))) && ((((scene_status-->(I426_gizmo_action-1)==1)))))  {
            ! phrase 3
            ! [3: say ~The pump is thumping[if lever-action is happening], humming,[end if] and shuddering.[if hose-action was happening and the leaky hose is not plugged][line break][end if]~]
            say__p=1;ParaContent();  print (PrintText) SC_319; 
	if (~~(((((scene_status-->(I425_lever_action-1)==1)))))) jump L_Say59;
		ParaContent();  print (PrintText) SC_320; 
	.L_Say59; .L_SayX52;
		ParaContent();  print (PrintText) SC_321;  new_line;
	if (~~(((TestSinglePastState(1, 13, false, 1)) && (((~~(((Adj_118_t1_v9(I526_leaky_hose)))))))))) jump L_Say60;
		ParaContent();  new_line; 
	.L_Say60; .L_SayX53;
		 .L_Say61; .L_SayX54;
            ! phrase 4
            ! [4: otherwise if gadget-action is happening and lever-action is happening]
             } else if (((((scene_status-->(I427_gadget_action-1)==1)))) && ((((scene_status-->(I425_lever_action-1)==1))))) { 
            ! phrase 5
            ! [5: say ~The pump is thumping and humming.~]
            say__p=1;ParaContent();  print (PrintText) SC_322;  new_line; .L_Say62; .L_SayX55;
            ! phrase 6
            ! [6: otherwise if gizmo-action is happening and lever-action is happening]
             } else if (((((scene_status-->(I426_gizmo_action-1)==1)))) && ((((scene_status-->(I425_lever_action-1)==1))))) { 
            ! phrase 7
            ! [7: say ~The pump is shuddering and humming.~]
            say__p=1;ParaContent();  print (PrintText) SC_323;  new_line; .L_Say63; .L_SayX56;
            ! phrase 8
            ! [8: otherwise]
            } else {

            ! phrase 9
            ! [9: if gadget-action is happening begin]
             if ((((scene_status-->(I427_gadget_action-1)==1))))  {
               ! phrase 10
               ! [10: say ~The pump is thumping a little.~]
               say__p=1;ParaContent();  print (PrintText) SC_324;  new_line; .L_Say64; .L_SayX57;
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: if gizmo-action is happening begin]
             if ((((scene_status-->(I426_gizmo_action-1)==1))))  {
               ! phrase 13
               ! [13: say ~The pump is shuddering a little.~]
               say__p=1;ParaContent();  print (PrintText) SC_325;  new_line; .L_Say65; .L_SayX58;
               ! phrase 14
               ! [14: end if]
               }

            ! phrase 15
            ! [15: if lever-action is happening begin]
             if ((((scene_status-->(I425_lever_action-1)==1))))  {
               ! phrase 16
               ! [16: say ~The pump is humming a little.~]
               say__p=1;ParaContent();  print (PrintText) SC_326;  new_line; .L_Say66; .L_SayX59;
               ! phrase 17
               ! [17: end if]
               }

            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: end if]
         }

      ! phrase 20
      ! [20: if hose-action was happening and the leaky hose is not plugged , say ~A leaky hose in the nest is spewing water from a hole, preventing the pipe from working properly.~]
       if ((TestSinglePastState(1, 14, false, 1)) && (((~~(((Adj_118_t1_v9(I526_leaky_hose)))))))) { say__p=1;ParaContent();  print (PrintText) SC_327;  new_line; .L_Say67; .L_SayX60;  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1342, 1342, true);
   rfalse;
];
! No specific request
! Every turn when the secretary's story has been happening for at least one turn:
[ R_1520 ;
   if ((((TestSinglePastState(0, 15, false, 6) >= 1 )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1520, 1520);
      ! phrase 1
      ! [1: if the player has been trapped for at least two turns , continue the attempt to free]
       if (TestSinglePastState(0, 16, false, 6) >= 2 ) { (PHR_1524_r7 ());  }
      ! phrase 2
      ! [2: if we are not speech or a random chance of 1 in 2 succeeds , continue the secretary's story]
       if (((~~((NAP_0()) &&  (actor==player)))) || (( (GenerateRandomNumber(1, 2) <= 1) ))) { (PHR_1519_r8 ());  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1520, 1520, true);
   rfalse;
];
! No specific request
! Every turn when the player has been trapped for exactly one turn:
[ R_1521 ;
   if ((((TestSinglePastState(0, 17, false, 6) == 1 )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1521, 1521);
      ! phrase 1
      ! [1: say ~'Oh gosh, you're trapped in the mud, aren't you?' [The secretary] opens her bag and pulls out a rope. 'Don't worry, this happens a lot,' she says. She ties the rope under your shoulders, knots tightly, and starts to pull.~]
      say__p=1;ParaContent();  print (PrintText) SC_328; ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_329;  new_line; .L_Say68; .L_SayX61;
      ! phrase 2
      ! [2: move the rope to the secretary]
       MoveObject(I612_rope, I545_secretary_of_water, 0, false); 
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1521, 1521, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Other Side of the Pond:
[ R_1544 ;
   if ((((((I494_other_side_of_the_pond == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1544, 1544);
      ! phrase 1
      ! [1: if a random chance of 1 in 6 succeeds , say ~[one of]A dense patch of mist passes through you[or]You shiver a little in the fog[at random].~]
       if (( (GenerateRandomNumber(1, 6) <= 1) )) { say__p=1;ParaContent();  I7_ST_say_one_of-->9 =
	i7_soo_ran(I7_ST_say_one_of-->9, 2);
	switch((I7_ST_say_one_of-->9)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_330; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_331; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say69; .L_SayX62;  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1544, 1544, true);
   rfalse;
];
! No specific request
! Every turn when Inside Waterworks has been flooded for exactly one turn:
[ R_1609 ;
   if ((((TestSinglePastState(0, 18, false, 6) == 1 )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1609, 1609);
      ! phrase 1
      ! [1: say ~You shiver, a little shaken by what's happened to the Waterworks. But your curiosity about the Crystal City is as strong as ever.~]
      say__p=1;ParaContent();  print (PrintText) SC_332;  new_line; .L_Say70; .L_SayX63;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1609, 1609, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Pump Room:
[ R_1613 ;
   if ((((((I510_pump_room == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1613, 1613);
      ! phrase 1
      ! [1: if the complicated pump has been switched on for exactly one turns , say ~Water starts to gush out of the pump.~]
       if (TestSinglePastState(0, 19, false, 6) == 1 ) { say__p=1;ParaContent();  print (PrintText) SC_333;  new_line; .L_Say71; .L_SayX64;  }
      ! phrase 2
      ! [2: if the complicated pump has been switched on for exactly two turns , say ~Seams on the pump start cracking, bursting. The water pools around your feet.~]
       if (TestSinglePastState(0, 20, false, 6) == 2 ) { say__p=1;ParaContent();  print (PrintText) SC_334;  new_line; .L_Say72; .L_SayX65;  }
      ! phrase 3
      ! [3: if the complicated pump has been switched on for at least three turns , say ~The water level rises alarmingly speedily.~]
       if (TestSinglePastState(0, 21, false, 6) >= 3 ) { say__p=1;ParaContent();  print (PrintText) SC_335;  new_line; .L_Say73; .L_SayX66;  }
      ! phrase 4
      ! [4: if the complicated pump has been switched on for at least four turns and the player has been in pump room at least one turn begin]
       if ((TestSinglePastState(0, 22, false, 6) >= 4 ) && (TestSinglePastState(0, 23, false, 6) >= 1 ))  {
         ! phrase 5
         ! [5: say ~[line break]The water level rises faster than you can keep up with it, gushing, mud and dirt and little pieces of algae.[paragraph break]Your mouth and nose fill with it -- you try to escape, but you can't, you're sinking--~]
         say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_336; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_337;  .L_Say74; .L_SayX67;
         ! phrase 6
         ! [6: end the game in death]
          deadflag=1; story_complete=false; 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1613, 1613, true);
   rfalse;
];
! No specific request
! Every turn when the player is in Inside Waterworks:
[ R_1614 ;
   if ((((((I506_inside_waterworks == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1614, 1614);
      ! phrase 1
      ! [1: if the complicated pump has been switched on for exactly two turns begin]
       if (TestSinglePastState(0, 24, false, 6) == 2 )  {
         ! phrase 2
         ! [2: say ~A damp stain starts to spread over the floor.~]
         say__p=1;ParaContent();  print (PrintText) SC_338;  new_line; .L_Say75; .L_SayX68;
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the complicated pump has been switched on for exactly three turns , say ~The damp stain on the floor widens, turning brown, growing to the size of the whole room.~]
       if (TestSinglePastState(0, 25, false, 6) == 3 ) { say__p=1;ParaContent();  print (PrintText) SC_339;  new_line; .L_Say76; .L_SayX69;  }
      ! phrase 5
      ! [5: if the complicated pump has been switched on for exactly four turns or the complicated pump has been switched on for at least four turns and the player was not in inside waterworks begin]
       if ((TestSinglePastState(0, 26, false, 6) == 4 ) || ((TestSinglePastState(0, 27, false, 6) >= 4 ) && (~~(TestSinglePastState(1, 28, false, 1)))))  {
         ! phrase 6
         ! [6: say ~The floor under the desk cracks -- breaks -- collapses entirely, the desk falling into the space below with a loud splash, and the cylinder cracking into innumerable pieces, the keychain finally floating within your reach.~]
         say__p=1;ParaContent();  print (PrintText) SC_340;  new_line; .L_Say77; .L_SayX70;
         ! phrase 7
         ! [7: now the desk is off-stage]
          (Adj_9_t3_v9(I518_desk)); 
         ! phrase 8
         ! [8: now the red keychain is in inside waterworks]
          MoveObject(I486_red_foam_keychain,I506_inside_waterworks); 
         ! phrase 9
         ! [9: end if]
         }

      ! phrase 10
      ! [10: if the complicated pump has been switched on for at least five turns and the player has been in inside waterworks at least one turn begin]
       if ((TestSinglePastState(0, 29, false, 6) >= 5 ) && (TestSinglePastState(0, 30, false, 6) >= 1 ))  {
         ! phrase 11
         ! [11: say ~The crack spreads, and the floor beneath your feet collapses with a horrible crunching noise, dropping you into the flooded basement.[paragraph break]You paddle helplessly in the dirty water, mud, crumbling leaves, algae bobbing and swirling around you.[paragraph break]The water swirls faster than you can handle -- up, around, over you --[paragraph break]You try to find something to grab onto, but only briefly touch [the random visible thing] before you fall, and the water is on top of you and you can't breathe.~]
         say__p=1;ParaContent();  print (PrintText) SC_341; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_342; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_343; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_344; ParaContent();  print (the)  (Prop_5()) ; ParaContent();  print (PrintText) SC_345;  new_line; .L_Say78; .L_SayX71;
         ! phrase 12
         ! [12: end the game in death]
          deadflag=1; story_complete=false; 
         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1614, 1614, true);
   rfalse;
];
! No specific request
! Every turn when Endgame is happening:
[ R_1708 
    t_0 ! Local variable e.g. 'leaflet' = flat paper
    ;
   if (((((((scene_status-->(I695_endgame-1)==1))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1708, 1708);
      ! phrase 1
      ! [1: if the giant metal wheel is spinning begin]
       if ((((Adj_138_t1_v9(I698_giant_metal_wheel)))))  {
         ! phrase 2
         ! [2: if the minutes part of the time of day is 0 or the minutes part of the time of day is 10 or the minutes part of the time of day is 20 or the minutes part of the time of day is 30 or the minutes part of the time of day is 40 or the minutes part of the time of day is 50 begin]
          if (((( (the_time%ONE_HOUR)  == 0))) || (((( (the_time%ONE_HOUR)  == 10))) || (((( (the_time%ONE_HOUR)  == 20))) || (((( (the_time%ONE_HOUR)  == 30))) || (((( (the_time%ONE_HOUR)  == 40))) || ((( (the_time%ONE_HOUR)  == 50))))))))  {
            ! phrase 3
            ! [3: say ~The metal wheel turns clockwise. A cavity in the metal wheel rises to the top.~]
            say__p=1;ParaContent();  print (PrintText) SC_346;  new_line; .L_Say79; .L_SayX72;
            ! phrase 4
            ! [4: now the cavity is accessible]
             (Adj_140_t2_v9(I701_cavity)); 
            ! phrase 5
            ! [5: the cavity hides in one turn from now]
             SetTimedEvent(R_1702, 1+1, 0); 
            ! phrase 6
            ! [6: if something is contained by the cavity begin]
             if ((Prop_6()))  {
               ! phrase 7
               ! [7: the cavity continues in two turns from now]
                SetTimedEvent(R_1703, 2+1, 0); 
               ! phrase 8
               ! [8: the cavity continues yet again in three turns from now]
                SetTimedEvent(R_1704, 3+1, 0); 
               ! phrase 9
               ! [9: end if]
               }

            ! phrase 10
            ! [10: the crystal gear approaches in four turns from now]
             SetTimedEvent(R_1705, 4+1, 0); 
            ! phrase 11
            ! [11: otherwise if the minutes part of the time of day is 5 or the minutes part of the time of day is 15 or the minutes part of the time of day is 25 or the minutes part of the time of day is 35 or the minutes part of the time of day is 45 or the minutes part of the time of day is 55]
             } else if (((( (the_time%ONE_HOUR)  == 5))) || (((( (the_time%ONE_HOUR)  == 15))) || (((( (the_time%ONE_HOUR)  == 25))) || (((( (the_time%ONE_HOUR)  == 35))) || (((( (the_time%ONE_HOUR)  == 45))) || ((( (the_time%ONE_HOUR)  == 55)))))))) { 
            ! phrase 12
            ! [12: if a flat paper ( called leaflet ) is in the cavity begin]
             if ((Prop_7() && (t_0=deferred_calling_list-->0, true)))  {
               ! phrase 13
               ! [13: say ~You hear a tearing sound from the pump as the metal wheel cuts through the insubstantial [leaflet] and rips it to pieces.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_347; ParaContent();  print (PrintShortName) t_0; ParaContent();  print (PrintText) SC_348; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say80; .L_SayX73;
               ! phrase 14
               ! [14: say ~'Oh,' Doug says, disappointed.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_349; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say81; .L_SayX74;
               ! phrase 15
               ! [15: now leaflet is off-stage]
                (Adj_9_t3_v9(t_0)); 
               ! phrase 16
               ! [16: end if]
               }

            ! phrase 17
            ! [17: if something that is not a flat paper is in the cavity begin]
             if ((Prop_8()))  {
               ! phrase 18
               ! [18: if a metal thing is in the cavity begin]
                if ((Prop_9()))  {
                  ! phrase 19
                  ! [19: say ~The metal wheel slows, and starts to emit a banging and cranking sound, distorted by the water. It whirrs and grunts, straining against [the random thing contained by the cavity], and stops altogether after a minute.[paragraph break]The crystal gear turns past the metal wheel.[paragraph break]~]
                  say__p=1;ParaContent();  print (PrintText) SC_350; ParaContent();  print (the)  (Prop_10()) ; ParaContent();  print (PrintText) SC_351; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_352; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say82; .L_SayX75;
                  ! phrase 20
                  ! [20: say ~'Oh!' Vivian says. Doug and Cordelia grab each other's hands, looking forward intensely.~]
                  say__p=1;ParaContent();  print (PrintText) SC_353;  new_line; .L_Say83; .L_SayX76;
                  ! phrase 21
                  ! [21: now the crystal gear is spinning]
                   (Adj_138_t2_v9(I699_large_crystal_gear)); 
                  ! phrase 22
                  ! [22: now the giant metal wheel is stopped]
                   (Adj_139_t2_v9(I698_giant_metal_wheel)); 
                  ! phrase 23
                  ! [23: the gears catch in one turn from now]
                   SetTimedEvent(R_1710, 1+1, 0); 
                  ! phrase 24
                  ! [24: otherwise]
                  } else {

                  ! phrase 25
                  ! [25: say ~The metal wheel slows, and starts to emit a crunching sound, distorted by the water. It whirrs and grunts, straining against [the random thing contained by the cavity that is not a flat paper] -- then, with a horrible crunching, [the random thing contained by the cavity that is not a flat paper] is torn apart, and the metal wheel continues its motion.[paragraph break]~]
                  say__p=1;ParaContent();  print (PrintText) SC_354; ParaContent();  print (the)  (Prop_11()) ; ParaContent();  print (PrintText) SC_355; ParaContent();  print (the)  (Prop_12()) ; ParaContent();  print (PrintText) SC_356; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say84; .L_SayX77;
                  ! phrase 26
                  ! [26: say ~[one of]'Ooh,' says Vivian, wrinkling her nose[or]Doug cringes at the noise[or]Cordelia jumps a little at the sound[at random].[paragraph break]~]
                  say__p=1;ParaContent();  I7_ST_say_one_of-->10 =
	i7_soo_ran(I7_ST_say_one_of-->10, 3);
	switch((I7_ST_say_one_of-->10)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_357; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_358; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_359; ParaContent();  } ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say85; .L_SayX78;
                  ! phrase 27
                  ! [27: now the random thing contained by the cavity that is not a flat paper is off-stage]
                   (Adj_9_t3_v9( (Prop_13()) )); 
                  ! phrase 28
                  ! [28: end if]
                  }

               ! phrase 29
               ! [29: end if]
               }

            ! phrase 30
            ! [30: if nothing that is in the cavity is metal begin]
             if ((Prop_14()))  {
               ! phrase 31
               ! [31: say ~[one of]A spike sticking out the side of the metal wheel moves downward with the wheel, blocking the crystal gear from continuing its movement[or]The spike blocks the crystal wheel again[stopping]. The crystal gear struggles to move forward under its own power, then slides backwards a few notches, blocked by the spike.~]
               say__p=1;ParaContent();  I7_ST_say_one_of-->11 =
	i7_soo_stop(I7_ST_say_one_of-->11, 2);
	switch((I7_ST_say_one_of-->11)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_360; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_361; ParaContent();  } ParaContent();  print (PrintText) SC_362;  new_line; .L_Say86; .L_SayX79;
               ! phrase 32
               ! [32: end if]
               }

            ! phrase 33
            ! [33: otherwise]
            } else {

            ! phrase 34
            ! [34: if a random chance of 1 in 2 succeeds , say ~[one of]A[or]The[stopping] giant metal wheel is turning slowly clockwise within the pump[if something is in the cavity], with [the random thing in the cavity] inside the cavity[end if].~]
             if (( (GenerateRandomNumber(1, 2) <= 1) )) { say__p=1;ParaContent();  I7_ST_say_one_of-->12 =
	i7_soo_stop(I7_ST_say_one_of-->12, 2);
	switch((I7_ST_say_one_of-->12)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_363; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_364; ParaContent();  } ParaContent();  print (PrintText) SC_365; 
	if (~~(((Prop_15())))) jump L_Say87;
		ParaContent();  print (PrintText) SC_366; ParaContent();  print (the)  (Prop_16()) ; ParaContent();  print (PrintText) SC_367; 
	.L_Say87; .L_SayX80;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say88; .L_SayX81;  }
            ! phrase 35
            ! [35: end if]
            }

         ! phrase 36
         ! [36: end if]
         }

   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1708, 1708, true);
   rfalse;
];
! No specific request
! Every turn during Second Pump:
[ R_1513 ;
   if (scene_status-->6 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1513, 1513);
      ! phrase 1
      ! [1: if the player is in freshwater crossing and the secretary is off-stage and the secretary's story has not happened begin]
       if ((((I507_freshwater_crossing == ContainerOf(player)))) && (((((~~Adj_9_t1_v9(I545_secretary_of_water))))) && (( (scene_endings-->(I611_secretary_s_story-1) == 0) ))))  {
         ! phrase 2
         ! [2: now the secretary is in freshwater crossing]
          MoveObject(I545_secretary_of_water,I507_freshwater_crossing); 
         ! phrase 3
         ! [3: say ~[The secretary] hurries past you to the southwest, carrying a large bag. Something about her demeanor gives you a chill.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_368;  new_line; .L_Say89; .L_SayX82;
         ! phrase 4
         ! [4: silently try the secretary going southwest]
          @push keep_silent; keep_silent=1; TryAction(0, I545_secretary_of_water, ##Go, I51_southwest, 0);; @pull keep_silent; 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1513, 1513, true);
   rfalse;
];
! No specific request
! Every turn during Third Pump:
[ R_1514 ;
   if (scene_status-->7 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1514, 1514);
      ! phrase 1
      ! [1: if the player is in freshwater crossing and the secretary is off-stage and the secretary's story has not happened begin]
       if ((((I507_freshwater_crossing == ContainerOf(player)))) && (((((~~Adj_9_t1_v9(I545_secretary_of_water))))) && (( (scene_endings-->(I611_secretary_s_story-1) == 0) ))))  {
         ! phrase 2
         ! [2: now the secretary is in freshwater crossing]
          MoveObject(I545_secretary_of_water,I507_freshwater_crossing); 
         ! phrase 3
         ! [3: say ~[The secretary] hurries past you to the southwest, carrying a large bag. Something about her demeanor gives you a chill.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_368;  new_line; .L_Say90; .L_SayX83;
         ! phrase 4
         ! [4: silently try the secretary going southwest]
          @push keep_silent; keep_silent=1; TryAction(0, I545_secretary_of_water, ##Go, I51_southwest, 0);; @pull keep_silent; 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1514, 1514, true);
   rfalse;
];
! No specific request
! Every turn during First Pump:
[ R_1515 ;
   if (scene_status-->1 == 1) { ! Runs only during scene
   if (debug_rules) DB_Rule(R_1515, 1515);
      ! phrase 1
      ! [1: if the player is in outside waterworks and the secretary is in inside waterworks begin]
       if ((((I447_outside_waterworks == ContainerOf(player)))) && (((I506_inside_waterworks == ContainerOf(I545_secretary_of_water)))))  {
         ! phrase 2
         ! [2: now the secretary is in outside waterworks]
          MoveObject(I545_secretary_of_water,I447_outside_waterworks); 
         ! phrase 3
         ! [3: say ~[The secretary] rushes out of the Waterworks, looking agitated. She dashes past you so quickly that, moments later, you realize you have no idea where she went.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_369;  new_line; .L_Say91; .L_SayX84;
         ! phrase 4
         ! [4: move the bag to the secretary]
          MoveObject(I610_large_bag, I545_secretary_of_water, 0, false); 
         ! phrase 5
         ! [5: now the secretary is off-stage]
          (Adj_9_t3_v9(I545_secretary_of_water)); 
         ! phrase 6
         ! [6: now the notebook is on the desk]
          MoveObject(I543_notebook,I518_desk); 
         ! phrase 7
         ! [7: now the notebook is described]
          (Adj_61_t2_v9(I543_notebook)); 
         ! phrase 8
         ! [8: end if]
         }

   } ! Runs only during scene
   else if (debug_rules > 1) DB_Rule(R_1515, 1515, true);
   rfalse;
];
! No specific request
! Every turn:
[ R_1344 ;
      ! phrase 1
      ! [1: if the player has been in the pump room for at least ten turns and the secretary has been in inside waterworks for at least four turns begin]
       if ((TestSinglePastState(0, 31, false, 6) >= 10 ) && (TestSinglePastState(0, 32, false, 6) >= 4 ))  {
         ! phrase 2
         ! [2: say ~[The secretary] clatters down the staircase into the Pump Room.[paragraph break]'OK, look, if my boss finds out I was letting a stranger mess around with this stuff, I would be in big trouble. So you gotta go,' says [the secretary]. She grabs your wrist -- with surprising strength, considering her youth and size -- dragging you back up the twisty stairs and escorting you outside.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_370; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_371; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_372;  new_line; .L_Say92; .L_SayX85;
         ! phrase 3
         ! [3: now the player is in outside waterworks]
          MoveObject(player,I447_outside_waterworks); 
         ! phrase 4
         ! [4: now the secretary is irked]
          (Adj_114_t2_v9(I545_secretary_of_water)); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! Every turn:
[ R_1470 ;
      ! phrase 1
      ! [1: if the drawer has been held for at least two turns and a random chance of 2 in 3 succeeds and the player is awake begin]
       if ((TestSinglePastState(0, 33, false, 6) >= 2 ) && ((( (GenerateRandomNumber(1, 3) <= 2) )) && ((((Adj_147_t1_v9(player)))))))  {
         ! phrase 2
         ! [2: say ~The drawer is getting pretty heavy.~]
         say__p=1;ParaContent();  print (PrintText) SC_373;  new_line; .L_Say93; .L_SayX86;
         ! phrase 3
         ! [3: end if]
         }

   rfalse;
];
! No specific request
! Every turn:
[ R_1471 ;
      ! phrase 1
      ! [1: if the drawer has been held for at least seven turns and a random chance of 1 in 3 succeeds and the player is awake begin]
       if ((TestSinglePastState(0, 34, false, 6) >= 7 ) && ((( (GenerateRandomNumber(1, 3) <= 1) )) && ((((Adj_147_t1_v9(player)))))))  {
         ! phrase 2
         ! [2: say ~Carrying the drawer is a pain! You're tired and you set it down, [if the drawer is upside-down]upside down[otherwise]right side up[end if].~]
         say__p=1;ParaContent();  print (PrintText) SC_374; 
	if (~~(((((Adj_128_t1_v9(I589_wooden_drawer))))))) jump L_Say94;
		ParaContent();  print (PrintText) SC_375; 
	jump L_SayX87; .L_Say94;
		ParaContent();  print (PrintText) SC_376; 
	.L_Say95; .L_SayX87;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say96; .L_SayX88;
         ! phrase 3
         ! [3: silently try dropping the drawer]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##Drop, I589_wooden_drawer, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! No specific request
! Every turn:
[ R_1556 ;
      ! phrase 1
      ! [1: if the player has been in the woods for exactly two turns and the dog has been in the woods for two turns , say ~The dog looks up at you expectantly.~]
       if ((TestSinglePastState(0, 35, false, 6) == 2 ) && (TestSinglePastState(0, 36, false, 6) >= 2 )) { say__p=1;ParaContent();  print (PrintText) SC_377;  new_line; .L_Say97; .L_SayX89;  }
   rfalse;
];
! No specific request
! Every turn:
[ R_1566 ;
      ! phrase 1
      ! [1: if the player has been in the woods for three turns and the dog has been in the woods for two turns begin]
       if ((TestSinglePastState(0, 37, false, 6) >= 3 ) && (TestSinglePastState(0, 38, false, 6) >= 2 ))  {
         ! phrase 2
         ! [2: if the dog is in the woods , try the dog going northwest]
          if (((I444_woods == ContainerOf(I443_dog)))) {  TryAction(0, I443_dog, ##Go, I48_northwest, 0);;   }
         ! phrase 3
         ! [3: now the dog is roaming]
          (Adj_132_t2_v9(I443_dog)); 
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! No specific request
! Every turn:
[ R_1607 ;
      ! phrase 1
      ! [1: if the underground pump has been switched on for exactly one turn , say ~[if the player is in Inside The Hut]The pump[otherwise]The hut[end if] shakes and vibrates.~]
       if (TestSinglePastState(0, 39, false, 6) == 1 ) { say__p=1;
	if (~~((((I637_inside_the_cinderblock_ == ContainerOf(player)))))) jump L_Say98;
		ParaContent();  print (PrintText) SC_378; 
	jump L_SayX90; .L_Say98;
		ParaContent();  print (PrintText) SC_379; 
	.L_Say99; .L_SayX90;
		ParaContent();  print (PrintText) SC_380;  new_line; .L_Say100; .L_SayX91;  }
      ! phrase 2
      ! [2: if the underground pump has been switched on for exactly two turns , say ~[if the player is in Inside The Hut]The floor[otherwise]The ground[end if] quakes.~]
       if (TestSinglePastState(0, 40, false, 6) == 2 ) { say__p=1;
	if (~~((((I637_inside_the_cinderblock_ == ContainerOf(player)))))) jump L_Say101;
		ParaContent();  print (PrintText) SC_381; 
	jump L_SayX92; .L_Say101;
		ParaContent();  print (PrintText) SC_382; 
	.L_Say102; .L_SayX92;
		ParaContent();  print (PrintText) SC_383;  new_line; .L_Say103; .L_SayX93;  }
      ! phrase 3
      ! [3: if the underground pump has been switched on for exactly three turns , say ~As if from deep below you, you hear the rumbling of rushing water.~]
       if (TestSinglePastState(0, 41, false, 6) == 3 ) { say__p=1;ParaContent();  print (PrintText) SC_384;  new_line; .L_Say104; .L_SayX94;  }
      ! phrase 4
      ! [4: if the underground pump has been switched on for exactly four turns , say ~The rumbling slows to a steady, almost unnoticeable vibration beneath you.~]
       if (TestSinglePastState(0, 42, false, 6) == 4 ) { say__p=1;ParaContent();  print (PrintText) SC_385;  new_line; .L_Say105; .L_SayX95;  }
   rfalse;
];
! No specific request
! Every turn:
[ R_1615 ;
      ! phrase 1
      ! [1: if the complicated pump has been switched on for at least seven turns , now inside waterworks is flooded]
       if (TestSinglePastState(0, 43, false, 6) >= 7 ) {  (Adj_136_t2_v9(I506_inside_waterworks));   }
      ! phrase 2
      ! [2: if the complicated pump has been switched on for at least five turns , now pump room is flooded]
       if (TestSinglePastState(0, 44, false, 6) >= 5 ) {  (Adj_136_t2_v9(I510_pump_room));   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B10_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/12 ! This is the announce items from multiple object lists rule:
!   === which is equally specific with ===
! Rule 2/12 ! This is the set pronouns from items from multiple object lists rule:
!   === which is equally specific with ===
! Rule 3/12 ! This is the before stage rule:
! --- now the mid-placed rules ---
! Rule 4/12 ! This is the update ambiguous pronouns for actions rule:
!   >>> III - Action requirement >>>
! Rule 5/12: BASIC_VISIBILITY_R
!   === which is equally specific with ===
! Rule 6/12: BASIC_ACCESSIBILITY_R
!   <<< III - Action requirement <<<
! Rule 7/12 ! This is the keychain-aware carrying requirements rule:
! --- now the last-placed rules ---
! Rule 8/12 ! This is the instead stage rule:
!   === which is equally specific with ===
! Rule 9/12: REQUESTED_ACTIONS_REQUIRE_R
!   === which is equally specific with ===
! Rule 10/12: CARRY_OUT_REQUESTED_ACTIONS_R
!   === which is equally specific with ===
! Rule 11/12: DESCEND_TO_SPECIFIC_ACTION_R
!   === which is equally specific with ===
! Rule 12/12 ! This is the end action-processing in success rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the announce items from multiple object lists rule:
[ R_20 ;
      ! phrase 1
      ! [1: if the current item from the multiple object list is not nothing , say ~[current item from the multiple object list]: [run paragraph on]~]
       if (((~~((multiple_object_item == nothing))))) { say__p=1;ParaContent();  print (PrintShortName) multiple_object_item; ParaContent();  print (PrintText) SC_386; ParaContent();  RunParagraphOn();  .L_Say106; .L_SayX96;  }
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the set pronouns from items from multiple object lists rule:
[ R_19 ;
      ! phrase 1
      ! [1: if the current item from the multiple object list is not nothing , set pronouns from the current item from the multiple object list]
       if (((~~((multiple_object_item == nothing))))) {  PronounNotice(multiple_object_item);   }
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the before stage rule:
[ R_21 ;
      ! phrase 1
      ! [1: abide by the before rules]
       if (ProcessRulebook(20)) rtrue; 
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! This is the update ambiguous pronouns for actions rule:
[ R_1004 ;
      ! phrase 1
      ! [1: if the noun is a thing and the noun is ambiguously plural begin]
       if ((((noun ofclass K2_thing))) && ((((Adj_92_t1_v9(noun))))))  {
         ! phrase 2
         ! [2: notice the plurality of the noun]
          PlugPlural(noun); 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the second noun is a thing and the second noun is ambiguously plural begin]
       if ((((second ofclass K2_thing))) && ((((Adj_92_t1_v9(second))))))  {
         ! phrase 5
         ! [5: notice the plurality of the second noun]
          PlugPlural(second); 
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the keychain-aware carrying requirements rule:
[ R_843 ;
      ! phrase 1
      ! [1: if locking or unlocking something with something which is on a keychain which is carried by the actor begin]
       if (((action ==##Lock) &&  (actor==player)) || ((action ==##Unlock) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing) && (SupporterOf(second) ofclass K19_keychain) && (actor == CarrierOf(SupporterOf(second))))))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: abide by the carrying requirements rule]
       if (ProcessRulebook(CARRYING_REQUIREMENTS_R)) rtrue; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the instead stage rule:
[ R_22 ;
      ! phrase 1
      ! [1: abide by the instead rules]
       if (ProcessRulebook(21)) rtrue; 
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the end action-processing in success rule:
[ R_23 ;
      ! phrase 1
      ! [1: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B11_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Rule for setting action variables for going ( this is the allow rideables to be going vehicles rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Setting action variables for exiting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_137 
    t_0 ! Local variable e.g. 'carriage' = vehicle
    t_1 ! Local variable e.g. 'target' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_137, 137);
      ! phrase 1
      ! [1: now the thing gone with is the item-pushed-between-rooms]
       (MStack-->MstVO(20007,4)) = move_pushing; 
      ! phrase 2
      ! [2: now the room gone from is the location of the actor]
       (MStack-->MstVO(20007,0)) =  LocationOf(actor) ; 
      ! phrase 3
      ! [3: if the actor is in an enterable vehicle ( called the carriage ) , now the vehicle gone by is the carriage]
       if (((ContainerOf(actor) ofclass K14_vehicle) && (t_0=(ContainerOf(actor)), true) && ((Adj_67_t1_v9(ContainerOf(actor)))))) {  (MStack-->MstVO(20007,3)) = t_0;   }
      ! phrase 4
      ! [4: let the target be nothing]
       t_1 = nothing; 
      ! phrase 5
      ! [5: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 6
         ! [6: let direction d be the noun]
          t_2 = noun; 
         ! phrase 7
         ! [7: let the target be the room-or-door direction d from the room gone from]
          t_1 = (Resolver_0(t_2,(MStack-->MstVO(20007,0)),"source", 1948)); 
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: if the noun is a door , let the target be the noun]
          if (((noun ofclass K4_door))) {  t_1 = noun;   }
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if the target is a door begin]
       if (((t_1 ofclass K4_door)))  {
         ! phrase 12
         ! [12: now the door gone through is the target]
          (MStack-->MstVO(20007,2)) = t_1; 
         ! phrase 13
         ! [13: now the target is the other side of the target from the room gone from]
          t_1 = (Resolver_1(t_1,(MStack-->MstVO(20007,0)),"source", 1953)); 
         ! phrase 14
         ! [14: end if]
         }

      ! phrase 15
      ! [15: now the room gone to is the target]
       (MStack-->MstVO(20007,1)) = t_1; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_137, 137, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_171 ;
   if ((action ==##Look)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_171, 171);
      ! phrase 1
      ! [1: if the actor is the player , calculate visibility ceiling at low level]
       if (((actor == player))) {  FindVisibilityLevels();   }
      ! phrase 2
      ! [2: now the visibility level count is the visibility ceiling count calculated]
       (MStack-->MstVO(20011,2)) =  visibility_levels ; 
      ! phrase 3
      ! [3: now the visibility ceiling is the visibility ceiling calculated]
       (MStack-->MstVO(20011,3)) =  visibility_ceiling ; 
      ! phrase 4
      ! [4: now the room-describing action is the looking action]
       (MStack-->MstVO(20011,0)) = ##Look; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_171, 171, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Rule for setting action variables for going ( this is the allow rideables to be going vehicles rule ):
[ R_792 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    t_1 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_792, 792);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal ( called the steed ) , now the vehicle gone by is the steed]
       if (((CarrierOf(actor) ofclass K16_rideable_animal) && (t_0=(CarrierOf(actor)), true))) {  (MStack-->MstVO(20007,3)) = t_0;   }
      ! phrase 2
      ! [2: if the actor is on a rideable vehicle ( called the conveyance ) , now the vehicle gone by is the conveyance]
       if (((SupporterOf(actor) ofclass K17_rideable_vehicle) && (t_1=(SupporterOf(actor)), true))) {  (MStack-->MstVO(20007,3)) = t_1;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_792, 792, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Setting action variables for exiting:
[ R_159 ;
   if ((action ==##Exit)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_159, 159);
      ! phrase 1
      ! [1: now the container exited from is the holder of the actor]
       (MStack-->MstVO(20009,0)) =  (HolderOf(actor)) ; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_159, 159, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: specific action-processing (B12_specific_action_processi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8: WORK_OUT_DETAILS_OF_SPECIFIC_R
! --- now the mid-placed rules ---
! Rule 2/8 ! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
!   === which is equally specific with ===
! Rule 3/8 ! A specific action-processing rule ( this is the check stage rule ):
!   === which is equally specific with ===
! Rule 4/8 ! A specific action-processing rule ( this is the carry out stage rule ):
!   === which is equally specific with ===
! Rule 5/8 ! A specific action-processing rule ( this is the after stage rule ):
!   === which is equally specific with ===
! Rule 6/8 ! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
!   === which is equally specific with ===
! Rule 7/8 ! A specific action-processing rule ( this is the report stage rule ):
! --- now the last-placed rules ---
! Rule 8/8 ! The last specific action-processing rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the investigate player's awareness before action rule ):
[ R_24 ;
      ! phrase 1
      ! [1: consider the player's action awareness rules]
       ProcessRulebook(13); 
      ! phrase 2
      ! [2: if rule succeeded , now within the player's sight is true]
       if (( (RulebookSucceeded()) )) {  (MStack-->MstVO(12,5)) = 1;   }
      ! phrase 3
      ! [3: otherwise now within the player's sight is false]
       else {  (MStack-->MstVO(12,5)) = 0;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the check stage rule ):
[ R_25 ;
      ! phrase 1
      ! [1: anonymously abide by the specific check rulebook]
       if (temporary_value = ProcessRulebook((MStack-->MstVO(12,2)))) {
		if (RulebookSucceeded()) ActRulebookSucceeds(temporary_value);
		else ActRulebookFails(temporary_value);
		return 2;
	} 
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the carry out stage rule ):
[ R_26 ;
      ! phrase 1
      ! [1: consider the specific carry out rulebook]
       ProcessRulebook((MStack-->MstVO(12,3))); 
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the after stage rule ):
[ R_27 ;
      ! phrase 1
      ! [1: if action in world is true , abide by the after rules]
       if (((((MStack-->MstVO(12,0)) && true) == (1 && true)))) {  if (ProcessRulebook(24)) rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the investigate player's awareness after action rule ):
[ R_28 ;
      ! phrase 1
      ! [1: if within the player's sight is false begin]
       if (((((MStack-->MstVO(12,5)) && true) == (0 && true))))  {
         ! phrase 2
         ! [2: consider the player's action awareness rules]
          ProcessRulebook(13); 
         ! phrase 3
         ! [3: if rule succeeded , now within the player's sight is true]
          if (( (RulebookSucceeded()) )) {  (MStack-->MstVO(12,5)) = 1;   }
         ! phrase 4
         ! [4: end if]
         }

   rfalse;
];
! No specific request
! From the Standard Rules
! A specific action-processing rule ( this is the report stage rule ):
[ R_29 ;
      ! phrase 1
      ! [1: if within the player's sight is true and action keeping silent is false , consider the specific report rulebook]
       if ((((((MStack-->MstVO(12,5)) && true) == (1 && true)))) && (((((MStack-->MstVO(12,1)) && true) == (0 && true))))) {  ProcessRulebook((MStack-->MstVO(12,4)));   }
   rfalse;
];
! No specific request
! From the Standard Rules
! The last specific action-processing rule:
[ R_30 ;
      ! phrase 1
      ! [1: rule succeeds]
       RulebookSucceeds(); rtrue; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: player's action awareness (B13_player_s_action_awarenes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! A player's action awareness rule ( this is the player aware of his own actions rule ):
!   === which is equally specific with ===
! Rule 2/4 ! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
!   === which is equally specific with ===
! Rule 3/4 ! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
!   === which is equally specific with ===
! Rule 4/4 ! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of his own actions rule ):
[ R_31 ;
      ! phrase 1
      ! [1: if the player is the actor , rule succeeds]
       if (((player == actor))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions by visible actors rule ):
[ R_32 ;
      ! phrase 1
      ! [1: if the player is not the actor and the player can see the actor , rule succeeds]
       if ((((~~((player == actor))))) && (((TestVisibility(player,actor))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions on visible nouns rule ):
[ R_33 ;
      ! phrase 1
      ! [1: if the noun is a thing and the player can see the noun , rule succeeds]
       if ((((noun ofclass K2_thing))) && (((TestVisibility(player,noun))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! No specific request
! From the Standard Rules
! A player's action awareness rule ( this is the player aware of actions on visible second nouns rule ):
[ R_34 ;
      ! phrase 1
      ! [1: if the second noun is a thing and the player can see the second noun , rule succeeds]
       if ((((second ofclass K2_thing))) && (((TestVisibility(player,second))))) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Reaching inside (B15_reaching_inside)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Rule for reaching inside the Steam Train when we are speech:
!   === which is equally specific with ===
! Rule 2/6 ! Rule for reaching inside the Steam Train when we are giving something to someone:
!   === which is equally specific with ===
! Rule 3/6 ! Rule for reaching inside the Steam Train when we are showing something to someone:
!   === which is equally specific with ===
! Rule 4/6 ! Rule for reaching inside Inside Waterworks when we are speech:
! --- now the last-placed rules ---
! Rule 5/6: CANT_REACH_INSIDE_ROOMS_R
!   === which is equally specific with ===
! Rule 6/6: CANT_REACH_INSIDE_CLOSED_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for reaching inside the Steam Train when we are speech:
[ R_1136 ;
   if (((parameter_object == I439_steam_train) && (true))) { ! Runs only when pattern matches
   if (((((NAP_0()) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1136, 1136);
      ! phrase 1
      ! [1: allow access]
      RulebookSucceeds(19, RBNO_0); rtrue;

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1136, 1136, true);
   rfalse;
];
! No specific request
! Rule for reaching inside the Steam Train when we are giving something to someone:
[ R_1137 ;
   if (((parameter_object == I439_steam_train) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1137, 1137);
      ! phrase 1
      ! [1: allow access]
      RulebookSucceeds(19, RBNO_0); rtrue;

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1137, 1137, true);
   rfalse;
];
! No specific request
! Rule for reaching inside the Steam Train when we are showing something to someone:
[ R_1138 ;
   if (((parameter_object == I439_steam_train) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1138, 1138);
      ! phrase 1
      ! [1: allow access]
      RulebookSucceeds(19, RBNO_0); rtrue;

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1138, 1138, true);
   rfalse;
];
! No specific request
! Rule for reaching inside Inside Waterworks when we are speech:
[ R_1374 ;
   if (((parameter_object == I506_inside_waterworks) && (true))) { ! Runs only when pattern matches
   if (((((NAP_0()) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1374, 1374);
      ! phrase 1
      ! [1: allow access]
      RulebookSucceeds(19, RBNO_0); rtrue;

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1374, 1374, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Visibility (B17_visibility)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last visibility rule ( this is the can't act in the dark rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! The last visibility rule ( this is the can't act in the dark rule ):
[ R_35 ;
      ! phrase 1
      ! [1: if in darkness , rule succeeds]
       if (( (location==thedark) )) {  RulebookSucceeds(); rtrue;   }
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Unsuccessful attempt by (B19_unsuccessful_attempt_by)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Unsuccessful attempt by someone trying mounting ( this is the mounting excuses rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Unsuccessful attempt by someone trying dismounting ( this is the dismounting excuses rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Unsuccessful attempt by someone trying mounting ( this is the mounting excuses rule ):
[ R_805 ;
   if ((action ==##A84_mounting) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_805, 805);
      ! phrase 1
      ! [1: if the reason the action failed is the can't mount when mounted on an animal rule , say ~[The person asked] [is-are] already riding [the random rideable animal which carries the person asked].~]
       if (((reason_the_action_failed == R_798))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_387; ParaContent(); (PHR_944_r9 ());ParaContent();  print (PrintText) SC_388; ParaContent();  print (the)  (Prop_17()) ; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say107; .L_SayX97;  }
      ! phrase 2
      ! [2: if the reason the action failed is the can't mount when mounted on a vehicle rule , say ~[The person asked] [is-are] already riding [the random rideable vehicle which supports the person asked].~]
       if (((reason_the_action_failed == R_799))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_387; ParaContent(); (PHR_944_r9 ());ParaContent();  print (PrintText) SC_388; ParaContent();  print (the)  (Prop_18()) ; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say108; .L_SayX98;  }
      ! phrase 3
      ! [3: if the reason the action failed is the can't mount something unrideable rule , say ~[The noun] cannot be ridden.~]
       if (((reason_the_action_failed == R_800))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_389;  new_line; .L_Say109; .L_SayX99;  }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_805, 805, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Unsuccessful attempt by someone trying dismounting ( this is the dismounting excuses rule ):
[ R_809 ;
   if ((action ==##A85_dismounting) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_809, 809);
      ! phrase 1
      ! [1: if the reason the action failed is the can't dismount when not mounted rule , say ~[The person asked] [is-are] not riding anything.~]
       if (((reason_the_action_failed == R_806))) { say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_387; ParaContent(); (PHR_944_r9 ());ParaContent();  print (PrintText) SC_390;  new_line; .L_Say110; .L_SayX100;  }
      ! phrase 2
      ! [2: otherwise make no decision]
       else {  rfalse;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_809, 809, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B20_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/45 ! Before going west in Other Side of the Pond by the rowboat:
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 2/45 ! Before going down in Inside Waterworks when the Secretary is visible and the secretary is calm for the first turn:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 3/45 ! Before going north from Grassy Shore when the player is in the rowboat:
!   === which is equally specific with ===
! Rule 4/45 ! Before going up from Underwater when Vivian is in Underwater:
!   >>> I - Number of aspects constrained >>>
! Rule 5/45 ! Before someone trying going through a closed door ( called the blocking door ) ( this is the intelligently opening doors rule ):
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 6/45 ! Before going west in Rocky Beach:
!   === which is equally specific with ===
! Rule 7/45 ! Before going up from the Pump Room:
!   === which is equally specific with ===
! Rule 8/45 ! Before going down from In The Sweetgum Tree:
!   === which is equally specific with ===
! Rule 9/45 ! Before going down from Atop the Tank:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 10/45 ! Before going to the Pump Room when the Secretary is not visible:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 11/45 ! Before going to the Pump Room when the Secretary is visible and the secretary is calm:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 12/45 ! Before inserting something into the vending machine when the vending machine is locked:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 13/45 ! Before taking the rock selection when Rock Limbo is not empty:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 14/45 ! Before going outside when the player is in the steam train:
!   === which is equally specific with ===
! Rule 15/45 ! Before going inside when the player is in the station of the steam train:
!   === which is equally specific with ===
! Rule 16/45 ! Before going east when the player is in the steam train:
!   === which is equally specific with ===
! Rule 17/45 ! Before taking the chimes when the player is in the Hill:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 18/45 ! Before taking or touching something contained by the Hill when the location is In The Sweetgum Tree:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 19/45 ! Before skipping something when the player is in Rocky Beach and the player does not enclose a small rock:
!   >>> I - Number of aspects constrained >>>
! Rule 20/45 ! Before when the noun is a thing:
!   === which is equally specific with ===
! Rule 21/45 ! Before when the second noun is a thing:
!   >>> II - When/while requirement >>>
! Rule 22/45 ! Before going through a closed door ( called the blocking door ) ( this is the opening doors before entering rule ):
!   >>> III.2.1 - Action/Where/Going In Exotic Ways >>>
! Rule 23/45 ! Before inserting something into a liquid source:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 24/45 ! Before someone trying locking an open thing ( called the door ajar ) with something ( this is the intelligently closing doors rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 25/45 ! Before locking an open thing ( called the door ajar ) with something ( this is the closing doors before locking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 26/45 ! Before switching on the fountain:
!   === which is equally specific with ===
! Rule 27/45 ! Before switching off the fountain:
!   === which is equally specific with ===
! Rule 28/45 ! Before taking the drawer:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 29/45 ! Before someone trying locking keylessly an open thing ( called the door ajar ) ( this is the intelligently closing keyless doors rule ):
!   === which is equally specific with ===
! Rule 30/45 ! Before someone trying opening a locked thing ( called the sealed chest ) ( this is the intelligently opening containers rule ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 31/45 ! Before eating an inedible thing ( this is the Small Kindnesses don't implicitly take inedibles rule ):
!   === which is equally specific with ===
! Rule 32/45 ! Before wearing a not wearable thing ( this is the Small Kindnesses don't implicitly take unwearables rule ):
!   === which is equally specific with ===
! Rule 33/45 ! Before locking keylessly an open thing ( called the door ajar ) ( this is the closing doors before locking keylessly rule ):
!   === which is equally specific with ===
! Rule 34/45 ! Before opening a locked thing ( called the sealed chest ) ( this is the unlocking before opening rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 35/45 ! Before asking a rideable animal ( called the mount ) to try going a direction ( called the way ):
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 36/45 ! Before an actor entering a rideable animal ( called the steed ):
!   === which is equally specific with ===
! Rule 37/45 ! Before an actor entering a rideable vehicle ( called the conveyance ):
!   === which is equally specific with ===
! Rule 38/45 ! Before an actor getting off a rideable animal ( called the steed ):
!   === which is equally specific with ===
! Rule 39/45 ! Before an actor getting off a rideable vehicle ( called the conveyance ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 40/45 ! Before a person ( called the pawn ) going:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 41/45 ! Before boarding when the ticket is contained by the right pocket or the ticket is contained by the left pocket:
!   >>> I - Number of aspects constrained >>>
! Rule 42/45 ! Before an actor exiting:
!   === which is equally specific with ===
! Rule 43/45 ! Before boarding:
!   === which is equally specific with ===
! Rule 44/45 ! Before rowing:
!   === which is equally specific with ===
! Rule 45/45 ! Before rowing toward:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Before going west in Other Side of the Pond by the rowboat:
[ R_1545 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I494_other_side_of_the_pond) && (true)) && (((MStack-->MstVON(20007,3)) == I481_rowboat) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1545, 1545);
      ! phrase 1
      ! [1: say ~(first getting out of the rowboat)[command clarification break]~]
      say__p=1;ParaContent();  print (PrintText) SC_391; ParaContent();  CommandClarificationBreak();  .L_Say111; .L_SayX101;
      ! phrase 2
      ! [2: silently try exiting]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##Exit, 0, 0);; @pull keep_silent; 
      ! phrase 3
      ! [3: move the player to the woods]
       MoveObject(player, I444_woods, 0, false); 
      ! phrase 4
      ! [4: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1545, 1545, true);
   rfalse;
];
! No specific request
! Before going down in Inside Waterworks when the Secretary is visible and the secretary is calm for the first turn:
[ R_1382 ;
   if ((PAPR_0() && ((TurnsActionHasBeenHappening-->0) == 1))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1382, 1382);
      ! phrase 1
      ! [1: say ~'Wait!' says [the Secretary of Water]. 'You're not allowed down there.'~]
      say__p=1;ParaContent();  print (PrintText) SC_392; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_393;  new_line; .L_Say112; .L_SayX102;
      ! phrase 2
      ! [2: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1382, 1382, true);
   rfalse;
];
! No specific request
! Before going north from Grassy Shore when the player is in the rowboat:
[ R_1298 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((I481_rowboat == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1298, 1298);
      ! phrase 1
      ! [1: say ~(first getting out of the rowboat)[command clarification break]~]
      say__p=1;ParaContent();  print (PrintText) SC_391; ParaContent();  CommandClarificationBreak();  .L_Say113; .L_SayX103;
      ! phrase 2
      ! [2: silently try exiting]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##Exit, 0, 0);; @pull keep_silent; 
      ! phrase 3
      ! [3: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1298, 1298, true);
   rfalse;
];
! No specific request
! Before going up from Underwater when Vivian is in Underwater:
[ R_1691 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && (((MStack-->MstVON(20007,0)) == I669_underwater) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((I669_underwater == ContainerOf(I671_vivian))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1691, 1691);
      ! phrase 1
      ! [1: say ~[one of]'OK, I understand. You don't want to come to the city,' she says, a little sadly[or]Vivian waves wistfully at you as you leave[stopping].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->13 =
	i7_soo_stop(I7_ST_say_one_of-->13, 2);
	switch((I7_ST_say_one_of-->13)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_394; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_395; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say114; .L_SayX104;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1691, 1691, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before someone trying going through a closed door ( called the blocking door ) ( this is the intelligently opening doors rule ):
[ R_815 
    t_0 ! Local variable e.g. 'blocking door' = door
    ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (t_0 = (MStack-->MstVON(20007,2)), (((t_0=((MStack-->MstVON(20007,2))), true) && ((MStack-->MstVON(20007,2)) ofclass K4_door) && ((Adj_71_t1_v9((MStack-->MstVON(20007,2)))))))) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_815, 815);
      ! phrase 1
      ! [1: try the person asked trying opening the blocking door]
       TryAction(0, actor, ##Open, t_0, 0);; 
      ! phrase 2
      ! [2: if the blocking door is closed , stop the action]
       if ((((Adj_71_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_815, 815, true);
   rfalse;
];
! No specific request
! Before going west in Rocky Beach:
[ R_1264 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I470_rocky_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1264, 1264);
      ! phrase 1
      ! [1: say ~You wade a few feet up to the structure.~]
      say__p=1;ParaContent();  print (PrintText) SC_396;  new_line; .L_Say115; .L_SayX105;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1264, 1264, true);
   rfalse;
];
! No specific request
! Before going up from the Pump Room:
[ R_1385 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && (((MStack-->MstVON(20007,0)) == I510_pump_room) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1385, 1385);
      ! phrase 1
      ! [1: say ~You make your way up the treacherous stairs[if a random chance of 1 in 2 succeeds], nearly falling but catching on to the railing before you hurt yourself[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_397; 
	if (~~((( (GenerateRandomNumber(1, 2) <= 1) )))) jump L_Say116;
		ParaContent();  print (PrintText) SC_398; 
	.L_Say116; .L_SayX106;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say117; .L_SayX107;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1385, 1385, true);
   rfalse;
];
! No specific request
! Before going down from In The Sweetgum Tree:
[ R_1409 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && (((MStack-->MstVON(20007,0)) == I442_in_the_sweetgum_tree) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1409, 1409);
      ! phrase 1
      ! [1: say ~You clamber down from the tree.~]
      say__p=1;ParaContent();  print (PrintText) SC_399;  new_line; .L_Say118; .L_SayX108;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1409, 1409, true);
   rfalse;
];
! No specific request
! Before going down from Atop the Tank:
[ R_1662 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && (((MStack-->MstVON(20007,0)) == I469_atop_the_tank) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1662, 1662);
      ! phrase 1
      ! [1: say ~You climb down the rungs and drop to the ground, giving yourself a nasty jolt as you drop[if the wooden drawer is upside-down and the wooden drawer is in Large Clearing] onto the drawer and then on to the grassy earth[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_400; 
	if (~~((((((Adj_128_t1_v9(I589_wooden_drawer))))) && (((I502_large_clearing == ContainerOf(I589_wooden_drawer))))))) jump L_Say119;
		ParaContent();  print (PrintText) SC_401; 
	.L_Say119; .L_SayX109;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say120; .L_SayX110;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1662, 1662, true);
   rfalse;
];
! No specific request
! Before going to the Pump Room when the Secretary is not visible:
[ R_1384 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I510_pump_room) && (true)) && (self=actor,true) && (((~~(((Adj_3_t1_v9(I545_secretary_of_water)))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1384, 1384);
      ! phrase 1
      ! [1: say ~You clatter down the twisting staircase. [if a random chance of 1 in 2 succeeds]You start to slip, but catch yourself just in time.[end if]~]
      say__p=1;ParaContent();  print (PrintText) SC_402; 
	if (~~((( (GenerateRandomNumber(1, 2) <= 1) )))) jump L_Say121;
		ParaContent();  print (PrintText) SC_403;  new_line;
	.L_Say121; .L_SayX111;
		 .L_Say122; .L_SayX112;
      ! phrase 2
      ! [2: record ~entering the Pump Room~ as achieved]
      (PHR_1164_r6 (SC_204));
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1384, 1384, true);
   rfalse;
];
! No specific request
! Before going to the Pump Room when the Secretary is visible and the secretary is calm:
[ R_1383 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I510_pump_room) && (true)) && (self=actor,true) && (((((Adj_3_t1_v9(I545_secretary_of_water))))) && ((((Adj_115_t1_v9(I545_secretary_of_water))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1383, 1383);
      ! phrase 1
      ! [1: say ~You ignore the secretary's warning, and clatter down the twisting staircase. [if a random chance of 1 in 2 succeeds]You start to slip, but catch yourself just in time.[end if]~]
      say__p=1;ParaContent();  print (PrintText) SC_404; 
	if (~~((( (GenerateRandomNumber(1, 2) <= 1) )))) jump L_Say123;
		ParaContent();  print (PrintText) SC_403;  new_line;
	.L_Say123; .L_SayX113;
		 .L_Say124; .L_SayX114;
      ! phrase 2
      ! [2: record ~entering the Pump Room~ as achieved]
      (PHR_1164_r6 (SC_204));
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1383, 1383, true);
   rfalse;
];
! No specific request
! Before inserting something into the vending machine when the vending machine is locked:
[ R_1446 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I580_vending_machine) && (true)) && (self=actor,true) && ((((Adj_75_t1_v9(I580_vending_machine)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1446, 1446);
      ! phrase 1
      ! [1: try inserting the noun into the slot instead]
       TryAction(0, player, ##Insert, noun, I581_slot);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1446, 1446, true);
   rfalse;
];
! No specific request
! Before taking the rock selection when Rock Limbo is not empty:
[ R_1490 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I601_rock_selection) && (true)) && (self=actor,true) && (((~~(((Adj_16_t1_v9(I595_rock_limbo)))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1490, 1490);
      ! phrase 1
      ! [1: say ~(picking up [if the player has handled a small rock]another[otherwise]one[end if] of the small rocks)[command clarification break]~]
      say__p=1;ParaContent();  print (PrintText) SC_405; 
	if (~~(((Prop_19())))) jump L_Say125;
		ParaContent();  print (PrintText) SC_406; 
	jump L_SayX115; .L_Say125;
		ParaContent();  print (PrintText) SC_407; 
	.L_Say126; .L_SayX115;
		ParaContent();  print (PrintText) SC_408; ParaContent();  CommandClarificationBreak();  .L_Say127; .L_SayX116;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1490, 1490, true);
   rfalse;
];
! No specific request
! Before going outside when the player is in the steam train:
[ R_1140 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == out_obj) && (true)) && (self=actor,true) && (((I439_steam_train == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1140, 1140);
      ! phrase 1
      ! [1: try exiting instead]
       TryAction(0, player, ##Exit, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1140, 1140, true);
   rfalse;
];
! No specific request
! Before going inside when the player is in the station of the steam train:
[ R_1141 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && (self=actor,true) && (((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1141, 1141);
      ! phrase 1
      ! [1: try boarding instead]
       TryAction(0, player, ##A104_boarding, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1141, 1141, true);
   rfalse;
];
! No specific request
! Before going east when the player is in the steam train:
[ R_1142 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && (self=actor,true) && (((I439_steam_train == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1142, 1142);
      ! phrase 1
      ! [1: try exiting instead]
       TryAction(0, player, ##Exit, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1142, 1142, true);
   rfalse;
];
! No specific request
! Before taking the chimes when the player is in the Hill:
[ R_1406 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true)) && (self=actor,true) && (((I441_hill == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1406, 1406);
      ! phrase 1
      ! [1: say ~You'd have to climb the tree to reach them.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_409;  new_line; rtrue; .L_Say128; .L_SayX117; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1406, 1406, true);
   rfalse;
];
! No specific request
! Before taking or touching something contained by the Hill when the location is In The Sweetgum Tree:
[ R_1397 ;
   if ((action ==##Touch or ##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (I441_hill == ContainerOf(noun))) && (self=actor,true) && (((real_location == I442_in_the_sweetgum_tree)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1397, 1397);
      ! phrase 1
      ! [1: say ~You can't reach [it-them of the noun] from in the tree.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_410; ParaContent(); (Resolver_2(noun,"source", 1949));ParaContent();  print (PrintText) SC_411;  new_line; rtrue; .L_Say129; .L_SayX118; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1397, 1397, true);
   rfalse;
];
! No specific request
! Before skipping something when the player is in Rocky Beach and the player does not enclose a small rock:
[ R_1494 ;
   if ((action ==##A127_skipping) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && ((((I470_rocky_beach == ContainerOf(player)))) && ((Prop_20())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1494, 1494);
      ! phrase 1
      ! [1: silently try taking the rock selection]
       @push keep_silent; keep_silent=1; TryAction(0, player, ##Take, I601_rock_selection, 0);; @pull keep_silent; 
      ! phrase 2
      ! [2: try skipping a random small rock held by the player]
       TryAction(0, player, ##A127_skipping,  (Prop_21()) , 0);; 
      ! phrase 3
      ! [3: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1494, 1494, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Before when the noun is a thing:
[ R_772 ;
   if ((((((noun ofclass K2_thing)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_772, 772);
      ! phrase 1
      ! [1: if the noun is not unstashable , note the noun]
       if (((~~(((Adj_85_t1_v9(noun))))))) { (Resolver_3(noun,"source", 23));  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_772, 772, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Before when the second noun is a thing:
[ R_773 ;
   if ((((((second ofclass K2_thing)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_773, 773);
      ! phrase 1
      ! [1: if the second noun is not unstashable , note the second noun]
       if (((~~(((Adj_85_t1_v9(second))))))) { (Resolver_3(second,"source", 25));  }
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_773, 773, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before going through a closed door ( called the blocking door ) ( this is the opening doors before entering rule ):
[ R_811 
    t_0 ! Local variable e.g. 'blocking door' = door
    ;
   if ((action ==##Go) &&  (actor==player) && (t_0 = (MStack-->MstVON(20007,2)), (((t_0=((MStack-->MstVON(20007,2))), true) && ((MStack-->MstVON(20007,2)) ofclass K4_door) && ((Adj_71_t1_v9((MStack-->MstVON(20007,2)))))))) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_811, 811);
      ! phrase 1
      ! [1: if sequential action option is active begin]
       if ((((Adj_22_t1_v15(24)))))  {
         ! phrase 2
         ! [2: try opening the blocking door]
          TryAction(0, player, ##Open, t_0, 0);; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~(first opening [the blocking door])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_412; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say130; .L_SayX119;
         ! phrase 5
         ! [5: silently try opening the blocking door]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##Open, t_0, 0);; @pull keep_silent; 
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: if the blocking door is closed , stop the action]
       if ((((Adj_71_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_811, 811, true);
   rfalse;
];
! No specific request
! Before inserting something into a liquid source:
[ R_1128 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K26_liquid_source))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1128, 1128);
      ! phrase 1
      ! [1: say ~[The noun] would get lost and never be seen again.~ instead]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_414;  new_line; rtrue; .L_Say131; .L_SayX120; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1128, 1128, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before someone trying locking an open thing ( called the door ajar ) with something ( this is the intelligently closing doors rule ):
[ R_816 
    t_0 ! Local variable e.g. 'door ajar' = thing
    ;
   if ((action ==##Lock) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_70_t1_v9(noun)))))) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_816, 816);
      ! phrase 1
      ! [1: try the person asked trying closing the door ajar]
       TryAction(0, actor, ##Close, t_0, 0);; 
      ! phrase 2
      ! [2: if the door ajar is open , stop the action]
       if ((((Adj_70_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_816, 816, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before locking an open thing ( called the door ajar ) with something ( this is the closing doors before locking rule ):
[ R_812 
    t_0 ! Local variable e.g. 'door ajar' = thing
    ;
   if ((action ==##Lock) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_70_t1_v9(noun)))))) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_812, 812);
      ! phrase 1
      ! [1: if sequential action option is active begin]
       if ((((Adj_22_t1_v15(24)))))  {
         ! phrase 2
         ! [2: try closing the door ajar]
          TryAction(0, player, ##Close, t_0, 0);; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~(first closing [the door ajar])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_415; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say132; .L_SayX121;
         ! phrase 5
         ! [5: silently try closing the door ajar]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##Close, t_0, 0);; @pull keep_silent; 
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: if the door ajar is open , stop the action]
       if ((((Adj_70_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_812, 812, true);
   rfalse;
];
! No specific request
! Before switching on the fountain:
[ R_1229 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1229, 1229);
      ! phrase 1
      ! [1: say ~Water starts to gurgle forth from the fountain.~]
      say__p=1;ParaContent();  print (PrintText) SC_416;  new_line; .L_Say133; .L_SayX122;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1229, 1229, true);
   rfalse;
];
! No specific request
! Before switching off the fountain:
[ R_1230 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1230, 1230);
      ! phrase 1
      ! [1: say ~The flow of water stops.~]
      say__p=1;ParaContent();  print (PrintText) SC_417;  new_line; .L_Say134; .L_SayX123;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1230, 1230, true);
   rfalse;
];
! No specific request
! Before taking the drawer:
[ R_1457 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1457, 1457);
      ! phrase 1
      ! [1: say ~It's going to be pretty heavy and annoying to cart around with you, but okay.~]
      say__p=1;ParaContent();  print (PrintText) SC_418;  new_line; .L_Say135; .L_SayX124;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1457, 1457, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before someone trying locking keylessly an open thing ( called the door ajar ) ( this is the intelligently closing keyless doors rule ):
[ R_817 
    t_0 ! Local variable e.g. 'door ajar' = thing
    ;
   if ((action ==##A87_locking_keylessly) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_70_t1_v9(noun))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_817, 817);
      ! phrase 1
      ! [1: try the person asked trying closing the door ajar]
       TryAction(0, actor, ##Close, t_0, 0);; 
      ! phrase 2
      ! [2: if the door ajar is open , stop the action]
       if ((((Adj_70_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_817, 817, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before someone trying opening a locked thing ( called the sealed chest ) ( this is the intelligently opening containers rule ):
[ R_818 
    t_0 ! Local variable e.g. 'sealed chest' = thing
    ;
   if ((action ==##Open) &&  (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_818, 818);
      ! phrase 1
      ! [1: try the person asked trying unlocking keylessly the sealed chest]
       TryAction(0, actor, ##A86_unlocking_keylessly, t_0, 0);; 
      ! phrase 2
      ! [2: if the sealed chest is locked , stop the action]
       if ((((Adj_75_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_818, 818, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Before eating an inedible thing ( this is the Small Kindnesses don't implicitly take inedibles rule ):
[ R_760 ;
   if ((action ==##Eat) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_54_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_760, 760);
      ! phrase 1
      ! [1: stop the action with library message eating action number 1 for the noun]
       return GL__M(##Eat,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_760, 760, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Before wearing a not wearable thing ( this is the Small Kindnesses don't implicitly take unwearables rule ):
[ R_761 ;
   if ((action ==##Wear) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((Adj_58_t1_v9(noun)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_761, 761);
      ! phrase 1
      ! [1: stop the action with library message wearing action number 1 for the noun]
       return GL__M(##Wear,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_761, 761, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before locking keylessly an open thing ( called the door ajar ) ( this is the closing doors before locking keylessly rule ):
[ R_813 
    t_0 ! Local variable e.g. 'door ajar' = thing
    ;
   if ((action ==##A87_locking_keylessly) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_70_t1_v9(noun))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_813, 813);
      ! phrase 1
      ! [1: if sequential action option is active begin]
       if ((((Adj_22_t1_v15(24)))))  {
         ! phrase 2
         ! [2: try closing the door ajar]
          TryAction(0, player, ##Close, t_0, 0);; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~(first closing [the door ajar])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_415; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say136; .L_SayX125;
         ! phrase 5
         ! [5: silently try closing the door ajar]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##Close, t_0, 0);; @pull keep_silent; 
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: if the door ajar is open , stop the action]
       if ((((Adj_70_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_813, 813, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Before opening a locked thing ( called the sealed chest ) ( this is the unlocking before opening rule ):
[ R_814 
    t_0 ! Local variable e.g. 'sealed chest' = thing
    ;
   if ((action ==##Open) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_814, 814);
      ! phrase 1
      ! [1: if sequential action option is active begin]
       if ((((Adj_22_t1_v15(24)))))  {
         ! phrase 2
         ! [2: try unlocking keylessly the sealed chest]
          TryAction(0, player, ##A86_unlocking_keylessly, t_0, 0);; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~(first unlocking [the sealed chest])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_419; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say137; .L_SayX126;
         ! phrase 5
         ! [5: silently try unlocking keylessly the sealed chest]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##A86_unlocking_keylessly, t_0, 0);; @pull keep_silent; 
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: if the sealed chest is locked , stop the action]
       if ((((Adj_75_t1_v9(t_0))))) {  rtrue;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_814, 814, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before asking a rideable animal ( called the mount ) to try going a direction ( called the way ):
[ R_810 
    t_0 ! Local variable e.g. 'mount' = rideable animal
    t_1 ! Local variable e.g. 'way' = direction
    ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester) && (t_0 = actor, (((t_0=(actor), true) && (actor ofclass K16_rideable_animal)))) && (t_1 = noun, (((t_1=(noun), true) && (noun ofclass K3_direction))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_810, 810);
      ! phrase 1
      ! [1: if the player is carried by the mount , try going the way instead]
       if (((t_0 == CarrierOf(player)))) {  TryAction(0, player, ##Go, t_1, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_810, 810, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor entering a rideable animal ( called the steed ):
[ R_793 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    ;
   if ((action ==##Enter) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K16_rideable_animal))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_793, 793);
      ! phrase 1
      ! [1: try the actor mounting the steed instead]
       TryAction(0, actor, ##A84_mounting, t_0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_793, 793, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor entering a rideable vehicle ( called the conveyance ):
[ R_794 
    t_0 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((action ==##Enter) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K17_rideable_vehicle))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_794, 794);
      ! phrase 1
      ! [1: try the actor mounting the conveyance instead]
       TryAction(0, actor, ##A84_mounting, t_0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_794, 794, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor getting off a rideable animal ( called the steed ):
[ R_795 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    ;
   if ((action ==##GetOff) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K16_rideable_animal))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_795, 795);
      ! phrase 1
      ! [1: try the actor dismounting instead]
       TryAction(0, actor, ##A85_dismounting, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_795, 795, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor getting off a rideable vehicle ( called the conveyance ):
[ R_796 
    t_0 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((action ==##GetOff) && (act_requester==nothing) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K17_rideable_vehicle))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_796, 796);
      ! phrase 1
      ! [1: try the actor dismounting instead]
       TryAction(0, actor, ##A85_dismounting, 0, 0);;  rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_796, 796, true);
   rfalse;
];
! No specific request
! Before a person ( called the pawn ) going:
[ R_1069 
    t_0 ! Local variable e.g. 'pawn' = person
    ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && (t_0 = actor, (((t_0=(actor), true) && (actor ofclass K8_person))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1069, 1069);
      ! phrase 1
      ! [1: if the holder of the pawn is a room , now the last location of the pawn is the holder of the pawn]
       if ((( (HolderOf(t_0))  ofclass K1_room))) {  WriteGProperty(9, t_0,p13_last_location, (HolderOf(t_0)) ); if (~~(GProperty(9, t_0,p13_last_location) ofclass K1_room)) RunTimeProblem(RTP_WRONGASSIGNEDKIND, GProperty(9, t_0,p13_last_location), "if the holder of the pawn is a room, now the last location of the pawn is the holder of the pawn", "room");;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1069, 1069, true);
   rfalse;
];
! No specific request
! Before boarding when the ticket is contained by the right pocket or the ticket is contained by the left pocket:
[ R_1736 ;
   if ((action ==##A104_boarding) &&  (actor==player) && (self=actor,true) && ((((I451_right_pocket == ContainerOf(I584_ticket)))) || (((I452_left_pocket == ContainerOf(I584_ticket)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1736, 1736);
      ! phrase 1
      ! [1: say ~(first taking the ticket)[command clarification break]~]
      say__p=1;ParaContent();  print (PrintText) SC_420; ParaContent();  CommandClarificationBreak();  .L_Say138; .L_SayX127;
      ! phrase 2
      ! [2: try taking the ticket]
       TryAction(0, player, ##Take, I584_ticket, 0);; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1736, 1736, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Before an actor exiting:
[ R_797 ;
   if ((action ==##Exit) && (act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_797, 797);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal , try the actor dismounting instead]
       if (((CarrierOf(actor) ofclass K16_rideable_animal))) {  TryAction(0, actor, ##A85_dismounting, 0, 0);;   rtrue; }
      ! phrase 2
      ! [2: if the actor is carried by a rideable vehicle , try the actor dismounting instead]
       if (((CarrierOf(actor) ofclass K17_rideable_vehicle) && (CarrierOf(actor) ofclass K8_person))) {  TryAction(0, actor, ##A85_dismounting, 0, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_797, 797, true);
   rfalse;
];
! No specific request
! Before boarding:
[ R_1146 ;
   if ((action ==##A104_boarding) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1146, 1146);
      ! phrase 1
      ! [1: if the player is in the steam train begin]
       if (((I439_steam_train == ContainerOf(player))))  {
         ! phrase 2
         ! [2: say ~You're already on the train.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_421;  new_line; rtrue; .L_Say139; .L_SayX128; rtrue;
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the player is in the station of the steam train begin]
       if (((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player))))  {
         ! phrase 5
         ! [5: continue the action]
          rfalse; 
         ! phrase 6
         ! [6: otherwise if the steam train approaches the location of the player]
          } else if ((((Relation_TestVtoV(I439_steam_train,Rel_Record_69, LocationOf(player) ,false))))) { 
         ! phrase 7
         ! [7: say ~It's not here yet.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_422;  new_line; rtrue; .L_Say140; .L_SayX129; rtrue;
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: say ~You don't see a train here.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_423;  new_line; rtrue; .L_Say141; .L_SayX130; rtrue;
         ! phrase 10
         ! [10: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1146, 1146, true);
   rfalse;
];
! No specific request
! Before rowing:
[ R_1273 ;
   if ((action ==##A114_rowing) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1273, 1273);
      ! phrase 1
      ! [1: if the player does not carry the second noun , try silently taking the second noun]
       if (((~~((player == CarrierOf(second)))))) {  @push keep_silent; keep_silent=1; TryAction(0, player, ##Take, second, 0);; @pull keep_silent;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1273, 1273, true);
   rfalse;
];
! No specific request
! Before rowing toward:
[ R_1310 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##A116_rowing_toward) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1310, 1310);
      ! phrase 1
      ! [1: if the player is not in the rowboat begin]
       if (((~~((I481_rowboat == ContainerOf(player))))))  {
         ! phrase 2
         ! [2: say ~You'll have to be more specific about which way you want to go.~]
         say__p=1;ParaContent();  print (PrintText) SC_424;  new_line; .L_Say142; .L_SayX131;
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if the player is in the location of the noun or the player is in the noun begin]
       if (((( LocationOf(noun)  == ContainerOf(player)))) || (((noun == ContainerOf(player)))))  {
         ! phrase 6
         ! [6: say ~You're already there!~]
         say__p=1;ParaContent();  print (PrintText) SC_425;  new_line; .L_Say143; .L_SayX132;
         ! phrase 7
         ! [7: stop the action]
          rtrue; 
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: if the noun is in waterland or the noun is in other side of the pond or the noun is other side of the pond or the noun is the structure begin]
       if ((((TestRegionalContainment(noun,I503_waterland)))) || ((((I494_other_side_of_the_pond == ContainerOf(noun)))) || ((((noun == I494_other_side_of_the_pond))) || (((noun == I477_structure))))))  {
         ! phrase 10
         ! [10: let the way be the best route from the location to the noun]
          t_0 =  MapRouteTo(real_location,noun,0,0) ; 
         ! phrase 11
         ! [11: if the noun is not a location , let the way be the best route from the location to the location of the noun , using doors]
          if (((~~((noun == real_location))))) {  t_0 =  MapRouteTo(real_location, LocationOf(noun) ,0,1) ;   }
         ! phrase 12
         ! [12: if the noun is the structure begin]
          if (((noun == I477_structure)))  {
            ! phrase 13
            ! [13: let the way be the best route from the location to boat house]
             t_0 =  MapRouteTo(real_location,I479_boat_house,0,0) ; 
            ! phrase 14
            ! [14: if the location is boat house begin]
             if (((real_location == I479_boat_house)))  {
               ! phrase 15
               ! [15: say ~You're already there!~]
               say__p=1;ParaContent();  print (PrintText) SC_425;  new_line; .L_Say144; .L_SayX133;
               ! phrase 16
               ! [16: stop the action]
                rtrue; 
               ! phrase 17
               ! [17: end if]
               }

            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: if the way is nothing begin]
          if (((t_0 == nothing)))  {
            ! phrase 20
            ! [20: say ~You can't seem to see which way to row.~]
            say__p=1;ParaContent();  print (PrintText) SC_426;  new_line; .L_Say145; .L_SayX134;
            ! phrase 21
            ! [21: stop the action]
             rtrue; 
            ! phrase 22
            ! [22: otherwise]
            } else {

            ! phrase 23
            ! [23: say ~You row toward [the noun].~]
            say__p=1;ParaContent();  print (PrintText) SC_427; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say146; .L_SayX135;
            ! phrase 24
            ! [24: try going the way]
             TryAction(0, player, ##Go, t_0, 0);; 
            ! phrase 25
            ! [25: end if]
            }

         ! phrase 26
         ! [26: otherwise]
         } else {

         ! phrase 27
         ! [27: say ~You can't see how to row to that from here.~]
         say__p=1;ParaContent();  print (PrintText) SC_428;  new_line; .L_Say147; .L_SayX136;
         ! phrase 28
         ! [28: stop the action]
          rtrue; 
         ! phrase 29
         ! [29: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1310, 1310, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Instead (B21_instead)
! ----------------------------------------------------------------------------------------------------
! Rule 1/433 ! Instead of the dog going inside from Small Clearing when Inside the Cinderblock Hut is keyed:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 2/433 ! Instead of going north in Outside Waterworks for the second turn:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 3/433 ! Instead of going west in Boat House when the player is not in the rowboat:
!   === which is equally specific with ===
! Rule 4/433 ! Instead of going southeast from Grassy Shore when the player is not in the rowboat:
!   === which is equally specific with ===
! Rule 5/433 ! Instead of going south in Weedy Island when the player is not in the rowboat:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 6/433 ! Instead of going west in Outside Waterworks when Muddy Beach is unvisited:
!   === which is equally specific with ===
! Rule 7/433 ! Instead of going northwest in Outside Waterworks when Muddy Beach is unvisited:
!   === which is equally specific with ===
! Rule 8/433 ! Instead of going west in Outside Waterworks when Muddy Beach is visited:
!   === which is equally specific with ===
! Rule 9/433 ! Instead of going northwest in Outside Waterworks when Muddy Beach is visited:
!   === which is equally specific with ===
! Rule 10/433 ! Instead of going south from Grassy Shore when the player is in the rowboat:
!   === which is equally specific with ===
! Rule 11/433 ! Instead of going southwest from Grassy Shore when the player is in the rowboat:
!   === which is equally specific with ===
! Rule 12/433 ! Instead of going east from Grassy Shore when the player is in the rowboat:
!   === which is equally specific with ===
! Rule 13/433 ! Instead of going inside in Small Clearing when Inside the Cinderblock Hut is keyed:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 14/433 ! Instead of going a direction ( called the way ) from Grassy Area when the secretary's story is happening:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 15/433 ! Instead of going nowhere from Grassy Area when the secretary's story is happening and the player is not trapped:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 16/433 ! Instead of going nowhere from Weedy Island when the player is not in the rowboat:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 17/433 ! Instead of going nowhere from Grassy Area when the secretary is off-stage:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 18/433 ! Instead of going nowhere from Waterland when the player is in the rowboat:
!   >>> I - Number of aspects constrained >>>
! Rule 19/433 ! Instead of the dog going east in Other Side of the Pond:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 20/433 ! Instead of going northwest from Outside Waterworks:
!   === which is equally specific with ===
! Rule 21/433 ! Instead of going north in Outside Waterworks:
!   === which is equally specific with ===
! Rule 22/433 ! Instead of going east in Muddy Beach:
!   === which is equally specific with ===
! Rule 23/433 ! Instead of going west in Muddy Beach:
!   === which is equally specific with ===
! Rule 24/433 ! Instead of going northwest in Muddy Beach:
!   === which is equally specific with ===
! Rule 25/433 ! Instead of going south in Muddy Beach:
!   === which is equally specific with ===
! Rule 26/433 ! Instead of going southeast in Muddy Beach:
!   === which is equally specific with ===
! Rule 27/433 ! Instead of going southwest in Muddy Beach:
!   === which is equally specific with ===
! Rule 28/433 ! Instead of going north in Muddy Beach:
!   === which is equally specific with ===
! Rule 29/433 ! Instead of going east in Boat House:
!   === which is equally specific with ===
! Rule 30/433 ! Instead of going up from Grassy Shore:
!   === which is equally specific with ===
! Rule 31/433 ! Instead of going inside in Grassy Shore:
!   === which is equally specific with ===
! Rule 32/433 ! Instead of going south from Grassy Shore:
!   === which is equally specific with ===
! Rule 33/433 ! Instead of going southwest from Grassy Shore:
!   === which is equally specific with ===
! Rule 34/433 ! Instead of going east from Grassy Shore:
!   === which is equally specific with ===
! Rule 35/433 ! Instead of going inside in Outside Waterworks:
!   === which is equally specific with ===
! Rule 36/433 ! Instead of going up in Inside Waterworks:
!   === which is equally specific with ===
! Rule 37/433 ! Instead of going northeast in the hill:
!   === which is equally specific with ===
! Rule 38/433 ! Instead of going southeast in the hill:
!   === which is equally specific with ===
! Rule 39/433 ! Instead of going up in Outside Waterworks:
!   === which is equally specific with ===
! Rule 40/433 ! Instead of going down in Outside Waterworks:
!   === which is equally specific with ===
! Rule 41/433 ! Instead of going down in the Hill:
!   === which is equally specific with ===
! Rule 42/433 ! Instead of going southeast in the Hill:
!   === which is equally specific with ===
! Rule 43/433 ! Instead of going up in Pine Forest:
!   === which is equally specific with ===
! Rule 44/433 ! Instead of going down in Pine Forest:
!   === which is equally specific with ===
! Rule 45/433 ! Instead of going inside in the Hill:
!   === which is equally specific with ===
! Rule 46/433 ! Instead of going east in Rocky Beach:
!   === which is equally specific with ===
! Rule 47/433 ! Instead of going southeast in Rocky Beach:
!   === which is equally specific with ===
! Rule 48/433 ! Instead of going south in Rocky Beach:
!   === which is equally specific with ===
! Rule 49/433 ! Instead of going north in Rocky Beach:
!   === which is equally specific with ===
! Rule 50/433 ! Instead of going northwest in Rocky Beach:
!   === which is equally specific with ===
! Rule 51/433 ! Instead of going east in Sandy Beach:
!   === which is equally specific with ===
! Rule 52/433 ! Instead of going south in Sandy Beach:
!   === which is equally specific with ===
! Rule 53/433 ! Instead of going southeast in Sandy Beach:
!   === which is equally specific with ===
! Rule 54/433 ! Instead of going west in Sandy Beach:
!   === which is equally specific with ===
! Rule 55/433 ! Instead of going north in Sandy Beach:
!   === which is equally specific with ===
! Rule 56/433 ! Instead of going northeast in Sandy Beach:
!   === which is equally specific with ===
! Rule 57/433 ! Instead of going west in Sandy Beach:
!   === which is equally specific with ===
! Rule 58/433 ! Instead of going up in Freshwater Crossing:
!   === which is equally specific with ===
! Rule 59/433 ! Instead of going down in Freshwater Crossing:
!   === which is equally specific with ===
! Rule 60/433 ! Instead of going up in Freshwater Crossing:
!   === which is equally specific with ===
! Rule 61/433 ! Instead of going up in Grassy Area:
!   === which is equally specific with ===
! Rule 62/433 ! Instead of going down in Grassy Area:
!   === which is equally specific with ===
! Rule 63/433 ! Instead of going up in the Woods:
!   === which is equally specific with ===
! Rule 64/433 ! Instead of going down in the Woods:
!   === which is equally specific with ===
! Rule 65/433 ! Instead of going up in Other Side of the Pond:
!   === which is equally specific with ===
! Rule 66/433 ! Instead of going down in Other Side of the Pond:
!   === which is equally specific with ===
! Rule 67/433 ! Instead of going in from the Woods:
!   === which is equally specific with ===
! Rule 68/433 ! Instead of going up in the Woods:
!   === which is equally specific with ===
! Rule 69/433 ! Instead of going west in Large Clearing:
!   === which is equally specific with ===
! Rule 70/433 ! Instead of going down in Large Clearing:
!   === which is equally specific with ===
! Rule 71/433 ! Instead of going down in Small Clearing:
!   === which is equally specific with ===
! Rule 72/433 ! Instead of going up in Small Clearing:
!   === which is equally specific with ===
! Rule 73/433 ! Instead of going up in Large Clearing:
!   === which is equally specific with ===
! Rule 74/433 ! Instead of going up in Weedy Island:
!   === which is equally specific with ===
! Rule 75/433 ! Instead of going down in Weedy Island:
!   === which is equally specific with ===
! Rule 76/433 ! Instead of going down in Underwater:
!   === which is equally specific with ===
! Rule 77/433 ! Instead of going up from Underwater:
!   === which is equally specific with ===
! Rule 78/433 ! Instead of going up in the Crystal City:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 79/433 ! Instead of exiting in Boat House when the player is not in the rowboat:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 80/433 ! Instead of going in Grassy Area when the player is trapped:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 81/433 ! Instead of going nowhere from Grassy Shore:
!   === which is equally specific with ===
! Rule 82/433 ! Instead of going nowhere from Spireland:
!   === which is equally specific with ===
! Rule 83/433 ! Instead of going nowhere from In The Sweetgum Tree:
!   === which is equally specific with ===
! Rule 84/433 ! Instead of going nowhere from the Hill:
!   === which is equally specific with ===
! Rule 85/433 ! Instead of going nowhere from Pine Forest:
!   === which is equally specific with ===
! Rule 86/433 ! Instead of going nowhere from Freshwater Crossing:
!   === which is equally specific with ===
! Rule 87/433 ! Instead of going nowhere from Grassy Area:
!   === which is equally specific with ===
! Rule 88/433 ! Instead of going nowhere from Other Side Of the Pond:
!   === which is equally specific with ===
! Rule 89/433 ! Instead of going nowhere from the Woods:
!   === which is equally specific with ===
! Rule 90/433 ! Instead of going nowhere from Small Clearing:
!   === which is equally specific with ===
! Rule 91/433 ! Instead of going nowhere from Large Clearing:
!   === which is equally specific with ===
! Rule 92/433 ! Instead of going nowhere in Underwater:
!   === which is equally specific with ===
! Rule 93/433 ! Instead of going nowhere in the Crystal City:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 94/433 ! Instead of going nowhere from a room that is indoors:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 95/433 ! Instead of the dog going to Atop the Tank:
!   >>> III.3.3 - Action/What/Actor Performing Action >>>
! Rule 96/433 ! Instead of going to the Pump Room when the Secretary is visible and the Secretary is irked:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 97/433 ! Instead of going to Grassy Area when the player has been trapped:
!   === which is equally specific with ===
! Rule 98/433 ! Instead of going to Pump Room when Pump Room is flooded:
!   === which is equally specific with ===
! Rule 99/433 ! Instead of going to Inside Waterworks when Inside Waterworks is flooded:
!   === which is equally specific with ===
! Rule 100/433 ! Instead of going to Sandy Beach when Sandy Beach is flooded:
!   === which is equally specific with ===
! Rule 101/433 ! Instead of going to Freshwater Crossing when the Steam Train is flooded:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 102/433 ! Instead of swimming in the presence of a liquid source when the location is Outside Waterworks or the location is the Hill or the location is In The Sweetgum Tree or the location is Atop the Tank:
!   >>> III.2.3 - Action/Where/In The Presence Of >>>
! Rule 103/433 ! Instead of inserting the screwdriver into the panel when the panel is closed:
!   === which is equally specific with ===
! Rule 104/433 ! Instead of putting the magnet on the deep crack when the old key is in the deep crack:
!   === which is equally specific with ===
! Rule 105/433 ! Instead of putting the magnet on the old key when the old key is in the deep crack:
!   === which is equally specific with ===
! Rule 106/433 ! Instead of taking the old key with the large magnet when the old key is in the deep crack:
!   === which is equally specific with ===
! Rule 107/433 ! Instead of putting the medium-sized wheel on the brass metal pipe when the flagpole is in the holes:
!   === which is equally specific with ===
! Rule 108/433 ! Instead of inserting the flagpole into the medium-sized wheel when the medium-sized wheel is on the brass metal pipe:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 109/433 ! Instead of inserting something into the pipe holes when the pipe holes contain something:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 110/433 ! Instead of inserting something into the vending machine when the vending machine is closed:
!   === which is equally specific with ===
! Rule 111/433 ! Instead of inserting something into the wheel holes when the medium-sized wheel is on the brass metal pipe:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 112/433 ! Instead of taking the brass key with something when the keychain is contained by the tall cylinder:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 113/433 ! Instead of taking the old key with something when the old key is in the deep crack:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 114/433 ! Instead of unlocking keylessly the door to the structure for the first time:
!   === which is equally specific with ===
! Rule 115/433 ! Instead of unlocking keylessly the community center door for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 116/433 ! Instead of going inside when the room inside from the location is not a room and at least one room is inward:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 117/433 ! Instead of turning the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and nothing is in the pipe holes:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 118/433 ! Instead of turning the flagpole when the flagpole is in the holes and the medium-sized wheel is not on the brass metal pipe:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 119/433 ! Instead of knocking on the Waterworks door when the Waterworks door is closed and the secretary of water is in Inside Waterworks and the player is in Outside Waterworks:
!   === which is equally specific with ===
! Rule 120/433 ! Instead of opening the structure when the player is not in Rocky Beach:
!   === which is equally specific with ===
! Rule 121/433 ! Instead of unlocking keylessly the door to the structure when the player does not enclose the old key:
!   === which is equally specific with ===
! Rule 122/433 ! Instead of unlocking keylessly the community center door when the player does not enclose the brass key:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 123/433 ! Instead of examining the pond when the player is in the steam train and the station of the steam train is Freshwater Crossing:
!   === which is equally specific with ===
! Rule 124/433 ! Instead of turning the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and the flagpole is in the pipe holes:
!   === which is equally specific with ===
! Rule 125/433 ! Instead of turning the flagpole when the flagpole is in the pipe holes and the medium-sized wheel is on the brass metal pipe:
!   === which is equally specific with ===
! Rule 126/433 ! Instead of taking the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and the flagpole is in the holes:
!   === which is equally specific with ===
! Rule 127/433 ! Instead of shaking the wind chimes when the player is in Underwater and Vivian is off-stage:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 128/433 ! Instead of taking the wind chimes when the player is in the Hill:
!   === which is equally specific with ===
! Rule 129/433 ! Instead of dropping the stick when the dog is in the location of the player:
!   === which is equally specific with ===
! Rule 130/433 ! Instead of entering the Waterworks when the location is Outside Waterworks:
!   === which is equally specific with ===
! Rule 131/433 ! Instead of facing northwest when the location is Outside Waterworks:
!   === which is equally specific with ===
! Rule 132/433 ! Instead of facing west when the location is Outside Waterworks:
!   === which is equally specific with ===
! Rule 133/433 ! Instead of taking the flag when the flagpole is in the mural:
!   === which is equally specific with ===
! Rule 134/433 ! Instead of opening the drawer when the secretary is visible:
!   === which is equally specific with ===
! Rule 135/433 ! Instead of taking the clump of sap when the leaky hose is plugged:
!   === which is equally specific with ===
! Rule 136/433 ! Instead of examining the notebook when the Secretary of Water is visible:
!   === which is equally specific with ===
! Rule 137/433 ! Instead of going down when the player is on a supporter:
!   === which is equally specific with ===
! Rule 138/433 ! Instead of opening the plate when the plate is locked:
!   === which is equally specific with ===
! Rule 139/433 ! Instead of taking the old key when the old key is in the deep crack:
!   === which is equally specific with ===
! Rule 140/433 ! Instead of searching the floor when the location is Inside The Cinderblock Hut:
!   === which is equally specific with ===
! Rule 141/433 ! Instead of turning the medium-sized wheel when Third Pump is happening:
!   === which is equally specific with ===
! Rule 142/433 ! Instead of facing down when the player is in Underwater:
!   === which is equally specific with ===
! Rule 143/433 ! Instead of shaking the wind chimes when the player is in Underwaterland:
!   === which is equally specific with ===
! Rule 144/433 ! Instead of shaking the wind chimes when the player is in the Crystal City:
!   === which is equally specific with ===
! Rule 145/433 ! Instead of taking off the diving mask when the player is in Underwaterland:
!   === which is equally specific with ===
! Rule 146/433 ! Instead of facing outside when the location is the steam train:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 147/433 ! Instead of doing anything other than examining with the access panel when the conductor is undistracted and the conductor is visible and the conductor's story is not happening:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 148/433 ! Instead of doing anything other than examining to the metal door when Inside the Cinderblock Hut is not keyed:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 149/433 ! Instead of doing anything other than examining to the metal door when Inside the Cinderblock Hut is keyed:
!   === which is equally specific with ===
! Rule 150/433 ! Instead of doing anything other than examining to the pond when the location is Atop the Tank:
!   === which is equally specific with ===
! Rule 151/433 ! Instead of doing anything other than examining to the weird lumpy island when the location is Atop the Tank:
!   === which is equally specific with ===
! Rule 152/433 ! Instead of doing anything other than examining to the distant house when the location is Atop the Tank:
!   === which is equally specific with ===
! Rule 153/433 ! Instead of doing anything other than examining with the conductor when the conductor is distracted:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 154/433 ! Instead of doing anything with the panel when the drawer is upside-down:
!   === which is equally specific with ===
! Rule 155/433 ! Instead of doing anything with the drawer bottom when the drawer is right-side-up:
!   === which is equally specific with ===
! Rule 156/433 ! Instead of doing anything to the cavity while the cavity is inaccessible:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 157/433 ! Instead of taking something that is in the tall cylinder when the player is on something:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 158/433 ! Instead of doing anything other than examining with something contained by the access panel when the conductor is visible and the conductor's story is not happening and the conductor is undistracted:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 159/433 ! Instead of doing anything to something contained by the cavity when the cavity is inaccessible:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 160/433 ! Instead of doing anything with something contained by the steam train when the location of the player is freshwater crossing or the location of the player is other side of the pond:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 161/433 ! Instead of taking a small rock when the rock selection is visible and Rocky Beach does not contain a small rock:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 162/433 ! Instead of dropping a pinecone when the dog is in the location of the player:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 163/433 ! Instead of examining something when the noun is contained by the vending machine and the vending machine is closed:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 164/433 ! Instead of dropping something when the location is In The Sweetgum Tree:
!   === which is equally specific with ===
! Rule 165/433 ! Instead of dropping anything when the player is in Underwater:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 166/433 ! Instead of the dog going when the dog is in the rowboat:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 167/433 ! Instead of going nowhere when the noun is outside:
!   >>> I - Number of aspects constrained >>>
! Rule 168/433 ! Instead of exiting in Pondside Community Center:
!   === which is equally specific with ===
! Rule 169/433 ! Instead of jumping in In The Sweetgum Tree:
!   === which is equally specific with ===
! Rule 170/433 ! Instead of jumping in the Hill:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 171/433 ! Instead of jumping or dancing in Atop the Tank:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 172/433 ! Instead of swimming in the presence of a liquid source ( called source ):
!   >>> III.2.3 - Action/Where/In The Presence Of >>>
! Rule 173/433 ! Instead of giving the wooden drawer to the secretary:
!   === which is equally specific with ===
! Rule 174/433 ! Instead of giving the torn page to the secretary:
!   === which is equally specific with ===
! Rule 175/433 ! Instead of giving the torn page to the conductor:
!   === which is equally specific with ===
! Rule 176/433 ! Instead of putting the sap on the complicated pump:
!   === which is equally specific with ===
! Rule 177/433 ! Instead of inserting the pine sap into the beer bottle:
!   === which is equally specific with ===
! Rule 178/433 ! Instead of unlocking the secret panel with the screwdriver:
!   === which is equally specific with ===
! Rule 179/433 ! Instead of taking the sap with the beer bottle:
!   === which is equally specific with ===
! Rule 180/433 ! Instead of inserting the magnet into the deep crack:
!   === which is equally specific with ===
! Rule 181/433 ! Instead of putting the medium-sized wheel on the pipe holes:
!   === which is equally specific with ===
! Rule 182/433 ! Instead of giving the train schedule to the conductor:
!   === which is equally specific with ===
! Rule 183/433 ! Instead of giving the ticket to the conductor:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 184/433 ! Instead of inserting something that is not a flat paper into the secret panel:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 185/433 ! Instead of inserting something that is not the flagpole into the pipe holes:
!   === which is equally specific with ===
! Rule 186/433 ! Instead of putting anything that is not the medium-sized wheel on the brass metal pipe:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 187/433 ! Instead of giving something unimportant to the Secretary:
!   === which is equally specific with ===
! Rule 188/433 ! Instead of giving something unimportant to the conductor:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 189/433 ! Instead of throwing something at the gull:
!   === which is equally specific with ===
! Rule 190/433 ! Instead of pouring something into the fountain:
!   === which is equally specific with ===
! Rule 191/433 ! Instead of inserting something into the tall cylinder:
!   === which is equally specific with ===
! Rule 192/433 ! Instead of pouring something into the tall cylinder:
!   === which is equally specific with ===
! Rule 193/433 ! Instead of throwing something at the tall cylinder:
!   === which is equally specific with ===
! Rule 194/433 ! Instead of putting something on the leaky hose:
!   === which is equally specific with ===
! Rule 195/433 ! Instead of inserting something into the keyhole:
!   === which is equally specific with ===
! Rule 196/433 ! Instead of inserting something into the gadget:
!   === which is equally specific with ===
! Rule 197/433 ! Instead of giving something to the Secretary:
!   === which is equally specific with ===
! Rule 198/433 ! Instead of inserting something into the slot:
!   === which is equally specific with ===
! Rule 199/433 ! Instead of giving something to the dog:
!   === which is equally specific with ===
! Rule 200/433 ! Instead of inserting something into the deep crack:
!   === which is equally specific with ===
! Rule 201/433 ! Instead of inserting something into the brass metal pipe:
!   === which is equally specific with ===
! Rule 202/433 ! Instead of inserting something into the giant metal wheel:
!   === which is equally specific with ===
! Rule 203/433 ! Instead of giving something to the conductor:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 204/433 ! Instead of inserting the flagpole into something that is not the pipe holes:
!   === which is equally specific with ===
! Rule 205/433 ! Instead of inserting the medium-sized wheel into something that is not the flagpole:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 206/433 ! Instead of taking the water fountain with a fluid container:
!   === which is equally specific with ===
! Rule 207/433 ! Instead of taking the sap with a pinecone:
!   === which is equally specific with ===
! Rule 208/433 ! Instead of taking the sap with a flat paper:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 209/433 ! Instead of putting something which is not a passkey on a keychain ( this is the limiting keychains rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 210/433 ! Instead of pouring a fluid container into a liquid source:
!   === which is equally specific with ===
! Rule 211/433 ! Instead of inserting a fluid container into the player's holdall:
!   === which is equally specific with ===
! Rule 212/433 ! Instead of taking a liquid source with a fluid container:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 213/433 ! Instead of showing something to someone:
!   === which is equally specific with ===
! Rule 214/433 ! Instead of inserting something into a fluid container:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 215/433 ! Instead of pouring the fountain into something:
!   === which is equally specific with ===
! Rule 216/433 ! Instead of pouring the pond into something:
!   === which is equally specific with ===
! Rule 217/433 ! Instead of inserting the wide stick into something:
!   === which is equally specific with ===
! Rule 218/433 ! Instead of inserting the wooden drawer into something:
!   === which is equally specific with ===
! Rule 219/433 ! Instead of unlocking the structure with something:
!   === which is equally specific with ===
! Rule 220/433 ! Instead of unlocking the structure with something:
!   === which is equally specific with ===
! Rule 221/433 ! Instead of unlocking the gadget with something:
!   === which is equally specific with ===
! Rule 222/433 ! Instead of locking the keyhole with something:
!   === which is equally specific with ===
! Rule 223/433 ! Instead of removing the sap from something:
!   === which is equally specific with ===
! Rule 224/433 ! Instead of unlocking the vending machine with something:
!   === which is equally specific with ===
! Rule 225/433 ! Instead of unlocking the secret panel with something:
!   === which is equally specific with ===
! Rule 226/433 ! Instead of taking the sap with something:
!   === which is equally specific with ===
! Rule 227/433 ! Instead of putting the sap on something:
!   === which is equally specific with ===
! Rule 228/433 ! Instead of inserting the sap into something:
!   === which is equally specific with ===
! Rule 229/433 ! Instead of unlocking the structure with something:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 230/433 ! Instead of taking something contained by the tall cylinder with something:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 231/433 ! Instead of taking something with something:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 232/433 ! Instead of kissing yourself:
!   === which is equally specific with ===
! Rule 233/433 ! Instead of kissing the dog:
!   === which is equally specific with ===
! Rule 234/433 ! Instead of attacking the dog:
!   === which is equally specific with ===
! Rule 235/433 ! Instead of facing up:
!   === which is equally specific with ===
! Rule 236/433 ! Instead of pushing the small button:
!   === which is equally specific with ===
! Rule 237/433 ! Instead of entering the steam train:
!   === which is equally specific with ===
! Rule 238/433 ! Instead of waving the flag:
!   === which is equally specific with ===
! Rule 239/433 ! Instead of waving the flagpole:
!   === which is equally specific with ===
! Rule 240/433 ! Instead of listening to the sound of the wind chimes:
!   === which is equally specific with ===
! Rule 241/433 ! Instead of taking the sound of the wind chimes:
!   === which is equally specific with ===
! Rule 242/433 ! Instead of rubbing the dog:
!   === which is equally specific with ===
! Rule 243/433 ! Instead of touching the dog:
!   === which is equally specific with ===
! Rule 244/433 ! Instead of taking off the boots:
!   === which is equally specific with ===
! Rule 245/433 ! Instead of drinking the fountain:
!   === which is equally specific with ===
! Rule 246/433 ! Instead of shaking the fence:
!   === which is equally specific with ===
! Rule 247/433 ! Instead of pushing the fence:
!   === which is equally specific with ===
! Rule 248/433 ! Instead of attacking the fence:
!   === which is equally specific with ===
! Rule 249/433 ! Instead of entering the structure:
!   === which is equally specific with ===
! Rule 250/433 ! Instead of taking the rowboat:
!   === which is equally specific with ===
! Rule 251/433 ! Instead of touching the red foam keychain:
!   === which is equally specific with ===
! Rule 252/433 ! Instead of entering the community center building:
!   === which is equally specific with ===
! Rule 253/433 ! Instead of taking the mural:
!   === which is equally specific with ===
! Rule 254/433 ! Instead of taking the peeling paint:
!   === which is equally specific with ===
! Rule 255/433 ! Instead of touching the real crystal spire:
!   === which is equally specific with ===
! Rule 256/433 ! Instead of touching the oval indentations:
!   === which is equally specific with ===
! Rule 257/433 ! Instead of opening the desk:
!   === which is equally specific with ===
! Rule 258/433 ! Instead of closing the desk:
!   === which is equally specific with ===
! Rule 259/433 ! Instead of attacking the tall cylinder:
!   === which is equally specific with ===
! Rule 260/433 ! Instead of climbing the tall cylinder:
!   === which is equally specific with ===
! Rule 261/433 ! Instead of touching the tall cylinder:
!   === which is equally specific with ===
! Rule 262/433 ! Instead of unlocking keylessly the gadget:
!   === which is equally specific with ===
! Rule 263/433 ! Instead of examining the notes:
!   === which is equally specific with ===
! Rule 264/433 ! Instead of attacking the secretary:
!   === which is equally specific with ===
! Rule 265/433 ! Instead of smelling the pine trees:
!   === which is equally specific with ===
! Rule 266/433 ! Instead of smelling the grove:
!   === which is equally specific with ===
! Rule 267/433 ! Instead of taking the leaves:
!   === which is equally specific with ===
! Rule 268/433 ! Instead of entering the visitor center building:
!   === which is equally specific with ===
! Rule 269/433 ! Instead of playing the wind chimes:
!   === which is equally specific with ===
! Rule 270/433 ! Instead of listening to the wind chimes:
!   === which is equally specific with ===
! Rule 271/433 ! Instead of shaking the wind chimes:
!   === which is equally specific with ===
! Rule 272/433 ! Instead of taking twinkling lights:
!   === which is equally specific with ===
! Rule 273/433 ! Instead of climbing the bench:
!   === which is equally specific with ===
! Rule 274/433 ! Instead of climbing the sweetgum tree:
!   === which is equally specific with ===
! Rule 275/433 ! Instead of taking the pine bark:
!   === which is equally specific with ===
! Rule 276/433 ! Instead of taking the needles:
!   === which is equally specific with ===
! Rule 277/433 ! Instead of climbing the tall pine trees:
!   === which is equally specific with ===
! Rule 278/433 ! Instead of taking the sap:
!   === which is equally specific with ===
! Rule 279/433 ! Instead of opening the window:
!   === which is equally specific with ===
! Rule 280/433 ! Instead of closing the window:
!   === which is equally specific with ===
! Rule 281/433 ! Instead of examining the vending machine:
!   === which is equally specific with ===
! Rule 282/433 ! Instead of attacking the vending machine:
!   === which is equally specific with ===
! Rule 283/433 ! Instead of attacking the slot:
!   === which is equally specific with ===
! Rule 284/433 ! Instead of pushing the slot:
!   === which is equally specific with ===
! Rule 285/433 ! Instead of shaking the slot:
!   === which is equally specific with ===
! Rule 286/433 ! Instead of shaking the vending machine:
!   === which is equally specific with ===
! Rule 287/433 ! Instead of pushing the vending machine:
!   === which is equally specific with ===
! Rule 288/433 ! Instead of rubbing the shelf:
!   === which is equally specific with ===
! Rule 289/433 ! Instead of rubbing the window:
!   === which is equally specific with ===
! Rule 290/433 ! Instead of unlocking keylessly the vending machine:
!   === which is equally specific with ===
! Rule 291/433 ! Instead of entering the pond:
!   === which is equally specific with ===
! Rule 292/433 ! Instead of turning the wooden drawer:
!   === which is equally specific with ===
! Rule 293/433 ! Instead of entering the wooden drawer:
!   === which is equally specific with ===
! Rule 294/433 ! Instead of getting off the wooden drawer:
!   === which is equally specific with ===
! Rule 295/433 ! Instead of climbing the wooden drawer:
!   === which is equally specific with ===
! Rule 296/433 ! Instead of dropping the secret panel:
!   === which is equally specific with ===
! Rule 297/433 ! Instead of taking the secret panel:
!   === which is equally specific with ===
! Rule 298/433 ! Instead of touching the secret panel:
!   === which is equally specific with ===
! Rule 299/433 ! Instead of pushing the secret panel:
!   === which is equally specific with ===
! Rule 300/433 ! Instead of taking the rock selection:
!   === which is equally specific with ===
! Rule 301/433 ! Instead of searching the spot:
!   === which is equally specific with ===
! Rule 302/433 ! Instead of taking sand:
!   === which is equally specific with ===
! Rule 303/433 ! Instead of searching sand:
!   === which is equally specific with ===
! Rule 304/433 ! Instead of taking the leaves:
!   === which is equally specific with ===
! Rule 305/433 ! Instead of climbing the birch trees:
!   === which is equally specific with ===
! Rule 306/433 ! Instead of taking the birch bark:
!   === which is equally specific with ===
! Rule 307/433 ! Instead of touching the ark:
!   === which is equally specific with ===
! Rule 308/433 ! Instead of touching the anchor:
!   === which is equally specific with ===
! Rule 309/433 ! Instead of entering the stone steps:
!   === which is equally specific with ===
! Rule 310/433 ! Instead of taking the mat of leaves:
!   === which is equally specific with ===
! Rule 311/433 ! Instead of climbing the colorful trees:
!   === which is equally specific with ===
! Rule 312/433 ! Instead of opening the hut:
!   === which is equally specific with ===
! Rule 313/433 ! Instead of touching the moss:
!   === which is equally specific with ===
! Rule 314/433 ! Instead of examining the deep crack:
!   === which is equally specific with ===
! Rule 315/433 ! Instead of turning the large metal wheel:
!   === which is equally specific with ===
! Rule 316/433 ! Instead of entering the hut:
!   === which is equally specific with ===
! Rule 317/433 ! Instead of switching off the underground pump:
!   === which is equally specific with ===
! Rule 318/433 ! Instead of entering the large tank:
!   === which is equally specific with ===
! Rule 319/433 ! Instead of climbing the large tank:
!   === which is equally specific with ===
! Rule 320/433 ! Instead of climbing the rungs:
!   === which is equally specific with ===
! Rule 321/433 ! Instead of turning the brass metal pipe:
!   === which is equally specific with ===
! Rule 322/433 ! Instead of pushing the flagpole:
!   === which is equally specific with ===
! Rule 323/433 ! Instead of pushing the medium-sized wheel:
!   === which is equally specific with ===
! Rule 324/433 ! Instead of attacking the emergency supplies box:
!   === which is equally specific with ===
! Rule 325/433 ! Instead of taking the emergency supplies box:
!   === which is equally specific with ===
! Rule 326/433 ! Instead of attacking Vivian:
!   === which is equally specific with ===
! Rule 327/433 ! Instead of attacking Cordelia:
!   === which is equally specific with ===
! Rule 328/433 ! Instead of attacking Douglas:
!   === which is equally specific with ===
! Rule 329/433 ! Instead of waving the wind chimes:
!   === which is equally specific with ===
! Rule 330/433 ! Instead of touching the underwater pump:
!   === which is equally specific with ===
! Rule 331/433 ! Instead of attacking the underwater pump:
!   === which is equally specific with ===
! Rule 332/433 ! Instead of switching on the underwater pump:
!   === which is equally specific with ===
! Rule 333/433 ! Instead of switching off the underwater pump:
!   === which is equally specific with ===
! Rule 334/433 ! Instead of examining the steam train:
!   === which is equally specific with ===
! Rule 335/433 ! Instead of entering the steam train:
!   === which is equally specific with ===
! Rule 336/433 ! Instead of unlocking keylessly the structure:
!   === which is equally specific with ===
! Rule 337/433 ! Instead of opening the structure:
!   === which is equally specific with ===
! Rule 338/433 ! Instead of attacking the conductor:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 339/433 ! Instead of searching or entering the large rusty pipe:
!   === which is equally specific with ===
! Rule 340/433 ! Instead of drinking or touching the pond:
!   === which is equally specific with ===
! Rule 341/433 ! Instead of pulling or pushing the tall cylinder:
!   === which is equally specific with ===
! Rule 342/433 ! Instead of switching on or switching off the complicated pump:
!   === which is equally specific with ===
! Rule 343/433 ! Instead of climbing or entering the ark:
!   === which is equally specific with ===
! Rule 344/433 ! Instead of pushing or taking the ark:
!   === which is equally specific with ===
! Rule 345/433 ! Instead of pushing or taking the anchor:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 346/433 ! Instead of touching or smelling or tasting or attacking or taking the father:
!   === which is equally specific with ===
! Rule 347/433 ! Instead of touching or smelling or tasting or attacking or taking the daughter:
!   === which is equally specific with ===
! Rule 348/433 ! Instead of touching or smelling or tasting or attacking or taking the family:
!   === which is equally specific with ===
! Rule 349/433 ! Instead of touching or smelling or tasting or attacking or taking the game:
!   === which is equally specific with ===
! Rule 350/433 ! Instead of touching or smelling or tasting or attacking or taking the house:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 351/433 ! Instead of doing anything other than touching , smelling , or examining to the rope:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 352/433 ! Instead of doing anything other than examining to the gull:
!   === which is equally specific with ===
! Rule 353/433 ! Instead of doing anything other than examining to the giant metal wheel:
!   === which is equally specific with ===
! Rule 354/433 ! Instead of doing anything other than examining to the large crystal gear:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 355/433 ! Instead of doing anything with bubbling water:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 356/433 ! Instead of getting off the location ( this is the Small Kindnesses overly elaborate exiting rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 357/433 ! Instead of taking something that is enclosed by the tall cylinder:
!   === which is equally specific with ===
! Rule 358/433 ! Instead of attacking something that is part of the underwater pump:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 359/433 ! Instead of knocking on an open door:
!   === which is equally specific with ===
! Rule 360/433 ! Instead of knocking on a closed door:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 361/433 ! Instead of kissing someone:
!   === which is equally specific with ===
! Rule 362/433 ! Instead of drinking a fluid container:
!   === which is equally specific with ===
! Rule 363/433 ! Instead of drinking a liquid source:
!   === which is equally specific with ===
! Rule 364/433 ! Instead of tasting a liquid source:
!   === which is equally specific with ===
! Rule 365/433 ! Instead of tasting a fluid container:
!   === which is equally specific with ===
! Rule 366/433 ! Instead of searching a liquid source:
!   === which is equally specific with ===
! Rule 367/433 ! Instead of attacking a door:
!   === which is equally specific with ===
! Rule 368/433 ! Instead of switching on a lever:
!   === which is equally specific with ===
! Rule 369/433 ! Instead of switching off a lever:
!   === which is equally specific with ===
! Rule 370/433 ! Instead of turning a lever:
!   === which is equally specific with ===
! Rule 371/433 ! Instead of turning a switch:
!   === which is equally specific with ===
! Rule 372/433 ! Instead of pulling a lever:
!   === which is equally specific with ===
! Rule 373/433 ! Instead of pushing a lever:
!   === which is equally specific with ===
! Rule 374/433 ! Instead of smelling a pinecone:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 375/433 ! Instead of cutting something:
!   === which is equally specific with ===
! Rule 376/433 ! Instead of burning something:
!   === which is equally specific with ===
! Rule 377/433 ! Instead of searching something:
!   === which is equally specific with ===
! Rule 378/433 ! Instead of drinking something:
!   === which is equally specific with ===
! Rule 379/433 ! Instead of playing something:
!   === which is equally specific with ===
! Rule 380/433 ! Instead of shaking something:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 381/433 ! Instead of exiting when the player is in a room and the player is not on a supporter:
!   === which is equally specific with ===
! Rule 382/433 ! Instead of exiting when the location is Inside Waterworks and the player is not on a supporter:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 383/433 ! Instead of listening when at least one pump is switched on:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 384/433 ! Instead of boarding when the ticket is not held and the conductor is unsatisfied:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 385/433 ! Instead of exiting when the player is in a room and the player is on a supporter:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 386/433 ! Instead of sleeping while the conductor's story is happening:
!   === which is equally specific with ===
! Rule 387/433 ! Instead of exiting when the player is in the steam train:
!   === which is equally specific with ===
! Rule 388/433 ! Instead of listening when the location is the Hill:
!   === which is equally specific with ===
! Rule 389/433 ! Instead of jumping when the player is enclosed by the rowboat:
!   === which is equally specific with ===
! Rule 390/433 ! Instead of jumping when the tall cylinder is visible:
!   === which is equally specific with ===
! Rule 391/433 ! Instead of exiting when the player is on a supporter:
!   === which is equally specific with ===
! Rule 392/433 ! Instead of jumping when the player is in Large Clearing:
!   === which is equally specific with ===
! Rule 393/433 ! Instead of smelling when the player is wearing the diving mask:
!   === which is equally specific with ===
! Rule 394/433 ! Instead of drinking when the player is wearing the diving mask:
!   === which is equally specific with ===
! Rule 395/433 ! Instead of looking up when the player is in Underwaterland:
!   === which is equally specific with ===
! Rule 396/433 ! Instead of swimming when the player is in Underwaterland:
!   === which is equally specific with ===
! Rule 397/433 ! Instead of boarding when the secretary is in Grassy Area:
!   === which is equally specific with ===
! Rule 398/433 ! Instead of boarding when the steam train is flooded:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 399/433 ! Instead of jumping or dancing when the player is trapped:
!   === which is equally specific with ===
! Rule 400/433 ! Instead of shouting or singing when the player is wearing the diving mask:
!   === which is equally specific with ===
! Rule 401/433 ! Instead of eating or drinking when the player is wearing the diving mask:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 402/433 ! Instead of speech when Endgame is happening and the player is wearing the diving mask:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 403/433 ! Instead of speech when the noun is the Secretary of Water:
!   === which is equally specific with ===
! Rule 404/433 ! Instead of speech when the noun is the dog:
!   === which is equally specific with ===
! Rule 405/433 ! Instead of speech when the noun is the family:
!   === which is equally specific with ===
! Rule 406/433 ! Instead of speech when the noun is the daughter:
!   === which is equally specific with ===
! Rule 407/433 ! Instead of speech when the noun is the father:
!   === which is equally specific with ===
! Rule 408/433 ! Instead of speech when the player is wearing the diving mask:
!   === which is equally specific with ===
! Rule 409/433 ! Instead of speech when the noun is the Conductor:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 410/433 ! Instead of going nowhere ( this is the Small Kindnesses reporting on exits rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 411/433 ! Instead of exiting from the rowboat:
!   >>> III.2.4 - Action/Where/Other Optional Clauses >>>
! Rule 412/433 ! Instead of swearing obscenely:
!   === which is equally specific with ===
! Rule 413/433 ! Instead of swearing mildly:
!   === which is equally specific with ===
! Rule 414/433 ! Instead of thinking:
!   === which is equally specific with ===
! Rule 415/433 ! Instead of praying:
!   === which is equally specific with ===
! Rule 416/433 ! Instead of blowing:
!   === which is equally specific with ===
! Rule 417/433 ! Instead of singing:
!   === which is equally specific with ===
! Rule 418/433 ! Instead of shouting:
!   === which is equally specific with ===
! Rule 419/433 ! Instead of swimming:
!   === which is equally specific with ===
! Rule 420/433 ! Instead of jumping:
!   === which is equally specific with ===
! Rule 421/433 ! Instead of smelling:
!   === which is equally specific with ===
! Rule 422/433 ! Instead of listening:
!   === which is equally specific with ===
! Rule 423/433 ! Instead of waving hands:
!   === which is equally specific with ===
! Rule 424/433 ! Instead of taking inventory:
!   === which is equally specific with ===
! Rule 425/433 ! Instead of wading:
!   === which is equally specific with ===
! Rule 426/433 ! Instead of looking up:
!   === which is equally specific with ===
! Rule 427/433 ! Instead of tightening:
!   === which is equally specific with ===
! Rule 428/433 ! Instead of thing-barking:
!   === which is equally specific with ===
! Rule 429/433 ! Instead of magnet-waving:
!   === which is equally specific with ===
! Rule 430/433 ! Instead of boat-examining:
!   === which is equally specific with ===
! Rule 431/433 ! Instead of lock-picking:
!   === which is equally specific with ===
! Rule 432/433 ! Instead of double-lock-picking:
!   === which is equally specific with ===
! Rule 433/433 ! Instead of sleeping:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Instead of the dog going inside from Small Clearing when Inside the Cinderblock Hut is keyed:
[ R_1600 ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor == I443_dog) && (true)) && ((noun == in_obj) && (true)) && (((MStack-->MstVON(20007,0)) == I501_small_clearing) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && ((((Adj_134_t1_v9(I637_inside_the_cinderblock_)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1600, 1600);
      ! phrase 1
      ! [1: do nothing]
       ; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1600, 1600, true);
   rfalse;
];
! No specific request
! Instead of going north in Outside Waterworks for the second turn:
[ R_1225 ;
   if ((PAPR_1() && ((TurnsActionHasBeenHappening-->1) == 2))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1225, 1225);
      ! phrase 1
      ! [1: if no pumps are switched on begin]
       if ((Prop_22()))  {
         ! phrase 2
         ! [2: say ~You trudge back along the path from which you came[if the player is carrying the page torn out of a children's book]; as you go, you crumple the illustration into a ball and toss it aside[end if]. This whole idea was probably silly, anyway. It's just a story -- there's no city.~]
         say__p=1;ParaContent();  print (PrintText) SC_429; 
	if (~~((((player == CarrierOf(I448_page_torn_out_of_a_chil)))))) jump L_Say148;
		ParaContent();  print (PrintText) SC_430; 
	.L_Say148; .L_SayX137;
		ParaContent();  print (PrintText) SC_431;  new_line; .L_Say149; .L_SayX138;
         ! phrase 3
         ! [3: end the story saying ~You have given up.~]
          deadflag=SC_432; story_complete=false; 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if exactly one pump is switched on begin]
       if ((Prop_23()))  {
         ! phrase 6
         ! [6: say ~You trudge back along the path from which you came, leaving the strange world of pond and trains behind. You may never find out what's at the bottom of that spire. But you don't have to know everything, do you?~]
         say__p=1;ParaContent();  print (PrintText) SC_433;  new_line; .L_Say150; .L_SayX139;
         ! phrase 7
         ! [7: end the story saying ~You have decided not to satisfy your curiosity.~]
          deadflag=SC_434; story_complete=false; 
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: if exactly two pumps are switched on begin]
       if ((Prop_24()))  {
         ! phrase 10
         ! [10: say ~You've done enough damage here. You turn away from the flooded Waterworks, hoping that the people of Pondside won't have too much trouble rebuilding it. Much as you would have loved to see the city, to visit it, to bask in its energies, it's not worth the havoc you'd cause.~]
         say__p=1;ParaContent();  print (PrintText) SC_435;  new_line; .L_Say151; .L_SayX140;
         ! phrase 11
         ! [11: end the story saying ~You have decided to leave well enough alone.~]
          deadflag=SC_436; story_complete=false; 
         ! phrase 12
         ! [12: end if]
         }

      ! phrase 13
      ! [13: if exactly three pumps are switched on begin]
       if ((Prop_25()))  {
         ! phrase 14
         ! [14: say ~You abandon the shining spire, the weedy island, the flooded beaches, the underwater city; you leave the people of Pondside to their rebuilding project, and leave the people of the Crystal City still underwater, suspended deep beneath the pond...~]
         say__p=1;ParaContent();  print (PrintText) SC_437;  new_line; .L_Say152; .L_SayX141;
         ! phrase 15
         ! [15: end the story finally saying ~You have decided not to restore the Crystal City.~]
          deadflag=SC_438; story_complete=true; 
         ! phrase 16
         ! [16: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1225, 1225, true);
   rfalse;
];
! No specific request
! Instead of going west in Boat House when the player is not in the rowboat:
[ R_1280 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I479_boat_house) && (true)) && (self=actor,true) && (((~~((I481_rowboat == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1280, 1280);
      ! phrase 1
      ! [1: say ~You peer into the murky water, but decide against entering it without a boat.~]
      say__p=1;ParaContent();  print (PrintText) SC_439;  new_line; .L_Say153; .L_SayX142;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1280, 1280, true);
   rfalse;
];
! No specific request
! Instead of going southeast from Grassy Shore when the player is not in the rowboat:
[ R_1293 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I50_southeast) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((~~((I481_rowboat == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1293, 1293);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1293, 1293, true);
   rfalse;
];
! No specific request
! Instead of going south in Weedy Island when the player is not in the rowboat:
[ R_1670 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I49_south) && (true)) && ((real_location == I504_weedy_island) && (true)) && (self=actor,true) && (((~~((I481_rowboat == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1670, 1670);
      ! phrase 1
      ! [1: say ~The island is small, and you could only dive into the water in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_440;  new_line; .L_Say154; .L_SayX143;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1670, 1670, true);
   rfalse;
];
! No specific request
! Instead of going west in Outside Waterworks when Muddy Beach is unvisited:
[ R_1233 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I447_outside_waterworks) && (true)) && (self=actor,true) && ((((Adj_50_t1_v9(I468_muddy_beach)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1233, 1233);
      ! phrase 1
      ! [1: say ~The chain-link fence blocks your way.~]
      say__p=1;ParaContent();  print (PrintText) SC_441;  new_line; .L_Say155; .L_SayX144;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1233, 1233, true);
   rfalse;
];
! No specific request
! Instead of going northwest in Outside Waterworks when Muddy Beach is unvisited:
[ R_1234 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I48_northwest) && (true)) && ((real_location == I447_outside_waterworks) && (true)) && (self=actor,true) && ((((Adj_50_t1_v9(I468_muddy_beach)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1234, 1234);
      ! phrase 1
      ! [1: say ~The chain-link fence blocks your way.~]
      say__p=1;ParaContent();  print (PrintText) SC_441;  new_line; .L_Say156; .L_SayX145;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1234, 1234, true);
   rfalse;
];
! No specific request
! Instead of going west in Outside Waterworks when Muddy Beach is visited:
[ R_1235 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I447_outside_waterworks) && (true)) && (self=actor,true) && ((((Adj_49_t1_v9(I468_muddy_beach)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1235, 1235);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1235, 1235, true);
   rfalse;
];
! No specific request
! Instead of going northwest in Outside Waterworks when Muddy Beach is visited:
[ R_1236 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I48_northwest) && (true)) && ((real_location == I447_outside_waterworks) && (true)) && (self=actor,true) && ((((Adj_49_t1_v9(I468_muddy_beach)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1236, 1236);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1236, 1236, true);
   rfalse;
];
! No specific request
! Instead of going south from Grassy Shore when the player is in the rowboat:
[ R_1294 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I49_south) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((I481_rowboat == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1294, 1294);
      ! phrase 1
      ! [1: try going southeast]
       TryAction(0, player, ##Go, I50_southeast, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1294, 1294, true);
   rfalse;
];
! No specific request
! Instead of going southwest from Grassy Shore when the player is in the rowboat:
[ R_1295 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I51_southwest) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((I481_rowboat == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1295, 1295);
      ! phrase 1
      ! [1: try going southeast]
       TryAction(0, player, ##Go, I50_southeast, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1295, 1295, true);
   rfalse;
];
! No specific request
! Instead of going east from Grassy Shore when the player is in the rowboat:
[ R_1296 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((I481_rowboat == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1296, 1296);
      ! phrase 1
      ! [1: try going southeast]
       TryAction(0, player, ##Go, I50_southeast, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1296, 1296, true);
   rfalse;
];
! No specific request
! Instead of going inside in Small Clearing when Inside the Cinderblock Hut is keyed:
[ R_1599 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && ((real_location == I501_small_clearing) && (true)) && (self=actor,true) && ((((Adj_134_t1_v9(I637_inside_the_cinderblock_)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1599, 1599);
      ! phrase 1
      ! [1: say ~You see no way to open it.~]
      say__p=1;ParaContent();  print (PrintText) SC_442;  new_line; .L_Say157; .L_SayX146;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1599, 1599, true);
   rfalse;
];
! No specific request
! Instead of going a direction ( called the way ) from Grassy Area when the secretary's story is happening:
[ R_1527 
    t_0 ! Local variable e.g. 'way' = direction
    ;
   if ((action ==##Go) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K3_direction)))) && (((MStack-->MstVON(20007,0)) == I509_grassy_area) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && ((((scene_status-->(I611_secretary_s_story-1)==1))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1527, 1527);
      ! phrase 1
      ! [1: say ~As you step toward [the way], the unstable ground gives way to sinking mud beneath you, and you're encircled in the marsh to the waist, trapped and unable to move!~]
      say__p=1;ParaContent();  print (PrintText) SC_443; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_444;  new_line; .L_Say158; .L_SayX147;
      ! phrase 2
      ! [2: now the player is trapped]
       (Adj_130_t2_v9(player)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1527, 1527, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Grassy Area when the secretary's story is happening and the player is not trapped:
[ R_1528 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I509_grassy_area) && (true)) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && (((((scene_status-->(I611_secretary_s_story-1)==1)))) && (((~~(((Adj_130_t1_v9(player))))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1528, 1528);
      ! phrase 1
      ! [1: say ~As you step toward [the noun], the unstable ground gives way beneath you, and you're encircled in mud to the waist, trapped and unable to move!~]
      say__p=1;ParaContent();  print (PrintText) SC_443; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_445;  new_line; .L_Say159; .L_SayX148;
      ! phrase 2
      ! [2: now the player is trapped]
       (Adj_130_t2_v9(player)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1528, 1528, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Weedy Island when the player is not in the rowboat:
[ R_1669 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I504_weedy_island) && (true)) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && (((~~((I481_rowboat == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1669, 1669);
      ! phrase 1
      ! [1: say ~The island is small, and you could only dive into the water in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_440;  new_line; .L_Say160; .L_SayX149;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1669, 1669, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Grassy Area when the secretary is off-stage:
[ R_1530 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I509_grassy_area) && (true)) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && ((((~~Adj_9_t1_v9(I545_secretary_of_water)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1530, 1530);
      ! phrase 1
      ! [1: say ~Water continues to pour out of the two pipes, and the marsh is too treacherous to venture any direction except back to the railroad tracks, to the northeast.~]
      say__p=1;ParaContent();  print (PrintText) SC_446;  new_line; .L_Say161; .L_SayX150;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1530, 1530, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Waterland when the player is in the rowboat:
[ R_1308 ;
   if ((action ==##Go) &&  (actor==player) && (TestRegionalContainment((MStack-->MstVON(20007,0)),I503_waterland)) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && (((I481_rowboat == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1308, 1308);
      ! phrase 1
      ! [1: if the location is grassy shore and the direction is inside , try going north]
       if ((((real_location == I464_grassy_shore))) && (((in_obj ofclass K3_direction)))) {  TryAction(0, player, ##Go, I46_north, 0);;   }
      ! phrase 2
      ! [2: otherwise say ~You drift around, not rowing toward any particular landmark.~]
       else { say__p=1;ParaContent();  print (PrintText) SC_447;  new_line; .L_Say162; .L_SayX151;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1308, 1308, true);
   rfalse;
];
! No specific request
! Instead of the dog going east in Other Side of the Pond:
[ R_1543 ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor == I443_dog) && (true)) && ((noun == I52_east) && (true)) &&  (actor_location = LocationOf(actor)) && ((actor_location == I494_other_side_of_the_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1543, 1543);
      ! phrase 1
      ! [1: if the rowboat is in other side of the pond , try the dog entering the rowboat]
       if (((I494_other_side_of_the_pond == ContainerOf(I481_rowboat)))) {  TryAction(0, I443_dog, ##Enter, I481_rowboat, 0);;   }
      ! phrase 2
      ! [2: otherwise do nothing]
       else {  ;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1543, 1543, true);
   rfalse;
];
! No specific request
! Instead of going northwest from Outside Waterworks:
[ R_1220 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I48_northwest) && (true)) && (((MStack-->MstVON(20007,0)) == I447_outside_waterworks) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1220, 1220);
      ! phrase 1
      ! [1: try going west]
       TryAction(0, player, ##Go, I53_west, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1220, 1220, true);
   rfalse;
];
! No specific request
! Instead of going north in Outside Waterworks:
[ R_1224 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && ((real_location == I447_outside_waterworks) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1224, 1224);
      ! phrase 1
      ! [1: say ~That direction just leads back to where you came from... you could head that way, but you're not sure yet if you want to give up on looking for the city.~]
      say__p=1;ParaContent();  print (PrintText) SC_448;  new_line; .L_Say163; .L_SayX152;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1224, 1224, true);
   rfalse;
];
! No specific request
! Instead of going east in Muddy Beach:
[ R_1252 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1252, 1252);
      ! phrase 1
      ! [1: try climbing the fence instead]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);;  rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1252, 1252, true);
   rfalse;
];
! No specific request
! Instead of going west in Muddy Beach:
[ R_1253 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1253, 1253);
      ! phrase 1
      ! [1: try entering the pond]
       TryAction(0, player, ##Enter, I463_pond, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1253, 1253, true);
   rfalse;
];
! No specific request
! Instead of going northwest in Muddy Beach:
[ R_1254 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I48_northwest) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1254, 1254);
      ! phrase 1
      ! [1: try entering the pond]
       TryAction(0, player, ##Enter, I463_pond, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1254, 1254, true);
   rfalse;
];
! No specific request
! Instead of going south in Muddy Beach:
[ R_1255 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I49_south) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1255, 1255);
      ! phrase 1
      ! [1: say ~The mud and sticks are impassable in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_449;  new_line; .L_Say164; .L_SayX153;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1255, 1255, true);
   rfalse;
];
! No specific request
! Instead of going southeast in Muddy Beach:
[ R_1256 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I50_southeast) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1256, 1256);
      ! phrase 1
      ! [1: say ~The mud and sticks are impassable in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_449;  new_line; .L_Say165; .L_SayX154;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1256, 1256, true);
   rfalse;
];
! No specific request
! Instead of going southwest in Muddy Beach:
[ R_1257 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I51_southwest) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1257, 1257);
      ! phrase 1
      ! [1: say ~The mud and sticks are impassable in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_449;  new_line; .L_Say166; .L_SayX155;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1257, 1257, true);
   rfalse;
];
! No specific request
! Instead of going north in Muddy Beach:
[ R_1258 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && ((real_location == I468_muddy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1258, 1258);
      ! phrase 1
      ! [1: say ~From here, you'd have to swim to the structure, but you could probably get close enough to wade from up the shore to the northeast.~]
      say__p=1;ParaContent();  print (PrintText) SC_450;  new_line; .L_Say167; .L_SayX156;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1258, 1258, true);
   rfalse;
];
! No specific request
! Instead of going east in Boat House:
[ R_1279 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && ((real_location == I479_boat_house) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1279, 1279);
      ! phrase 1
      ! [1: if the player is in the rowboat , say ~You can't take the boat out of the water.~]
       if (((I481_rowboat == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_451;  new_line; .L_Say168; .L_SayX157;  }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1279, 1279, true);
   rfalse;
];
! No specific request
! Instead of going up from Grassy Shore:
[ R_1282 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1282, 1282);
      ! phrase 1
      ! [1: try going north]
       TryAction(0, player, ##Go, I46_north, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1282, 1282, true);
   rfalse;
];
! No specific request
! Instead of going inside in Grassy Shore:
[ R_1287 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && ((real_location == I464_grassy_shore) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1287, 1287);
      ! phrase 1
      ! [1: try going north]
       TryAction(0, player, ##Go, I46_north, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1287, 1287, true);
   rfalse;
];
! No specific request
! Instead of going south from Grassy Shore:
[ R_1289 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I49_south) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1289, 1289);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1289, 1289, true);
   rfalse;
];
! No specific request
! Instead of going southwest from Grassy Shore:
[ R_1290 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I51_southwest) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1290, 1290);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1290, 1290, true);
   rfalse;
];
! No specific request
! Instead of going east from Grassy Shore:
[ R_1291 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1291, 1291);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1291, 1291, true);
   rfalse;
];
! No specific request
! Instead of going inside in Outside Waterworks:
[ R_1314 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && ((real_location == I447_outside_waterworks) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1314, 1314);
      ! phrase 1
      ! [1: try going east]
       TryAction(0, player, ##Go, I52_east, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1314, 1314, true);
   rfalse;
];
! No specific request
! Instead of going up in Inside Waterworks:
[ R_1375 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I506_inside_waterworks) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1375, 1375);
      ! phrase 1
      ! [1: say ~That way is only the ceiling.~]
      say__p=1;ParaContent();  print (PrintText) SC_452;  new_line; .L_Say169; .L_SayX158;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1375, 1375, true);
   rfalse;
];
! No specific request
! Instead of going northeast in the hill:
[ R_1387 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I47_northeast) && (true)) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1387, 1387);
      ! phrase 1
      ! [1: say ~That way the hill slopes down a little and bumps into the Waterworks building; to the north, you can head back towards the Waterworks.~]
      say__p=1;ParaContent();  print (PrintText) SC_453;  new_line; .L_Say170; .L_SayX159;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1387, 1387, true);
   rfalse;
];
! No specific request
! Instead of going southeast in the hill:
[ R_1388 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I50_southeast) && (true)) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1388, 1388);
      ! phrase 1
      ! [1: say ~The hill descends steeply into the woods in that direction; you can enter the woods directly to the south.~]
      say__p=1;ParaContent();  print (PrintText) SC_454;  new_line; .L_Say171; .L_SayX160;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1388, 1388, true);
   rfalse;
];
! No specific request
! Instead of going up in Outside Waterworks:
[ R_1393 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I447_outside_waterworks) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1393, 1393);
      ! phrase 1
      ! [1: try going south]
       TryAction(0, player, ##Go, I49_south, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1393, 1393, true);
   rfalse;
];
! No specific request
! Instead of going down in Outside Waterworks:
[ R_1394 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I447_outside_waterworks) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1394, 1394);
      ! phrase 1
      ! [1: try going north]
       TryAction(0, player, ##Go, I46_north, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1394, 1394, true);
   rfalse;
];
! No specific request
! Instead of going down in the Hill:
[ R_1395 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1395, 1395);
      ! phrase 1
      ! [1: try going southwest]
       TryAction(0, player, ##Go, I51_southwest, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1395, 1395, true);
   rfalse;
];
! No specific request
! Instead of going southeast in the Hill:
[ R_1412 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I50_southeast) && (true)) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1412, 1412);
      ! phrase 1
      ! [1: say ~The hill drops off too steeply in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_455;  new_line; .L_Say172; .L_SayX161;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1412, 1412, true);
   rfalse;
];
! No specific request
! Instead of going up in Pine Forest:
[ R_1421 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I511_pine_forest) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1421, 1421);
      ! phrase 1
      ! [1: try climbing the pine trees]
       TryAction(0, player, ##Climb, I574_tall_pine_trees, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1421, 1421, true);
   rfalse;
];
! No specific request
! Instead of going down in Pine Forest:
[ R_1426 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I511_pine_forest) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1426, 1426);
      ! phrase 1
      ! [1: say ~Only the thick carpet of needles.~]
      say__p=1;ParaContent();  print (PrintText) SC_456;  new_line; .L_Say173; .L_SayX162;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1426, 1426, true);
   rfalse;
];
! No specific request
! Instead of going inside in the Hill:
[ R_1427 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1427, 1427);
      ! phrase 1
      ! [1: try going east]
       TryAction(0, player, ##Go, I52_east, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1427, 1427, true);
   rfalse;
];
! No specific request
! Instead of going east in Rocky Beach:
[ R_1448 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && ((real_location == I470_rocky_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1448, 1448);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1448, 1448, true);
   rfalse;
];
! No specific request
! Instead of going southeast in Rocky Beach:
[ R_1449 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I50_southeast) && (true)) && ((real_location == I470_rocky_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1449, 1449);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1449, 1449, true);
   rfalse;
];
! No specific request
! Instead of going south in Rocky Beach:
[ R_1450 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I49_south) && (true)) && ((real_location == I470_rocky_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1450, 1450);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1450, 1450, true);
   rfalse;
];
! No specific request
! Instead of going north in Rocky Beach:
[ R_1451 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && ((real_location == I470_rocky_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1451, 1451);
      ! phrase 1
      ! [1: try entering the pond]
       TryAction(0, player, ##Enter, I463_pond, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1451, 1451, true);
   rfalse;
];
! No specific request
! Instead of going northwest in Rocky Beach:
[ R_1452 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I48_northwest) && (true)) && ((real_location == I470_rocky_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1452, 1452);
      ! phrase 1
      ! [1: try entering the pond]
       TryAction(0, player, ##Enter, I463_pond, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1452, 1452, true);
   rfalse;
];
! No specific request
! Instead of going east in Sandy Beach:
[ R_1496 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I52_east) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1496, 1496);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1496, 1496, true);
   rfalse;
];
! No specific request
! Instead of going south in Sandy Beach:
[ R_1497 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I49_south) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1497, 1497);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1497, 1497, true);
   rfalse;
];
! No specific request
! Instead of going southeast in Sandy Beach:
[ R_1498 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I50_southeast) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1498, 1498);
      ! phrase 1
      ! [1: try climbing the fence]
       TryAction(0, player, ##Climb, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1498, 1498, true);
   rfalse;
];
! No specific request
! Instead of going west in Sandy Beach:
[ R_1499 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1499, 1499);
      ! phrase 1
      ! [1: try entering the pond]
       TryAction(0, player, ##Enter, I463_pond, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1499, 1499, true);
   rfalse;
];
! No specific request
! Instead of going north in Sandy Beach:
[ R_1500 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1500, 1500);
      ! phrase 1
      ! [1: say ~The sandy beach continues, but there doesn't seem to be much more of interest there.~]
      say__p=1;ParaContent();  print (PrintText) SC_457;  new_line; .L_Say174; .L_SayX163;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1500, 1500, true);
   rfalse;
];
! No specific request
! Instead of going northeast in Sandy Beach:
[ R_1501 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I47_northeast) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1501, 1501);
      ! phrase 1
      ! [1: say ~The sandy beach continues, but there doesn't seem to be much more of interest there.~]
      say__p=1;ParaContent();  print (PrintText) SC_457;  new_line; .L_Say175; .L_SayX164;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1501, 1501, true);
   rfalse;
];
! No specific request
! Instead of going west in Sandy Beach:
[ R_1504 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I474_sandy_beach) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1504, 1504);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1504, 1504, true);
   rfalse;
];
! No specific request
! Instead of going up in Freshwater Crossing:
[ R_1506 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I507_freshwater_crossing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1506, 1506);
      ! phrase 1
      ! [1: try going northeast]
       TryAction(0, player, ##Go, I47_northeast, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1506, 1506, true);
   rfalse;
];
! No specific request
! Instead of going down in Freshwater Crossing:
[ R_1511 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I507_freshwater_crossing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1511, 1511);
      ! phrase 1
      ! [1: say ~That way is only the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_458;  new_line; .L_Say176; .L_SayX165;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1511, 1511, true);
   rfalse;
];
! No specific request
! Instead of going up in Freshwater Crossing:
[ R_1512 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I507_freshwater_crossing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1512, 1512);
      ! phrase 1
      ! [1: say ~That way is only the sky.~]
      say__p=1;ParaContent();  print (PrintText) SC_459;  new_line; .L_Say177; .L_SayX166;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1512, 1512, true);
   rfalse;
];
! No specific request
! Instead of going up in Grassy Area:
[ R_1517 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I509_grassy_area) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1517, 1517);
      ! phrase 1
      ! [1: say ~That way is only the sky.~]
      say__p=1;ParaContent();  print (PrintText) SC_459;  new_line; .L_Say178; .L_SayX167;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1517, 1517, true);
   rfalse;
];
! No specific request
! Instead of going down in Grassy Area:
[ R_1518 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I509_grassy_area) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1518, 1518);
      ! phrase 1
      ! [1: say ~That way is only the mud.~]
      say__p=1;ParaContent();  print (PrintText) SC_460;  new_line; .L_Say179; .L_SayX168;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1518, 1518, true);
   rfalse;
];
! No specific request
! Instead of going up in the Woods:
[ R_1559 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I444_woods) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1559, 1559);
      ! phrase 1
      ! [1: try climbing the colorful trees]
       TryAction(0, player, ##Climb, I628_colorful_trees, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1559, 1559, true);
   rfalse;
];
! No specific request
! Instead of going down in the Woods:
[ R_1560 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I444_woods) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1560, 1560);
      ! phrase 1
      ! [1: say ~There's nothing down there but a mat of leaves.~]
      say__p=1;ParaContent();  print (PrintText) SC_461;  new_line; .L_Say180; .L_SayX169;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1560, 1560, true);
   rfalse;
];
! No specific request
! Instead of going up in Other Side of the Pond:
[ R_1563 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I494_other_side_of_the_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1563, 1563);
      ! phrase 1
      ! [1: say ~That way is only the sky.~]
      say__p=1;ParaContent();  print (PrintText) SC_459;  new_line; .L_Say181; .L_SayX170;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1563, 1563, true);
   rfalse;
];
! No specific request
! Instead of going down in Other Side of the Pond:
[ R_1564 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I494_other_side_of_the_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1564, 1564);
      ! phrase 1
      ! [1: say ~That way is only the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_458;  new_line; .L_Say182; .L_SayX171;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1564, 1564, true);
   rfalse;
];
! No specific request
! Instead of going in from the Woods:
[ R_1568 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I442_in_the_sweetgum_tree) && (true)) && (((MStack-->MstVON(20007,0)) == I444_woods) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1568, 1568);
      ! phrase 1
      ! [1: say ~There's nothing down there.~]
      say__p=1;ParaContent();  print (PrintText) SC_462;  new_line; .L_Say183; .L_SayX172;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1568, 1568, true);
   rfalse;
];
! No specific request
! Instead of going up in the Woods:
[ R_1569 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I444_woods) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1569, 1569);
      ! phrase 1
      ! [1: say ~None of the trees look very climbable.~]
      say__p=1;ParaContent();  print (PrintText) SC_463;  new_line; .L_Say184; .L_SayX173;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1569, 1569, true);
   rfalse;
];
! No specific request
! Instead of going west in Large Clearing:
[ R_1629 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I502_large_clearing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1629, 1629);
      ! phrase 1
      ! [1: say ~The house is far away, and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_464;  new_line; .L_Say185; .L_SayX174;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1629, 1629, true);
   rfalse;
];
! No specific request
! Instead of going down in Large Clearing:
[ R_1631 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I502_large_clearing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1631, 1631);
      ! phrase 1
      ! [1: say ~That way is only the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_458;  new_line; .L_Say186; .L_SayX175;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1631, 1631, true);
   rfalse;
];
! No specific request
! Instead of going down in Small Clearing:
[ R_1632 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I501_small_clearing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1632, 1632);
      ! phrase 1
      ! [1: say ~That way is only the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_458;  new_line; .L_Say187; .L_SayX176;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1632, 1632, true);
   rfalse;
];
! No specific request
! Instead of going up in Small Clearing:
[ R_1633 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I501_small_clearing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1633, 1633);
      ! phrase 1
      ! [1: say ~That way is only the sky.~]
      say__p=1;ParaContent();  print (PrintText) SC_459;  new_line; .L_Say188; .L_SayX177;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1633, 1633, true);
   rfalse;
];
! No specific request
! Instead of going up in Large Clearing:
[ R_1661 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I502_large_clearing) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1661, 1661);
      ! phrase 1
      ! [1: try climbing the rungs]
       TryAction(0, player, ##Climb, I654_rungs, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1661, 1661, true);
   rfalse;
];
! No specific request
! Instead of going up in Weedy Island:
[ R_1671 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I504_weedy_island) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1671, 1671);
      ! phrase 1
      ! [1: say ~That way is only the sky.~]
      say__p=1;ParaContent();  print (PrintText) SC_459;  new_line; .L_Say189; .L_SayX178;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1671, 1671, true);
   rfalse;
];
! No specific request
! Instead of going down in Weedy Island:
[ R_1674 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I504_weedy_island) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1674, 1674);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1674, 1674, true);
   rfalse;
];
! No specific request
! Instead of going down in Underwater:
[ R_1675 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I669_underwater) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1675, 1675);
      ! phrase 1
      ! [1: say ~You try to swim downward, but your own natural buoyancy, plus the tank of air that you need to breathe, push you back up toward the surface.~]
      say__p=1;ParaContent();  print (PrintText) SC_465;  new_line; .L_Say190; .L_SayX179;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1675, 1675, true);
   rfalse;
];
! No specific request
! Instead of going up from Underwater:
[ R_1692 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && (((MStack-->MstVON(20007,0)) == I669_underwater) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1692, 1692);
      ! phrase 1
      ! [1: if the rowboat is in floating on the pond or the rowboat is in spireland , move the player to the rowboat]
       if ((((I466_floating_on_the_pond == ContainerOf(I481_rowboat)))) || (((I465_spireland == ContainerOf(I481_rowboat))))) {  MoveObject(player, I481_rowboat, 0, false);   }
      ! phrase 2
      ! [2: otherwise move the player to the location of the rowboat]
       else {  MoveObject(player,  LocationOf(I481_rowboat) , 0, false);   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1692, 1692, true);
   rfalse;
];
! No specific request
! Instead of going up in the Crystal City:
[ R_1695 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I677_the_crystal_city) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1695, 1695);
      ! phrase 1
      ! [1: say ~Just as before you felt too buoyant to swim down, now you feel gravity holding you to the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_466;  new_line; .L_Say191; .L_SayX180;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1695, 1695, true);
   rfalse;
];
! No specific request
! Instead of exiting in Boat House when the player is not in the rowboat:
[ R_1259 ;
   if ((action ==##Exit) &&  (actor==player) && ((real_location == I479_boat_house) && (true)) && (self=actor,true) && (((~~((I481_rowboat == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1259, 1259);
      ! phrase 1
      ! [1: try going east]
       TryAction(0, player, ##Go, I52_east, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1259, 1259, true);
   rfalse;
];
! No specific request
! Instead of going in Grassy Area when the player is trapped:
[ R_1529 ;
   if ((action ==##Go) &&  (actor==player) && ((real_location == I509_grassy_area) && (true)) && (self=actor,true) && ((((Adj_130_t1_v9(player)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1529, 1529);
      ! phrase 1
      ! [1: say ~You're stuck in mud to your waist, and trying to move only entrenches you deeper.~]
      say__p=1;ParaContent();  print (PrintText) SC_467;  new_line; .L_Say192; .L_SayX181;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1529, 1529, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Grassy Shore:
[ R_1292 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I464_grassy_shore) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1292, 1292);
      ! phrase 1
      ! [1: say ~The grass that way is too wet and muddy to step in.~]
      say__p=1;ParaContent();  print (PrintText) SC_468;  new_line; .L_Say193; .L_SayX182;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1292, 1292, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Spireland:
[ R_1311 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I465_spireland) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1311, 1311);
      ! phrase 1
      ! [1: move the player to floating on the pond]
       MoveObject(player, I466_floating_on_the_pond, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1311, 1311, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from In The Sweetgum Tree:
[ R_1398 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I442_in_the_sweetgum_tree) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1398, 1398);
      ! phrase 1
      ! [1: say ~You can't reach the rest of the tree -- you can only go down from here.~]
      say__p=1;ParaContent();  print (PrintText) SC_469;  new_line; .L_Say194; .L_SayX183;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1398, 1398, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from the Hill:
[ R_1415 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I441_hill) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1415, 1415);
      ! phrase 1
      ! [1: say ~In that direction the hill drops precipitously down -- too precipitously to risk -- directly into the pond, a tumble of rocks and mud and tree roots and little marsh plants.~]
      say__p=1;ParaContent();  print (PrintText) SC_470;  new_line; .L_Say195; .L_SayX184;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1415, 1415, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Pine Forest:
[ R_1425 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I511_pine_forest) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1425, 1425);
      ! phrase 1
      ! [1: say ~The trees get too dense and too dark in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_471;  new_line; .L_Say196; .L_SayX185;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1425, 1425, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Freshwater Crossing:
[ R_1510 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I507_freshwater_crossing) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1510, 1510);
      ! phrase 1
      ! [1: say ~The ground is too marshy and unstable in that direction.~]
      say__p=1;ParaContent();  print (PrintText) SC_472;  new_line; .L_Say197; .L_SayX186;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1510, 1510, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Grassy Area:
[ R_1539 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I509_grassy_area) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1539, 1539);
      ! phrase 1
      ! [1: say ~You take a few steps to [the noun], but you soon find yourself sinking into the mud, and retreat.~]
      say__p=1;ParaContent();  print (PrintText) SC_473; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_474;  new_line; .L_Say198; .L_SayX187;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1539, 1539, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Other Side Of the Pond:
[ R_1562 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I494_other_side_of_the_pond) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1562, 1562);
      ! phrase 1
      ! [1: try going west]
       TryAction(0, player, ##Go, I53_west, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1562, 1562, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from the Woods:
[ R_1570 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I444_woods) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1570, 1570);
      ! phrase 1
      ! [1: say ~You tromp through the trees for a few steps, but it feels like you might have just walked in a circle.~]
      say__p=1;ParaContent();  print (PrintText) SC_475;  new_line; .L_Say199; .L_SayX188;
      ! phrase 2
      ! [2: move the player to the woods]
       MoveObject(player, I444_woods, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1570, 1570, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Small Clearing:
[ R_1605 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I501_small_clearing) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1605, 1605);
      ! phrase 1
      ! [1: move the player to the woods]
       MoveObject(player, I444_woods, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1605, 1605, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from Large Clearing:
[ R_1630 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) == I502_large_clearing) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1630, 1630);
      ! phrase 1
      ! [1: move the player to the woods]
       MoveObject(player, I444_woods, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1630, 1630, true);
   rfalse;
];
! No specific request
! Instead of going nowhere in Underwater:
[ R_1676 ;
   if ((action ==##Go) &&  (actor==player) && ((real_location == I669_underwater) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1676, 1676);
      ! phrase 1
      ! [1: say ~Cardinal directions mean little under the pond's surface. You [one of]kick your legs[or]move your arms[at random] and move slowly through the still water, but nothing much changes about your location.~]
      say__p=1;ParaContent();  print (PrintText) SC_476; ParaContent();  I7_ST_say_one_of-->14 =
	i7_soo_ran(I7_ST_say_one_of-->14, 2);
	switch((I7_ST_say_one_of-->14)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_477; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_478; ParaContent();  } ParaContent();  print (PrintText) SC_479;  new_line; .L_Say200; .L_SayX189;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1676, 1676, true);
   rfalse;
];
! No specific request
! Instead of going nowhere in the Crystal City:
[ R_1696 ;
   if ((action ==##Go) &&  (actor==player) && ((real_location == I677_the_crystal_city) && (true)) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1696, 1696);
      ! phrase 1
      ! [1: say ~Vivian and her family, friendly as they are, are clear in their expressions when you move to step outside the courtyard.~]
      say__p=1;ParaContent();  print (PrintText) SC_480;  new_line; .L_Say201; .L_SayX190;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1696, 1696, true);
   rfalse;
];
! No specific request
! Instead of going nowhere from a room that is indoors:
[ R_1203 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,0)) ofclass K1_room) && ((Adj_98_t1_v9((MStack-->MstVON(20007,0)))))) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1203, 1203);
      ! phrase 1
      ! [1: say ~That way is only a wall.~]
      say__p=1;ParaContent();  print (PrintText) SC_481;  new_line; .L_Say202; .L_SayX191;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1203, 1203, true);
   rfalse;
];
! No specific request
! Instead of the dog going to Atop the Tank:
[ R_1567 ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor == I443_dog) && (true)) && (((MStack-->MstVON(20007,1)) == I469_atop_the_tank) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1567, 1567);
      ! phrase 1
      ! [1: try the dog going a random direction]
       TryAction(0, I443_dog, ##Go,  (Prop_26()) , 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1567, 1567, true);
   rfalse;
];
! No specific request
! Instead of going to the Pump Room when the Secretary is visible and the Secretary is irked:
[ R_1386 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I510_pump_room) && (true)) && (self=actor,true) && (((((Adj_3_t1_v9(I545_secretary_of_water))))) && ((((Adj_114_t1_v9(I545_secretary_of_water))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1386, 1386);
      ! phrase 1
      ! [1: say ~[The secretary] [one of]tightens her lips[or]grimaces[at random] and pushes you away from the staircase[one of]. 'I [bold type]told[roman type] you I'll get in trouble if you go down there.'[or], reminding you that she can't let you mess with the pump.[stopping]~]
      say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_387; ParaContent();  I7_ST_say_one_of-->15 =
	i7_soo_ran(I7_ST_say_one_of-->15, 2);
	switch((I7_ST_say_one_of-->15)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_482; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_483; ParaContent();  } ParaContent();  print (PrintText) SC_484; ParaContent();  I7_ST_say_one_of-->16 =
	i7_soo_stop(I7_ST_say_one_of-->16, 2);
	switch((I7_ST_say_one_of-->16)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_485; ParaContent();  style bold; ParaContent();  print (PrintText) SC_486; ParaContent();  style roman; ParaContent();  print (PrintText) SC_487;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_488;  new_line;ParaContent();  }  .L_Say203; .L_SayX192;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1386, 1386, true);
   rfalse;
];
! No specific request
! Instead of going to Grassy Area when the player has been trapped:
[ R_1531 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I509_grassy_area) && (true)) && (self=actor,true) && (TestSinglePastState(0, 45, false, 5))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1531, 1531);
      ! phrase 1
      ! [1: say ~The marsh is clearly too flooded and unstable to hold your weight. You shudder at the thought of getting stuck in that mud again.~]
      say__p=1;ParaContent();  print (PrintText) SC_489;  new_line; .L_Say204; .L_SayX193;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1531, 1531, true);
   rfalse;
];
! No specific request
! Instead of going to Pump Room when Pump Room is flooded:
[ R_1610 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I510_pump_room) && (true)) && (self=actor,true) && ((((Adj_136_t1_v9(I510_pump_room)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1610, 1610);
      ! phrase 1
      ! [1: say ~The water level is up to the top of the stairs -- it was treacherous enough when the room wasn't flooded, but now, there's definitely no safe way to get down there.~]
      say__p=1;ParaContent();  print (PrintText) SC_490;  new_line; .L_Say205; .L_SayX194;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1610, 1610, true);
   rfalse;
];
! No specific request
! Instead of going to Inside Waterworks when Inside Waterworks is flooded:
[ R_1611 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I506_inside_waterworks) && (true)) && (self=actor,true) && ((((Adj_136_t1_v9(I506_inside_waterworks)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1611, 1611);
      ! phrase 1
      ! [1: say ~You peer into the door. The entire floor seems to have collapsed, leaving only a deep, gaping hole and an ominous pool of muddy water, algae and dirt and little twigs swirling and bobbing. There's no way you could enter safely, and no chance that anything inside hasn't been ruined by the water.~]
      say__p=1;ParaContent();  print (PrintText) SC_491;  new_line; .L_Say206; .L_SayX195;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1611, 1611, true);
   rfalse;
];
! No specific request
! Instead of going to Sandy Beach when Sandy Beach is flooded:
[ R_1612 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I474_sandy_beach) && (true)) && (self=actor,true) && ((((Adj_136_t1_v9(I474_sandy_beach)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1612, 1612);
      ! phrase 1
      ! [1: say ~The former sandy beach is now completely flooded; you take a step in that direction, splashing into the deepening water, and feel your boot sink into the sand. Hurriedly you shift your weight and retreat back to the comparative safety of the wet beach.~]
      say__p=1;ParaContent();  print (PrintText) SC_492;  new_line; .L_Say207; .L_SayX196;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1612, 1612, true);
   rfalse;
];
! No specific request
! Instead of going to Freshwater Crossing when the Steam Train is flooded:
[ R_1740 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I507_freshwater_crossing) && (true)) && (self=actor,true) && ((((Adj_136_t1_v9(I439_steam_train)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1740, 1740);
      ! phrase 1
      ! [1: if the location is grassy area , continue the action]
       if (((real_location == I509_grassy_area))) {  rfalse;   }
      ! phrase 2
      ! [2: otherwise say ~You're not really surprised when your boot meets the familiar squelch of unstable mud [if the player is in The Hill]near the bottom of the steps[otherwise]before you can reach the train[end if]. The crossing and the train are inaccessible; [if the player is in Pine Forest]through the trees [otherwise if the player is in The Hill]down the hill [end if]you can make out the train, more completely still than you've ever seen it, wheel-deep in a muddy film of water that covers the tracks.~]
       else { say__p=1;ParaContent();  print (PrintText) SC_493; 
	if (~~((((I441_hill == ContainerOf(player)))))) jump L_Say208;
		ParaContent();  print (PrintText) SC_494; 
	jump L_SayX197; .L_Say208;
		ParaContent();  print (PrintText) SC_495; 
	.L_Say209; .L_SayX197;
		ParaContent();  print (PrintText) SC_496; 
	if (~~((((I511_pine_forest == ContainerOf(player)))))) jump L_Say210;
		ParaContent();  print (PrintText) SC_497; ParaContent(); 
	jump L_SayX198; .L_Say210; if (~~((((I441_hill == ContainerOf(player)))))) jump L_Say211;
		ParaContent();  print (PrintText) SC_498; 
	.L_Say211; .L_SayX198;
		ParaContent();  print (PrintText) SC_499;  new_line; .L_Say212; .L_SayX199;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1740, 1740, true);
   rfalse;
];
! No specific request
! Instead of swimming in the presence of a liquid source when the location is Outside Waterworks or the location is the Hill or the location is In The Sweetgum Tree or the location is Atop the Tank:
[ R_1246 ;
   if ((action ==##A102_swimming) &&  (actor==player) && (los_rv=false, LoopOverScope(LOS_0, actor), los_rv) && (self=actor,true) && ((((real_location == I447_outside_waterworks))) || ((((real_location == I441_hill))) || ((((real_location == I442_in_the_sweetgum_tree))) || (((real_location == I469_atop_the_tank))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1246, 1246);
      ! phrase 1
      ! [1: say ~You can see the pond from here, but you can't access it.~]
      say__p=1;ParaContent();  print (PrintText) SC_500;  new_line; .L_Say213; .L_SayX200;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1246, 1246, true);
   rfalse;
];
! No specific request
! Instead of inserting the screwdriver into the panel when the panel is closed:
[ R_1456 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I636_screwdriver) && (true)) && ((second == I591_secret_panel) && (true)) && (self=actor,true) && ((((Adj_71_t1_v9(I591_secret_panel)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1456, 1456);
      ! phrase 1
      ! [1: try prying the panel with the screwdriver]
       TryAction(0, player, ##A126_prying_it_with, I591_secret_panel, I636_screwdriver);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1456, 1456, true);
   rfalse;
];
! No specific request
! Instead of putting the magnet on the deep crack when the old key is in the deep crack:
[ R_1582 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I604_large_magnet) && (true)) && ((second == I639_deep_crack) && (true)) && (self=actor,true) && (((I639_deep_crack == ContainerOf(I640_old_key))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1582, 1582);
      ! phrase 1
      ! [1: try taking the old key with the magnet]
       TryAction(0, player, ##A130_taking_it_with, I640_old_key, I604_large_magnet);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1582, 1582, true);
   rfalse;
];
! No specific request
! Instead of putting the magnet on the old key when the old key is in the deep crack:
[ R_1583 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I604_large_magnet) && (true)) && ((second == I640_old_key) && (true)) && (self=actor,true) && (((I639_deep_crack == ContainerOf(I640_old_key))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1583, 1583);
      ! phrase 1
      ! [1: try taking the old key with the magnet]
       TryAction(0, player, ##A130_taking_it_with, I640_old_key, I604_large_magnet);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1583, 1583, true);
   rfalse;
];
! No specific request
! Instead of taking the old key with the large magnet when the old key is in the deep crack:
[ R_1595 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I640_old_key) && (true)) && ((second == I604_large_magnet) && (true)) && (self=actor,true) && (((I639_deep_crack == ContainerOf(I640_old_key))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1595, 1595);
      ! phrase 1
      ! [1: say ~The magnet pulls the key toward the front of the crack, until it's close enough for you to grab with the tips of your fingers, which you do.~]
      say__p=1;ParaContent();  print (PrintText) SC_501;  new_line; .L_Say214; .L_SayX201;
      ! phrase 2
      ! [2: move the old key to the player]
       MoveObject(I640_old_key, player, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1595, 1595, true);
   rfalse;
];
! No specific request
! Instead of putting the medium-sized wheel on the brass metal pipe when the flagpole is in the holes:
[ R_1648 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && ((second == I657_brass_metal_pipe) && (true)) && (self=actor,true) && (((I661_wheel_holes == ContainerOf(I490_flagpole))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1648, 1648);
      ! phrase 1
      ! [1: say ~The flagpole is in the way.~]
      say__p=1;ParaContent();  print (PrintText) SC_502;  new_line; .L_Say215; .L_SayX202;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1648, 1648, true);
   rfalse;
];
! No specific request
! Instead of inserting the flagpole into the medium-sized wheel when the medium-sized wheel is on the brass metal pipe:
[ R_1654 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I490_flagpole) && (true)) && ((second == I660_medium_sized_wheel) && (true)) && (self=actor,true) && (((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1654, 1654);
      ! phrase 1
      ! [1: try inserting the flagpole into the brass metal pipe]
       TryAction(0, player, ##Insert, I490_flagpole, I657_brass_metal_pipe);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1654, 1654, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the pipe holes when the pipe holes contain something:
[ R_1650 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I662_pipe_holes) && (true)) && (self=actor,true) && ((Prop_27()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1650, 1650);
      ! phrase 1
      ! [1: say ~[The random thing that is in the holes] is already in the holes.~]
      say__p=1;ParaContent();  print (The)  (Prop_28()) ; ParaContent();  print (PrintText) SC_503;  new_line; .L_Say216; .L_SayX203;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1650, 1650, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the vending machine when the vending machine is closed:
[ R_1436 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I580_vending_machine) && (true)) && (self=actor,true) && ((((Adj_71_t1_v9(I580_vending_machine)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1436, 1436);
      ! phrase 1
      ! [1: try inserting the noun into the slot]
       TryAction(0, player, ##Insert, noun, I581_slot);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1436, 1436, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the wheel holes when the medium-sized wheel is on the brass metal pipe:
[ R_1655 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I661_wheel_holes) && (true)) && (self=actor,true) && (((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1655, 1655);
      ! phrase 1
      ! [1: try inserting the noun into the brass metal pipe]
       TryAction(0, player, ##Insert, noun, I657_brass_metal_pipe);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1655, 1655, true);
   rfalse;
];
! No specific request
! Instead of taking the brass key with something when the keychain is contained by the tall cylinder:
[ R_1587 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I485_brass_key) && (true)) && ((second ofclass K2_thing)) && (self=actor,true) && ((Prop_29()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1587, 1587);
      ! phrase 1
      ! [1: say ~You still can't reach [it-them of the second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_504; ParaContent(); (Resolver_2(second,"source", 2727));ParaContent();  print (PrintText) SC_250;  new_line; .L_Say217; .L_SayX204;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1587, 1587, true);
   rfalse;
];
! No specific request
! Instead of taking the old key with something when the old key is in the deep crack:
[ R_1594 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I640_old_key) && (true)) && ((second ofclass K2_thing)) && (self=actor,true) && (((I639_deep_crack == ContainerOf(I640_old_key))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1594, 1594);
      ! phrase 1
      ! [1: say ~The key is too far in there.~]
      say__p=1;ParaContent();  print (PrintText) SC_505;  new_line; .L_Say218; .L_SayX205;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1594, 1594, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the door to the structure for the first time:
[ R_1268 ;
   if ((PAPR_2() && (((TimesActionHasHappened-->2) == 1) && (ActionCurrentlyHappeningFlag->2)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1268, 1268);
      ! phrase 1
      ! [1: say ~Damn. It's locked.[paragraph break]You wade back to the beach.~]
      say__p=1;ParaContent();  print (PrintText) SC_506; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_507;  new_line; .L_Say219; .L_SayX206;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1268, 1268, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the community center door for the first time:
[ R_1283 ;
   if ((PAPR_3() && (((TimesActionHasHappened-->3) == 1) && (ActionCurrentlyHappeningFlag->3)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1283, 1283);
      ! phrase 1
      ! [1: say ~Damn. It's locked.~]
      say__p=1;ParaContent();  print (PrintText) SC_506;  new_line; .L_Say220; .L_SayX207;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1283, 1283, true);
   rfalse;
];
! No specific request
! Instead of going inside when the room inside from the location is not a room and at least one room is inward:
[ R_1063 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##Go) &&  (actor==player) && ((noun == in_obj) && (true)) && (self=actor,true) && ((((~~(((Resolver_4(in_obj,real_location,"source", 175)) ofclass K1_room))))) && ((Prop_30())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1063, 1063);
      ! phrase 1
      ! [1: if more than one room is inward begin]
       if ((Prop_31()))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: let the destination be a random inward room]
          t_0 =  (Prop_32()) ; 
         ! phrase 5
         ! [5: let the way be the best route from the location to the destination]
          t_1 =  MapRouteTo(real_location,t_0,0,0) ; 
         ! phrase 6
         ! [6: say ~(that is, [way])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_508; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say221; .L_SayX208;
         ! phrase 7
         ! [7: try going the way instead]
          TryAction(0, player, ##Go, t_1, 0);;  rtrue;
         ! phrase 8
         ! [8: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1063, 1063, true);
   rfalse;
];
! No specific request
! Instead of turning the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and nothing is in the pipe holes:
[ R_1641 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && (self=actor,true) && ((((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))) && ((Prop_33())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1641, 1641);
      ! phrase 1
      ! [1: say ~The wheel spins freely around the pipe, but nothing happens.~]
      say__p=1;ParaContent();  print (PrintText) SC_509;  new_line; .L_Say222; .L_SayX209;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1641, 1641, true);
   rfalse;
];
! No specific request
! Instead of turning the flagpole when the flagpole is in the holes and the medium-sized wheel is not on the brass metal pipe:
[ R_1647 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I490_flagpole) && (true)) && (self=actor,true) && ((((I661_wheel_holes == ContainerOf(I490_flagpole)))) && (((~~((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1647, 1647);
      ! phrase 1
      ! [1: say ~You can't seem to push with enough force to get anything moving.~]
      say__p=1;ParaContent();  print (PrintText) SC_510;  new_line; .L_Say223; .L_SayX210;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1647, 1647, true);
   rfalse;
];
! No specific request
! Instead of knocking on the Waterworks door when the Waterworks door is closed and the secretary of water is in Inside Waterworks and the player is in Outside Waterworks:
[ R_1216 ;
   if ((action ==##A112_knocking_on) &&  (actor==player) && ((noun == I516_door_to_the_waterworks) && (true)) && (self=actor,true) && (((((Adj_71_t1_v9(I516_door_to_the_waterworks))))) && ((((I506_inside_waterworks == ContainerOf(I545_secretary_of_water)))) && (((I447_outside_waterworks == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1216, 1216);
      ! phrase 1
      ! [1: say ~You knock on the door. After a moment, [if the player has been in Inside Waterworks][the secretary][otherwise]a woman[end if] opens the door [if the secretary is irked]grudgingly[otherwise]and welcomes you in[end if], and then returns to her desk.~]
      say__p=1;ParaContent();  print (PrintText) SC_511; 
	if (~~((TestSinglePastState(0, 46, false, 5)))) jump L_Say224;
		ParaContent();  print (the) I545_secretary_of_water; 
	jump L_SayX211; .L_Say224;
		ParaContent();  print (PrintText) SC_512; 
	.L_Say225; .L_SayX211;
		ParaContent();  print (PrintText) SC_513; 
	if (~~(((((Adj_114_t1_v9(I545_secretary_of_water))))))) jump L_Say226;
		ParaContent();  print (PrintText) SC_514; 
	jump L_SayX212; .L_Say226;
		ParaContent();  print (PrintText) SC_515; 
	.L_Say227; .L_SayX212;
		ParaContent();  print (PrintText) SC_516;  new_line; .L_Say228; .L_SayX213;
      ! phrase 2
      ! [2: say ~'[if the secretary is not irked]Hi! [end if]Can I help you?' she asks.'~]
      say__p=1;ParaContent();  print (PrintText) SC_517; 
	if (~~((((~~(((Adj_114_t1_v9(I545_secretary_of_water))))))))) jump L_Say229;
		ParaContent();  print (PrintText) SC_518; 
	.L_Say229; .L_SayX214;
		ParaContent();  print (PrintText) SC_519;  new_line; .L_Say230; .L_SayX215;
      ! phrase 3
      ! [3: now the waterworks door is open]
       (Adj_70_t2_v9(I516_door_to_the_waterworks)); 
      ! phrase 4
      ! [4: now the player is in inside waterworks]
       MoveObject(player,I506_inside_waterworks); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1216, 1216, true);
   rfalse;
];
! No specific request
! Instead of opening the structure when the player is not in Rocky Beach:
[ R_1263 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I477_structure) && (true)) && (self=actor,true) && (((~~((I470_rocky_beach == ContainerOf(player))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1263, 1263);
      ! phrase 1
      ! [1: try entering the structure]
       TryAction(0, player, ##Enter, I477_structure, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1263, 1263, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the door to the structure when the player does not enclose the old key:
[ R_1269 ;
   if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I480_door_to_the_structure) && (true)) && (self=actor,true) && (((~~((IndirectlyContains(player,I640_old_key))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1269, 1269);
      ! phrase 1
      ! [1: say ~Still locked. You wade back to the beach.~]
      say__p=1;ParaContent();  print (PrintText) SC_520;  new_line; .L_Say231; .L_SayX216;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1269, 1269, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the community center door when the player does not enclose the brass key:
[ R_1284 ;
   if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I483_community_center_door) && (true)) && (self=actor,true) && (((~~((IndirectlyContains(player,I485_brass_key))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1284, 1284);
      ! phrase 1
      ! [1: say ~Still locked.~]
      say__p=1;ParaContent();  print (PrintText) SC_521;  new_line; .L_Say232; .L_SayX217;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1284, 1284, true);
   rfalse;
];
! No specific request
! Instead of examining the pond when the player is in the steam train and the station of the steam train is Freshwater Crossing:
[ R_1241 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I463_pond) && (true)) && (self=actor,true) && ((((I439_steam_train == ContainerOf(player)))) && (((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1241, 1241);
      ! phrase 1
      ! [1: say ~You can't see it from here.~]
      say__p=1;ParaContent();  print (PrintText) SC_522;  new_line; .L_Say233; .L_SayX218;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1241, 1241, true);
   rfalse;
];
! No specific request
! Instead of turning the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and the flagpole is in the pipe holes:
[ R_1643 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && (self=actor,true) && ((((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))) && (((I662_pipe_holes == ContainerOf(I490_flagpole)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1643, 1643);
      ! phrase 1
      ! [1: say ~[one of]You turn the wheel, and because the flagpole is threaded through the wheel and pipe, the pipe turns with it. You hear a grinding noise. You keep turning.[or]The wheel turns only a little further, and then you meet resistance.[or]You are unable to turn the wheel further.[stopping]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->17 =
	i7_soo_stop(I7_ST_say_one_of-->17, 3);
	switch((I7_ST_say_one_of-->17)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_523;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_524;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_525;  new_line;ParaContent();  }  .L_Say234; .L_SayX219;
      ! phrase 2
      ! [2: now the big pump is switched on]
       (Adj_80_t2_v9(I418_big_pump)); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1643, 1643, true);
   rfalse;
];
! No specific request
! Instead of turning the flagpole when the flagpole is in the pipe holes and the medium-sized wheel is on the brass metal pipe:
[ R_1646 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I490_flagpole) && (true)) && (self=actor,true) && ((((I662_pipe_holes == ContainerOf(I490_flagpole)))) && (((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1646, 1646);
      ! phrase 1
      ! [1: try turning the medium-sized wheel]
       TryAction(0, player, ##Turn, I660_medium_sized_wheel, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1646, 1646, true);
   rfalse;
];
! No specific request
! Instead of taking the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and the flagpole is in the holes:
[ R_1649 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && (self=actor,true) && ((((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))) && (((I661_wheel_holes == ContainerOf(I490_flagpole)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1649, 1649);
      ! phrase 1
      ! [1: say ~The flagpole is in the way.~]
      say__p=1;ParaContent();  print (PrintText) SC_502;  new_line; .L_Say235; .L_SayX220;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1649, 1649, true);
   rfalse;
];
! No specific request
! Instead of shaking the wind chimes when the player is in Underwater and Vivian is off-stage:
[ R_1682 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true)) && (self=actor,true) && ((((I669_underwater == ContainerOf(player)))) && ((((~~Adj_9_t1_v9(I671_vivian))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1682, 1682);
      ! phrase 1
      ! [1: say ~The chimes ring deep, distorted, and melodic under the water.[paragraph break]The city is far away, but sound travels quickly under the water; it's only a moment before the tiny figures turn to look towards the origin of the sound.[paragraph break]After what seems to be a brief parley, one of them breaks away from the city and starts to move toward you. The small figure moves remarkably fast -- certainly much faster than [bold type]you[roman type] can swim.[paragraph break] -- and almost before you know it, a cloud of bubbles washes over you, dissolving to reveal a face, wet and grinning at you with an infectious enthusiasm.[paragraph break]'Hi! I'm Vivian!' she burbles, and grabs your hand.~]
      say__p=1;ParaContent();  print (PrintText) SC_526; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_527; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_528; ParaContent();  style bold; ParaContent();  print (PrintText) SC_529; ParaContent();  style roman; ParaContent();  print (PrintText) SC_530; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_531; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_532;  new_line; .L_Say236; .L_SayX221;
      ! phrase 2
      ! [2: record ~attracting the attention of the city~ as achieved]
      (PHR_1164_r6 (SC_191));
      ! phrase 3
      ! [3: now vivian is in underwater]
       MoveObject(I671_vivian,I669_underwater); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1682, 1682, true);
   rfalse;
];
! No specific request
! Instead of taking the wind chimes when the player is in the Hill:
[ R_1186 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true)) && (self=actor,true) && (((I441_hill == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1186, 1186);
      ! phrase 1
      ! [1: say ~You'd have to be in the tree to reach them.~]
      say__p=1;ParaContent();  print (PrintText) SC_533;  new_line; .L_Say237; .L_SayX222;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1186, 1186, true);
   rfalse;
];
! No specific request
! Instead of dropping the stick when the dog is in the location of the player:
[ R_1195 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun == I476_wide_stick) && (true)) && (self=actor,true) && ((( LocationOf(player)  == ContainerOf(I443_dog))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1195, 1195);
      ! phrase 1
      ! [1: say ~You drop the stick, but the dog runs toward it, picks it up, and returns it to you.~]
      say__p=1;ParaContent();  print (PrintText) SC_534;  new_line; .L_Say238; .L_SayX223;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1195, 1195, true);
   rfalse;
];
! No specific request
! Instead of entering the Waterworks when the location is Outside Waterworks:
[ R_1221 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I455_waterworks) && (true)) && (self=actor,true) && (((real_location == I447_outside_waterworks)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1221, 1221);
      ! phrase 1
      ! [1: try going east]
       TryAction(0, player, ##Go, I52_east, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1221, 1221, true);
   rfalse;
];
! No specific request
! Instead of facing northwest when the location is Outside Waterworks:
[ R_1222 ;
   if ((action ==##A94_facing) &&  (actor==player) && ((noun == I48_northwest) && (true)) && (self=actor,true) && (((real_location == I447_outside_waterworks)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1222, 1222);
      ! phrase 1
      ! [1: try examining the structure]
       TryAction(0, player, ##Examine, I477_structure, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1222, 1222, true);
   rfalse;
];
! No specific request
! Instead of facing west when the location is Outside Waterworks:
[ R_1223 ;
   if ((action ==##A94_facing) &&  (actor==player) && ((noun == I53_west) && (true)) && (self=actor,true) && (((real_location == I447_outside_waterworks)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1223, 1223);
      ! phrase 1
      ! [1: try looking toward muddy beach]
       TryAction(0, player, ##A95_looking_toward, I468_muddy_beach, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1223, 1223, true);
   rfalse;
];
! No specific request
! Instead of taking the flag when the flagpole is in the mural:
[ R_1304 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I492_flag) && (true)) && (self=actor,true) && (((I489_large_painted_mural == ContainerOf(I490_flagpole))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1304, 1304);
      ! phrase 1
      ! [1: say ~As you tug on the green silk, the flagpole comes out of the wall with it.~]
      say__p=1;ParaContent();  print (PrintText) SC_535;  new_line; .L_Say239; .L_SayX224;
      ! phrase 2
      ! [2: move the flagpole to the player]
       MoveObject(I490_flagpole, player, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1304, 1304, true);
   rfalse;
];
! No specific request
! Instead of opening the drawer when the secretary is visible:
[ R_1317 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I521_metal_drawer) && (true)) && (self=actor,true) && ((((Adj_3_t1_v9(I545_secretary_of_water)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1317, 1317);
      ! phrase 1
      ! [1: say ~[The secretary] stops you. 'Don't mess with my stuff!'~]
      say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_536;  new_line; .L_Say240; .L_SayX225;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1317, 1317, true);
   rfalse;
];
! No specific request
! Instead of taking the clump of sap when the leaky hose is plugged:
[ R_1337 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I576_clump_of_sap) && (true)) && (self=actor,true) && ((((Adj_118_t1_v9(I526_leaky_hose)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1337, 1337);
      ! phrase 1
      ! [1: say ~It's firmly stuck on there.~]
      say__p=1;ParaContent();  print (PrintText) SC_537;  new_line; .L_Say241; .L_SayX226;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1337, 1337, true);
   rfalse;
];
! No specific request
! Instead of examining the notebook when the Secretary of Water is visible:
[ R_1373 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I543_notebook) && (true)) && (self=actor,true) && ((((Adj_3_t1_v9(I545_secretary_of_water)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1373, 1373);
      ! phrase 1
      ! [1: say ~You can't make out any details from here.~]
      say__p=1;ParaContent();  print (PrintText) SC_137;  new_line; .L_Say242; .L_SayX227;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1373, 1373, true);
   rfalse;
];
! No specific request
! Instead of going down when the player is on a supporter:
[ R_1465 ;
   if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && (self=actor,true) && (((SupporterOf(player) ofclass K6_supporter)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1465, 1465);
      ! phrase 1
      ! [1: try getting off the holder of the player]
       TryAction(0, player, ##GetOff,  (HolderOf(player)) , 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1465, 1465, true);
   rfalse;
];
! No specific request
! Instead of opening the plate when the plate is locked:
[ R_1575 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I635_metal_plate) && (true)) && (self=actor,true) && ((((Adj_75_t1_v9(I635_metal_plate)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1575, 1575);
      ! phrase 1
      ! [1: say ~You would need to unscrew it.~]
      say__p=1;ParaContent();  print (PrintText) SC_538;  new_line; .L_Say243; .L_SayX228;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1575, 1575, true);
   rfalse;
];
! No specific request
! Instead of taking the old key when the old key is in the deep crack:
[ R_1577 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I640_old_key) && (true)) && (self=actor,true) && (((I639_deep_crack == ContainerOf(I640_old_key))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1577, 1577);
      ! phrase 1
      ! [1: say ~The crack is too narrow for you to reach very far inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_539;  new_line; .L_Say244; .L_SayX229;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1577, 1577, true);
   rfalse;
];
! No specific request
! Instead of searching the floor when the location is Inside The Cinderblock Hut:
[ R_1597 ;
   if ((action ==##Search) &&  (actor==player) && ((noun == I641_dirt_floor) && (true)) && (self=actor,true) && (((real_location == I637_inside_the_cinderblock_)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1597, 1597);
      ! phrase 1
      ! [1: say ~It's packed too hard to dig in, and you have a feeling you might break part of the pump anyway.~]
      say__p=1;ParaContent();  print (PrintText) SC_540;  new_line; .L_Say245; .L_SayX230;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1597, 1597, true);
   rfalse;
];
! No specific request
! Instead of turning the medium-sized wheel when Third Pump is happening:
[ R_1642 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && (self=actor,true) && ((((scene_status-->(I430_third_pump-1)==1))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1642, 1642);
      ! phrase 1
      ! [1: say ~Nothing further happens.~]
      say__p=1;ParaContent();  print (PrintText) SC_541;  new_line; .L_Say246; .L_SayX231;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1642, 1642, true);
   rfalse;
];
! No specific request
! Instead of facing down when the player is in Underwater:
[ R_1677 ;
   if ((action ==##A94_facing) &&  (actor==player) && ((noun == I55_down) && (true)) && (self=actor,true) && (((I669_underwater == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1677, 1677);
      ! phrase 1
      ! [1: try examining the crystal city]
       TryAction(0, player, ##Examine, I677_the_crystal_city, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1677, 1677, true);
   rfalse;
];
! No specific request
! Instead of shaking the wind chimes when the player is in Underwaterland:
[ R_1683 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true)) && (self=actor,true) && (((TestRegionalContainment(player,I676_underwaterland))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1683, 1683);
      ! phrase 1
      ! [1: say ~The chimes ring deep, distorted, and melodic under the water.~]
      say__p=1;ParaContent();  print (PrintText) SC_526;  new_line; .L_Say247; .L_SayX232;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1683, 1683, true);
   rfalse;
];
! No specific request
! Instead of shaking the wind chimes when the player is in the Crystal City:
[ R_1685 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true)) && (self=actor,true) && (((I677_the_crystal_city == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1685, 1685);
      ! phrase 1
      ! [1: say ~They play the same distorted melody.~]
      say__p=1;ParaContent();  print (PrintText) SC_542;  new_line; .L_Say248; .L_SayX233;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1685, 1685, true);
   rfalse;
];
! No specific request
! Instead of taking off the diving mask when the player is in Underwaterland:
[ R_1694 ;
   if ((action ==##Disrobe) &&  (actor==player) && ((noun == I666_diving_mask) && (true)) && (self=actor,true) && (((TestRegionalContainment(player,I676_underwaterland))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1694, 1694);
      ! phrase 1
      ! [1: say ~You pull the mask away from your face -- and immediately get a lungful of water. Choking and spluttering, you quickly replace the mask, and gratefully breathe in air from the tank.~]
      say__p=1;ParaContent();  print (PrintText) SC_543;  new_line; .L_Say249; .L_SayX234;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1694, 1694, true);
   rfalse;
];
! No specific request
! Instead of facing outside when the location is the steam train:
[ R_1733 ;
   if ((action ==##A94_facing) &&  (actor==player) && ((noun == out_obj) && (true)) && (self=actor,true) && (((real_location == I439_steam_train)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1733, 1733);
      ! phrase 1
      ! [1: try examining the train window]
       TryAction(0, player, ##Examine, I708_train_window, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1733, 1733, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining with the access panel when the conductor is undistracted and the conductor is visible and the conductor's story is not happening:
[ R_1751 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I709_access_panel) && (true)) && (self=actor,true) && (((((Adj_145_t1_v9(I711_conductor))))) && (((((Adj_3_t1_v9(I711_conductor))))) && (((~~(((scene_status-->(I431_conductor_s_story-1)==1))))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1751, 1751);
      ! phrase 1
      ! [1: say ~The conductor catches what you're doing and stops you. 'Hey! That's train property, that is!'~]
      say__p=1;ParaContent();  print (PrintText) SC_544;  new_line; .L_Say250; .L_SayX235;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1751, 1751, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the metal door when Inside the Cinderblock Hut is not keyed:
[ R_1572 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I631_smooth_metal_door) && (true)) && (self=actor,true) && (((~~(((Adj_134_t1_v9(I637_inside_the_cinderblock_)))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1572, 1572);
      ! phrase 1
      ! [1: say ~The door seems to have retracted into the hut's wall.~]
      say__p=1;ParaContent();  print (PrintText) SC_545;  new_line; .L_Say251; .L_SayX236;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1572, 1572, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the metal door when Inside the Cinderblock Hut is keyed:
[ R_1571 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I631_smooth_metal_door) && (true)) && (self=actor,true) && ((((Adj_134_t1_v9(I637_inside_the_cinderblock_)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1571, 1571);
      ! phrase 1
      ! [1: say ~Nothing you do to the metal door seems to have any interesting effect.~]
      say__p=1;ParaContent();  print (PrintText) SC_546;  new_line; .L_Say252; .L_SayX237;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1571, 1571, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the pond when the location is Atop the Tank:
[ R_1635 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I463_pond) && (true)) && (self=actor,true) && (((real_location == I469_atop_the_tank)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1635, 1635);
      ! phrase 1
      ! [1: say ~You can't reach it from here.~]
      say__p=1;ParaContent();  print (PrintText) SC_547;  new_line; .L_Say253; .L_SayX238;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1635, 1635, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the weird lumpy island when the location is Atop the Tank:
[ R_1636 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I658_weird_lumpy_island) && (true)) && (self=actor,true) && (((real_location == I469_atop_the_tank)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1636, 1636);
      ! phrase 1
      ! [1: say ~You can't reach it from here.~]
      say__p=1;ParaContent();  print (PrintText) SC_547;  new_line; .L_Say254; .L_SayX239;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1636, 1636, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the distant house when the location is Atop the Tank:
[ R_1637 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I659_distant_house) && (true)) && (self=actor,true) && (((real_location == I469_atop_the_tank)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1637, 1637);
      ! phrase 1
      ! [1: say ~You can't reach it from here.~]
      say__p=1;ParaContent();  print (PrintText) SC_547;  new_line; .L_Say255; .L_SayX240;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1637, 1637, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining with the conductor when the conductor is distracted:
[ R_1742 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I711_conductor) && (true)) && (self=actor,true) && ((((Adj_144_t1_v9(I711_conductor)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1742, 1742);
      ! phrase 1
      ! [1: say ~He doesn't seem to be paying attention to you.~]
      say__p=1;ParaContent();  print (PrintText) SC_548;  new_line; .L_Say256; .L_SayX241;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1742, 1742, true);
   rfalse;
];
! No specific request
! Instead of doing anything with the panel when the drawer is upside-down:
[ R_1461 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I591_secret_panel) && (true)) && (self=actor,true) && ((((Adj_128_t1_v9(I589_wooden_drawer)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1461, 1461);
      ! phrase 1
      ! [1: say ~You can't get to that while the drawer is upside down.~]
      say__p=1;ParaContent();  print (PrintText) SC_549;  new_line; .L_Say257; .L_SayX242;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1461, 1461, true);
   rfalse;
];
! No specific request
! Instead of doing anything with the drawer bottom when the drawer is right-side-up:
[ R_1469 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I590_drawer_bottom) && (true)) && (self=actor,true) && ((((Adj_129_t1_v9(I589_wooden_drawer)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1469, 1469);
      ! phrase 1
      ! [1: say ~You can't get to that while the drawer is right side up.~]
      say__p=1;ParaContent();  print (PrintText) SC_550;  new_line; .L_Say258; .L_SayX243;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1469, 1469, true);
   rfalse;
];
! No specific request
! Instead of doing anything to the cavity while the cavity is inaccessible:
[ R_1706 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I701_cavity) && (true)) && (self=actor,true) && ((((Adj_141_t1_v9(I701_cavity)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1706, 1706);
      ! phrase 1
      ! [1: say ~The part of the wheel the cavity is on is now inside the pump's crystal shell.~]
      say__p=1;ParaContent();  print (PrintText) SC_551;  new_line; .L_Say259; .L_SayX244;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1706, 1706, true);
   rfalse;
];
! No specific request
! Instead of taking something that is in the tall cylinder when the player is on something:
[ R_1320 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (I522_tall_cylinder == ContainerOf(noun))) && (self=actor,true) && (((SupporterOf(player) ofclass K6_supporter)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1320, 1320);
      ! phrase 1
      ! [1: say ~The cylinder is much too high to reach the opening at the top, even while standing on something.~]
      say__p=1;ParaContent();  print (PrintText) SC_552;  new_line; .L_Say260; .L_SayX245;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1320, 1320, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining with something contained by the access panel when the conductor is visible and the conductor's story is not happening and the conductor is undistracted:
[ R_1754 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun ofclass K2_thing) && (I709_access_panel == ContainerOf(noun))) && (self=actor,true) && (((((Adj_3_t1_v9(I711_conductor))))) && ((((~~(((scene_status-->(I431_conductor_s_story-1)==1)))))) && ((((Adj_145_t1_v9(I711_conductor)))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1754, 1754);
      ! phrase 1
      ! [1: say ~The conductor interrupts you. 'Leave that there, then! It belongs to the train!'~]
      say__p=1;ParaContent();  print (PrintText) SC_553;  new_line; .L_Say261; .L_SayX246;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1754, 1754, true);
   rfalse;
];
! No specific request
! Instead of doing anything to something contained by the cavity when the cavity is inaccessible:
[ R_1700 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun ofclass K2_thing) && (I701_cavity == ContainerOf(noun))) && (self=actor,true) && ((((Adj_141_t1_v9(I701_cavity)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1700, 1700);
      ! phrase 1
      ! [1: say ~It's inside the pump now.~]
      say__p=1;ParaContent();  print (PrintText) SC_554;  new_line; .L_Say262; .L_SayX247;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1700, 1700, true);
   rfalse;
];
! No specific request
! Instead of doing anything with something contained by the steam train when the location of the player is freshwater crossing or the location of the player is other side of the pond:
[ R_1725 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun ofclass K2_thing) && (I439_steam_train == ContainerOf(noun))) && (self=actor,true) && (((( LocationOf(player)  == I507_freshwater_crossing))) || ((( LocationOf(player)  == I494_other_side_of_the_pond))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1725, 1725);
      ! phrase 1
      ! [1: if the noun is not the conductor , say ~Something you mentioned is either not here or not important.~]
       if (((~~((noun == I711_conductor))))) { say__p=1;ParaContent();  print (PrintText) SC_555;  new_line; .L_Say263; .L_SayX248;  }
      ! phrase 2
      ! [2: if the noun is the conductor , continue the action]
       if (((noun == I711_conductor))) {  rfalse;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1725, 1725, true);
   rfalse;
];
! No specific request
! Instead of taking a small rock when the rock selection is visible and Rocky Beach does not contain a small rock:
[ R_1486 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K24_small_rock)) && (self=actor,true) && (((((Adj_3_t1_v9(I601_rock_selection))))) && ((Prop_34())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1486, 1486);
      ! phrase 1
      ! [1: try taking the rock selection]
       TryAction(0, player, ##Take, I601_rock_selection, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1486, 1486, true);
   rfalse;
];
! No specific request
! Instead of dropping a pinecone when the dog is in the location of the player:
[ R_1196 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K30_pinecone)) && (self=actor,true) && ((( LocationOf(player)  == ContainerOf(I443_dog))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1196, 1196);
      ! phrase 1
      ! [1: say ~You toss the pinecone to the dog; the dog catches it in its mouth and returns it to you.~]
      say__p=1;ParaContent();  print (PrintText) SC_556;  new_line; .L_Say264; .L_SayX249;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1196, 1196, true);
   rfalse;
];
! No specific request
! Instead of examining something when the noun is contained by the vending machine and the vending machine is closed:
[ R_1440 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && ((((I580_vending_machine == ContainerOf(noun)))) && ((((Adj_71_t1_v9(I580_vending_machine))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1440, 1440);
      ! phrase 1
      ! [1: say ~You can't make out any details through the plexiglass.~]
      say__p=1;ParaContent();  print (PrintText) SC_557;  new_line; .L_Say265; .L_SayX250;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1440, 1440, true);
   rfalse;
];
! No specific request
! Instead of dropping something when the location is In The Sweetgum Tree:
[ R_1408 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((real_location == I442_in_the_sweetgum_tree)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1408, 1408);
      ! phrase 1
      ! [1: say ~[The noun] falls to the ground beneath the tree.~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_558;  new_line; .L_Say266; .L_SayX251;
      ! phrase 2
      ! [2: move the noun to the hill]
       MoveObject(noun, I441_hill, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1408, 1408, true);
   rfalse;
];
! No specific request
! Instead of dropping anything when the player is in Underwater:
[ R_1684 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K2_thing)) && (self=actor,true) && (((I669_underwater == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1684, 1684);
      ! phrase 1
      ! [1: say ~You would lose it forever.~]
      say__p=1;ParaContent();  print (PrintText) SC_559;  new_line; .L_Say267; .L_SayX252;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1684, 1684, true);
   rfalse;
];
! No specific request
! Instead of the dog going when the dog is in the rowboat:
[ R_1547 ;
   if ((action ==##Go) &&  (actor~=player) && (act_requester==nothing) && ((actor == I443_dog) && (true)) && (self=actor,true) && (((I481_rowboat == ContainerOf(I443_dog))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1547, 1547);
      ! phrase 1
      ! [1: if the rowboat is in other side of the pond or the rowboat is in boat house , try the dog exiting]
       if ((((I494_other_side_of_the_pond == ContainerOf(I481_rowboat)))) || (((I479_boat_house == ContainerOf(I481_rowboat))))) {  TryAction(0, I443_dog, ##Exit, 0, 0);;   }
      ! phrase 2
      ! [2: otherwise do nothing]
       else {  ;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1547, 1547, true);
   rfalse;
];
! No specific request
! Instead of going nowhere when the noun is outside:
[ R_1061 ;
   if ((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing) && (self=actor,true) && (((noun == out_obj)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1061, 1061);
      ! phrase 1
      ! [1: try exiting]
       TryAction(0, player, ##Exit, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1061, 1061, true);
   rfalse;
];
! No specific request
! Instead of exiting in Pondside Community Center:
[ R_1288 ;
   if ((action ==##Exit) &&  (actor==player) && ((real_location == I484_pondside_community_cent) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1288, 1288);
      ! phrase 1
      ! [1: try going south]
       TryAction(0, player, ##Go, I49_south, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1288, 1288, true);
   rfalse;
];
! No specific request
! Instead of jumping in In The Sweetgum Tree:
[ R_1399 ;
   if ((action ==##Jump) &&  (actor==player) && ((real_location == I442_in_the_sweetgum_tree) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1399, 1399);
      ! phrase 1
      ! [1: try going down]
       TryAction(0, player, ##Go, I55_down, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1399, 1399, true);
   rfalse;
];
! No specific request
! Instead of jumping in the Hill:
[ R_1414 ;
   if ((action ==##Jump) &&  (actor==player) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1414, 1414);
      ! phrase 1
      ! [1: if the player is on the bench or the player is on the wooden drawer begin]
       if ((((I552_bench == SupporterOf(player)))) || (((I589_wooden_drawer == SupporterOf(player)))))  {
         ! phrase 2
         ! [2: say ~You leap up from [if the player is on the wooden drawer]the drawer[otherwise]the bench[end if] and grab the bottom branch of the tree, hauling yourself up.~]
         say__p=1;ParaContent();  print (PrintText) SC_560; 
	if (~~((((I589_wooden_drawer == SupporterOf(player)))))) jump L_Say268;
		ParaContent();  print (PrintText) SC_256; 
	jump L_SayX253; .L_Say268;
		ParaContent();  print (PrintText) SC_561; 
	.L_Say269; .L_SayX253;
		ParaContent();  print (PrintText) SC_562;  new_line; .L_Say270; .L_SayX254;
         ! phrase 3
         ! [3: move the player to in the sweetgum tree]
          MoveObject(player, I442_in_the_sweetgum_tree, 0, false); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You leap up from the ground and try to grab the bottom branch of the tree, but your fingers just brush it and you can't get a grip.~]
         say__p=1;ParaContent();  print (PrintText) SC_563;  new_line; .L_Say271; .L_SayX255;
         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1414, 1414, true);
   rfalse;
];
! No specific request
! Instead of jumping or dancing in Atop the Tank:
[ R_1634 ;
   if ((action ==##A115_dancing or ##Jump) &&  (actor==player) && ((real_location == I469_atop_the_tank) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1634, 1634);
      ! phrase 1
      ! [1: say ~There's not enough room up here to do that safely -- just a glance downward makes you dizzy.~]
      say__p=1;ParaContent();  print (PrintText) SC_564;  new_line; .L_Say272; .L_SayX256;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1634, 1634, true);
   rfalse;
];
! No specific request
! Instead of swimming in the presence of a liquid source ( called source ):
[ R_1126 
    t_0 ! Local variable e.g. 'source' = liquid source
    ;
   if ((action ==##A102_swimming) &&  (actor==player) && (los_rv=false, LoopOverScope(LOS_1, actor), t_0=los_rv)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1126, 1126);
      ! phrase 1
      ! [1: if the player is wearing the diving mask begin]
       if (((player == WearerOf(I666_diving_mask))))  {
         ! phrase 2
         ! [2: say ~You dive in...[paragraph break]~]
         say__p=1;ParaContent();  print (PrintText) SC_565; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say273; .L_SayX257;
         ! phrase 3
         ! [3: move the player to underwater]
          MoveObject(player, I669_underwater, 0, false); 
         ! phrase 4
         ! [4: record ~getting underwater~ as achieved]
         (PHR_1164_r6 (SC_200));
         ! phrase 5
         ! [5: now the wetness level is ~wet, wet, wet all over~]
          (Global_Vars-->22) = SC_566; 
         ! phrase 6
         ! [6: change the description of the player to ~You are very wet.~]
          WriteGProperty(9, player,description,SC_567); 
         ! phrase 7
         ! [7: if vivian is in underwater , say ~[one of]'You're back!' Vivian grins happily[or]Vivian smiles when she sees you[stopping].~]
          if (((I669_underwater == ContainerOf(I671_vivian)))) { say__p=1;ParaContent();  I7_ST_say_one_of-->18 =
	i7_soo_stop(I7_ST_say_one_of-->18, 2);
	switch((I7_ST_say_one_of-->18)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_568; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_569; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say274; .L_SayX258;  }
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: say ~You peer into [the source] and think about it, but something about the murky depths suggests you're better off on land.~]
         say__p=1;ParaContent();  print (PrintText) SC_570; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_571;  new_line; .L_Say275; .L_SayX259;
         ! phrase 10
         ! [10: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1126, 1126, true);
   rfalse;
];
! No specific request
! Instead of giving the wooden drawer to the secretary:
[ R_1033 ;
   if ((action ==##Give) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true)) && ((second == I545_secretary_of_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1033, 1033);
      ! phrase 1
      ! [1: if the panel has not been open begin]
       if (~~(TestSinglePastState(0, 47, false, 5)))  {
         ! phrase 2
         ! [2: move the wooden drawer to the secretary]
          MoveObject(I589_wooden_drawer, I545_secretary_of_water, 0, false); 
         ! phrase 3
         ! [3: say ~She takes the drawer. [one of]'Huh', she says. 'Looks like a secret panel, but I can't get it open with my fingers.'[or]She pushes the outline again, but still no luck.[stopping] [line break]She hands the drawer back to you.~]
         say__p=1;ParaContent();  print (PrintText) SC_572; ParaContent();  I7_ST_say_one_of-->19 =
	i7_soo_stop(I7_ST_say_one_of-->19, 2);
	switch((I7_ST_say_one_of-->19)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_573;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_574;  new_line;ParaContent();  } ParaContent();  print (PrintText) SC_387; ParaContent();  new_line; ParaContent();  print (PrintText) SC_575;  new_line; .L_Say276; .L_SayX260;
         ! phrase 4
         ! [4: move the wooden drawer to the player]
          MoveObject(I589_wooden_drawer, player, 0, false); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[one of]'A secret panel! Neat.'[or][The secretary] admires the secret panel.[stopping]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->20 =
	i7_soo_stop(I7_ST_say_one_of-->20, 2);
	switch((I7_ST_say_one_of-->20)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_576;  new_line;ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_577;  new_line;ParaContent();  }  .L_Say277; .L_SayX261;
         ! phrase 7
         ! [7: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1033, 1033, true);
   rfalse;
];
! No specific request
! Instead of giving the torn page to the secretary:
[ R_1044 ;
   if ((action ==##Give) &&  (actor==player) && ((noun == I448_page_torn_out_of_a_chil) && (true)) && ((second == I545_secretary_of_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1044, 1044);
      ! phrase 1
      ! [1: say ~You hand the page to [the secretary]. [one of]'It's the city!' she says excitedly, and then smothers her excitement, looking down as she hands the page back to you.[or]She grins at the picture -- briefly looking as though she's going to put it in her notebook -- then hands it back.[stopping]~]
      say__p=1;ParaContent();  print (PrintText) SC_578; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_579; ParaContent();  I7_ST_say_one_of-->21 =
	i7_soo_stop(I7_ST_say_one_of-->21, 2);
	switch((I7_ST_say_one_of-->21)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_580;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_581;  new_line;ParaContent();  }  .L_Say278; .L_SayX262;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1044, 1044, true);
   rfalse;
];
! No specific request
! Instead of giving the torn page to the conductor:
[ R_1045 ;
   if ((action ==##Give) &&  (actor==player) && ((noun == I448_page_torn_out_of_a_chil) && (true)) && ((second == I711_conductor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1045, 1045);
      ! phrase 1
      ! [1: say ~He glances briefly at it. 'That's a pretty picture!'~]
      say__p=1;ParaContent();  print (PrintText) SC_582;  new_line; .L_Say279; .L_SayX263;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1045, 1045, true);
   rfalse;
];
! No specific request
! Instead of putting the sap on the complicated pump:
[ R_1340 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second == I416_complicated_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1340, 1340);
      ! phrase 1
      ! [1: try putting the sap on the leaky hose]
       TryAction(0, player, ##PutOn, I575_pine_sap, I526_leaky_hose);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1340, 1340, true);
   rfalse;
];
! No specific request
! Instead of inserting the pine sap into the beer bottle:
[ R_1424 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second == I472_beer_bottle) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1424, 1424);
      ! phrase 1
      ! [1: if the bottle is not empty begin]
       if (((~~(((Adj_16_t1_v9(I472_beer_bottle)))))))  {
         ! phrase 2
         ! [2: say ~You can't do that while [the bottle] still has [liquid of the bottle] in it.~]
         say__p=1;ParaContent();  print (PrintText) SC_583; ParaContent();  print (the) I472_beer_bottle; ParaContent();  print (PrintText) SC_584; ParaContent(); @push self;  print (T70) GProperty(9, self=I472_beer_bottle,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_585;  new_line; .L_Say280; .L_SayX264;
         ! phrase 3
         ! [3: otherwise if the clump of sap is handled]
          } else if ((((Adj_60_t1_v9(I576_clump_of_sap))))) { 
         ! phrase 4
         ! [4: say ~You already took some sap.~]
         say__p=1;ParaContent();  print (PrintText) SC_586;  new_line; .L_Say281; .L_SayX265;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: move the clump of sap to the beer bottle]
          MoveObject(I576_clump_of_sap, I472_beer_bottle, 0, false); 
         ! phrase 7
         ! [7: say ~You scrape a clump of sticky sap into the bottle.~]
         say__p=1;ParaContent();  print (PrintText) SC_587;  new_line; .L_Say282; .L_SayX266;
         ! phrase 8
         ! [8: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1424, 1424, true);
   rfalse;
];
! No specific request
! Instead of unlocking the secret panel with the screwdriver:
[ R_1479 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I591_secret_panel) && (true)) && ((second == I636_screwdriver) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1479, 1479);
      ! phrase 1
      ! [1: try prying the secret panel with the screwdriver]
       TryAction(0, player, ##A126_prying_it_with, I591_secret_panel, I636_screwdriver);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1479, 1479, true);
   rfalse;
];
! No specific request
! Instead of taking the sap with the beer bottle:
[ R_1589 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second == I472_beer_bottle) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1589, 1589);
      ! phrase 1
      ! [1: try inserting the sap into the beer bottle]
       TryAction(0, player, ##Insert, I575_pine_sap, I472_beer_bottle);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1589, 1589, true);
   rfalse;
];
! No specific request
! Instead of inserting the magnet into the deep crack:
[ R_1596 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I604_large_magnet) && (true)) && ((second == I639_deep_crack) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1596, 1596);
      ! phrase 1
      ! [1: try taking the old key with the large magnet]
       TryAction(0, player, ##A130_taking_it_with, I640_old_key, I604_large_magnet);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1596, 1596, true);
   rfalse;
];
! No specific request
! Instead of putting the medium-sized wheel on the pipe holes:
[ R_1659 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && ((second == I662_pipe_holes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1659, 1659);
      ! phrase 1
      ! [1: try putting the medium-sized wheel on the brass metal pipe]
       TryAction(0, player, ##PutOn, I660_medium_sized_wheel, I657_brass_metal_pipe);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1659, 1659, true);
   rfalse;
];
! No specific request
! Instead of giving the train schedule to the conductor:
[ R_1748 ;
   if ((action ==##Give) &&  (actor==player) && ((noun == I583_train_schedule) && (true)) && ((second == I711_conductor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1748, 1748);
      ! phrase 1
      ! [1: say ~'Oh, I have it memorized!'~]
      say__p=1;ParaContent();  print (PrintText) SC_588;  new_line; .L_Say283; .L_SayX267;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1748, 1748, true);
   rfalse;
];
! No specific request
! Instead of giving the ticket to the conductor:
[ R_1749 ;
   if ((action ==##Give) &&  (actor==player) && ((noun == I584_ticket) && (true)) && ((second == I711_conductor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1749, 1749);
      ! phrase 1
      ! [1: if the player is in the steam train begin]
       if (((I439_steam_train == ContainerOf(player))))  {
         ! phrase 2
         ! [2: say ~'It's good for another week! You hang on to that.'~]
         say__p=1;ParaContent();  print (PrintText) SC_589;  new_line; .L_Say284; .L_SayX268;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~'Looks like you're in order!' says the conductor, and he lets you pass.~]
         say__p=1;ParaContent();  print (PrintText) SC_590;  new_line; .L_Say285; .L_SayX269;
         ! phrase 5
         ! [5: move the player to the steam train]
          MoveObject(player, I439_steam_train, 0, false); 
         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1749, 1749, true);
   rfalse;
];
! No specific request
! Instead of inserting something that is not a flat paper into the secret panel:
[ R_1475 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K31_flat_paper)))) && ((second == I591_secret_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1475, 1475);
      ! phrase 1
      ! [1: say ~It won't fit.~]
      say__p=1;ParaContent();  print (PrintText) SC_591;  new_line; .L_Say286; .L_SayX270;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1475, 1475, true);
   rfalse;
];
! No specific request
! Instead of inserting something that is not the flagpole into the pipe holes:
[ R_1653 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun == I490_flagpole)))) && ((second == I662_pipe_holes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1653, 1653);
      ! phrase 1
      ! [1: if the noun is the screwdriver or the noun is the wind chimes or the noun is the wrench begin]
       if ((((noun == I636_screwdriver))) || ((((noun == I563_metal_wind_chimes))) || (((noun == I710_wrench)))))  {
         ! phrase 2
         ! [2: say ~You poke [the noun] through the holes in the [if the medium-sized wheel is on the brass metal pipe]wheel and [end if]pipe, but [it-they of the noun] [is-are of the noun]n't the right shape to stay put there, and clatter[if the noun is singular-named]s[end if] out onto the top of the tank.~]
         say__p=1;ParaContent();  print (PrintText) SC_592; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_593; 
	if (~~((((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))))) jump L_Say287;
		ParaContent();  print (PrintText) SC_594; 
	.L_Say287; .L_SayX271;
		ParaContent();  print (PrintText) SC_595; ParaContent(); (Resolver_5(noun,"source", 2973));ParaContent();  print (PrintText) SC_387; ParaContent(); (Resolver_6(noun,"source", 2973));ParaContent();  print (PrintText) SC_596; 
	if (~~(((((Adj_42_t1_v9(noun))))))) jump L_Say288;
		ParaContent();  print (PrintText) SC_597; 
	.L_Say288; .L_SayX272;
		ParaContent();  print (PrintText) SC_598;  new_line; .L_Say289; .L_SayX273;
         ! phrase 3
         ! [3: move the noun to the location]
          MoveObject(noun, real_location, 0, false); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You can't seem to fit [the noun] through the holes.~]
         say__p=1;ParaContent();  print (PrintText) SC_599; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_600;  new_line; .L_Say290; .L_SayX274;
         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1653, 1653, true);
   rfalse;
];
! No specific request
! Instead of putting anything that is not the medium-sized wheel on the brass metal pipe:
[ R_1658 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun == I660_medium_sized_wheel)))) && ((second == I657_brass_metal_pipe) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1658, 1658);
      ! phrase 1
      ! [1: say ~That's not the right shape to put on the pipe.~]
      say__p=1;ParaContent();  print (PrintText) SC_601;  new_line; .L_Say291; .L_SayX275;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1658, 1658, true);
   rfalse;
];
! No specific request
! Instead of giving something unimportant to the Secretary:
[ R_1381 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_127_t1_v9(noun)))) && ((second == I545_secretary_of_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1381, 1381);
      ! phrase 1
      ! [1: say ~She smiles, pocketing [the noun]. 'Thanks!'~]
      say__p=1;ParaContent();  print (PrintText) SC_602; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_603;  new_line; .L_Say292; .L_SayX276;
      ! phrase 2
      ! [2: move the noun to the secretary]
       MoveObject(noun, I545_secretary_of_water, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1381, 1381, true);
   rfalse;
];
! No specific request
! Instead of giving something unimportant to the conductor:
[ R_1750 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_127_t1_v9(noun)))) && ((second == I711_conductor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1750, 1750);
      ! phrase 1
      ! [1: say ~'Fantastic! Thanks!' He pockets it.~]
      say__p=1;ParaContent();  print (PrintText) SC_604;  new_line; .L_Say293; .L_SayX277;
      ! phrase 2
      ! [2: move the noun to the conductor]
       MoveObject(noun, I711_conductor, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1750, 1750, true);
   rfalse;
];
! No specific request
! Instead of throwing something at the gull:
[ R_1058 ;
   if ((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I588_gull) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1058, 1058);
      ! phrase 1
      ! [1: say ~You toss [the noun] at the gull, but it hops out of the way, squawking.~]
      say__p=1;ParaContent();  print (PrintText) SC_605; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_606;  new_line; .L_Say294; .L_SayX278;
      ! phrase 2
      ! [2: move the noun to the location]
       MoveObject(noun, real_location, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1058, 1058, true);
   rfalse;
];
! No specific request
! Instead of pouring something into the fountain:
[ R_1122 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1122, 1122);
      ! phrase 1
      ! [1: try spilling the noun]
       TryAction(0, player, ##A103_spilling, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1122, 1122, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the tall cylinder:
[ R_1323 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1323, 1323);
      ! phrase 1
      ! [1: say ~It's much too high to reach the opening at the top.~]
      say__p=1;ParaContent();  print (PrintText) SC_607;  new_line; .L_Say295; .L_SayX279;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1323, 1323, true);
   rfalse;
];
! No specific request
! Instead of pouring something into the tall cylinder:
[ R_1325 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1325, 1325);
      ! phrase 1
      ! [1: say ~It's much too high to reach the opening at the top.~]
      say__p=1;ParaContent();  print (PrintText) SC_607;  new_line; .L_Say296; .L_SayX280;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1325, 1325, true);
   rfalse;
];
! No specific request
! Instead of throwing something at the tall cylinder:
[ R_1327 ;
   if ((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1327, 1327);
      ! phrase 1
      ! [1: say ~You toss [the noun] at the cylinder, but it bounces harmlessly to the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_605; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_608;  new_line; .L_Say297; .L_SayX281;
      ! phrase 2
      ! [2: move the noun to the location]
       MoveObject(noun, real_location, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1327, 1327, true);
   rfalse;
];
! No specific request
! Instead of putting something on the leaky hose:
[ R_1339 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I526_leaky_hose) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1339, 1339);
      ! phrase 1
      ! [1: try plugging the leaky hose with the noun]
       TryAction(0, player, ##A118_plugging_it_with, I526_leaky_hose, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1339, 1339, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the keyhole:
[ R_1348 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I536_keyhole_on_the_security) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1348, 1348);
      ! phrase 1
      ! [1: try unlocking the keyhole with the noun]
       TryAction(0, player, ##Unlock, I536_keyhole_on_the_security, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1348, 1348, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the gadget:
[ R_1349 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I534_security_gadget) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1349, 1349);
      ! phrase 1
      ! [1: try unlocking the keyhole with the noun]
       TryAction(0, player, ##Unlock, I536_keyhole_on_the_security, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1349, 1349, true);
   rfalse;
];
! No specific request
! Instead of giving something to the Secretary:
[ R_1380 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I545_secretary_of_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1380, 1380);
      ! phrase 1
      ! [1: say ~'Oh no, you can keep that,' she says.~]
      say__p=1;ParaContent();  print (PrintText) SC_609;  new_line; .L_Say298; .L_SayX282;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1380, 1380, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the slot:
[ R_1443 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I581_slot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1443, 1443);
      ! phrase 1
      ! [1: if the noun is not the small rock , say ~You try to wedge the [noun] into the slot, but it doesn[']t seem to fit.~ instead]
       if (((~~((noun ofclass K24_small_rock))))) { say__p=1;ParaContent();  print (PrintText) SC_610; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_611; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_612;  new_line; .L_Say299; .L_SayX283;  rtrue; }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1443, 1443, true);
   rfalse;
];
! No specific request
! Instead of giving something to the dog:
[ R_1550 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I443_dog) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1550, 1550);
      ! phrase 1
      ! [1: say ~[one of]The dog sniffs at [the noun], but doesn't seem interested[or]The dog ignores you[or]The dog tries to chew on [the noun], then drops it back in your hand[at random]. [if a random chance of 1 in 2 succeeds][the dog-action][end if]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->22 =
	i7_soo_ran(I7_ST_say_one_of-->22, 3);
	switch((I7_ST_say_one_of-->22)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_613; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_614; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_615; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_616; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_617; ParaContent();  } ParaContent();  print (PrintText) SC_579; 
	if (~~((( (GenerateRandomNumber(1, 2) <= 1) )))) jump L_Say300;
		ParaContent(); (PHR_1554_r4 ());
	.L_Say300; .L_SayX284;
		 .L_Say301; .L_SayX285;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1550, 1550, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the deep crack:
[ R_1579 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I639_deep_crack) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1579, 1579);
      ! phrase 1
      ! [1: say ~The crack is too narrow for you to reach very far inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_539;  new_line; .L_Say302; .L_SayX286;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1579, 1579, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the brass metal pipe:
[ R_1652 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I657_brass_metal_pipe) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1652, 1652);
      ! phrase 1
      ! [1: try inserting the noun into the pipe holes]
       TryAction(0, player, ##Insert, noun, I662_pipe_holes);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1652, 1652, true);
   rfalse;
];
! No specific request
! Instead of inserting something into the giant metal wheel:
[ R_1709 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I698_giant_metal_wheel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1709, 1709);
      ! phrase 1
      ! [1: try inserting the noun into the cavity]
       TryAction(0, player, ##Insert, noun, I701_cavity);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1709, 1709, true);
   rfalse;
];
! No specific request
! Instead of giving something to the conductor:
[ R_1747 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I711_conductor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1747, 1747);
      ! phrase 1
      ! [1: say ~He grins at you and shakes his head. 'Nope, I don't need that. The ticket's enough!'~]
      say__p=1;ParaContent();  print (PrintText) SC_618;  new_line; .L_Say303; .L_SayX287;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1747, 1747, true);
   rfalse;
];
! No specific request
! Instead of inserting the flagpole into something that is not the pipe holes:
[ R_1250 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I490_flagpole) && (true)) && ((second ofclass K2_thing) && (~~((second == I662_pipe_holes))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1250, 1250);
      ! phrase 1
      ! [1: if the second noun is the mural , continue the action]
       if (((second == I489_large_painted_mural))) {  rfalse;   }
      ! phrase 2
      ! [2: if the second noun is the wheel and the wheel is on the brass metal pipe begin]
       if ((((second ofclass K20_wheel))) && ((Prop_35())))  {
         ! phrase 3
         ! [3: try inserting the flagpole into the pipe holes]
          TryAction(0, player, ##Insert, I490_flagpole, I662_pipe_holes);; 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: if the second noun is the brass metal pipe begin]
          if (((second == I657_brass_metal_pipe)))  {
            ! phrase 6
            ! [6: try inserting the flagpole into the pipe holes]
             TryAction(0, player, ##Insert, I490_flagpole, I662_pipe_holes);; 
            ! phrase 7
            ! [7: otherwise]
            } else {

            ! phrase 8
            ! [8: if the second noun is the wheel and the wheel is not on the brass metal pipe begin]
             if ((((second ofclass K20_wheel))) && ((Prop_36())))  {
               ! phrase 9
               ! [9: say ~That wouldn't do you much good when the wheel is freestanding.~]
               say__p=1;ParaContent();  print (PrintText) SC_619;  new_line; .L_Say304; .L_SayX288;
               ! phrase 10
               ! [10: otherwise]
               } else {

               ! phrase 11
               ! [11: say ~[The flagpole] won't fit in [the second noun].~]
               say__p=1;ParaContent();  print (The) I490_flagpole; ParaContent();  print (PrintText) SC_620; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say305; .L_SayX289;
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1250, 1250, true);
   rfalse;
];
! No specific request
! Instead of inserting the medium-sized wheel into something that is not the flagpole:
[ R_1656 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && ((second ofclass K2_thing) && (~~((second == I490_flagpole))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1656, 1656);
      ! phrase 1
      ! [1: say ~The wheel won't fit.~]
      say__p=1;ParaContent();  print (PrintText) SC_621;  new_line; .L_Say306; .L_SayX290;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1656, 1656, true);
   rfalse;
];
! No specific request
! Instead of taking the water fountain with a fluid container:
[ R_1581 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I461_water_fountain) && (true)) && ((second ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1581, 1581);
      ! phrase 1
      ! [1: try filling the second noun with the noun]
       TryAction(0, player, ##A100_filling_it_with, second, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1581, 1581, true);
   rfalse;
];
! No specific request
! Instead of taking the sap with a pinecone:
[ R_1590 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second ofclass K30_pinecone))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1590, 1590);
      ! phrase 1
      ! [1: say ~The pinecone is already sticky and sappy.~]
      say__p=1;ParaContent();  print (PrintText) SC_622;  new_line; .L_Say307; .L_SayX291;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1590, 1590, true);
   rfalse;
];
! No specific request
! Instead of taking the sap with a flat paper:
[ R_1591 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second ofclass K31_flat_paper))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1591, 1591);
      ! phrase 1
      ! [1: say ~You try to stick the sap onto [the second noun], but you just succeed in making a mess.~]
      say__p=1;ParaContent();  print (PrintText) SC_623; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_624;  new_line; .L_Say308; .L_SayX292;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1591, 1591, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Instead of putting something which is not a passkey on a keychain ( this is the limiting keychains rule ):
[ R_841 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((noun ofclass K18_passkey)))) && ((second ofclass K19_keychain))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_841, 841);
      ! phrase 1
      ! [1: say ~[The noun] is not a key.~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_625;  new_line; .L_Say309; .L_SayX293;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_841, 841, true);
   rfalse;
];
! No specific request
! Instead of pouring a fluid container into a liquid source:
[ R_1123 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun ofclass K25_fluid_container)) && ((second ofclass K26_liquid_source))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1123, 1123);
      ! phrase 1
      ! [1: if the noun is empty , say ~[The noun] is already empty.~ instead]
       if ((((Adj_16_t1_v9(noun))))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_626;  new_line; .L_Say310; .L_SayX294;  rtrue; }
      ! phrase 2
      ! [2: now the current volume of the noun is 0.0 fl oz]
       WriteGProperty(OBJECT_TY, noun,p15_current_volume,0); 
      ! phrase 3
      ! [3: say ~You dump out [the noun] into [the second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_627; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_628; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say311; .L_SayX295;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1123, 1123, true);
   rfalse;
];
! No specific request
! Instead of inserting a fluid container into the player's holdall:
[ R_1124 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K25_fluid_container)) && ((second ofclass K15_player_s_holdall))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1124, 1124);
      ! phrase 1
      ! [1: if the noun is open and the noun is not empty , say ~You would spill it.~]
       if (((((Adj_70_t1_v9(noun))))) && (((~~(((Adj_16_t1_v9(noun)))))))) { say__p=1;ParaContent();  print (PrintText) SC_629;  new_line; .L_Say312; .L_SayX296;  }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1124, 1124, true);
   rfalse;
];
! No specific request
! Instead of taking a liquid source with a fluid container:
[ R_1580 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun ofclass K26_liquid_source)) && ((second ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1580, 1580);
      ! phrase 1
      ! [1: try filling the second noun with the noun]
       TryAction(0, player, ##A100_filling_it_with, second, noun);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1580, 1580, true);
   rfalse;
];
! No specific request
! Instead of showing something to someone:
[ R_1042 ;
   if ((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1042, 1042);
      ! phrase 1
      ! [1: try giving the noun to the second noun]
       TryAction(0, player, ##Give, noun, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1042, 1042, true);
   rfalse;
];
! No specific request
! Instead of inserting something into a fluid container:
[ R_1101 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1101, 1101);
      ! phrase 1
      ! [1: if the noun is sand , say ~Putting sand in [the second noun] seems pointless.~]
       if (((noun == I602_sand))) { say__p=1;ParaContent();  print (PrintText) SC_630; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_631;  new_line; .L_Say313; .L_SayX297;  }
      ! phrase 2
      ! [2: otherwise say ~[The second noun] has too narrow a mouth to accept [the noun].~]
       else { say__p=1;ParaContent();  print (The) second; ParaContent();  print (PrintText) SC_632; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say314; .L_SayX298;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1101, 1101, true);
   rfalse;
];
! No specific request
! Instead of pouring the fountain into something:
[ R_1121 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun == I461_water_fountain) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1121, 1121);
      ! phrase 1
      ! [1: if the fountain is switched off begin]
       if ((((Adj_81_t1_v9(I461_water_fountain)))))  {
         ! phrase 2
         ! [2: say ~The fountain is off.~]
         say__p=1;ParaContent();  print (PrintText) SC_633;  new_line; .L_Say315; .L_SayX299;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: try pouring running water into the second noun]
          TryAction(0, player, ##A101_pouring_it_into, I462_running_water, second);; 
         ! phrase 5
         ! [5: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1121, 1121, true);
   rfalse;
];
! No specific request
! Instead of pouring the pond into something:
[ R_1245 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun == I463_pond) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1245, 1245);
      ! phrase 1
      ! [1: if the location is outside waterworks or the location is the hill or the location is in the sweetgum tree or the location is atop the tank , say ~You can see the pond from here, but you can't access it.~]
       if ((((real_location == I447_outside_waterworks))) || ((((real_location == I441_hill))) || ((((real_location == I442_in_the_sweetgum_tree))) || (((real_location == I469_atop_the_tank)))))) { say__p=1;ParaContent();  print (PrintText) SC_500;  new_line; .L_Say316; .L_SayX300;  }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1245, 1245, true);
   rfalse;
];
! No specific request
! Instead of inserting the wide stick into something:
[ R_1248 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I476_wide_stick) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1248, 1248);
      ! phrase 1
      ! [1: say ~[The wide stick] won't fit in [the second noun].~]
      say__p=1;ParaContent();  print (The) I476_wide_stick; ParaContent();  print (PrintText) SC_620; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say317; .L_SayX301;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1248, 1248, true);
   rfalse;
];
! No specific request
! Instead of inserting the wooden drawer into something:
[ R_1249 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1249, 1249);
      ! phrase 1
      ! [1: say ~[The wooden drawer] won't fit in [the second noun].~]
      say__p=1;ParaContent();  print (The) I589_wooden_drawer; ParaContent();  print (PrintText) SC_620; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say318; .L_SayX302;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1249, 1249, true);
   rfalse;
];
! No specific request
! Instead of unlocking the structure with something:
[ R_1262 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I477_structure) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1262, 1262);
      ! phrase 1
      ! [1: try unlocking the door to the structure with the second noun]
       TryAction(0, player, ##Unlock, I480_door_to_the_structure, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1262, 1262, true);
   rfalse;
];
! No specific request
! Instead of unlocking the structure with something:
[ R_1266 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I477_structure) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1266, 1266);
      ! phrase 1
      ! [1: try unlocking the door to the structure with the second noun]
       TryAction(0, player, ##Unlock, I480_door_to_the_structure, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1266, 1266, true);
   rfalse;
];
! No specific request
! Instead of unlocking the gadget with something:
[ R_1350 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I534_security_gadget) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1350, 1350);
      ! phrase 1
      ! [1: try unlocking the keyhole with the second noun]
       TryAction(0, player, ##Unlock, I536_keyhole_on_the_security, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1350, 1350, true);
   rfalse;
];
! No specific request
! Instead of locking the keyhole with something:
[ R_1352 ;
   if ((action ==##Lock) &&  (actor==player) && ((noun == I536_keyhole_on_the_security) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1352, 1352);
      ! phrase 1
      ! [1: say ~You've already bypassed the pump's security measure.~]
      say__p=1;ParaContent();  print (PrintText) SC_634;  new_line; .L_Say319; .L_SayX303;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1352, 1352, true);
   rfalse;
];
! No specific request
! Instead of removing the sap from something:
[ R_1423 ;
   if ((action ==##Remove) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1423, 1423);
      ! phrase 1
      ! [1: say ~You don't want to take it with your hands.~]
      say__p=1;ParaContent();  print (PrintText) SC_635;  new_line; .L_Say320; .L_SayX304;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1423, 1423, true);
   rfalse;
];
! No specific request
! Instead of unlocking the vending machine with something:
[ R_1444 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I580_vending_machine) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1444, 1444);
      ! phrase 1
      ! [1: say ~There doesn't seem to be a way to unlock this with a key. You'll have to find another way in.~]
      say__p=1;ParaContent();  print (PrintText) SC_636;  new_line; .L_Say321; .L_SayX305;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1444, 1444, true);
   rfalse;
];
! No specific request
! Instead of unlocking the secret panel with something:
[ R_1477 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I591_secret_panel) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1477, 1477);
      ! phrase 1
      ! [1: try prying the secret panel with the second noun]
       TryAction(0, player, ##A126_prying_it_with, I591_secret_panel, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1477, 1477, true);
   rfalse;
];
! No specific request
! Instead of taking the sap with something:
[ R_1586 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1586, 1586);
      ! phrase 1
      ! [1: say ~You don't want to get [the second noun] all sticky and ruined.~]
      say__p=1;ParaContent();  print (PrintText) SC_637; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_638;  new_line; .L_Say322; .L_SayX306;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1586, 1586, true);
   rfalse;
];
! No specific request
! Instead of putting the sap on something:
[ R_1592 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1592, 1592);
      ! phrase 1
      ! [1: try taking the sap with the second noun]
       TryAction(0, player, ##A130_taking_it_with, I575_pine_sap, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1592, 1592, true);
   rfalse;
];
! No specific request
! Instead of inserting the sap into something:
[ R_1593 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun == I575_pine_sap) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1593, 1593);
      ! phrase 1
      ! [1: try taking the sap with the second noun]
       TryAction(0, player, ##A130_taking_it_with, I575_pine_sap, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1593, 1593, true);
   rfalse;
];
! No specific request
! Instead of unlocking the structure with something:
[ R_1729 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I477_structure) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1729, 1729);
      ! phrase 1
      ! [1: try unlocking the door to the structure with the second noun]
       TryAction(0, player, ##Unlock, I480_door_to_the_structure, second);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1729, 1729, true);
   rfalse;
];
! No specific request
! Instead of taking something contained by the tall cylinder with something:
[ R_1588 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun ofclass K2_thing) && (I522_tall_cylinder == ContainerOf(noun))) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1588, 1588);
      ! phrase 1
      ! [1: say ~You still can't reach [it-them of the second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_504; ParaContent(); (Resolver_2(second,"source", 2728));ParaContent();  print (PrintText) SC_250;  new_line; .L_Say323; .L_SayX307;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1588, 1588, true);
   rfalse;
];
! No specific request
! Instead of taking something with something:
[ R_1585 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1585, 1585);
      ! phrase 1
      ! [1: say ~That seems like overkill when you have hands.~]
      say__p=1;ParaContent();  print (PrintText) SC_639;  new_line; .L_Say324; .L_SayX308;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1585, 1585, true);
   rfalse;
];
! No specific request
! Instead of kissing yourself:
[ R_1052 ;
   if ((action ==##Kiss) &&  (actor==player) && ((noun == selfobj) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1052, 1052);
      ! phrase 1
      ! [1: say ~You'd have to be a bit more of a contortionist.~]
      say__p=1;ParaContent();  print (PrintText) SC_640;  new_line; .L_Say325; .L_SayX309;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1052, 1052, true);
   rfalse;
];
! No specific request
! Instead of kissing the dog:
[ R_1053 ;
   if ((action ==##Kiss) &&  (actor==player) && ((noun == I443_dog) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1053, 1053);
      ! phrase 1
      ! [1: say ~It licks your face in return.~]
      say__p=1;ParaContent();  print (PrintText) SC_641;  new_line; .L_Say326; .L_SayX310;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1053, 1053, true);
   rfalse;
];
! No specific request
! Instead of attacking the dog:
[ R_1054 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I443_dog) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1054, 1054);
      ! phrase 1
      ! [1: say ~It bites your hand in a lightning-fast reaction, almost drawing blood.~]
      say__p=1;ParaContent();  print (PrintText) SC_642;  new_line; .L_Say327; .L_SayX311;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1054, 1054, true);
   rfalse;
];
! No specific request
! Instead of facing up:
[ R_1065 ;
   if ((action ==##A94_facing) &&  (actor==player) && ((noun == I54_up) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1065, 1065);
      ! phrase 1
      ! [1: try looking up]
       TryAction(0, player, ##A117_looking_up, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1065, 1065, true);
   rfalse;
];
! No specific request
! Instead of pushing the small button:
[ R_1080 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I423_small_button) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1080, 1080);
      ! phrase 1
      ! [1: try switching on the metal detector]
       TryAction(0, player, ##SwitchOn, I421_small_metal_detector, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1080, 1080, true);
   rfalse;
];
! No specific request
! Instead of entering the steam train:
[ R_1144 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I439_steam_train) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1144, 1144);
      ! phrase 1
      ! [1: try boarding]
       TryAction(0, player, ##A104_boarding, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1144, 1144, true);
   rfalse;
];
! No specific request
! Instead of waving the flag:
[ R_1184 ;
   if ((action ==##Wave) &&  (actor==player) && ((noun == I492_flag) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1184, 1184);
      ! phrase 1
      ! [1: try waving the flagpole]
       TryAction(0, player, ##Wave, I490_flagpole, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1184, 1184, true);
   rfalse;
];
! No specific request
! Instead of waving the flagpole:
[ R_1185 ;
   if ((action ==##Wave) &&  (actor==player) && ((noun == I490_flagpole) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1185, 1185);
      ! phrase 1
      ! [1: if the player is in a room that is outdoors , say ~You wave the flag proudly; it billows in the wind.~]
       if (((ContainerOf(player) ofclass K1_room) && ((Adj_99_t1_v9(ContainerOf(player)))))) { say__p=1;ParaContent();  print (PrintText) SC_643;  new_line; .L_Say328; .L_SayX312;  }
      ! phrase 2
      ! [2: if the player is in underwater , say ~The flag drags in the water.~]
       if (((I669_underwater == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_644;  new_line; .L_Say329; .L_SayX313;  }
      ! phrase 3
      ! [3: if the player is in a room that is indoors and the player is not in underwater , say ~You wave the flag proudly.~]
       if ((((ContainerOf(player) ofclass K1_room) && ((Adj_98_t1_v9(ContainerOf(player)))))) && (((~~((I669_underwater == ContainerOf(player))))))) { say__p=1;ParaContent();  print (PrintText) SC_645;  new_line; .L_Say330; .L_SayX314;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1185, 1185, true);
   rfalse;
];
! No specific request
! Instead of listening to the sound of the wind chimes:
[ R_1188 ;
   if ((action ==##Listen) &&  (actor==player) && ((noun == I440_sound_of_the_wind_chime) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1188, 1188);
      ! phrase 1
      ! [1: try examining the sound of the wind chimes]
       TryAction(0, player, ##Examine, I440_sound_of_the_wind_chime, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1188, 1188, true);
   rfalse;
];
! No specific request
! Instead of taking the sound of the wind chimes:
[ R_1190 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I440_sound_of_the_wind_chime) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1190, 1190);
      ! phrase 1
      ! [1: try taking the wind chimes]
       TryAction(0, player, ##Take, I563_metal_wind_chimes, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1190, 1190, true);
   rfalse;
];
! No specific request
! Instead of rubbing the dog:
[ R_1192 ;
   if ((action ==##Rub) &&  (actor==player) && ((noun == I443_dog) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1192, 1192);
      ! phrase 1
      ! [1: say ~Its tail wags happily.~]
      say__p=1;ParaContent();  print (PrintText) SC_646;  new_line; .L_Say331; .L_SayX315;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1192, 1192, true);
   rfalse;
];
! No specific request
! Instead of touching the dog:
[ R_1193 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I443_dog) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1193, 1193);
      ! phrase 1
      ! [1: try rubbing the dog]
       TryAction(0, player, ##Rub, I443_dog, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1193, 1193, true);
   rfalse;
];
! No specific request
! Instead of taking off the boots:
[ R_1213 ;
   if ((action ==##Disrobe) &&  (actor==player) && ((noun == I449_your_tall_rubber_boots) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1213, 1213);
      ! phrase 1
      ! [1: say ~You have a feeling you're better off keeping them on... it seems like things are likely to get pretty muddy around here.~]
      say__p=1;ParaContent();  print (PrintText) SC_647;  new_line; .L_Say332; .L_SayX316;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1213, 1213, true);
   rfalse;
];
! No specific request
! Instead of drinking the fountain:
[ R_1231 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1231, 1231);
      ! phrase 1
      ! [1: if running water is on-stage , try drinking running water]
       if ((((Adj_9_t1_v9(I462_running_water))))) {  TryAction(0, player, ##Drink, I462_running_water, 0);;   }
      ! phrase 2
      ! [2: otherwise say ~The fountain isn't on.~ instead]
       else { say__p=1;ParaContent();  print (PrintText) SC_648;  new_line; .L_Say333; .L_SayX317;  rtrue; }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1231, 1231, true);
   rfalse;
];
! No specific request
! Instead of shaking the fence:
[ R_1237 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I473_chain_link_fence) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1237, 1237);
      ! phrase 1
      ! [1: try attacking the fence]
       TryAction(0, player, ##Attack, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1237, 1237, true);
   rfalse;
];
! No specific request
! Instead of pushing the fence:
[ R_1238 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I473_chain_link_fence) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1238, 1238);
      ! phrase 1
      ! [1: try attacking the fence]
       TryAction(0, player, ##Attack, I473_chain_link_fence, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1238, 1238, true);
   rfalse;
];
! No specific request
! Instead of attacking the fence:
[ R_1239 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I473_chain_link_fence) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1239, 1239);
      ! phrase 1
      ! [1: say ~You shake the rusty fence, but it shows no signs of giving way.~]
      say__p=1;ParaContent();  print (PrintText) SC_649;  new_line; .L_Say334; .L_SayX318;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1239, 1239, true);
   rfalse;
];
! No specific request
! Instead of entering the structure:
[ R_1265 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I477_structure) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1265, 1265);
      ! phrase 1
      ! [1: if the player is in outside waterworks , say ~You'd have to get up to the edge of the pond first.~ instead]
       if (((I447_outside_waterworks == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_650;  new_line; .L_Say335; .L_SayX319;  rtrue; }
      ! phrase 2
      ! [2: if the player is in muddy beach , say ~From here, you'd have to swim to the structure, but you could probably get close enough to wade from up the shore to the northeast.~ instead]
       if (((I468_muddy_beach == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_450;  new_line; .L_Say336; .L_SayX320;  rtrue; }
      ! phrase 3
      ! [3: if the player is in rocky beach , try going west]
       if (((I470_rocky_beach == ContainerOf(player)))) {  TryAction(0, player, ##Go, I53_west, 0);;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1265, 1265, true);
   rfalse;
];
! No specific request
! Instead of taking the rowboat:
[ R_1270 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I481_rowboat) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1270, 1270);
      ! phrase 1
      ! [1: say ~It's too heavy to lift -- it's floating in the water, which is probably where it should stay.~]
      say__p=1;ParaContent();  print (PrintText) SC_651;  new_line; .L_Say337; .L_SayX321;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1270, 1270, true);
   rfalse;
];
! No specific request
! Instead of touching the red foam keychain:
[ R_1285 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I486_red_foam_keychain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1285, 1285);
      ! phrase 1
      ! [1: say ~Squishy.~]
      say__p=1;ParaContent();  print (PrintText) SC_652;  new_line; .L_Say338; .L_SayX322;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1285, 1285, true);
   rfalse;
];
! No specific request
! Instead of entering the community center building:
[ R_1286 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I487_community_center_buildi) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1286, 1286);
      ! phrase 1
      ! [1: try going north]
       TryAction(0, player, ##Go, I46_north, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1286, 1286, true);
   rfalse;
];
! No specific request
! Instead of taking the mural:
[ R_1300 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I489_large_painted_mural) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1300, 1300);
      ! phrase 1
      ! [1: try taking the peeling paint]
       TryAction(0, player, ##Take, I491_peeling_paint, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1300, 1300, true);
   rfalse;
];
! No specific request
! Instead of taking the peeling paint:
[ R_1302 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I491_peeling_paint) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1302, 1302);
      ! phrase 1
      ! [1: if the mural is unpeeled begin]
       if ((((Adj_113_t1_v9(I489_large_painted_mural)))))  {
         ! phrase 2
         ! [2: say ~You strip back part of the paint, and see that there's another picture underneath this mural -- a picture of shining turrets and translucent eggs. The Crystal City, of course.~]
         say__p=1;ParaContent();  print (PrintText) SC_653;  new_line; .L_Say339; .L_SayX323;
         ! phrase 3
         ! [3: now the mural is peeled]
          (Adj_112_t2_v9(I489_large_painted_mural)); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You've already peeled back as much of the paint as you can.~]
         say__p=1;ParaContent();  print (PrintText) SC_654;  new_line; .L_Say340; .L_SayX324;
         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1302, 1302, true);
   rfalse;
];
! No specific request
! Instead of touching the real crystal spire:
[ R_1306 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I495_real_crystal_spire) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1306, 1306);
      ! phrase 1
      ! [1: say ~Sharp, cold, damp.~]
      say__p=1;ParaContent();  print (PrintText) SC_655;  new_line; .L_Say341; .L_SayX325;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1306, 1306, true);
   rfalse;
];
! No specific request
! Instead of touching the oval indentations:
[ R_1307 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I496_oval_indentations) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1307, 1307);
      ! phrase 1
      ! [1: say ~The smooth swirls of the indentations seem almost soft under your fingers.~]
      say__p=1;ParaContent();  print (PrintText) SC_656;  new_line; .L_Say342; .L_SayX326;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1307, 1307, true);
   rfalse;
];
! No specific request
! Instead of opening the desk:
[ R_1316 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I518_desk) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1316, 1316);
      ! phrase 1
      ! [1: try opening the drawer]
       TryAction(0, player, ##Open, I521_metal_drawer, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1316, 1316, true);
   rfalse;
];
! No specific request
! Instead of closing the desk:
[ R_1318 ;
   if ((action ==##Close) &&  (actor==player) && ((noun == I518_desk) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1318, 1318);
      ! phrase 1
      ! [1: try closing the drawer]
       TryAction(0, player, ##Close, I521_metal_drawer, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1318, 1318, true);
   rfalse;
];
! No specific request
! Instead of attacking the tall cylinder:
[ R_1321 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1321, 1321);
      ! phrase 1
      ! [1: say ~You pound on the cylinder, but seems to be impervious to your efforts.[if the secretary is visible][line break][one of]'The key's not coming out of there,' [the secretary] says[or][The secretary] shakes her head at you[stopping].[end if]~]
      say__p=1;ParaContent();  print (PrintText) SC_657;  new_line;
	if (~~(((((Adj_3_t1_v9(I545_secretary_of_water))))))) jump L_Say343;
		ParaContent();  new_line; ParaContent();  I7_ST_say_one_of-->23 =
	i7_soo_stop(I7_ST_say_one_of-->23, 2);
	switch((I7_ST_say_one_of-->23)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_658; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_659; ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_660; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line;
	.L_Say343; .L_SayX327;
		 .L_Say344; .L_SayX328;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1321, 1321, true);
   rfalse;
];
! No specific request
! Instead of climbing the tall cylinder:
[ R_1324 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1324, 1324);
      ! phrase 1
      ! [1: say ~It's too smooth.~]
      say__p=1;ParaContent();  print (PrintText) SC_661;  new_line; .L_Say345; .L_SayX329;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1324, 1324, true);
   rfalse;
];
! No specific request
! Instead of touching the tall cylinder:
[ R_1326 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1326, 1326);
      ! phrase 1
      ! [1: say ~It's completely smooth.~]
      say__p=1;ParaContent();  print (PrintText) SC_662;  new_line; .L_Say346; .L_SayX330;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1326, 1326, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the gadget:
[ R_1351 ;
   if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I534_security_gadget) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1351, 1351);
      ! phrase 1
      ! [1: try unlocking keylessly the keyhole]
       TryAction(0, player, ##A86_unlocking_keylessly, I536_keyhole_on_the_security, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1351, 1351, true);
   rfalse;
];
! No specific request
! Instead of examining the notes:
[ R_1372 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I544_notes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1372, 1372);
      ! phrase 1
      ! [1: say ~Alternatingly mushy and angsty.~]
      say__p=1;ParaContent();  print (PrintText) SC_663;  new_line; .L_Say347; .L_SayX331;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1372, 1372, true);
   rfalse;
];
! No specific request
! Instead of attacking the secretary:
[ R_1379 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I545_secretary_of_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1379, 1379);
      ! phrase 1
      ! [1: say ~She grabs your wrist and throws you away from her with surprising force, considering her small size.~]
      say__p=1;ParaContent();  print (PrintText) SC_664;  new_line; .L_Say348; .L_SayX332;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1379, 1379, true);
   rfalse;
];
! No specific request
! Instead of smelling the pine trees:
[ R_1389 ;
   if ((action ==##Smell) &&  (actor==player) && ((noun == I574_tall_pine_trees) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1389, 1389);
      ! phrase 1
      ! [1: say ~A deep musk of forest.~]
      say__p=1;ParaContent();  print (PrintText) SC_665;  new_line; .L_Say349; .L_SayX333;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1389, 1389, true);
   rfalse;
];
! No specific request
! Instead of smelling the grove:
[ R_1390 ;
   if ((action ==##Smell) &&  (actor==player) && ((noun == I548_grove_of_pine_trees) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1390, 1390);
      ! phrase 1
      ! [1: say ~A deep musk of forest.~]
      say__p=1;ParaContent();  print (PrintText) SC_665;  new_line; .L_Say350; .L_SayX334;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1390, 1390, true);
   rfalse;
];
! No specific request
! Instead of taking the leaves:
[ R_1391 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I607_yellow_leaves) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1391, 1391);
      ! phrase 1
      ! [1: say ~You pick up a few, but then let them drift through your fingers again; you don't need to carry them around.~]
      say__p=1;ParaContent();  print (PrintText) SC_666;  new_line; .L_Say351; .L_SayX335;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1391, 1391, true);
   rfalse;
];
! No specific request
! Instead of entering the visitor center building:
[ R_1392 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I554_visitor_center_building) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1392, 1392);
      ! phrase 1
      ! [1: try going east]
       TryAction(0, player, ##Go, I52_east, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1392, 1392, true);
   rfalse;
];
! No specific request
! Instead of playing the wind chimes:
[ R_1401 ;
   if ((action ==##A125_playing) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1401, 1401);
      ! phrase 1
      ! [1: try shaking the wind chimes]
       TryAction(0, player, ##A124_shaking, I563_metal_wind_chimes, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1401, 1401, true);
   rfalse;
];
! No specific request
! Instead of listening to the wind chimes:
[ R_1402 ;
   if ((action ==##Listen) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1402, 1402);
      ! phrase 1
      ! [1: if the wind chimes are in in the sweetgum tree begin]
       if (((I442_in_the_sweetgum_tree == ContainerOf(I563_metal_wind_chimes))))  {
         ! phrase 2
         ! [2: say ~They 'ting!' softly in the wind.~]
         say__p=1;ParaContent();  print (PrintText) SC_667;  new_line; .L_Say352; .L_SayX336;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~They don't make any noise when you're not shaking them.~]
         say__p=1;ParaContent();  print (PrintText) SC_668;  new_line; .L_Say353; .L_SayX337;
         ! phrase 5
         ! [5: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1402, 1402, true);
   rfalse;
];
! No specific request
! Instead of shaking the wind chimes:
[ R_1404 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1404, 1404);
      ! phrase 1
      ! [1: say ~They ring with a melodious jangle -- a random cluster of tones that somehow manage to combine into a pleasing sound.~]
      say__p=1;ParaContent();  print (PrintText) SC_669;  new_line; .L_Say354; .L_SayX338;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1404, 1404, true);
   rfalse;
];
! No specific request
! Instead of taking twinkling lights:
[ R_1407 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I564_twinkling_lights) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1407, 1407);
      ! phrase 1
      ! [1: say ~You can't see a way to get them off the tree, and besides, they look so picturesque here.~]
      say__p=1;ParaContent();  print (PrintText) SC_670;  new_line; .L_Say355; .L_SayX339;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1407, 1407, true);
   rfalse;
];
! No specific request
! Instead of climbing the bench:
[ R_1410 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I552_bench) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1410, 1410);
      ! phrase 1
      ! [1: try entering the bench]
       TryAction(0, player, ##Enter, I552_bench, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1410, 1410, true);
   rfalse;
];
! No specific request
! Instead of climbing the sweetgum tree:
[ R_1411 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I561_lone_sweetgum_tree) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1411, 1411);
      ! phrase 1
      ! [1: try going up]
       TryAction(0, player, ##Go, I54_up, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1411, 1411, true);
   rfalse;
];
! No specific request
! Instead of taking the pine bark:
[ R_1417 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I572_pine_bark) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1417, 1417);
      ! phrase 1
      ! [1: say ~You would only hurt the trees by doing that.~]
      say__p=1;ParaContent();  print (PrintText) SC_671;  new_line; .L_Say356; .L_SayX340;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1417, 1417, true);
   rfalse;
];
! No specific request
! Instead of taking the needles:
[ R_1418 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I573_pine_needles) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1418, 1418);
      ! phrase 1
      ! [1: say ~You pick up a few, but then let them drift through your fingers again; you don't need to carry them around.~]
      say__p=1;ParaContent();  print (PrintText) SC_666;  new_line; .L_Say357; .L_SayX341;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1418, 1418, true);
   rfalse;
];
! No specific request
! Instead of climbing the tall pine trees:
[ R_1419 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I574_tall_pine_trees) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1419, 1419);
      ! phrase 1
      ! [1: say ~You hoist yourself up and climb a few branches, but you don't find anything interesting.[paragraph break]You drop back down to the ground.~]
      say__p=1;ParaContent();  print (PrintText) SC_672; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_673;  new_line; .L_Say358; .L_SayX342;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1419, 1419, true);
   rfalse;
];
! No specific request
! Instead of taking the sap:
[ R_1422 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I575_pine_sap) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1422, 1422);
      ! phrase 1
      ! [1: say ~You don't want to take it with your hands.~]
      say__p=1;ParaContent();  print (PrintText) SC_635;  new_line; .L_Say359; .L_SayX343;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1422, 1422, true);
   rfalse;
];
! No specific request
! Instead of opening the window:
[ R_1429 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I578_window) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1429, 1429);
      ! phrase 1
      ! [1: say ~You can't -- it's painted shut.~]
      say__p=1;ParaContent();  print (PrintText) SC_674;  new_line; .L_Say360; .L_SayX344;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1429, 1429, true);
   rfalse;
];
! No specific request
! Instead of closing the window:
[ R_1430 ;
   if ((action ==##Close) &&  (actor==player) && ((noun == I578_window) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1430, 1430);
      ! phrase 1
      ! [1: say ~That's already closed.~]
      say__p=1;ParaContent();  print (PrintText) SC_675;  new_line; .L_Say361; .L_SayX345;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1430, 1430, true);
   rfalse;
];
! No specific request
! Instead of examining the vending machine:
[ R_1431 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I580_vending_machine) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1431, 1431);
      ! phrase 1
      ! [1: say ~[the description of the vending machine][paragraph break]~]
      say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=I580_vending_machine,description); @pull self; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say362; .L_SayX346;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1431, 1431, true);
   rfalse;
];
! No specific request
! Instead of attacking the vending machine:
[ R_1432 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I580_vending_machine) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1432, 1432);
      ! phrase 1
      ! [1: say ~You hit the vending machine with a satisfying 'thwack!'. It shakes a little, but remains intact, and seems to be made of stuff too solid for you to damage.~]
      say__p=1;ParaContent();  print (PrintText) SC_676;  new_line; .L_Say363; .L_SayX347;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1432, 1432, true);
   rfalse;
];
! No specific request
! Instead of attacking the slot:
[ R_1433 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I581_slot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1433, 1433);
      ! phrase 1
      ! [1: try attacking the vending machine]
       TryAction(0, player, ##Attack, I580_vending_machine, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1433, 1433, true);
   rfalse;
];
! No specific request
! Instead of pushing the slot:
[ R_1434 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I581_slot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1434, 1434);
      ! phrase 1
      ! [1: try pushing the vending machine]
       TryAction(0, player, ##Push, I580_vending_machine, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1434, 1434, true);
   rfalse;
];
! No specific request
! Instead of shaking the slot:
[ R_1435 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I581_slot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1435, 1435);
      ! phrase 1
      ! [1: try pushing the vending machine]
       TryAction(0, player, ##Push, I580_vending_machine, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1435, 1435, true);
   rfalse;
];
! No specific request
! Instead of shaking the vending machine:
[ R_1437 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun == I580_vending_machine) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1437, 1437);
      ! phrase 1
      ! [1: try pushing the vending machine]
       TryAction(0, player, ##Push, I580_vending_machine, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1437, 1437, true);
   rfalse;
];
! No specific request
! Instead of pushing the vending machine:
[ R_1438 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I580_vending_machine) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1438, 1438);
      ! phrase 1
      ! [1: say ~You push the vending machine; it shakes a little, but seems to be firmly fixed in place.~]
      say__p=1;ParaContent();  print (PrintText) SC_677;  new_line; .L_Say364; .L_SayX348;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1438, 1438, true);
   rfalse;
];
! No specific request
! Instead of rubbing the shelf:
[ R_1441 ;
   if ((action ==##Rub) &&  (actor==player) && ((noun == I582_shelf) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1441, 1441);
      ! phrase 1
      ! [1: say ~You wipe off some dust, but it's clear there's nothing interesting under there.~]
      say__p=1;ParaContent();  print (PrintText) SC_678;  new_line; .L_Say365; .L_SayX349;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1441, 1441, true);
   rfalse;
];
! No specific request
! Instead of rubbing the window:
[ R_1442 ;
   if ((action ==##Rub) &&  (actor==player) && ((noun == I578_window) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1442, 1442);
      ! phrase 1
      ! [1: say ~You wipe off some of the dust, but the only result is a clearer view of the hill outside.~]
      say__p=1;ParaContent();  print (PrintText) SC_679;  new_line; .L_Say366; .L_SayX350;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1442, 1442, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the vending machine:
[ R_1445 ;
   if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I580_vending_machine) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1445, 1445);
      ! phrase 1
      ! [1: say ~There doesn't seem to be a way to unlock this with a key. You'll have to find another way in.~]
      say__p=1;ParaContent();  print (PrintText) SC_636;  new_line; .L_Say367; .L_SayX351;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1445, 1445, true);
   rfalse;
];
! No specific request
! Instead of entering the pond:
[ R_1455 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I463_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1455, 1455);
      ! phrase 1
      ! [1: try swimming]
       TryAction(0, player, ##A102_swimming, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1455, 1455, true);
   rfalse;
];
! No specific request
! Instead of turning the wooden drawer:
[ R_1460 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1460, 1460);
      ! phrase 1
      ! [1: if the noun is upside-down begin]
       if ((((Adj_128_t1_v9(noun)))))  {
         ! phrase 2
         ! [2: now the noun is right-side-up]
          (Adj_129_t2_v9(noun)); 
         ! phrase 3
         ! [3: say ~You turn the drawer right side up.~]
         say__p=1;ParaContent();  print (PrintText) SC_680;  new_line; .L_Say368; .L_SayX352;
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: now the noun is upside-down]
          (Adj_128_t2_v9(noun)); 
         ! phrase 6
         ! [6: say ~You turn the drawer upside down[if the noun contains something]; [the list of things contained by the noun] tumble[s] to the ground[end if].~]
         say__p=1;ParaContent();  print (PrintText) SC_681; 
	if (~~(((Prop_37())))) jump L_Say369;
		ParaContent();  print (PrintText) SC_682; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (noun == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_683; ParaContent();  STextSubstitution(); ParaContent();  print (PrintText) SC_684; 
	.L_Say369; .L_SayX353;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say370; .L_SayX354;
         ! phrase 7
         ! [7: repeat with item running through every thing contained by the noun begin]
          for (t_0=Prop_38(0), t_1=Prop_38(t_0): t_0: t_0=t_1, t_1=Prop_38(t_1))  {
              if (debug_rules>1) print "  [repetition with item set to ", (PrintShortName) t_0, "]^";
            ! phrase 8
            ! [8: move item to the location of the player]
             MoveObject(t_0,  LocationOf(player) , 0, false); 
            ! phrase 9
            ! [9: end repeat]
            }

           if (debug_rules>1) print "  [9: end repeat]^";
         ! phrase 10
         ! [10: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1460, 1460, true);
   rfalse;
];
! No specific request
! Instead of entering the wooden drawer:
[ R_1463 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1463, 1463);
      ! phrase 1
      ! [1: if the drawer is held , say ~You'd have to put it down first.~]
       if ((((Adj_2_t1_v9(I589_wooden_drawer))))) { say__p=1;ParaContent();  print (PrintText) SC_685;  new_line; .L_Say371; .L_SayX355;  }
      ! phrase 2
      ! [2: if the drawer is right-side-up , say ~You won't gain much height from just standing [bold type]in[roman type] the drawer when it's oriented like this.~]
       if ((((Adj_129_t1_v9(I589_wooden_drawer))))) { say__p=1;ParaContent();  print (PrintText) SC_686; ParaContent();  style bold; ParaContent();  print (PrintText) SC_687; ParaContent();  style roman; ParaContent();  print (PrintText) SC_688;  new_line; .L_Say372; .L_SayX356;  }
      ! phrase 3
      ! [3: if the drawer is upside-down , try entering the drawer bottom]
       if ((((Adj_128_t1_v9(I589_wooden_drawer))))) {  TryAction(0, player, ##Enter, I590_drawer_bottom, 0);;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1463, 1463, true);
   rfalse;
];
! No specific request
! Instead of getting off the wooden drawer:
[ R_1464 ;
   if ((action ==##GetOff) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1464, 1464);
      ! phrase 1
      ! [1: try getting off the drawer bottom]
       TryAction(0, player, ##GetOff, I590_drawer_bottom, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1464, 1464, true);
   rfalse;
];
! No specific request
! Instead of climbing the wooden drawer:
[ R_1468 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1468, 1468);
      ! phrase 1
      ! [1: try entering the wooden drawer]
       TryAction(0, player, ##Enter, I589_wooden_drawer, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1468, 1468, true);
   rfalse;
];
! No specific request
! Instead of dropping the secret panel:
[ R_1474 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun == I591_secret_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1474, 1474);
      ! phrase 1
      ! [1: try dropping the drawer]
       TryAction(0, player, ##Drop, I589_wooden_drawer, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1474, 1474, true);
   rfalse;
];
! No specific request
! Instead of taking the secret panel:
[ R_1480 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I591_secret_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1480, 1480);
      ! phrase 1
      ! [1: try opening the secret panel]
       TryAction(0, player, ##Open, I591_secret_panel, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1480, 1480, true);
   rfalse;
];
! No specific request
! Instead of touching the secret panel:
[ R_1481 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I591_secret_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1481, 1481);
      ! phrase 1
      ! [1: try opening the secret panel]
       TryAction(0, player, ##Open, I591_secret_panel, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1481, 1481, true);
   rfalse;
];
! No specific request
! Instead of pushing the secret panel:
[ R_1482 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I591_secret_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1482, 1482);
      ! phrase 1
      ! [1: try opening the secret panel]
       TryAction(0, player, ##Open, I591_secret_panel, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1482, 1482, true);
   rfalse;
];
! No specific request
! Instead of taking the rock selection:
[ R_1491 
    t_0 ! Local variable e.g. 'chosen rock' = object
    ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I601_rock_selection) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1491, 1491);
      ! phrase 1
      ! [1: let chosen rock be a random small rock in rock limbo]
       t_0 =  (Prop_39()) ; 
      ! phrase 2
      ! [2: if chosen rock is nothing begin]
       if (((t_0 == nothing)))  {
         ! phrase 3
         ! [3: say ~You probably have enough. You have better things to do than cart rocks around all day.~]
         say__p=1;ParaContent();  print (PrintText) SC_689;  new_line; .L_Say373; .L_SayX357;
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: move the chosen rock to the location of the player]
          MoveObject(t_0,  LocationOf(player) , 0, false); 
         ! phrase 6
         ! [6: set pronouns from the chosen rock]
          PronounNotice(t_0); 
         ! phrase 7
         ! [7: try taking the chosen rock]
          TryAction(0, player, ##Take, t_0, 0);; 
         ! phrase 8
         ! [8: rule succeeds]
          RulebookSucceeds(); rtrue; 
         ! phrase 9
         ! [9: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1491, 1491, true);
   rfalse;
];
! No specific request
! Instead of searching the spot:
[ R_1502 ;
   if ((action ==##Search) &&  (actor==player) && ((noun == I603_particular_spot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1502, 1502);
      ! phrase 1
      ! [1: try searching the sand]
       TryAction(0, player, ##Search, I602_sand, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1502, 1502, true);
   rfalse;
];
! No specific request
! Instead of taking sand:
[ R_1503 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I602_sand) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1503, 1503);
      ! phrase 1
      ! [1: say ~It runs through your fingers, and you can't hold on to any.~]
      say__p=1;ParaContent();  print (PrintText) SC_690;  new_line; .L_Say374; .L_SayX358;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1503, 1503, true);
   rfalse;
];
! No specific request
! Instead of searching sand:
[ R_1505 ;
   if ((action ==##Search) &&  (actor==player) && ((noun == I602_sand) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1505, 1505);
      ! phrase 1
      ! [1: if the metal detector is visible and the metal detector is switched on and the large magnet is not handled begin]
       if (((((Adj_3_t1_v9(I421_small_metal_detector))))) && (((((Adj_80_t1_v9(I421_small_metal_detector))))) && (((~~(((Adj_60_t1_v9(I604_large_magnet)))))))))  {
         ! phrase 2
         ! [2: say ~You dig in the sand, in the spot where the metal detector beeps the most intensely, and find a large magnet.~]
         say__p=1;ParaContent();  print (PrintText) SC_691;  new_line; .L_Say375; .L_SayX359;
         ! phrase 3
         ! [3: record ~finding a magnet~ as achieved]
         (PHR_1164_r6 (SC_193));
         ! phrase 4
         ! [4: now the large magnet is in sandy beach]
          MoveObject(I604_large_magnet,I474_sandy_beach); 
         ! phrase 5
         ! [5: otherwise if the large magnet is not handled]
          } else if (((~~(((Adj_60_t1_v9(I604_large_magnet))))))) { 
         ! phrase 6
         ! [6: say ~You try digging in the sand, but without having a better idea of where to dig, you aren't that likely to find anything.~]
         say__p=1;ParaContent();  print (PrintText) SC_692;  new_line; .L_Say376; .L_SayX360;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~You dig in the sand, but find nothing further.~]
         say__p=1;ParaContent();  print (PrintText) SC_693;  new_line; .L_Say377; .L_SayX361;
         ! phrase 9
         ! [9: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1505, 1505, true);
   rfalse;
];
! No specific request
! Instead of taking the leaves:
[ R_1507 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I607_yellow_leaves) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1507, 1507);
      ! phrase 1
      ! [1: say ~You can't reach them.~]
      say__p=1;ParaContent();  print (PrintText) SC_694;  new_line; .L_Say378; .L_SayX362;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1507, 1507, true);
   rfalse;
];
! No specific request
! Instead of climbing the birch trees:
[ R_1508 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I606_birch_trees) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1508, 1508);
      ! phrase 1
      ! [1: say ~They're too slender to support your weight, and the nearest branch is too far away.~]
      say__p=1;ParaContent();  print (PrintText) SC_695;  new_line; .L_Say379; .L_SayX363;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1508, 1508, true);
   rfalse;
];
! No specific request
! Instead of taking the birch bark:
[ R_1509 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I609_birch_bark) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1509, 1509);
      ! phrase 1
      ! [1: say ~You would only hurt the trees by doing that.~]
      say__p=1;ParaContent();  print (PrintText) SC_671;  new_line; .L_Say380; .L_SayX364;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1509, 1509, true);
   rfalse;
];
! No specific request
! Instead of touching the ark:
[ R_1535 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I616_ark) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1535, 1535);
      ! phrase 1
      ! [1: if the player is trapped begin]
       if ((((Adj_130_t1_v9(player)))))  {
         ! phrase 2
         ! [2: say ~You can't reach it from here.~]
         say__p=1;ParaContent();  print (PrintText) SC_547;  new_line; .L_Say381; .L_SayX365;
         ! phrase 3
         ! [3: otherwise if the secretary's story has not happened]
          } else if (( (scene_endings-->(I611_secretary_s_story-1) == 0) )) { 
         ! phrase 4
         ! [4: say ~The wooden sides of the boat are smooth, with little evidence that the boat has been to sea.~]
         say__p=1;ParaContent();  print (PrintText) SC_696;  new_line; .L_Say382; .L_SayX366;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~You try to press your hand against the boat, just as [the Secretary] did, but nothing happens.~]
         say__p=1;ParaContent();  print (PrintText) SC_697; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_698;  new_line; .L_Say383; .L_SayX367;
         ! phrase 7
         ! [7: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1535, 1535, true);
   rfalse;
];
! No specific request
! Instead of touching the anchor:
[ R_1536 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I619_anchor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1536, 1536);
      ! phrase 1
      ! [1: say ~Surprisingly smooth.~]
      say__p=1;ParaContent();  print (PrintText) SC_699;  new_line; .L_Say384; .L_SayX368;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1536, 1536, true);
   rfalse;
];
! No specific request
! Instead of entering the stone steps:
[ R_1541 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I623_stone_steps) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1541, 1541);
      ! phrase 1
      ! [1: try going east]
       TryAction(0, player, ##Go, I52_east, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1541, 1541, true);
   rfalse;
];
! No specific request
! Instead of taking the mat of leaves:
[ R_1558 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I626_mat_of_leaves) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1558, 1558);
      ! phrase 1
      ! [1: say ~You pick up a few, but then let them drift through your fingers again; you don't need to carry them around.~]
      say__p=1;ParaContent();  print (PrintText) SC_666;  new_line; .L_Say385; .L_SayX369;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1558, 1558, true);
   rfalse;
];
! No specific request
! Instead of climbing the colorful trees:
[ R_1561 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I628_colorful_trees) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1561, 1561);
      ! phrase 1
      ! [1: say ~None of the trees here look very climbable.~]
      say__p=1;ParaContent();  print (PrintText) SC_700;  new_line; .L_Say386; .L_SayX370;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1561, 1561, true);
   rfalse;
];
! No specific request
! Instead of opening the hut:
[ R_1573 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I630_cinderblock_hut) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1573, 1573);
      ! phrase 1
      ! [1: try opening the metal door]
       TryAction(0, player, ##Open, I631_smooth_metal_door, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1573, 1573, true);
   rfalse;
];
! No specific request
! Instead of touching the moss:
[ R_1574 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I634_moss) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1574, 1574);
      ! phrase 1
      ! [1: say ~It is damp and soft to the touch.~]
      say__p=1;ParaContent();  print (PrintText) SC_701;  new_line; .L_Say387; .L_SayX371;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1574, 1574, true);
   rfalse;
];
! No specific request
! Instead of examining the deep crack:
[ R_1576 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I639_deep_crack) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1576, 1576);
      ! phrase 1
      ! [1: say ~[the description of the deep crack][paragraph break]~]
      say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=I639_deep_crack,description); @pull self; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say388; .L_SayX372;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1576, 1576, true);
   rfalse;
];
! No specific request
! Instead of turning the large metal wheel:
[ R_1598 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I642_large_metal_wheel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1598, 1598);
      ! phrase 1
      ! [1: if the underground pump is switched off , try switching on the underground pump]
       if ((((Adj_81_t1_v9(I417_underground_pump))))) {  TryAction(0, player, ##SwitchOn, I417_underground_pump, 0);;   }
      ! phrase 2
      ! [2: otherwise try switching off the underground pump]
       else {  TryAction(0, player, ##SwitchOff, I417_underground_pump, 0);;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1598, 1598, true);
   rfalse;
];
! No specific request
! Instead of entering the hut:
[ R_1601 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I630_cinderblock_hut) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1601, 1601);
      ! phrase 1
      ! [1: try going inside]
       TryAction(0, player, ##Go, in_obj, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1601, 1601, true);
   rfalse;
];
! No specific request
! Instead of switching off the underground pump:
[ R_1616 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == I417_underground_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1616, 1616);
      ! phrase 1
      ! [1: say ~Nothing happens. Maybe it's broken?~]
      say__p=1;ParaContent();  print (PrintText) SC_702;  new_line; .L_Say389; .L_SayX373;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1616, 1616, true);
   rfalse;
];
! No specific request
! Instead of entering the large tank:
[ R_1625 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I653_large_tank) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1625, 1625);
      ! phrase 1
      ! [1: try climbing the large tank]
       TryAction(0, player, ##Climb, I653_large_tank, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1625, 1625, true);
   rfalse;
];
! No specific request
! Instead of climbing the large tank:
[ R_1626 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I653_large_tank) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1626, 1626);
      ! phrase 1
      ! [1: if the player is on the drawer bottom begin]
       if (((I590_drawer_bottom == SupporterOf(player))))  {
         ! phrase 2
         ! [2: say ~You can just reach the bottom-most rung from here.~]
         say__p=1;ParaContent();  print (PrintText) SC_703;  new_line; .L_Say390; .L_SayX374;
         ! phrase 3
         ! [3: move the player to atop the tank]
          MoveObject(player, I469_atop_the_tank, 0, false); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You can't reach the rungs -- the bottom-most rung is several inches too high for you to reach.~]
         say__p=1;ParaContent();  print (PrintText) SC_704;  new_line; .L_Say391; .L_SayX375;
         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1626, 1626, true);
   rfalse;
];
! No specific request
! Instead of climbing the rungs:
[ R_1628 ;
   if ((action ==##Climb) &&  (actor==player) && ((noun == I654_rungs) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1628, 1628);
      ! phrase 1
      ! [1: try climbing the large tank]
       TryAction(0, player, ##Climb, I653_large_tank, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1628, 1628, true);
   rfalse;
];
! No specific request
! Instead of turning the brass metal pipe:
[ R_1640 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I657_brass_metal_pipe) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1640, 1640);
      ! phrase 1
      ! [1: say ~You have no leverage to turn it with.~]
      say__p=1;ParaContent();  print (PrintText) SC_705;  new_line; .L_Say392; .L_SayX376;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1640, 1640, true);
   rfalse;
];
! No specific request
! Instead of pushing the flagpole:
[ R_1644 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I490_flagpole) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1644, 1644);
      ! phrase 1
      ! [1: try turning the flagpole]
       TryAction(0, player, ##Turn, I490_flagpole, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1644, 1644, true);
   rfalse;
];
! No specific request
! Instead of pushing the medium-sized wheel:
[ R_1645 ;
   if ((action ==##Push) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1645, 1645);
      ! phrase 1
      ! [1: try turning the medium-sized wheel]
       TryAction(0, player, ##Turn, I660_medium_sized_wheel, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1645, 1645, true);
   rfalse;
];
! No specific request
! Instead of attacking the emergency supplies box:
[ R_1664 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I667_emergency_supplies_box) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1664, 1664);
      ! phrase 1
      ! [1: say ~You hit the box, and it rings with a clear vibration.~]
      say__p=1;ParaContent();  print (PrintText) SC_706;  new_line; .L_Say393; .L_SayX377;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1664, 1664, true);
   rfalse;
];
! No specific request
! Instead of taking the emergency supplies box:
[ R_1665 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I667_emergency_supplies_box) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1665, 1665);
      ! phrase 1
      ! [1: say ~It's too big to carry around.~]
      say__p=1;ParaContent();  print (PrintText) SC_707;  new_line; .L_Say394; .L_SayX378;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1665, 1665, true);
   rfalse;
];
! No specific request
! Instead of attacking Vivian:
[ R_1687 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I671_vivian) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1687, 1687);
      ! phrase 1
      ! [1: say ~She grabs your hands almost instantly and twists them into immobility, only letting go after a long, wary glance. [one of]'That wasn't very nice!'[or][stopping]~]
      say__p=1;ParaContent();  print (PrintText) SC_708; ParaContent();  I7_ST_say_one_of-->24 =
	i7_soo_stop(I7_ST_say_one_of-->24, 2);
	switch((I7_ST_say_one_of-->24)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_709;  new_line;ParaContent();  @nop; 1: ParaContent();  }  .L_Say395; .L_SayX379;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1687, 1687, true);
   rfalse;
];
! No specific request
! Instead of attacking Cordelia:
[ R_1688 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I687_cordelia) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1688, 1688);
      ! phrase 1
      ! [1: say ~She blocks you expertly.~]
      say__p=1;ParaContent();  print (PrintText) SC_710;  new_line; .L_Say396; .L_SayX380;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1688, 1688, true);
   rfalse;
];
! No specific request
! Instead of attacking Douglas:
[ R_1689 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I688_douglas) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1689, 1689);
      ! phrase 1
      ! [1: say ~He blocks you expertly.~]
      say__p=1;ParaContent();  print (PrintText) SC_711;  new_line; .L_Say397; .L_SayX381;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1689, 1689, true);
   rfalse;
];
! No specific request
! Instead of waving the wind chimes:
[ R_1693 ;
   if ((action ==##Wave) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1693, 1693);
      ! phrase 1
      ! [1: try shaking the wind chimes]
       TryAction(0, player, ##A124_shaking, I563_metal_wind_chimes, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1693, 1693, true);
   rfalse;
];
! No specific request
! Instead of touching the underwater pump:
[ R_1699 ;
   if ((action ==##Touch) &&  (actor==player) && ((noun == I419_underwater_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1699, 1699);
      ! phrase 1
      ! [1: say ~Its surface is smooth, hard, and impenetrable.~]
      say__p=1;ParaContent();  print (PrintText) SC_712;  new_line; .L_Say398; .L_SayX382;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1699, 1699, true);
   rfalse;
];
! No specific request
! Instead of attacking the underwater pump:
[ R_1712 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I419_underwater_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1712, 1712);
      ! phrase 1
      ! [1: say ~It shudders for a minute.~]
      say__p=1;ParaContent();  print (PrintText) SC_713;  new_line; .L_Say399; .L_SayX383;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1712, 1712, true);
   rfalse;
];
! No specific request
! Instead of switching on the underwater pump:
[ R_1717 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I419_underwater_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1717, 1717);
      ! phrase 1
      ! [1: say ~It's not obvious how.~]
      say__p=1;ParaContent();  print (PrintText) SC_714;  new_line; .L_Say400; .L_SayX384;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1717, 1717, true);
   rfalse;
];
! No specific request
! Instead of switching off the underwater pump:
[ R_1718 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == I419_underwater_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1718, 1718);
      ! phrase 1
      ! [1: say ~It's not obvious how.~]
      say__p=1;ParaContent();  print (PrintText) SC_714;  new_line; .L_Say401; .L_SayX385;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1718, 1718, true);
   rfalse;
];
! No specific request
! Instead of examining the steam train:
[ R_1726 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I439_steam_train) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1726, 1726);
      ! phrase 1
      ! [1: try train-examining]
       TryAction(0, player, ##A135_train_examining, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1726, 1726, true);
   rfalse;
];
! No specific request
! Instead of entering the steam train:
[ R_1727 ;
   if ((action ==##Enter) &&  (actor==player) && ((noun == I439_steam_train) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1727, 1727);
      ! phrase 1
      ! [1: try boarding]
       TryAction(0, player, ##A104_boarding, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1727, 1727, true);
   rfalse;
];
! No specific request
! Instead of unlocking keylessly the structure:
[ R_1728 ;
   if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I477_structure) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1728, 1728);
      ! phrase 1
      ! [1: try unlocking keylessly the door to the structure]
       TryAction(0, player, ##A86_unlocking_keylessly, I480_door_to_the_structure, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1728, 1728, true);
   rfalse;
];
! No specific request
! Instead of opening the structure:
[ R_1730 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I477_structure) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1730, 1730);
      ! phrase 1
      ! [1: try opening the door to the structure]
       TryAction(0, player, ##Open, I480_door_to_the_structure, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1730, 1730, true);
   rfalse;
];
! No specific request
! Instead of attacking the conductor:
[ R_1753 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun == I711_conductor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1753, 1753);
      ! phrase 1
      ! [1: say ~His lean arm expertly blocks your attack.~]
      say__p=1;ParaContent();  print (PrintText) SC_715;  new_line; .L_Say402; .L_SayX386;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1753, 1753, true);
   rfalse;
];
! No specific request
! Instead of searching or entering the large rusty pipe:
[ R_1242 ;
   if ((action ==##Enter or ##Search) &&  (actor==player) && ((noun == I454_large_rusty_pipe) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1242, 1242);
      ! phrase 1
      ! [1: say ~From here, you can only see the curved surface of the pipe, and can't see or reach inside it.~]
      say__p=1;ParaContent();  print (PrintText) SC_716;  new_line; .L_Say403; .L_SayX387;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1242, 1242, true);
   rfalse;
];
! No specific request
! Instead of drinking or touching the pond:
[ R_1244 ;
   if ((action ==##Touch or ##Drink) &&  (actor==player) && ((noun == I463_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1244, 1244);
      ! phrase 1
      ! [1: if the location is outside waterworks or the location is the hill or the location is in the sweetgum tree or the location is atop the tank , say ~You can see the pond from here, but you can't access it.~]
       if ((((real_location == I447_outside_waterworks))) || ((((real_location == I441_hill))) || ((((real_location == I442_in_the_sweetgum_tree))) || (((real_location == I469_atop_the_tank)))))) { say__p=1;ParaContent();  print (PrintText) SC_500;  new_line; .L_Say404; .L_SayX388;  }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1244, 1244, true);
   rfalse;
];
! No specific request
! Instead of pulling or pushing the tall cylinder:
[ R_1322 ;
   if ((action ==##Push or ##Pull) &&  (actor==player) && ((noun == I522_tall_cylinder) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1322, 1322);
      ! phrase 1
      ! [1: say ~It seems to be firmly fixed in place.~]
      say__p=1;ParaContent();  print (PrintText) SC_717;  new_line; .L_Say405; .L_SayX389;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1322, 1322, true);
   rfalse;
];
! No specific request
! Instead of switching on or switching off the complicated pump:
[ R_1371 ;
   if ((action ==##SwitchOff or ##SwitchOn) &&  (actor==player) && ((noun == I416_complicated_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1371, 1371);
      ! phrase 1
      ! [1: say ~You consider yourself pretty good with technology, but you're not really sure which of the levers or gizmos or gadgets you should manipulate.~]
      say__p=1;ParaContent();  print (PrintText) SC_718;  new_line; .L_Say406; .L_SayX390;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1371, 1371, true);
   rfalse;
];
! No specific request
! Instead of climbing or entering the ark:
[ R_1533 ;
   if ((action ==##Enter or ##Climb) &&  (actor==player) && ((noun == I616_ark) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1533, 1533);
      ! phrase 1
      ! [1: say ~The sides are too sleek to climb, and the boat is much taller than you.~]
      say__p=1;ParaContent();  print (PrintText) SC_719;  new_line; .L_Say407; .L_SayX391;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1533, 1533, true);
   rfalse;
];
! No specific request
! Instead of pushing or taking the ark:
[ R_1534 ;
   if ((action ==##Take or ##Push) &&  (actor==player) && ((noun == I616_ark) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1534, 1534);
      ! phrase 1
      ! [1: if the player is trapped begin]
       if ((((Adj_130_t1_v9(player)))))  {
         ! phrase 2
         ! [2: say ~You can't reach it from here.~]
         say__p=1;ParaContent();  print (PrintText) SC_547;  new_line; .L_Say408; .L_SayX392;
         ! phrase 3
         ! [3: otherwise if the secretary's story has not happened]
          } else if (( (scene_endings-->(I611_secretary_s_story-1) == 0) )) { 
         ! phrase 4
         ! [4: say ~It's a giant boat on dry land -- it's probably not going anywhere.~]
         say__p=1;ParaContent();  print (PrintText) SC_720;  new_line; .L_Say409; .L_SayX393;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~You try to press your hand against the boat, just as [the Secretary] did, but nothing happens.~]
         say__p=1;ParaContent();  print (PrintText) SC_697; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_698;  new_line; .L_Say410; .L_SayX394;
         ! phrase 7
         ! [7: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1534, 1534, true);
   rfalse;
];
! No specific request
! Instead of pushing or taking the anchor:
[ R_1538 ;
   if ((action ==##Take or ##Push) &&  (actor==player) && ((noun == I619_anchor) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1538, 1538);
      ! phrase 1
      ! [1: say ~It maybe sinks a little deeper into the mud after your efforts -- that's about it.~]
      say__p=1;ParaContent();  print (PrintText) SC_721;  new_line; .L_Say411; .L_SayX395;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1538, 1538, true);
   rfalse;
];
! No specific request
! Instead of touching or smelling or tasting or attacking or taking the father:
[ R_1620 ;
   if ((action ==##Take or ##Attack or ##Taste or ##Smell or ##Touch) &&  (actor==player) && ((noun == I651_father) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1620, 1620);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say412; .L_SayX396;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1620, 1620, true);
   rfalse;
];
! No specific request
! Instead of touching or smelling or tasting or attacking or taking the daughter:
[ R_1621 ;
   if ((action ==##Take or ##Attack or ##Taste or ##Smell or ##Touch) &&  (actor==player) && ((noun == I652_daughter) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1621, 1621);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say413; .L_SayX397;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1621, 1621, true);
   rfalse;
];
! No specific request
! Instead of touching or smelling or tasting or attacking or taking the family:
[ R_1622 ;
   if ((action ==##Take or ##Attack or ##Taste or ##Smell or ##Touch) &&  (actor==player) && ((noun == I650_family) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1622, 1622);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say414; .L_SayX398;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1622, 1622, true);
   rfalse;
];
! No specific request
! Instead of touching or smelling or tasting or attacking or taking the game:
[ R_1623 ;
   if ((action ==##Take or ##Attack or ##Taste or ##Smell or ##Touch) &&  (actor==player) && ((noun == I649_game) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1623, 1623);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say415; .L_SayX399;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1623, 1623, true);
   rfalse;
];
! No specific request
! Instead of touching or smelling or tasting or attacking or taking the house:
[ R_1624 ;
   if ((action ==##Take or ##Attack or ##Taste or ##Smell or ##Touch) &&  (actor==player) && ((noun == I648_suburban_house) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1624, 1624);
      ! phrase 1
      ! [1: say ~The house is far away.~]
      say__p=1;ParaContent();  print (PrintText) SC_723;  new_line; .L_Say416; .L_SayX400;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1624, 1624, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than touching , smelling , or examining to the rope:
[ R_1522 ;
   if ((action ~=##Examine or ##Smell or ##Touch) &&  (actor==player) && ((noun == I612_rope) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1522, 1522);
      ! phrase 1
      ! [1: say ~[The secretary] has a firm hold on the rope.~]
      say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_724;  new_line; .L_Say417; .L_SayX401;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1522, 1522, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the gull:
[ R_1057 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I588_gull) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1057, 1057);
      ! phrase 1
      ! [1: say ~[one of]It snaps at you and almost bites your finger. You jump back.[or]It flaps just out of your reach.[or]It pecks at your hand, hard. You yelp in pain.[at random]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->25 =
	i7_soo_ran(I7_ST_say_one_of-->25, 3);
	switch((I7_ST_say_one_of-->25)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_725;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_726;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_727;  new_line;ParaContent();  }  .L_Say418; .L_SayX402;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1057, 1057, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the giant metal wheel:
[ R_1697 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I698_giant_metal_wheel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1697, 1697);
      ! phrase 1
      ! [1: say ~You can't reach it; it's inside the pump's crystal shell.~]
      say__p=1;ParaContent();  print (PrintText) SC_728;  new_line; .L_Say419; .L_SayX403;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1697, 1697, true);
   rfalse;
];
! No specific request
! Instead of doing anything other than examining to the large crystal gear:
[ R_1698 ;
   if ((action ~=##Examine) &&  (actor==player) && ((noun == I699_large_crystal_gear) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1698, 1698);
      ! phrase 1
      ! [1: say ~You can't reach it; it's inside the pump's crystal shell.~]
      say__p=1;ParaContent();  print (PrintText) SC_728;  new_line; .L_Say420; .L_SayX404;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1698, 1698, true);
   rfalse;
];
! No specific request
! Instead of doing anything with bubbling water:
[ R_1328 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I523_bubbling_water) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1328, 1328);
      ! phrase 1
      ! [1: say ~It's inside the cylinder, where you can't get at it.~]
      say__p=1;ParaContent();  print (PrintText) SC_729;  new_line; .L_Say421; .L_SayX405;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1328, 1328, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Instead of getting off the location ( this is the Small Kindnesses overly elaborate exiting rule ):
[ R_751 ;
   if ((action ==##GetOff) &&  (actor==player) && ((noun == real_location) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_751, 751);
      ! phrase 1
      ! [1: try exiting]
       TryAction(0, player, ##Exit, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_751, 751, true);
   rfalse;
];
! No specific request
! Instead of taking something that is enclosed by the tall cylinder:
[ R_1319 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (IndirectlyContains(I522_tall_cylinder,noun)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1319, 1319);
      ! phrase 1
      ! [1: say ~The cylinder is much too high to reach the opening at the top[if the player is on something], even from [the holder of the player][end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_730; 
	if (~~((((SupporterOf(player) ofclass K6_supporter))))) jump L_Say422;
		ParaContent();  print (PrintText) SC_731; ParaContent();  print (the)  (HolderOf(player)) ; 
	.L_Say422; .L_SayX406;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say423; .L_SayX407;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1319, 1319, true);
   rfalse;
];
! No specific request
! Instead of attacking something that is part of the underwater pump:
[ R_1707 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun ofclass K2_thing) && (I419_underwater_pump == (noun.component_parent)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1707, 1707);
      ! phrase 1
      ! [1: try attacking the underwater pump]
       TryAction(0, player, ##Attack, I419_underwater_pump, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1707, 1707, true);
   rfalse;
];
! No specific request
! Instead of knocking on an open door:
[ R_1214 ;
   if ((action ==##A112_knocking_on) &&  (actor==player) && ((noun ofclass K4_door) && ((Adj_70_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1214, 1214);
      ! phrase 1
      ! [1: say ~[The noun] is already open.~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_732;  new_line; .L_Say424; .L_SayX408;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1214, 1214, true);
   rfalse;
];
! No specific request
! Instead of knocking on a closed door:
[ R_1215 ;
   if ((action ==##A112_knocking_on) &&  (actor==player) && ((noun ofclass K4_door) && ((Adj_71_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1215, 1215);
      ! phrase 1
      ! [1: say ~You knock on [the noun], but there is no reply.~]
      say__p=1;ParaContent();  print (PrintText) SC_733; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_734;  new_line; .L_Say425; .L_SayX409;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1215, 1215, true);
   rfalse;
];
! No specific request
! Instead of kissing someone:
[ R_1051 ;
   if ((action ==##Kiss) &&  (actor==player) && ((noun ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1051, 1051);
      ! phrase 1
      ! [1: if the noun is irked , say ~She turns away from you.~]
       if ((((Adj_114_t1_v9(noun))))) { say__p=1;ParaContent();  print (PrintText) SC_735;  new_line; .L_Say426; .L_SayX410;  }
      ! phrase 2
      ! [2: otherwise say ~[if the noun is female]She[else]He[end if] blushes.~]
       else { say__p=1;
	if (~~(((((Adj_77_t1_v9(noun))))))) jump L_Say427;
		ParaContent();  print (PrintText) SC_736; 
	jump L_SayX411; .L_Say427;
		ParaContent();  print (PrintText) SC_737; 
	.L_Say428; .L_SayX411;
		ParaContent();  print (PrintText) SC_738;  new_line; .L_Say429; .L_SayX412;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1051, 1051, true);
   rfalse;
];
! No specific request
! Instead of drinking a fluid container:
[ R_1110 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1110, 1110);
      ! phrase 1
      ! [1: if the noun is empty begin]
       if ((((Adj_16_t1_v9(noun)))))  {
         ! phrase 2
         ! [2: say ~There is no more [liquid of the noun] in [the noun].~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_739; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_740; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; rtrue; .L_Say430; .L_SayX413; rtrue;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: decrease the current volume of the noun by 0.2 fl oz]
          WriteGProperty(OBJECT_TY, noun,p15_current_volume,GProperty(OBJECT_TY, noun,p15_current_volume) - 2); 
         ! phrase 5
         ! [5: if the current volume of the noun is less than 0.0 fl oz , now the current volume of the noun is 0.0 fl oz]
          if (((GProperty(OBJECT_TY, noun,p15_current_volume) < 0))) {  WriteGProperty(OBJECT_TY, noun,p15_current_volume,0);   }
         ! phrase 6
         ! [6: say ~You take a sip of [the liquid of the noun][if the noun is empty], leaving [the noun] empty[end if].~]
         say__p=1;ParaContent();  print (PrintText) SC_741; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; 
	if (~~(((((Adj_16_t1_v9(noun))))))) jump L_Say431;
		ParaContent();  print (PrintText) SC_742; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_743; 
	.L_Say431; .L_SayX414;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say432; .L_SayX415;
         ! phrase 7
         ! [7: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1110, 1110, true);
   rfalse;
];
! No specific request
! Instead of drinking a liquid source:
[ R_1111 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun ofclass K26_liquid_source))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1111, 1111);
      ! phrase 1
      ! [1: say ~You drink some [the liquid of the noun] from [the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_744; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_745; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say433; .L_SayX416;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1111, 1111, true);
   rfalse;
];
! No specific request
! Instead of tasting a liquid source:
[ R_1112 ;
   if ((action ==##Taste) &&  (actor==player) && ((noun ofclass K26_liquid_source))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1112, 1112);
      ! phrase 1
      ! [1: if the liquid of the noun is pond water , say ~A little muddy, but not too bad.~]
       if (((GProperty(OBJECT_TY, noun,p85_liquid) == I437_pond_water))) { say__p=1;ParaContent();  print (PrintText) SC_746;  new_line; .L_Say434; .L_SayX417;  }
      ! phrase 2
      ! [2: if the liquid of the noun is clean water , say ~Clear and refreshing.~]
       if (((GProperty(OBJECT_TY, noun,p85_liquid) == I436_clean_water))) { say__p=1;ParaContent();  print (PrintText) SC_747;  new_line; .L_Say435; .L_SayX418;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1112, 1112, true);
   rfalse;
];
! No specific request
! Instead of tasting a fluid container:
[ R_1113 ;
   if ((action ==##Taste) &&  (actor==player) && ((noun ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1113, 1113);
      ! phrase 1
      ! [1: if the liquid of the noun is pond water , say ~A little muddy, but not too bad.~]
       if (((GProperty(OBJECT_TY, noun,p85_liquid) == I437_pond_water))) { say__p=1;ParaContent();  print (PrintText) SC_746;  new_line; .L_Say436; .L_SayX419;  }
      ! phrase 2
      ! [2: if the liquid of the noun is clean water , say ~Clear and refreshing.~]
       if (((GProperty(OBJECT_TY, noun,p85_liquid) == I436_clean_water))) { say__p=1;ParaContent();  print (PrintText) SC_747;  new_line; .L_Say437; .L_SayX420;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1113, 1113, true);
   rfalse;
];
! No specific request
! Instead of searching a liquid source:
[ R_1133 ;
   if ((action ==##Search) &&  (actor==player) && ((noun ofclass K26_liquid_source))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1133, 1133);
      ! phrase 1
      ! [1: say ~[The noun] is full of [the liquid of the noun].~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_748; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say438; .L_SayX421;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1133, 1133, true);
   rfalse;
];
! No specific request
! Instead of attacking a door:
[ R_1217 ;
   if ((action ==##Attack) &&  (actor==player) && ((noun ofclass K4_door))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1217, 1217);
      ! phrase 1
      ! [1: try knocking on the noun]
       TryAction(0, player, ##A112_knocking_on, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1217, 1217, true);
   rfalse;
];
! No specific request
! Instead of switching on a lever:
[ R_1334 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun ofclass K27_lever))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1334, 1334);
      ! phrase 1
      ! [1: try flipping the noun]
       TryAction(0, player, ##A123_flipping, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1334, 1334, true);
   rfalse;
];
! No specific request
! Instead of switching off a lever:
[ R_1335 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun ofclass K27_lever))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1335, 1335);
      ! phrase 1
      ! [1: try flipping the noun]
       TryAction(0, player, ##A123_flipping, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1335, 1335, true);
   rfalse;
];
! No specific request
! Instead of turning a lever:
[ R_1355 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun ofclass K27_lever))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1355, 1355);
      ! phrase 1
      ! [1: try flipping the noun]
       TryAction(0, player, ##A123_flipping, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1355, 1355, true);
   rfalse;
];
! No specific request
! Instead of turning a switch:
[ R_1356 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun ofclass K29_switch))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1356, 1356);
      ! phrase 1
      ! [1: try flipping the noun]
       TryAction(0, player, ##A123_flipping, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1356, 1356, true);
   rfalse;
];
! No specific request
! Instead of pulling a lever:
[ R_1367 ;
   if ((action ==##Pull) &&  (actor==player) && ((noun ofclass K27_lever))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1367, 1367);
      ! phrase 1
      ! [1: try flipping the noun]
       TryAction(0, player, ##A123_flipping, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1367, 1367, true);
   rfalse;
];
! No specific request
! Instead of pushing a lever:
[ R_1368 ;
   if ((action ==##Push) &&  (actor==player) && ((noun ofclass K27_lever))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1368, 1368);
      ! phrase 1
      ! [1: try flipping the noun]
       TryAction(0, player, ##A123_flipping, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1368, 1368, true);
   rfalse;
];
! No specific request
! Instead of smelling a pinecone:
[ R_1416 ;
   if ((action ==##Smell) &&  (actor==player) && ((noun ofclass K30_pinecone))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1416, 1416);
      ! phrase 1
      ! [1: say ~A deep musk of forest.~]
      say__p=1;ParaContent();  print (PrintText) SC_665;  new_line; .L_Say439; .L_SayX422;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1416, 1416, true);
   rfalse;
];
! No specific request
! Instead of cutting something:
[ R_1037 ;
   if ((action ==##Cut) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1037, 1037);
      ! phrase 1
      ! [1: say ~You have nothing to cut with, and probably don't want to destroy [the noun] anyway.~]
      say__p=1;ParaContent();  print (PrintText) SC_749; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_750;  new_line; .L_Say440; .L_SayX423;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1037, 1037, true);
   rfalse;
];
! No specific request
! Instead of burning something:
[ R_1038 ;
   if ((action ==##Burn) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1038, 1038);
      ! phrase 1
      ! [1: say ~You have no source of fire, and probably don't want to destroy [the noun] anyway.~]
      say__p=1;ParaContent();  print (PrintText) SC_751; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_750;  new_line; .L_Say441; .L_SayX424;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1038, 1038, true);
   rfalse;
];
! No specific request
! Instead of searching something:
[ R_1041 ;
   if ((action ==##Search) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1041, 1041);
      ! phrase 1
      ! [1: try examining the noun]
       TryAction(0, player, ##Examine, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1041, 1041, true);
   rfalse;
];
! No specific request
! Instead of drinking something:
[ R_1109 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1109, 1109);
      ! phrase 1
      ! [1: if the noun is not a fluid container and the noun is not a liquid source begin]
       if ((((~~((noun ofclass K25_fluid_container))))) && (((~~((noun ofclass K26_liquid_source))))))  {
         ! phrase 2
         ! [2: say ~You can't exactly drink [the noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_752; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say442; .L_SayX425;
         ! phrase 3
         ! [3: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1109, 1109, true);
   rfalse;
];
! No specific request
! Instead of playing something:
[ R_1400 ;
   if ((action ==##A125_playing) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1400, 1400);
      ! phrase 1
      ! [1: say ~That's not something you can play.~]
      say__p=1;ParaContent();  print (PrintText) SC_753;  new_line; .L_Say443; .L_SayX426;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1400, 1400, true);
   rfalse;
];
! No specific request
! Instead of shaking something:
[ R_1403 ;
   if ((action ==##A124_shaking) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1403, 1403);
      ! phrase 1
      ! [1: say ~Nothing much happens.~]
      say__p=1;ParaContent();  print (PrintText) SC_754;  new_line; .L_Say444; .L_SayX427;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1403, 1403, true);
   rfalse;
];
! No specific request
! Instead of exiting when the player is in a room and the player is not on a supporter:
[ R_1062 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && ((((ContainerOf(player) ofclass K1_room))) && ((Prop_40())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1062, 1062);
      ! phrase 1
      ! [1: if at least one room is outward begin]
       if ((Prop_41()))  {
         ! phrase 2
         ! [2: let the destination be a random outward room]
          t_0 =  (Prop_42()) ; 
         ! phrase 3
         ! [3: let the way be the best route from the location to the destination]
          t_1 =  MapRouteTo(real_location,t_0,0,0) ; 
         ! phrase 4
         ! [4: say ~(that is, [way])[command clarification break]~]
         say__p=1;ParaContent();  print (PrintText) SC_508; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say445; .L_SayX428;
         ! phrase 5
         ! [5: try going the way instead]
          TryAction(0, player, ##Go, t_1, 0);;  rtrue;
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: continue the action]
          rfalse; 
         ! phrase 8
         ! [8: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1062, 1062, true);
   rfalse;
];
! No specific request
! Instead of exiting when the location is Inside Waterworks and the player is not on a supporter:
[ R_1376 ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && ((((real_location == I506_inside_waterworks))) && ((Prop_43())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1376, 1376);
      ! phrase 1
      ! [1: try going west]
       TryAction(0, player, ##Go, I53_west, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1376, 1376, true);
   rfalse;
];
! No specific request
! Instead of listening when at least one pump is switched on:
[ R_1181 ;
   if ((action ==##Listen) &&  (actor==player) && (self=actor,true) && ((Prop_44()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1181, 1181);
      ! phrase 1
      ! [1: say ~Somewhere below you you hear a gurgling.~]
      say__p=1;ParaContent();  print (PrintText) SC_755;  new_line; .L_Say446; .L_SayX429;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1181, 1181, true);
   rfalse;
];
! No specific request
! Instead of boarding when the ticket is not held and the conductor is unsatisfied:
[ R_1737 ;
   if ((action ==##A104_boarding) &&  (actor==player) && (self=actor,true) && ((((~~(((Adj_2_t1_v9(I584_ticket))))))) && ((((Adj_143_t1_v9(I711_conductor))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1737, 1737);
      ! phrase 1
      ! [1: if the player is in the station of the steam train and the conductor is distracted begin]
       if ((((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))) && ((((Adj_144_t1_v9(I711_conductor))))))  {
         ! phrase 2
         ! [2: say ~As you try to walk past the conductor onto the train, he startles, and seems to realize where he is again.[paragraph break]~]
         say__p=1;ParaContent();  print (PrintText) SC_756; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say447; .L_SayX430;
         ! phrase 3
         ! [3: now the conductor is undistracted]
          (Adj_145_t2_v9(I711_conductor)); 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if the player is in the station of the steam train , say ~[if the conductor was distracted]He[otherwise]You try to get on the train, but the conductor[end if] shakes his head and blocks your way. 'Sorry, friend! I'd love to let you on, but you gotta have a ticket.'~ instead]
       if (((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))) { say__p=1;
	if (~~((TestSinglePastState(1, 48, false, 1)))) jump L_Say448;
		ParaContent();  print (PrintText) SC_737; 
	jump L_SayX431; .L_Say448;
		ParaContent();  print (PrintText) SC_757; 
	.L_Say449; .L_SayX431;
		ParaContent();  print (PrintText) SC_758;  new_line; .L_Say450; .L_SayX432;  rtrue; }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1737, 1737, true);
   rfalse;
];
! No specific request
! Instead of exiting when the player is in a room and the player is on a supporter:
[ R_1070 ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && ((((ContainerOf(player) ofclass K1_room))) && (((SupporterOf(player) ofclass K6_supporter))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1070, 1070);
      ! phrase 1
      ! [1: try getting off the holder of the player]
       TryAction(0, player, ##GetOff,  (HolderOf(player)) , 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1070, 1070, true);
   rfalse;
];
! No specific request
! Instead of sleeping while the conductor's story is happening:
[ R_1093 ;
   if ((action ==##Sleep) &&  (actor==player) && (self=actor,true) && ((((scene_status-->(I431_conductor_s_story-1)==1))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1093, 1093);
      ! phrase 1
      ! [1: say ~Listening to the conductor talk to you is keeping you awake.~]
      say__p=1;ParaContent();  print (PrintText) SC_759;  new_line; .L_Say451; .L_SayX433;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1093, 1093, true);
   rfalse;
];
! No specific request
! Instead of exiting when the player is in the steam train:
[ R_1139 ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && (((I439_steam_train == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1139, 1139);
      ! phrase 1
      ! [1: if the station of the steam train is the steam train begin]
       if (((GProperty(9, I439_steam_train,p16_station) == I439_steam_train)))  {
         ! phrase 2
         ! [2: say ~You consider leaping from the moving train, but think better of it.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_760;  new_line; rtrue; .L_Say452; .L_SayX434; rtrue;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: move the player to the station of the steam train instead]
          MoveObject(player, GProperty(9, I439_steam_train,p16_station), 0, false);  rtrue;
         ! phrase 5
         ! [5: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1139, 1139, true);
   rfalse;
];
! No specific request
! Instead of listening when the location is the Hill:
[ R_1180 ;
   if ((action ==##Listen) &&  (actor==player) && (self=actor,true) && (((real_location == I441_hill)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1180, 1180);
      ! phrase 1
      ! [1: if the wind chimes are in in the sweetgum tree , say ~You hear a faint tinkling.~]
       if (((I442_in_the_sweetgum_tree == ContainerOf(I563_metal_wind_chimes)))) { say__p=1;ParaContent();  print (PrintText) SC_761;  new_line; .L_Say453; .L_SayX435;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1180, 1180, true);
   rfalse;
];
! No specific request
! Instead of jumping when the player is enclosed by the rowboat:
[ R_1309 ;
   if ((action ==##Jump) &&  (actor==player) && (self=actor,true) && (((IndirectlyContains(I481_rowboat,player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1309, 1309);
      ! phrase 1
      ! [1: say ~You rock the boat.~]
      say__p=1;ParaContent();  print (PrintText) SC_762;  new_line; .L_Say454; .L_SayX436;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1309, 1309, true);
   rfalse;
];
! No specific request
! Instead of jumping when the tall cylinder is visible:
[ R_1330 ;
   if ((action ==##Jump) &&  (actor==player) && (self=actor,true) && ((((Adj_3_t1_v9(I522_tall_cylinder)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1330, 1330);
      ! phrase 1
      ! [1: say ~You leap up, and scrape your fingers against the smooth side of the cylinder, but the top is still inaccessible to you.[if the secretary is visible][line break][one of]'I tried that too! It doesn't work,' says [the secretary][or][The secretary] laughs[stopping].[end if]~]
      say__p=1;ParaContent();  print (PrintText) SC_763;  new_line;
	if (~~(((((Adj_3_t1_v9(I545_secretary_of_water))))))) jump L_Say455;
		ParaContent();  new_line; ParaContent();  I7_ST_say_one_of-->26 =
	i7_soo_stop(I7_ST_say_one_of-->26, 2);
	switch((I7_ST_say_one_of-->26)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_764; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_765; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line;
	.L_Say455; .L_SayX437;
		 .L_Say456; .L_SayX438;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1330, 1330, true);
   rfalse;
];
! No specific request
! Instead of exiting when the player is on a supporter:
[ R_1466 ;
   if ((action ==##Exit) &&  (actor==player) && (self=actor,true) && (((SupporterOf(player) ofclass K6_supporter)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1466, 1466);
      ! phrase 1
      ! [1: try getting off the holder of the player]
       TryAction(0, player, ##GetOff,  (HolderOf(player)) , 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1466, 1466, true);
   rfalse;
];
! No specific request
! Instead of jumping when the player is in Large Clearing:
[ R_1627 ;
   if ((action ==##Jump) &&  (actor==player) && (self=actor,true) && (((I502_large_clearing == ContainerOf(player))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1627, 1627);
      ! phrase 1
      ! [1: say ~You leap up, and just grab the bottom-most rung. From there you easily climb the long series of rungs to the top of the tank.~]
      say__p=1;ParaContent();  print (PrintText) SC_766;  new_line; .L_Say457; .L_SayX439;
      ! phrase 2
      ! [2: move the player to atop the tank]
       MoveObject(player, I469_atop_the_tank, 0, false); 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1627, 1627, true);
   rfalse;
];
! No specific request
! Instead of smelling when the player is wearing the diving mask:
[ R_1667 ;
   if ((action ==##Smell) &&  (actor==player) && (self=actor,true) && (((player == WearerOf(I666_diving_mask))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1667, 1667);
      ! phrase 1
      ! [1: say ~The diving mask gives off a stale, wet odor directly into your nostrils.~]
      say__p=1;ParaContent();  print (PrintText) SC_767;  new_line; .L_Say458; .L_SayX440;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1667, 1667, true);
   rfalse;
];
! No specific request
! Instead of drinking when the player is wearing the diving mask:
[ R_1668 ;
   if ((action ==##Drink) &&  (actor==player) && (self=actor,true) && (((player == WearerOf(I666_diving_mask))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1668, 1668);
      ! phrase 1
      ! [1: say ~You can't drink anything while you're wearing the diving mask.~]
      say__p=1;ParaContent();  print (PrintText) SC_768;  new_line; .L_Say459; .L_SayX441;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1668, 1668, true);
   rfalse;
];
! No specific request
! Instead of looking up when the player is in Underwaterland:
[ R_1678 ;
   if ((action ==##A117_looking_up) &&  (actor==player) && (self=actor,true) && (((TestRegionalContainment(player,I676_underwaterland))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1678, 1678);
      ! phrase 1
      ! [1: say ~You see only a blurred shaft of sunlight through the water.~]
      say__p=1;ParaContent();  print (PrintText) SC_769;  new_line; .L_Say460; .L_SayX442;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1678, 1678, true);
   rfalse;
];
! No specific request
! Instead of swimming when the player is in Underwaterland:
[ R_1690 ;
   if ((action ==##A102_swimming) &&  (actor==player) && (self=actor,true) && (((TestRegionalContainment(player,I676_underwaterland))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1690, 1690);
      ! phrase 1
      ! [1: say ~You're already swimming!~]
      say__p=1;ParaContent();  print (PrintText) SC_770;  new_line; .L_Say461; .L_SayX443;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1690, 1690, true);
   rfalse;
];
! No specific request
! Instead of boarding when the secretary is in Grassy Area:
[ R_1738 ;
   if ((action ==##A104_boarding) &&  (actor==player) && (self=actor,true) && (((I509_grassy_area == ContainerOf(I545_secretary_of_water))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1738, 1738);
      ! phrase 1
      ! [1: say ~You take a step toward the train, but then stop. [the secretary] had looked... agitated? nervous?, and you can't help feeling that you're part of the cause of her distress, and that maybe you shouldn't run away from her.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_771; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_772;  new_line; rtrue; .L_Say462; .L_SayX444; rtrue;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1738, 1738, true);
   rfalse;
];
! No specific request
! Instead of boarding when the steam train is flooded:
[ R_1739 ;
   if ((action ==##A104_boarding) &&  (actor==player) && (self=actor,true) && ((((Adj_136_t1_v9(I439_steam_train)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1739, 1739);
      ! phrase 1
      ! [1: say ~The train is closed, locked, and shut down. Either the conductor is preparing it for storage and the anticipated flood, or he's already gone; either way, this doesn't look like the train is going anywhere anytime soon.~]
      say__p=1;ParaContent();  print (PrintText) SC_773;  new_line; .L_Say463; .L_SayX445;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1739, 1739, true);
   rfalse;
];
! No specific request
! Instead of jumping or dancing when the player is trapped:
[ R_1378 ;
   if ((action ==##A115_dancing or ##Jump) &&  (actor==player) && (self=actor,true) && ((((Adj_130_t1_v9(player)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1378, 1378);
      ! phrase 1
      ! [1: say ~You only sink further.~]
      say__p=1;ParaContent();  print (PrintText) SC_774;  new_line; .L_Say464; .L_SayX446;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1378, 1378, true);
   rfalse;
];
! No specific request
! Instead of shouting or singing when the player is wearing the diving mask:
[ R_1672 ;
   if ((action ==##Sing or ##A93_shouting) &&  (actor==player) && (self=actor,true) && (((player == WearerOf(I666_diving_mask))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1672, 1672);
      ! phrase 1
      ! [1: say ~The mask is tight against your face, and no sound escapes.~]
      say__p=1;ParaContent();  print (PrintText) SC_775;  new_line; .L_Say465; .L_SayX447;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1672, 1672, true);
   rfalse;
];
! No specific request
! Instead of eating or drinking when the player is wearing the diving mask:
[ R_1681 ;
   if ((action ==##Drink or ##Eat) &&  (actor==player) && (self=actor,true) && (((player == WearerOf(I666_diving_mask))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1681, 1681);
      ! phrase 1
      ! [1: say ~The mask blocks access to your mouth.~]
      say__p=1;ParaContent();  print (PrintText) SC_776;  new_line; .L_Say466; .L_SayX448;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1681, 1681, true);
   rfalse;
];
! No specific request
! Instead of speech when Endgame is happening and the player is wearing the diving mask:
[ R_1719 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((((scene_status-->(I695_endgame-1)==1)))) && (((player == WearerOf(I666_diving_mask)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1719, 1719);
      ! phrase 1
      ! [1: say ~You try to speak, but with the diving mask on it just comes out an incomprehensible burble.[paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) SC_777; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say467; .L_SayX449;
      ! phrase 2
      ! [2: say ~[the noun] notices your attempt. [The apology of the noun]~]
      say__p=1;ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_778; ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=noun,p17_apology); @pull self;  .L_Say468; .L_SayX450;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1719, 1719, true);
   rfalse;
];
! No specific request
! Instead of speech when the noun is the Secretary of Water:
[ R_1377 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((noun == I545_secretary_of_water)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1377, 1377);
      ! phrase 1
      ! [1: if the player is in pump room begin]
       if (((I510_pump_room == ContainerOf(player))))  {
         ! phrase 2
         ! [2: say ~[one of]'Just come back up here and we can talk.'[or]'Look, all I need right now is for you to stop messing with the pump.'[or]'Just stop what you're doing and come back upstairs.' She tries to look authoritative, but it comes across more... petulant.[at random]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->27 =
	i7_soo_ran(I7_ST_say_one_of-->27, 3);
	switch((I7_ST_say_one_of-->27)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_779;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_780;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_781;  new_line;ParaContent();  }  .L_Say469; .L_SayX451;
         ! phrase 3
         ! [3: otherwise if the secretary is in grassy area]
          } else if (((I509_grassy_area == ContainerOf(I545_secretary_of_water)))) { 
         ! phrase 4
         ! [4: repeat through table of further secretary's commentary begin]
          @push ct_0; @push ct_1;
		for (t_0=T13_further_secretary_s_comm,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
              if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
            ! phrase 5
            ! [5: if the topic understood includes topic entry begin]
             if (( (matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number)) ))  {
               ! phrase 6
               ! [6: if there is a commentary entry begin]
                if (( (ExistsTableLookUpEntry(ct_0,117,ct_1)) ))  {
                  ! phrase 7
                  ! [7: say ~[commentary entry][paragraph break]~]
                  say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,117,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say470; .L_SayX452;
                  ! phrase 8
                  ! [8: blank out the commentary entry]
                   TableLookUpEntry(ct_0,117,ct_1,4); 
                  ! phrase 9
                  ! [9: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 10
                  ! [10: otherwise]
                  } else {

                  ! phrase 11
                  ! [11: say ~[one of]'I thought I already explained that, '[or]'I'm telling you a bunch of stuff I'm not supposed to, so the least you can do is remember it,'[at random] [the secretary] says[one of] irritably[or], jerking hard on the rope[at random].~]
                  say__p=1;ParaContent();  I7_ST_say_one_of-->28 =
	i7_soo_ran(I7_ST_say_one_of-->28, 2);
	switch((I7_ST_say_one_of-->28)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_782; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_783; ParaContent();  } ParaContent();  print (PrintText) SC_387; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_659; ParaContent();  I7_ST_say_one_of-->29 =
	i7_soo_ran(I7_ST_say_one_of-->29, 2);
	switch((I7_ST_say_one_of-->29)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_784; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_785; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say471; .L_SayX453;
                  ! phrase 12
                  ! [12: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 13
                  ! [13: end if]
                  }

               ! phrase 14
               ! [14: end if]
               }

            ! phrase 15
            ! [15: end repeat]
            }
@pull ct_1; @pull ct_0;
           if (debug_rules>1) print "  [15: end repeat]^";
         ! phrase 16
         ! [16: say ~[one of]'That's not important right now,' she says.[or][The secretary] ignores your question.[at random]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->30 =
	i7_soo_ran(I7_ST_say_one_of-->30, 2);
	switch((I7_ST_say_one_of-->30)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_786;  new_line;ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_787;  new_line;ParaContent();  }  .L_Say472; .L_SayX454;
         ! phrase 17
         ! [17: otherwise if the secretary is irked]
          } else if ((((Adj_114_t1_v9(I545_secretary_of_water))))) { 
         ! phrase 18
         ! [18: say ~[one of]'Look, you can get into a lot of trouble here if you're too curious.'[or]'I [bold type]asked[roman type] you not to mess with the pump. I'll definitely get in trouble now if I talk to you more.'[or]She half smiles. 'Look, of [bold type]course[roman type] you're curious! I'm definitely curious about... well, never mind. But I'll get in trouble if anyone finds out you saw the pump, and I'll get in trouble if I talk to you any more about that.'[at random]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->31 =
	i7_soo_ran(I7_ST_say_one_of-->31, 3);
	switch((I7_ST_say_one_of-->31)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_788;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_789; ParaContent();  style bold; ParaContent();  print (PrintText) SC_790; ParaContent();  style roman; ParaContent();  print (PrintText) SC_791;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_792; ParaContent();  style bold; ParaContent();  print (PrintText) SC_793; ParaContent();  style roman; ParaContent();  print (PrintText) SC_794;  new_line;ParaContent();  }  .L_Say473; .L_SayX455;
         ! phrase 19
         ! [19: otherwise]
         } else {

         ! phrase 20
         ! [20: repeat through table of secretary's commentary begin]
          @push ct_0; @push ct_1;
		for (t_0=T14_secretary_s_commentary,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
              if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
            ! phrase 21
            ! [21: if the topic understood includes ~self/secretary/name~ begin]
             if (( (matched_text=SnippetIncludes(Consult_Grammar_366,parsed_number)) ))  {
               ! phrase 22
               ! [22: now the printed name of the secretary is ~Adriana~]
                WriteGProperty(9, I545_secretary_of_water,short_name,SC_795); 
               ! phrase 23
               ! [23: now the secretary is proper-named]
                (Adj_43_t2_v9(I545_secretary_of_water)); 
               ! phrase 24
               ! [24: end if]
               }

            ! phrase 25
            ! [25: if the topic understood includes topic entry begin]
             if (( (matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number)) ))  {
               ! phrase 26
               ! [26: say ~[commentary entry][paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,117,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say474; .L_SayX456;
               ! phrase 27
               ! [27: rule succeeds]
                RulebookSucceeds(); rtrue; 
               ! phrase 28
               ! [28: end if]
               }

            ! phrase 29
            ! [29: end repeat]
            }
@pull ct_1; @pull ct_0;
           if (debug_rules>1) print "  [29: end repeat]^";
         ! phrase 30
         ! [30: say ~[one of][The Secretary] gives you a little half-smile, without answering.[or]'Sorry, can't help you.'[or]'The what?'[or][The Secretary] just looks confused.[at random]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->32 =
	i7_soo_ran(I7_ST_say_one_of-->32, 4);
	switch((I7_ST_say_one_of-->32)%(4+1)-1) {
		0: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_796;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_797;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_798;  new_line;ParaContent();  @nop; 3: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_799;  new_line;ParaContent();  }  .L_Say475; .L_SayX457;
         ! phrase 31
         ! [31: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1377, 1377, true);
   rfalse;
];
! No specific request
! Instead of speech when the noun is the dog:
[ R_1548 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((noun == I443_dog)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1548, 1548);
      ! phrase 1
      ! [1: say ~The dog barks softly.~]
      say__p=1;ParaContent();  print (PrintText) SC_800;  new_line; .L_Say476; .L_SayX458;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1548, 1548, true);
   rfalse;
];
! No specific request
! Instead of speech when the noun is the family:
[ R_1617 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((noun == I650_family)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1617, 1617);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say477; .L_SayX459;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1617, 1617, true);
   rfalse;
];
! No specific request
! Instead of speech when the noun is the daughter:
[ R_1618 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((noun == I652_daughter)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1618, 1618);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say478; .L_SayX460;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1618, 1618, true);
   rfalse;
];
! No specific request
! Instead of speech when the noun is the father:
[ R_1619 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((noun == I651_father)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1619, 1619);
      ! phrase 1
      ! [1: say ~The house is far away and the family is inside.~]
      say__p=1;ParaContent();  print (PrintText) SC_722;  new_line; .L_Say479; .L_SayX461;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1619, 1619, true);
   rfalse;
];
! No specific request
! Instead of speech when the player is wearing the diving mask:
[ R_1673 ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((player == WearerOf(I666_diving_mask))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1673, 1673);
      ! phrase 1
      ! [1: say ~The mask is tight against your face, and no sound escapes.~]
      say__p=1;ParaContent();  print (PrintText) SC_775;  new_line; .L_Say480; .L_SayX462;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1673, 1673, true);
   rfalse;
];
! No specific request
! Instead of speech when the noun is the Conductor:
[ R_1743 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
   if ((NAP_0()) &&  (actor==player) && (self=actor,true) && (((noun == I711_conductor)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1743, 1743);
      ! phrase 1
      ! [1: if the conductor's story is happening begin]
       if ((((scene_status-->(I431_conductor_s_story-1)==1))))  {
         ! phrase 2
         ! [2: repeat through table of further conductor's commentary begin]
          @push ct_0; @push ct_1;
		for (t_0=T10_further_conductor_s_comm,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
              if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
            ! phrase 3
            ! [3: if the topic understood includes topic entry begin]
             if (( (matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number)) ))  {
               ! phrase 4
               ! [4: if there is a commentary entry begin]
                if (( (ExistsTableLookUpEntry(ct_0,117,ct_1)) ))  {
                  ! phrase 5
                  ! [5: say ~[commentary entry][paragraph break]~]
                  say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,117,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say481; .L_SayX463;
                  ! phrase 6
                  ! [6: blank out the commentary entry]
                   TableLookUpEntry(ct_0,117,ct_1,4); 
                  ! phrase 7
                  ! [7: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 8
                  ! [8: otherwise]
                  } else {

                  ! phrase 9
                  ! [9: say ~[one of]'I think we already talked about that.'[or]The conductor just gives you a look.[at random][line break]~]
                  say__p=1;ParaContent();  I7_ST_say_one_of-->33 =
	i7_soo_ran(I7_ST_say_one_of-->33, 2);
	switch((I7_ST_say_one_of-->33)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_801;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_802;  new_line;ParaContent();  } ParaContent();  new_line;  .L_Say482; .L_SayX464;
                  ! phrase 10
                  ! [10: continue the conductor's story]
                  (PHR_1092_r5 ());
                  ! phrase 11
                  ! [11: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 12
                  ! [12: end if]
                  }

               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end repeat]
            }
@pull ct_1; @pull ct_0;
           if (debug_rules>1) print "  [14: end repeat]^";
         ! phrase 15
         ! [15: say ~[one of]'Let's not get into that now,' he says.[or][The conductor] pokes some piece of train machinery, ignoring your question.[at random][line break]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->34 =
	i7_soo_ran(I7_ST_say_one_of-->34, 2);
	switch((I7_ST_say_one_of-->34)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_803;  new_line;ParaContent();  @nop; 1: ParaContent();  print (The) I711_conductor; ParaContent();  print (PrintText) SC_804;  new_line;ParaContent();  } ParaContent();  new_line;  .L_Say483; .L_SayX465;
         ! phrase 16
         ! [16: continue the conductor's story]
         (PHR_1092_r5 ());
         ! phrase 17
         ! [17: otherwise]
         } else {

         ! phrase 18
         ! [18: repeat through table of conductor's commentary begin]
          @push ct_0; @push ct_1;
		for (t_0=T17_conductor_s_commentary,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
              if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
            ! phrase 19
            ! [19: if the topic understood includes topic entry begin]
             if (( (matched_text=SnippetIncludes(TableLookUpEntry(ct_0,102,ct_1),parsed_number)) ))  {
               ! phrase 20
               ! [20: say ~[commentary entry][paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,117,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say484; .L_SayX466;
               ! phrase 21
               ! [21: rule succeeds]
                RulebookSucceeds(); rtrue; 
               ! phrase 22
               ! [22: end if]
               }

            ! phrase 23
            ! [23: end repeat]
            }
@pull ct_1; @pull ct_0;
           if (debug_rules>1) print "  [23: end repeat]^";
         ! phrase 24
         ! [24: if the topic understood includes ~train~ or the topic understood includes ~trains~ or the topic understood includes ~steam train~ begin]
          if ((( (matched_text=SnippetIncludes(Consult_Grammar_367,parsed_number)) )) || ((( (matched_text=SnippetIncludes(Consult_Grammar_368,parsed_number)) )) || (( (matched_text=SnippetIncludes(Consult_Grammar_369,parsed_number)) ))))  {
            ! phrase 25
            ! [25: now the conductor is distracted]
             (Adj_144_t2_v9(I711_conductor)); 
            ! phrase 26
            ! [26: the conductor says the second train monologue in one turn from now]
             SetTimedEvent(R_1744, 1+1, 0); 
            ! phrase 27
            ! [27: the conductor says the third train monologue in two turns from now]
             SetTimedEvent(R_1745, 2+1, 0); 
            ! phrase 28
            ! [28: the conductor shuts up in three turns from now]
             SetTimedEvent(R_1746, 3+1, 0); 
            ! phrase 29
            ! [29: say ~[one of]'Trains! Now there's something I know about!' The conductor smiles, and gets a glazed look in his eye; in fact, now that he's on his favorite subject, he doesn't seem to be paying attention to anything you're doing.[paragraph break]'Now this one we're riding is the PX1105; she has a rolling resistance of about 0.0005, which means she has to be pretty heavy to get enough traction. Almost three tons! Steam-powered, of course; there are those who say it's obsolete, but give me a taper boiler like this one any day.'[or]The conductor starts up again telling you about the many features of his train; you don't really follow the purpose of most of them, but he clearly seems to think they're exciting. While he's talking about the train, he doesn't seem to be paying attention to you.[stopping]~]
            say__p=1;ParaContent();  I7_ST_say_one_of-->35 =
	i7_soo_stop(I7_ST_say_one_of-->35, 2);
	switch((I7_ST_say_one_of-->35)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_805; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_806;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_807;  new_line;ParaContent();  }  .L_Say485; .L_SayX467;
            ! phrase 30
            ! [30: otherwise]
            } else {

            ! phrase 31
            ! [31: say ~[one of]The conductor turns away from you, whistling[or]'Sorry, trains are really more my bag,' he replies[or]'Mmm,' says the conductor[at random].~]
            say__p=1;ParaContent();  I7_ST_say_one_of-->36 =
	i7_soo_ran(I7_ST_say_one_of-->36, 3);
	switch((I7_ST_say_one_of-->36)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_808; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_809; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_810; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say486; .L_SayX468;
            ! phrase 32
            ! [32: end if]
            }

         ! phrase 33
         ! [33: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1743, 1743, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Instead of going nowhere ( this is the Small Kindnesses reporting on exits rule ):
[ R_752 ;
   if ((action ==##Go) &&  (actor==player) && ((MStack-->MstVON(20007,1)) == nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_752, 752);
      ! phrase 1
      ! [1: if the no normal movement tricks option is active , continue the action]
       if ((((Adj_22_t1_v15(22))))) {  rfalse;   }
      ! phrase 2
      ! [2: if in darkness begin]
       if (( (location==thedark) ))  {
         ! phrase 3
         ! [3: issue miscellaneous library message number 17]
          GL__M(##Miscellany,17); 
         ! phrase 4
         ! [4: stop the action]
          rtrue; 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: issue library message going action number 2 for the room gone from]
       GL__M(##Go,2,(MStack-->MstVO(20007,0))); 
      ! phrase 7
      ! [7: try listing exits]
       TryAction(0, player, ##A82_listing_exits, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_752, 752, true);
   rfalse;
];
! No specific request
! Instead of exiting from the rowboat:
[ R_1281 ;
   if ((action ==##Exit) &&  (actor==player) && (((MStack-->MstVON(20009,0)) == I481_rowboat) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1281, 1281);
      ! phrase 1
      ! [1: if the location is floating on the pond or the location is spireland begin]
       if ((((real_location == I466_floating_on_the_pond))) || (((real_location == I465_spireland))))  {
         ! phrase 2
         ! [2: try swimming]
          TryAction(0, player, ##A102_swimming, 0, 0);; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: continue the action]
          rfalse; 
         ! phrase 5
         ! [5: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1281, 1281, true);
   rfalse;
];
! No specific request
! Instead of swearing obscenely:
[ R_1035 ;
   if ((action ==##Strong) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1035, 1035);
      ! phrase 1
      ! [1: say ~You curse in frustration.~]
      say__p=1;ParaContent();  print (PrintText) SC_811;  new_line; .L_Say487; .L_SayX469;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1035, 1035, true);
   rfalse;
];
! No specific request
! Instead of swearing mildly:
[ R_1036 ;
   if ((action ==##Mild) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1036, 1036);
      ! phrase 1
      ! [1: say ~You curse in frustration.~]
      say__p=1;ParaContent();  print (PrintText) SC_811;  new_line; .L_Say488; .L_SayX470;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1036, 1036, true);
   rfalse;
];
! No specific request
! Instead of thinking:
[ R_1048 ;
   if ((action ==##Think) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1048, 1048);
      ! phrase 1
      ! [1: say ~You ponder your situation.~]
      say__p=1;ParaContent();  print (PrintText) SC_812;  new_line; .L_Say489; .L_SayX471;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1048, 1048, true);
   rfalse;
];
! No specific request
! Instead of praying:
[ R_1049 ;
   if ((action ==##A91_praying) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1049, 1049);
      ! phrase 1
      ! [1: say ~Nothing happens to your immediate surroundings, but you do feel a little better.~]
      say__p=1;ParaContent();  print (PrintText) SC_813;  new_line; .L_Say490; .L_SayX472;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1049, 1049, true);
   rfalse;
];
! No specific request
! Instead of blowing:
[ R_1050 ;
   if ((action ==##A92_blowing) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1050, 1050);
      ! phrase 1
      ! [1: say ~You blow on [the noun], but nothing happens.~]
      say__p=1;ParaContent();  print (PrintText) SC_814; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_815;  new_line; .L_Say491; .L_SayX473;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1050, 1050, true);
   rfalse;
];
! No specific request
! Instead of singing:
[ R_1055 ;
   if ((action ==##Sing) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1055, 1055);
      ! phrase 1
      ! [1: say ~You hum a few bars.~]
      say__p=1;ParaContent();  print (PrintText) SC_816;  new_line; .L_Say492; .L_SayX474;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1055, 1055, true);
   rfalse;
];
! No specific request
! Instead of shouting:
[ R_1056 ;
   if ((action ==##A93_shouting) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1056, 1056);
      ! phrase 1
      ! [1: say ~Your voice echoes. [if a person that is not the player is in the location of the player][The random visible person that is not the player] looks startled[otherwise]There is no response[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_817; 
	if (~~(((Prop_45(, LocationOf(player) ))))) jump L_Say493;
		ParaContent();  print (The)  (Prop_46()) ; ParaContent();  print (PrintText) SC_818; 
	jump L_SayX475; .L_Say493;
		ParaContent();  print (PrintText) SC_819; 
	.L_Say494; .L_SayX475;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say495; .L_SayX476;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1056, 1056, true);
   rfalse;
];
! No specific request
! Instead of swimming:
[ R_1127 ;
   if ((action ==##A102_swimming) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1127, 1127);
      ! phrase 1
      ! [1: say ~There's nothing here to swim in.~]
      say__p=1;ParaContent();  print (PrintText) SC_820;  new_line; .L_Say496; .L_SayX477;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1127, 1127, true);
   rfalse;
];
! No specific request
! Instead of jumping:
[ R_1177 ;
   if ((action ==##Jump) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1177, 1177);
      ! phrase 1
      ! [1: say ~You leap up, and are several inches off the ground before gravity returns you to it.~]
      say__p=1;ParaContent();  print (PrintText) SC_821;  new_line; .L_Say497; .L_SayX478;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1177, 1177, true);
   rfalse;
];
! No specific request
! Instead of smelling:
[ R_1179 ;
   if ((action ==##Smell) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1179, 1179);
      ! phrase 1
      ! [1: say ~You catch a faint damp, muddy whiff.~]
      say__p=1;ParaContent();  print (PrintText) SC_822;  new_line; .L_Say498; .L_SayX479;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1179, 1179, true);
   rfalse;
];
! No specific request
! Instead of listening:
[ R_1182 ;
   if ((action ==##Listen) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1182, 1182);
      ! phrase 1
      ! [1: say ~Only the faint [one of]lapping of the pond[or]whistle of the wind[at random].~]
      say__p=1;ParaContent();  print (PrintText) SC_823; ParaContent();  I7_ST_say_one_of-->37 =
	i7_soo_ran(I7_ST_say_one_of-->37, 2);
	switch((I7_ST_say_one_of-->37)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_824; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_825; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say499; .L_SayX480;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1182, 1182, true);
   rfalse;
];
! No specific request
! Instead of waving hands:
[ R_1183 ;
   if ((action ==##WaveHands) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1183, 1183);
      ! phrase 1
      ! [1: say ~You wave your hands, feeling the cool, damp [if the player is in Underwater]water[otherwise]air[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_826; 
	if (~~((((I669_underwater == ContainerOf(player)))))) jump L_Say500;
		ParaContent();  print (PrintText) SC_827; 
	jump L_SayX481; .L_Say500;
		ParaContent();  print (PrintText) SC_828; 
	.L_Say501; .L_SayX481;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say502; .L_SayX482;
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1183, 1183, true);
   rfalse;
];
! No specific request
! Instead of taking inventory:
[ R_1204 ;
   if ((action ==##Inv) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1204, 1204);
      ! phrase 1
      ! [1: say ~You are holding [a list of things carried by the player].~]
      say__p=1;ParaContent();  print (PrintText) SC_829; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (player == CarrierOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say503; .L_SayX483;
      ! phrase 2
      ! [2: if the player wears something , say ~[line break]You are wearing [a list of things worn by the player].~]
       if ((Prop_47())) { say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_830; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (player == WearerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say504; .L_SayX484;  }
      ! phrase 3
      ! [3: if the player has the coat begin]
       if (((player == OwnerOf(I450_your_coat))))  {
         ! phrase 4
         ! [4: if the left pocket contains nothing and the right pocket contains nothing , say ~[line break]Both the pockets of your coat are empty.~]
          if (((Prop_48())) && ((Prop_49()))) { say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_831;  new_line; .L_Say505; .L_SayX485;  }
         ! phrase 5
         ! [5: otherwise say ~[line break][if the left pocket contains nothing]The left pocket of your coat is empty[otherwise]In the left pocket of your coat [is-are a list of things in the left pocket][end if], and [if the right pocket contains nothing]the right pocket is empty[otherwise]in the right pocket [is-are a list of things in the right pocket][end if].~]
          else { say__p=1;ParaContent();  new_line; 
	if (~~(((Prop_50())))) jump L_Say506;
		ParaContent();  print (PrintText) SC_832; 
	jump L_SayX486; .L_Say506;
		ParaContent();  print (PrintText) SC_833; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I452_left_pocket == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+ISARE_BIT);
		@pull subst__v; 
	.L_Say507; .L_SayX486;
		ParaContent();  print (PrintText) SC_834; 
	if (~~(((Prop_51())))) jump L_Say508;
		ParaContent();  print (PrintText) SC_835; 
	jump L_SayX487; .L_Say508;
		ParaContent();  print (PrintText) SC_836; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I451_right_pocket == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+ISARE_BIT);
		@pull subst__v; 
	.L_Say509; .L_SayX487;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say510; .L_SayX488;  }
         ! phrase 6
         ! [6: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1204, 1204, true);
   rfalse;
];
! No specific request
! Instead of wading:
[ R_1261 ;
   if ((action ==##A113_wading) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1261, 1261);
      ! phrase 1
      ! [1: if the player is in outside waterworks begin]
       if (((I447_outside_waterworks == ContainerOf(player))))  {
         ! phrase 2
         ! [2: try entering the structure]
          TryAction(0, player, ##Enter, I477_structure, 0);; 
         ! phrase 3
         ! [3: otherwise if the player is in rocky beach]
          } else if (((I470_rocky_beach == ContainerOf(player)))) { 
         ! phrase 4
         ! [4: try entering the structure]
          TryAction(0, player, ##Enter, I477_structure, 0);; 
         ! phrase 5
         ! [5: otherwise if the player is in muddy beach]
          } else if (((I468_muddy_beach == ContainerOf(player)))) { 
         ! phrase 6
         ! [6: try entering the structure]
          TryAction(0, player, ##Enter, I477_structure, 0);; 
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: if the pond is visible , try swimming]
          if ((((Adj_3_t1_v9(I463_pond))))) {  TryAction(0, player, ##A102_swimming, 0, 0);;   }
         ! phrase 9
         ! [9: otherwise say ~You can't wade from here.~]
          else { say__p=1;ParaContent();  print (PrintText) SC_837;  new_line; .L_Say511; .L_SayX489;  }
         ! phrase 10
         ! [10: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1261, 1261, true);
   rfalse;
];
! No specific request
! Instead of looking up:
[ R_1313 ;
   if ((action ==##A117_looking_up) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1313, 1313);
      ! phrase 1
      ! [1: try examining the sky]
       TryAction(0, player, ##Examine, I515_sky, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1313, 1313, true);
   rfalse;
];
! No specific request
! Instead of tightening:
[ R_1345 ;
   if ((action ==##A119_tightening) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1345, 1345);
      ! phrase 1
      ! [1: if the noun is the janky bolt and the second noun is the wrench begin]
       if ((((noun == I533_janky_bolt))) && (((second == I710_wrench))))  {
         ! phrase 2
         ! [2: say ~You tighten the janky bolt on the square gizmo, and switch it on. It starts to twitch a little.~]
         say__p=1;ParaContent();  print (PrintText) SC_838;  new_line; .L_Say512; .L_SayX490;
         ! phrase 3
         ! [3: now the square gizmo is fixed]
          (Adj_120_t2_v9(I532_square_gizmo)); 
         ! phrase 4
         ! [4: now the printed name of the janky bolt is ~secure bolt~]
          WriteGProperty(9, I533_janky_bolt,short_name,SC_839); 
         ! phrase 5
         ! [5: now the square gizmo is switched on]
          (Adj_80_t2_v9(I532_square_gizmo)); 
         ! phrase 6
         ! [6: continue the action]
          rfalse; 
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~Tightening [the noun] seems pointless.~]
         say__p=1;ParaContent();  print (PrintText) SC_840; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_631;  new_line; .L_Say513; .L_SayX491;
         ! phrase 9
         ! [9: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1345, 1345, true);
   rfalse;
];
! No specific request
! Instead of thing-barking:
[ R_1549 ;
   if ((action ==##A129_thing_barking) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1549, 1549);
      ! phrase 1
      ! [1: try barking]
       TryAction(0, player, ##A128_barking, 0, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1549, 1549, true);
   rfalse;
];
! No specific request
! Instead of magnet-waving:
[ R_1584 ;
   if ((action ==##A131_magnet_waving) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1584, 1584);
      ! phrase 1
      ! [1: try taking the old key with the magnet]
       TryAction(0, player, ##A130_taking_it_with, I640_old_key, I604_large_magnet);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1584, 1584, true);
   rfalse;
];
! No specific request
! Instead of boat-examining:
[ R_1663 ;
   if ((action ==##A133_boat_examining) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1663, 1663);
      ! phrase 1
      ! [1: if the location of the rowboat is boat house and the waterstained door is closed , say ~You can't see it from here.~]
       if (((( LocationOf(I481_rowboat)  == I479_boat_house))) && ((((Adj_71_t1_v9(I482_waterstained_door)))))) { say__p=1;ParaContent();  print (PrintText) SC_522;  new_line; .L_Say514; .L_SayX492;  }
      ! phrase 2
      ! [2: otherwise say ~You can just make out the rowboat floating near the [the location of the rowboat in lower case].~]
       else { say__p=1;ParaContent();  print (PrintText) SC_841; ParaContent();  Decapitalize( LocationOf(I481_rowboat) ); ParaContent();  print (PrintText) SC_250;  new_line; .L_Say515; .L_SayX493;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1663, 1663, true);
   rfalse;
];
! No specific request
! Instead of lock-picking:
[ R_1731 ;
   if ((action ==##A136_lock_picking) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1731, 1731);
      ! phrase 1
      ! [1: if the noun is a locked door or the noun is the center lock or the noun is the structure lock , say ~You fumble around, but you really don't have the skills to pick a lock.~]
       if ((((noun ofclass K4_door) && ((Adj_75_t1_v9(noun))))) || ((((noun == I706_center_lock))) || (((noun == I705_structure_lock))))) { say__p=1;ParaContent();  print (PrintText) SC_842;  new_line; .L_Say516; .L_SayX494;  }
      ! phrase 2
      ! [2: otherwise say ~You can't pick that!~]
       else { say__p=1;ParaContent();  print (PrintText) SC_843;  new_line; .L_Say517; .L_SayX495;  }
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1731, 1731, true);
   rfalse;
];
! No specific request
! Instead of double-lock-picking:
[ R_1732 ;
   if ((action ==##A137_double_lock_picking) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1732, 1732);
      ! phrase 1
      ! [1: try lock-picking the noun]
       TryAction(0, player, ##A136_lock_picking, noun, 0);; 
      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1732, 1732, true);
   rfalse;
];
! No specific request
! Instead of sleeping:
[ R_1755 ;
   if ((action ==##Sleep) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1755, 1755);
      ! phrase 1
      ! [1: if the location of the player is the steam train begin]
       if ((( LocationOf(player)  == I439_steam_train)))  {
         ! phrase 2
         ! [2: if third pump is not happening begin]
          if (((~~(((scene_status-->(I430_third_pump-1)==1))))))  {
            ! phrase 3
            ! [3: if the player is not on the seat , silently try entering the seat]
             if (((~~((I707_seat == SupporterOf(player)))))) {  @push keep_silent; keep_silent=1; TryAction(0, player, ##Enter, I707_seat, 0);; @pull keep_silent;   }
            ! phrase 4
            ! [4: say ~You settle down on one of the seats and nap fitfully, soothed by the gentle rumble of the train; you dream of [one of]wandering through the Crystal City, enveloped in its glittering reflections, sharing a deep love with its inhabitants.[or]plodding through an endless and seemingly identical parade of pondside beaches, digging in each one for something very important, you know it's important but you don't know what it is...[or]being in a boat, a small boat, and somehow it tips over and you're drowning, drowning...[at random]~]
            say__p=1;ParaContent();  print (PrintText) SC_844; ParaContent();  I7_ST_say_one_of-->38 =
	i7_soo_ran(I7_ST_say_one_of-->38, 3);
	switch((I7_ST_say_one_of-->38)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_845;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_846;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_847;  new_line;ParaContent();  }  .L_Say518; .L_SayX496;
            ! phrase 5
            ! [5: now the player is asleep]
             (Adj_146_t2_v9(player)); 
            ! phrase 6
            ! [6: if the station of the steam train is other side of the pond begin]
             if (((GProperty(9, I439_steam_train,p16_station) == I494_other_side_of_the_pond)))  {
               ! phrase 7
               ! [7: while the station of the steam train is other side of the pond begin]
                while (((GProperty(9, I439_steam_train,p16_station) == I494_other_side_of_the_pond)))  {
                  ! phrase 8
                  ! [8: follow the turn sequence rules]
                   FollowRulebook(2); 
                  ! phrase 9
                  ! [9: end while]
                  }

               ! phrase 10
               ! [10: end if]
               }

            ! phrase 11
            ! [11: if the station of the steam train is freshwater crossing begin]
             if (((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing)))  {
               ! phrase 12
               ! [12: while the station of the steam train is freshwater crossing begin]
                while (((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing)))  {
                  ! phrase 13
                  ! [13: follow the turn sequence rules]
                   FollowRulebook(2); 
                  ! phrase 14
                  ! [14: end while]
                  }

               ! phrase 15
               ! [15: end if]
               }

            ! phrase 16
            ! [16: while the station of the steam train is the steam train begin]
             while (((GProperty(9, I439_steam_train,p16_station) == I439_steam_train)))  {
               ! phrase 17
               ! [17: follow the turn sequence rules]
                FollowRulebook(2); 
               ! phrase 18
               ! [18: end while]
               }

            ! phrase 19
            ! [19: now the player is awake]
             (Adj_147_t2_v9(player)); 
            ! phrase 20
            ! [20: if the player is on the seat , silently try exiting]
             if (((I707_seat == SupporterOf(player)))) {  @push keep_silent; keep_silent=1; TryAction(0, player, ##Exit, 0, 0);; @pull keep_silent;   }
            ! phrase 21
            ! [21: say ~...[paragraph break]...[paragraph break]You awake with a jolt, uncertain how long you've slept, as the conductor taps you on the shoulder. '[one of][']Scuse me. [or][stopping]We're here.' You get up and [one of]rub your eyes[or]stretch[or]smile, embarrassed, at the conductor[at random] and peer out the window[if the station of the steam train is Freshwater Crossing] at Freshwater Crossing.[end if][if the station of the steam train is Other Side Of The Pond], where you see a misty clearing.[end if]~]
            say__p=1;ParaContent();  print (PrintText) SC_848; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_848; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_849; ParaContent();  I7_ST_say_one_of-->39 =
	i7_soo_stop(I7_ST_say_one_of-->39, 2);
	switch((I7_ST_say_one_of-->39)%(2+1)-1) {
		0: ParaContent();  print "'"; ParaContent();  print (PrintText) SC_850; ParaContent();  @nop; 1: ParaContent();  } ParaContent();  print (PrintText) SC_851; ParaContent();  I7_ST_say_one_of-->40 =
	i7_soo_ran(I7_ST_say_one_of-->40, 3);
	switch((I7_ST_say_one_of-->40)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_852; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_853; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_854; ParaContent();  } ParaContent();  print (PrintText) SC_855; 
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing))))) jump L_Say519;
		ParaContent();  print (PrintText) SC_856;  new_line;
	.L_Say519; .L_SayX497;
		
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I494_other_side_of_the_pond))))) jump L_Say520;
		ParaContent();  print (PrintText) SC_857;  new_line;
	.L_Say520; .L_SayX498;
		 .L_Say521; .L_SayX499;
            ! phrase 22
            ! [22: otherwise]
            } else {

            ! phrase 23
            ! [23: if the player is not on the seat , try entering the seat]
             if (((~~((I707_seat == SupporterOf(player)))))) {  TryAction(0, player, ##Enter, I707_seat, 0);;   }
            ! phrase 24
            ! [24: say ~You try to get comfortable, but you just toss and turn on the train seat.~]
            say__p=1;ParaContent();  print (PrintText) SC_858;  new_line; .L_Say522; .L_SayX500;
            ! phrase 25
            ! [25: end if]
            }

         ! phrase 26
         ! [26: otherwise if the player is on the bench]
          } else if (((I552_bench == SupporterOf(player)))) { 
         ! phrase 27
         ! [27: say ~You curl up on the bench and toss and turn for a few minutes...~]
         say__p=1;ParaContent();  print (PrintText) SC_859;  new_line; .L_Say523; .L_SayX501;
         ! phrase 28
         ! [28: now the player is asleep]
          (Adj_146_t2_v9(player)); 
         ! phrase 29
         ! [29: silently try waiting more a random number between 2 and 10]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##A106_waiting_more,  R_DecimalNumber(2, 10) , 0);; @pull keep_silent; 
         ! phrase 30
         ! [30: now the player is awake]
          (Adj_147_t2_v9(player)); 
         ! phrase 31
         ! [31: say ~You slowly open your eyes, uncertain how long you've slept.~]
         say__p=1;ParaContent();  print (PrintText) SC_860;  new_line; .L_Say524; .L_SayX502;
         ! phrase 32
         ! [32: otherwise if the location of the player is pine forest]
          } else if ((( LocationOf(player)  == I511_pine_forest))) { 
         ! phrase 33
         ! [33: say ~You curl up on the carpet of needles and fall into a restless sleep...~]
         say__p=1;ParaContent();  print (PrintText) SC_861;  new_line; .L_Say525; .L_SayX503;
         ! phrase 34
         ! [34: now the player is asleep]
          (Adj_146_t2_v9(player)); 
         ! phrase 35
         ! [35: silently try waiting more a random number between 5 and 20]
          @push keep_silent; keep_silent=1; TryAction(0, player, ##A106_waiting_more,  R_DecimalNumber(5, 20) , 0);; @pull keep_silent; 
         ! phrase 36
         ! [36: now the player is awake]
          (Adj_147_t2_v9(player)); 
         ! phrase 37
         ! [37: say ~You wake with a start and stand up, uncertain how long you've slept.~]
         say__p=1;ParaContent();  print (PrintText) SC_862;  new_line; .L_Say526; .L_SayX504;
         ! phrase 38
         ! [38: otherwise]
         } else {

         ! phrase 39
         ! [39: say ~You're not so sleepy that you'd nap here; there's nowhere very comfortable to rest.~]
         say__p=1;ParaContent();  print (PrintText) SC_863;  new_line; .L_Say527; .L_SayX505;
         ! phrase 40
         ! [40: end if]
         }

      RulebookFails(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1755, 1755, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B24_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/38 ! After looking in Other Side of the Pond while First Pump is happening and we have not examined the pondy crystal spire:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 2/38 ! After going to Boat House when the rowboat is moved:
!   === which is equally specific with ===
! Rule 3/38 ! After going to Inside Waterworks when the secretary is in Inside Waterworks:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 4/38 ! After examining the pond when the underground pump is switched off for the first time:
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 5/38 ! After examining the engineer's blueprint for the first time:
!   === which is equally specific with ===
! Rule 6/38 ! After wearing the diving mask for the first time:
!   >>> III.5.1 - Action/When/Duration >>>
! Rule 7/38 ! After opening the waterstained door when the rowboat is moved and the rowboat is in Floating on the Pond:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 8/38 ! After flipping a lever when lever-action is happening:
!   >>> I - Number of aspects constrained >>>
! Rule 9/38 ! After going to Floating on the Pond:
!   === which is equally specific with ===
! Rule 10/38 ! After going to the Boat House:
!   === which is equally specific with ===
! Rule 11/38 ! After going to Grassy Shore:
!   >>> III.2.2 - Action/Where/Room Where Action Takes Place >>>
! Rule 12/38 ! After inserting a small rock ( called rocky ) into the slot:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 13/38 ! After inserting something into a pocket:
!   === which is equally specific with ===
! Rule 14/38 ! After removing something from a pocket:
!   === which is equally specific with ===
! Rule 15/38 ! After inserting something into the cavity:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 16/38 ! After pouring a liquid source into a fluid container:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 17/38 ! After unlocking the door to the structure with something:
!   === which is equally specific with ===
! Rule 18/38 ! After unlocking the keyhole with something:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 19/38 ! After switching on the metal detector:
!   === which is equally specific with ===
! Rule 20/38 ! After taking the ticket:
!   === which is equally specific with ===
! Rule 21/38 ! After taking the old key:
!   === which is equally specific with ===
! Rule 22/38 ! After taking the flashlight:
!   === which is equally specific with ===
! Rule 23/38 ! After taking the screwdriver:
!   === which is equally specific with ===
! Rule 24/38 ! After taking the wrench:
!   === which is equally specific with ===
! Rule 25/38 ! After taking the wind chimes:
!   === which is equally specific with ===
! Rule 26/38 ! After examining the coat:
!   === which is equally specific with ===
! Rule 27/38 ! After switching on the fountain:
!   === which is equally specific with ===
! Rule 28/38 ! After switching off the fountain:
!   === which is equally specific with ===
! Rule 29/38 ! After examining the pond:
!   === which is equally specific with ===
! Rule 30/38 ! After examining the nest of hoses:
!   === which is equally specific with ===
! Rule 31/38 ! After switching on the underground pump:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 32/38 ! After examining an identified passkey ( this is the passkey description rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 33/38 ! After switching off a light source ( called source ):
!   === which is equally specific with ===
! Rule 34/38 ! After switching on a light source ( called source ):
!   === which is equally specific with ===
! Rule 35/38 ! After examining a fluid container:
!   === which is equally specific with ===
! Rule 36/38 ! After switching on a gizmo:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 37/38 ! After examining something:
!   >>> I - Number of aspects constrained >>>
! Rule 38/38 ! After boarding:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After looking in Other Side of the Pond while First Pump is happening and we have not examined the pondy crystal spire:
[ R_1540 ;
   if ((action ==##Look) &&  (actor==player) && ((real_location == I494_other_side_of_the_pond) && (true)) && (self=actor,true) && (((((scene_status-->(I424_first_pump-1)==1)))) && ((~~(TestActionBitmap(I498_pondy_crystal_spire,##Examine)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1540, 1540);
      ! phrase 1
      ! [1: say ~A glint of light from the pond catches your eye.~]
      say__p=1;ParaContent();  print (PrintText) SC_864;  new_line; .L_Say528; .L_SayX506;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1540, 1540, true);
   rfalse;
];
! No specific request
! After going to Boat House when the rowboat is moved:
[ R_1277 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I479_boat_house) && (true)) && (self=actor,true) && ((((Adj_104_t1_v9(I481_rowboat)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1277, 1277);
      ! phrase 1
      ! [1: if the rowboat is in boat house begin]
       if (((I479_boat_house == ContainerOf(I481_rowboat))))  {
         ! phrase 2
         ! [2: say ~The rowboat bumps gently against the doorway, wet from its journey across the pond.~]
         say__p=1;ParaContent();  print (PrintText) SC_865;  new_line; .L_Say529; .L_SayX507;
         ! phrase 3
         ! [3: now the rowboat is not moved]
          (Adj_104_t3_v9(I481_rowboat)); 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if the rowboat is in floating on the pond , say ~You can hear the rowboat outside bumping against the door.~]
       if (((I466_floating_on_the_pond == ContainerOf(I481_rowboat)))) { say__p=1;ParaContent();  print (PrintText) SC_866;  new_line; .L_Say530; .L_SayX508;  }
      ! phrase 6
      ! [6: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1277, 1277, true);
   rfalse;
];
! No specific request
! After going to Inside Waterworks when the secretary is in Inside Waterworks:
[ R_1315 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I506_inside_waterworks) && (true)) && (self=actor,true) && (((I506_inside_waterworks == ContainerOf(I545_secretary_of_water))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1315, 1315);
      ! phrase 1
      ! [1: if the player was in pump room begin]
       if (TestSinglePastState(1, 49, false, 1))  {
         ! phrase 2
         ! [2: say ~[The secretary] unclenches her hands and returns to her desk. '[bold type]Thank[roman type] you!,' she says.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_867; ParaContent();  style bold; ParaContent();  print (PrintText) SC_868; ParaContent();  style roman; ParaContent();  print (PrintText) SC_869;  new_line; .L_Say531; .L_SayX509;
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
      ! phrase 5
      ! [5: if the secretary is not irked and the player was not in pump room begin]
       if ((((~~(((Adj_114_t1_v9(I545_secretary_of_water))))))) && (~~(TestSinglePastState(1, 50, false, 1))))  {
         ! phrase 6
         ! [6: say ~[one of]The woman looks up and smiles at you. 'Can I help you?'[or][The secretary] smiles. 'Hello!'[stopping]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->41 =
	i7_soo_stop(I7_ST_say_one_of-->41, 2);
	switch((I7_ST_say_one_of-->41)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_870;  new_line;ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_871;  new_line;ParaContent();  }  .L_Say532; .L_SayX510;
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the secretary is irked begin]
       if ((((Adj_114_t1_v9(I545_secretary_of_water)))))  {
         ! phrase 9
         ! [9: say ~[The secretary] looks at you; a little wary, a little intrigued, you suspect.~]
         say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_872;  new_line; .L_Say533; .L_SayX511;
         ! phrase 10
         ! [10: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1315, 1315, true);
   rfalse;
];
! No specific request
! After examining the pond when the underground pump is switched off for the first time:
[ R_1240 ;
   if ((PAPR_4() && (((TimesActionHasHappened-->4) == 1) && (ActionCurrentlyHappeningFlag->4)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1240, 1240);
      ! phrase 1
      ! [1: say ~For a moment you think you see the sparkle of a crystal tower in the pond, but it's just a trick of the sunlight.~]
      say__p=1;ParaContent();  print (PrintText) SC_873;  new_line; .L_Say534; .L_SayX512;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1240, 1240, true);
   rfalse;
];
! No specific request
! After examining the engineer's blueprint for the first time:
[ R_1473 ;
   if ((PAPR_5() && (((TimesActionHasHappened-->5) == 1) && (ActionCurrentlyHappeningFlag->5)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1473, 1473);
      ! phrase 1
      ! [1: say ~You feel a tingle as you realize how close you must be to the Crystal City.~]
      say__p=1;ParaContent();  print (PrintText) SC_874;  new_line; .L_Say535; .L_SayX513;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1473, 1473, true);
   rfalse;
];
! No specific request
! After wearing the diving mask for the first time:
[ R_1666 ;
   if ((PAPR_6() && (((TimesActionHasHappened-->6) == 1) && (ActionCurrentlyHappeningFlag->6)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1666, 1666);
      ! phrase 1
      ! [1: say ~It smells both stale and wet inside, but the rubber holds tight against your skin and you have no trouble breathing.~]
      say__p=1;ParaContent();  print (PrintText) SC_875;  new_line; .L_Say536; .L_SayX514;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1666, 1666, true);
   rfalse;
];
! No specific request
! After opening the waterstained door when the rowboat is moved and the rowboat is in Floating on the Pond:
[ R_1278 ;
   if ((action ==##Open) &&  (actor==player) && ((noun == I482_waterstained_door) && (true)) && (self=actor,true) && (((((Adj_104_t1_v9(I481_rowboat))))) && (((I466_floating_on_the_pond == ContainerOf(I481_rowboat)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1278, 1278);
      ! phrase 1
      ! [1: say ~The rowboat floats into the boat house as you open the door.~]
      say__p=1;ParaContent();  print (PrintText) SC_876;  new_line; .L_Say537; .L_SayX515;
      ! phrase 2
      ! [2: move the rowboat to boat house]
       MoveObject(I481_rowboat, I479_boat_house, 0, false); 
      ! phrase 3
      ! [3: now the rowboat is not moved]
       (Adj_104_t3_v9(I481_rowboat)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1278, 1278, true);
   rfalse;
];
! No specific request
! After flipping a lever when lever-action is happening:
[ R_1084 ;
   if ((action ==##A123_flipping) &&  (actor==player) && ((noun ofclass K27_lever)) && (self=actor,true) && ((((scene_status-->(I425_lever_action-1)==1))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1084, 1084);
      ! phrase 1
      ! [1: say ~The pump stops humming.~]
      say__p=1;ParaContent();  print (PrintText) SC_877;  new_line; .L_Say538; .L_SayX516;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1084, 1084, true);
   rfalse;
];
! No specific request
! After going to Floating on the Pond:
[ R_1175 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I466_floating_on_the_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1175, 1175);
      ! phrase 1
      ! [1: record ~launching the boat~ as achieved]
      (PHR_1164_r6 (SC_197));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1175, 1175, true);
   rfalse;
];
! No specific request
! After going to the Boat House:
[ R_1176 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I479_boat_house) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1176, 1176);
      ! phrase 1
      ! [1: record ~entering the boathouse~ as achieved]
      (PHR_1164_r6 (SC_196));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1176, 1176, true);
   rfalse;
];
! No specific request
! After going to Grassy Shore:
[ R_1297 ;
   if ((action ==##Go) &&  (actor==player) && (((MStack-->MstVON(20007,1)) == I464_grassy_shore) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1297, 1297);
      ! phrase 1
      ! [1: record ~traveling to further parts of the pond~ as achieved]
      (PHR_1164_r6 (SC_203));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1297, 1297, true);
   rfalse;
];
! No specific request
! After inserting a small rock ( called rocky ) into the slot:
[ R_1447 
    t_0 ! Local variable e.g. 'rocky' = small rock
    ;
   if ((action ==##Insert) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K24_small_rock)))) && ((second == I581_slot) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1447, 1447);
      ! phrase 1
      ! [1: say ~It slips smoothly into the machine, and you hear a click.~]
      say__p=1;ParaContent();  print (PrintText) SC_878;  new_line; .L_Say539; .L_SayX517;
      ! phrase 2
      ! [2: now the vending machine is unlocked]
       (Adj_76_t2_v9(I580_vending_machine)); 
      ! phrase 3
      ! [3: now rocky is in rock limbo]
       MoveObject(t_0,I595_rock_limbo); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1447, 1447, true);
   rfalse;
];
! No specific request
! After inserting something into a pocket:
[ R_1073 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I451_right_pocket) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1073, 1073);
      ! phrase 1
      ! [1: now the noun is pocketed]
       (Adj_100_t2_v9(noun)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1073, 1073, true);
   rfalse;
];
! No specific request
! After removing something from a pocket:
[ R_1074 ;
   if ((action ==##Remove) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I451_right_pocket) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1074, 1074);
      ! phrase 1
      ! [1: now the noun is unpocketed]
       (Adj_101_t2_v9(noun)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1074, 1074, true);
   rfalse;
];
! No specific request
! After inserting something into the cavity:
[ R_1701 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second == I701_cavity) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1701, 1701);
      ! phrase 1
      ! [1: say ~[one of]'Aha!' Cordelia says, looking intently at the wheel[or]'Of course!' Doug snaps his fingers[or]'Oh, [bold type]exciting[roman type]!' says Vivian, stretching forward to see what will happen[at random].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->42 =
	i7_soo_ran(I7_ST_say_one_of-->42, 3);
	switch((I7_ST_say_one_of-->42)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_879; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_880; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_881; ParaContent();  style bold; ParaContent();  print (PrintText) SC_882; ParaContent();  style roman; ParaContent();  print (PrintText) SC_883; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say540; .L_SayX518;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1701, 1701, true);
   rfalse;
];
! No specific request
! After pouring a liquid source into a fluid container:
[ R_1120 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun ofclass K26_liquid_source)) && ((second ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1120, 1120);
      ! phrase 1
      ! [1: say ~You fill [the second noun] up with [liquid of the noun] from [the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_884; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_885; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_745; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say541; .L_SayX519;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1120, 1120, true);
   rfalse;
];
! No specific request
! After unlocking the door to the structure with something:
[ R_1267 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I480_door_to_the_structure) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1267, 1267);
      ! phrase 1
      ! [1: say ~You unlock the structure with [the second noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_886; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say542; .L_SayX520;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1267, 1267, true);
   rfalse;
];
! No specific request
! After unlocking the keyhole with something:
[ R_1353 ;
   if ((action ==##Unlock) &&  (actor==player) && ((noun == I536_keyhole_on_the_security) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1353, 1353);
      ! phrase 1
      ! [1: say ~You turn [the second noun] in the security gadget's keyhole; the complicated pump emits a series of beeps, and the warning lights turn off.~]
      say__p=1;ParaContent();  print (PrintText) SC_887; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_888;  new_line; .L_Say543; .L_SayX521;
      ! phrase 2
      ! [2: now the security gadget is insecure]
       (Adj_123_t2_v9(I534_security_gadget)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1353, 1353, true);
   rfalse;
];
! No specific request
! After switching on the metal detector:
[ R_1081 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I421_small_metal_detector) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1081, 1081);
      ! phrase 1
      ! [1: say ~A small blue light on the detector starts blinking wildly.~]
      say__p=1;ParaContent();  print (PrintText) SC_889;  new_line; .L_Say544; .L_SayX522;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1081, 1081, true);
   rfalse;
];
! No specific request
! After taking the ticket:
[ R_1168 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I584_ticket) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1168, 1168);
      ! phrase 1
      ! [1: record ~finding a ticket~ as achieved]
      (PHR_1164_r6 (SC_185));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1168, 1168, true);
   rfalse;
];
! No specific request
! After taking the old key:
[ R_1169 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I640_old_key) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1169, 1169);
      ! phrase 1
      ! [1: record ~finding a key~ as achieved]
      (PHR_1164_r6 (SC_190));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1169, 1169, true);
   rfalse;
];
! No specific request
! After taking the flashlight:
[ R_1170 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I414_flashlight) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1170, 1170);
      ! phrase 1
      ! [1: record ~acquiring a flashlight~ as achieved]
      (PHR_1164_r6 (SC_187));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1170, 1170, true);
   rfalse;
];
! No specific request
! After taking the screwdriver:
[ R_1171 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I636_screwdriver) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1171, 1171);
      ! phrase 1
      ! [1: record ~acquiring a screwdriver~ as achieved]
      (PHR_1164_r6 (SC_188));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1171, 1171, true);
   rfalse;
];
! No specific request
! After taking the wrench:
[ R_1172 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I710_wrench) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1172, 1172);
      ! phrase 1
      ! [1: record ~acquiring a wrench~ as achieved]
      (PHR_1164_r6 (SC_189));
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1172, 1172, true);
   rfalse;
];
! No specific request
! After taking the wind chimes:
[ R_1191 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I563_metal_wind_chimes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1191, 1191);
      ! phrase 1
      ! [1: now the sound of the wind chimes is off-stage]
       (Adj_9_t3_v9(I440_sound_of_the_wind_chime)); 
      ! phrase 2
      ! [2: continue the action]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1191, 1191, true);
   rfalse;
];
! No specific request
! After examining the coat:
[ R_1206 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I450_your_coat) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1206, 1206);
      ! phrase 1
      ! [1: if the left pocket contains nothing and the right pocket contains nothing , say ~Both the pockets are empty.~]
       if (((Prop_52())) && ((Prop_53()))) { say__p=1;ParaContent();  print (PrintText) SC_890;  new_line; .L_Say545; .L_SayX523;  }
      ! phrase 2
      ! [2: otherwise say ~[if the left pocket contains nothing]The left pocket is empty[otherwise]In the left pocket [is-are a list of things in the left pocket][end if], and [if the right pocket contains nothing]the right pocket is empty[otherwise]in the right pocket [is-are a list of things in the right pocket][end if].~]
       else { say__p=1;
	if (~~(((Prop_54())))) jump L_Say546;
		ParaContent();  print (PrintText) SC_891; 
	jump L_SayX524; .L_Say546;
		ParaContent();  print (PrintText) SC_892; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I452_left_pocket == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+ISARE_BIT);
		@pull subst__v; 
	.L_Say547; .L_SayX524;
		ParaContent();  print (PrintText) SC_834; 
	if (~~(((Prop_55())))) jump L_Say548;
		ParaContent();  print (PrintText) SC_835; 
	jump L_SayX525; .L_Say548;
		ParaContent();  print (PrintText) SC_836; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I451_right_pocket == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+ISARE_BIT);
		@pull subst__v; 
	.L_Say549; .L_SayX525;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say550; .L_SayX526;  }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1206, 1206, true);
   rfalse;
];
! No specific request
! After switching on the fountain:
[ R_1226 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1226, 1226);
      ! phrase 1
      ! [1: now running water is in pathland]
       MoveObject(I462_running_water,I513_pathland); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1226, 1226, true);
   rfalse;
];
! No specific request
! After switching off the fountain:
[ R_1228 ;
   if ((action ==##SwitchOff) &&  (actor==player) && ((noun == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1228, 1228);
      ! phrase 1
      ! [1: now running water is off-stage]
       (Adj_9_t3_v9(I462_running_water)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1228, 1228, true);
   rfalse;
];
! No specific request
! After examining the pond:
[ R_1243 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I463_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1243, 1243);
      ! phrase 1
      ! [1: if a random chance of 1 in 3 succeeds , say ~You see a paddling of ducks bobbing on the water.~]
       if (( (GenerateRandomNumber(1, 3) <= 1) )) { say__p=1;ParaContent();  print (PrintText) SC_893;  new_line; .L_Say551; .L_SayX527;  }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1243, 1243, true);
   rfalse;
];
! No specific request
! After examining the nest of hoses:
[ R_1341 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I525_nest_of_hoses) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1341, 1341);
      ! phrase 1
      ! [1: if hose-action is happening , say the description of the leaky hose]
       if ((((scene_status-->(I428_hose_action-1)==1)))) { say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=I526_leaky_hose,description); @pull self;  .L_Say552; .L_SayX528;  }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1341, 1341, true);
   rfalse;
];
! No specific request
! After switching on the underground pump:
[ R_1606 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I417_underground_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1606, 1606);
      ! phrase 1
      ! [1: say ~The hut starts to shake for a few seconds -- even making you lose your balance -- and water rushes through the hoses.[paragraph break]The pump rattles.~]
      say__p=1;ParaContent();  print (PrintText) SC_894; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_895;  new_line; .L_Say553; .L_SayX529;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1606, 1606, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! After examining an identified passkey ( this is the passkey description rule ):
[ R_836 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun ofclass K18_passkey) && ((Adj_38_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_836, 836);
      ! phrase 1
      ! [1: say ~[The noun] unlocks [the list of things unbolted by the noun].~]
      say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_896; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (noun == (subst__v.p67_unbolting))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say554; .L_SayX530;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_836, 836, true);
   rfalse;
];
! No specific request
! After switching off a light source ( called source ):
[ R_1075 
    t_0 ! Local variable e.g. 'source' = light source
    ;
   if ((action ==##SwitchOff) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K22_light_source))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1075, 1075);
      ! phrase 1
      ! [1: say ~You turn off [the source].~]
      say__p=1;ParaContent();  print (PrintText) SC_897; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say555; .L_SayX531;
      ! phrase 2
      ! [2: now source is not lit]
       (Adj_51_t3_v9(t_0)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1075, 1075, true);
   rfalse;
];
! No specific request
! After switching on a light source ( called source ):
[ R_1076 
    t_0 ! Local variable e.g. 'source' = light source
    ;
   if ((action ==##SwitchOn) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K22_light_source))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1076, 1076);
      ! phrase 1
      ! [1: if the location is dark begin]
       if ((((Adj_48_t1_v9(real_location)))))  {
         ! phrase 2
         ! [2: if the source is the flashlight , say ~The flashlight flickers once or twice, and then provides a steady beam that illuminates your surroundings.~]
          if (((t_0 == I414_flashlight))) { say__p=1;ParaContent();  print (PrintText) SC_898;  new_line; .L_Say556; .L_SayX532;  }
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the source is the flashlight , say ~You turn on the flashlight. Its beam is weak compared to the sunlight.~]
          if (((t_0 == I414_flashlight))) { say__p=1;ParaContent();  print (PrintText) SC_899;  new_line; .L_Say557; .L_SayX533;  }
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: now source is lit]
       (Adj_51_t2_v9(t_0)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1076, 1076, true);
   rfalse;
];
! No specific request
! After examining a fluid container:
[ R_1099 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1099, 1099);
      ! phrase 1
      ! [1: if the noun contains something begin]
       if ((Prop_56()))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: otherwise if the noun is empty]
          } else if ((((Adj_16_t1_v9(noun))))) { 
         ! phrase 4
         ! [4: say ~[The noun] is empty.~]
         say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_900;  new_line; .L_Say558; .L_SayX534;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[The noun] contains [current volume of the noun in rough terms] of [liquid of the noun].~]
         say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_901; ParaContent(); @push self; (PHR_1100_r14 (GProperty(OBJECT_TY, self=noun,p15_current_volume)));@pull self; ParaContent();  print (PrintText) SC_902; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say559; .L_SayX535;
         ! phrase 7
         ! [7: end if]
         }

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1099, 1099, true);
   rfalse;
];
! No specific request
! After switching on a gizmo:
[ R_1347 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun ofclass K28_gizmo))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1347, 1347);
      ! phrase 1
      ! [1: say ~It starts to twitch a little.~]
      say__p=1;ParaContent();  print (PrintText) SC_903;  new_line; .L_Say560; .L_SayX536;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1347, 1347, true);
   rfalse;
];
! No specific request
! After examining something:
[ R_1039 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1039, 1039);
      ! phrase 1
      ! [1: now the noun is examined]
       (Adj_94_t2_v9(noun)); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1039, 1039, true);
   rfalse;
];
! No specific request
! After boarding:
[ R_1741 ;
   if ((action ==##A104_boarding) &&  (actor==player)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1741, 1741);
      ! phrase 1
      ! [1: if third pump is happening begin]
       if ((((scene_status-->(I430_third_pump-1)==1))))  {
         ! phrase 2
         ! [2: say ~The conductor looks at you, his customary grin faded. 'Oh, hey.'~]
         say__p=1;ParaContent();  print (PrintText) SC_904;  new_line; .L_Say561; .L_SayX537;
         ! phrase 3
         ! [3: otherwise if the conductor is not satisfied]
          } else if (((~~(((Adj_142_t1_v9(I711_conductor))))))) { 
         ! phrase 4
         ! [4: say ~The conductor checks your ticket, and smiles at you. 'Thanks, friend!' he says.~]
         say__p=1;ParaContent();  print (PrintText) SC_905;  new_line; .L_Say562; .L_SayX538;
         ! phrase 5
         ! [5: now the conductor is satisfied]
          (Adj_142_t2_v9(I711_conductor)); 
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: say ~The conductor smiles[one of]. 'Hello, again! Welcome aboard!'[line break][or]. 'Welcome back!'[line break][or], and waves you aboard.[stopping]~]
         say__p=1;ParaContent();  print (PrintText) SC_906; ParaContent();  I7_ST_say_one_of-->43 =
	i7_soo_stop(I7_ST_say_one_of-->43, 3);
	switch((I7_ST_say_one_of-->43)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_907; ParaContent();  new_line; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_908; ParaContent();  new_line; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_909;  new_line;ParaContent();  }  .L_Say563; .L_SayX539;
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: record ~getting on a train~ as achieved]
      (PHR_1164_r6 (SC_186));
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1741, 1741, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B26_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_36 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_36, 36);
      ! phrase 1
      ! [1: it is very unlikely]
      RulebookSucceeds(19, RBNO_10); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_36, 36, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B29_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_58 
    t_0 ! Local variable e.g. 'item being printed' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_58, 58);
      ! phrase 1
      ! [1: now the item being printed is mentioned]
       (Adj_65_t2_v9(t_0)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_58, 58, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the name (B30_for_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Rule for printing the name of a fluid container ( called bottle ) while taking inventory:
! --- now the last-placed rules ---
! Rule 2/2: STANDARD_NAME_PRINTING_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for printing the name of a fluid container ( called bottle ) while taking inventory:
[ R_1125 
    t_0 ! Local variable e.g. 'bottle' = fluid container
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K25_fluid_container))))) { ! Runs only when pattern matches
   if (((((action ==##Inv) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1125, 1125);
      ! phrase 1
      ! [1: if the fluid container contains something begin]
       if ((Prop_57()))  {
         ! phrase 2
         ! [2: say ~[printed name of the bottle] (containing [a list of things in the bottle])~]
         say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,short_name); @pull self; ParaContent();  print (PrintText) SC_910; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (t_0 == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_413;  .L_Say564; .L_SayX540;
         ! phrase 3
         ! [3: otherwise if the fluid container is empty]
          } else if ((Prop_58())) { 
         ! phrase 4
         ! [4: say ~empty [printed name of the bottle]~]
         say__p=1;ParaContent();  print (PrintText) SC_911; ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,short_name); @pull self;  .L_Say565; .L_SayX541;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[printed name of the bottle] of [the liquid of the bottle]~]
         say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,short_name); @pull self; ParaContent();  print (PrintText) SC_902; ParaContent(); @push self;  print (T70) GProperty(9, self=t_0,p85_liquid); @pull self;  .L_Say566; .L_SayX542;
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: omit contents in listing]
       c_style = c_style &~ (RECURSE_BIT+FULLINV_BIT+PARTINV_BIT); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1125, 1125, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the name (B31_after_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! After printing the name of the wooden drawer when looking:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 2/7 ! After printing the name of the location when the player is trapped:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/7 ! After printing the name of an identified passkey ( called the item ) while taking inventory ( this is the identify passkeys in inventory rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/7 ! After printing the name of a lever ( called flippy ) when not examining:
!   === which is equally specific with ===
! Rule 5/7 ! After printing the name of a switch ( called flippy ) when not examining:
!   >>> I - Number of aspects constrained >>>
! Rule 6/7 ! After printing the name of an ambiguously plural thing ( called the suspect ) ( this is the notice plurality of printed ambiguous object rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 7/7 ! After printing the name of something ( called the target ) ( this is the notice plurality of printed object rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! After printing the name of the wooden drawer when looking:
[ R_1462 ;
   if (((parameter_object == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
   if (((((action ==##Look) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1462, 1462);
      ! phrase 1
      ! [1: if the drawer is upside-down , say ~[run paragraph on] (upside down)~]
       if ((((Adj_128_t1_v9(I589_wooden_drawer))))) { say__p=1;ParaContent();  RunParagraphOn(); ParaContent();  print (PrintText) SC_912;  .L_Say567; .L_SayX543;  }
      ! phrase 2
      ! [2: otherwise say ~[run paragraph on] (right side up)~]
       else { say__p=1;ParaContent();  RunParagraphOn(); ParaContent();  print (PrintText) SC_913;  .L_Say568; .L_SayX544;  }
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1462, 1462, true);
   rfalse;
];
! No specific request
! After printing the name of the location when the player is trapped:
[ R_1525 ;
   if (((parameter_object == real_location) && (true))) { ! Runs only when pattern matches
   if (((((((Adj_130_t1_v9(player)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1525, 1525);
      ! phrase 1
      ! [1: say ~ (trapped in mud)~]
      say__p=1;ParaContent();  print (PrintText) SC_914;  .L_Say569; .L_SayX545;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1525, 1525, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! After printing the name of an identified passkey ( called the item ) while taking inventory ( this is the identify passkeys in inventory rule ):
[ R_835 
    t_0 ! Local variable e.g. 'item' = passkey
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K18_passkey) && ((Adj_38_t1_v9(parameter_object))))))) { ! Runs only when pattern matches
   if (((((action ==##Inv) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_835, 835);
      ! phrase 1
      ! [1: say ~ (which opens [the list of things unbolted by the item])~]
      say__p=1;ParaContent();  print (PrintText) SC_915; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (t_0 == (subst__v.p67_unbolting))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+DEFART_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_413;  .L_Say570; .L_SayX546;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_835, 835, true);
   rfalse;
];
! No specific request
! After printing the name of a lever ( called flippy ) when not examining:
[ R_1357 
    t_0 ! Local variable e.g. 'flippy' = lever
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K27_lever))))) { ! Runs only when pattern matches
   if (~~((((action ==##Examine) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1357, 1357);
      ! phrase 1
      ! [1: say ~ (currently flipped [if flippy is flipped up]up[otherwise]down[end if])~]
      say__p=1;ParaContent();  print (PrintText) SC_916; 
	if (~~(((((Adj_124_t1_v9(t_0))))))) jump L_Say571;
		ParaContent();  print (PrintText) SC_917; 
	jump L_SayX547; .L_Say571;
		ParaContent();  print (PrintText) SC_918; 
	.L_Say572; .L_SayX547;
		ParaContent();  print (PrintText) SC_413;  .L_Say573; .L_SayX548;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1357, 1357, true);
   rfalse;
];
! No specific request
! After printing the name of a switch ( called flippy ) when not examining:
[ R_1358 
    t_0 ! Local variable e.g. 'flippy' = switch
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K29_switch))))) { ! Runs only when pattern matches
   if (~~((((action ==##Examine) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1358, 1358);
      ! phrase 1
      ! [1: say ~ (currently flipped [if flippy is flipped up]up[otherwise]down[end if])~]
      say__p=1;ParaContent();  print (PrintText) SC_916; 
	if (~~(((((Adj_124_t1_v9(t_0))))))) jump L_Say574;
		ParaContent();  print (PrintText) SC_917; 
	jump L_SayX549; .L_Say574;
		ParaContent();  print (PrintText) SC_918; 
	.L_Say575; .L_SayX549;
		ParaContent();  print (PrintText) SC_413;  .L_Say576; .L_SayX550;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1358, 1358, true);
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! After printing the name of an ambiguously plural thing ( called the suspect ) ( this is the notice plurality of printed ambiguous object rule ):
[ R_1005 
    t_0 ! Local variable e.g. 'suspect' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing) && ((Adj_92_t1_v9(parameter_object))))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1005, 1005);
      ! phrase 1
      ! [1: if the manual pronouns option is active begin]
       if ((((Adj_22_t1_v15(29)))))  {
         ! phrase 2
         ! [2: do nothing]
          ; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: notice the plurality of the suspect]
          PlugPlural(t_0); 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1005, 1005, true);
   rfalse;
];
! No specific request
! From "Plurality" by Emily Short
! After printing the name of something ( called the target ) ( this is the notice plurality of printed object rule ):
[ R_939 
    t_0 ! Local variable e.g. 'target' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_939, 939);
      ! phrase 1
      ! [1: mark target in output]
      (PHR_940_r15 (t_0));
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_939, 939, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the plural name (B33_for_printing_the_plural_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for printing the plural name of something ( called the item ) ( this is the standard printing the plural name rule ):
[ R_59 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_59, 59);
      ! phrase 1
      ! [1: say the printed plural name of the item]
      say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,plural); @pull self;  .L_Say577; .L_SayX551;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_59, 59, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a number (B36_for_printing_a_number)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for printing a number of something ( called the item ) ( this is the standard printing a number of something rule ):
[ R_60 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_60, 60);
      ! phrase 1
      ! [1: say ~[listing group size in words] ~]
      say__p=1;ParaContent();  print (number) say__n=(listing_size); ParaContent();  print (PrintText) SC_387;  .L_Say578; .L_SayX552;
      ! phrase 2
      ! [2: carry out the printing the plural name activity with the item]
       CarryOutActivity(V1_printing_the_plural_name_, t_0); 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_60, 60, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the announcement of light (B63_for_printing_the_announc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the look around once light available rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the look around once light available rule:
[ R_61 ;
      ! phrase 1
      ! [1: try looking]
       TryAction(0, player, ##Look, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Constructing the status line (B69_for_constructing_the_sta)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for constructing the status line:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for constructing the status line:
[ R_1198 ;
      ! phrase 1
      ! [1: center ~[The player's surroundings]          ...          ([the wetness level])~ at row 1]
       CenterPrint(text_routine_235, 1); 
      ! phrase 2
      ! [2: rule succeeds]
       RulebookSucceeds(); rtrue; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Printing the banner text (B73_after_printing_the_banne)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! After printing the banner text:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After printing the banner text:
[ R_1160 ;
      ! phrase 1
      ! [1: say ~First time players type HELP for more instructions.~]
      say__p=1;ParaContent();  print (PrintText) SC_919;  new_line; .L_Say579; .L_SayX553;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: after Deciding the scope (B79_after_deciding_the_scope)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! After deciding the scope of the player when the player is in Pump Room and the secretary is in Inside Waterworks:
!   >>> II - When/while requirement >>>
! Rule 2/9 ! After deciding the scope of the player when overly elaborate looking ( this is the Small Kindnesses place the room in scope while looking rule ):
!   === which is equally specific with ===
! Rule 3/9 ! After deciding the scope of the player when getting off ( this is the Small Kindnesses place the room in scope while getting off rule ):
!   === which is equally specific with ===
! Rule 4/9 ! After deciding the scope of the player when in darkness ( this is the Small Kindnesses allow for switching things in darkness rule ):
!   === which is equally specific with ===
! Rule 5/9 ! After deciding the scope of the player when the player is in the station of the steam train:
!   === which is equally specific with ===
! Rule 6/9 ! After deciding the scope of the player when the player is in the Hill:
!   === which is equally specific with ===
! Rule 7/9 ! After deciding the scope of the player when the player is in Visitor Center:
!   === which is equally specific with ===
! Rule 8/9 ! After deciding the scope of the player when the location of the player is the station of the steam train:
!   >>> I - Number of aspects constrained >>>
! Rule 9/9 ! After deciding the scope of the player:
! ----------------------------------------------------------------------------------------------------
! No specific request
! After deciding the scope of the player when the player is in Pump Room and the secretary is in Inside Waterworks:
[ R_1135 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if (((((((I510_pump_room == ContainerOf(player)))) && (((I506_inside_waterworks == ContainerOf(I545_secretary_of_water)))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1135, 1135);
      ! phrase 1
      ! [1: place the secretary in scope]
       PlaceInScope(I545_secretary_of_water, 0); 
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1135, 1135, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! After deciding the scope of the player when overly elaborate looking ( this is the Small Kindnesses place the room in scope while looking rule ):
[ R_748 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if (((((action ==##A81_overly_elaborate_looking) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_748, 748);
      ! phrase 1
      ! [1: place the location in scope , but not its contents]
       PlaceInScope(real_location, 1); 
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_748, 748, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! After deciding the scope of the player when getting off ( this is the Small Kindnesses place the room in scope while getting off rule ):
[ R_750 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if (((((action ==##GetOff) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_750, 750);
      ! phrase 1
      ! [1: place the location in scope , but not its contents]
       PlaceInScope(real_location, 1); 
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_750, 750, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! After deciding the scope of the player when in darkness ( this is the Small Kindnesses allow for switching things in darkness rule ):
[ R_759 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if ((((( (location==thedark) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_759, 759);
      ! phrase 1
      ! [1: repeat with machine running through switchable things enclosed by location begin]
       for (t_0=Prop_59(0), t_1=Prop_59(t_0): t_0: t_0=t_1, t_1=Prop_59(t_1))  {
         ! phrase 2
         ! [2: unless the holder of machine is a closed opaque container and the holder of machine is not the holder of player , place machine in scope]
          if (~~(((( (HolderOf(t_0))  ofclass K5_container) && ((Adj_71_t1_v9( (HolderOf(t_0)) ))) && ((Adj_68_t1_v9( (HolderOf(t_0)) ))))) && (((~~(( (HolderOf(t_0))  ==  (HolderOf(player)) ))))))) {  PlaceInScope(t_0, 0);   }
         ! phrase 3
         ! [3: end repeat]
         }

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_759, 759, true);
   rfalse;
];
! No specific request
! After deciding the scope of the player when the player is in the station of the steam train:
[ R_1134 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if ((((((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1134, 1134);
      ! phrase 1
      ! [1: place the conductor in scope]
       PlaceInScope(I711_conductor, 0); 
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1134, 1134, true);
   rfalse;
];
! No specific request
! After deciding the scope of the player when the player is in the Hill:
[ R_1405 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if ((((((I441_hill == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1405, 1405);
      ! phrase 1
      ! [1: if the lone sweetgum tree is examined or the player has been in in the sweetgum tree begin]
       if (((((Adj_94_t1_v9(I561_lone_sweetgum_tree))))) || (TestSinglePastState(0, 51, false, 5)))  {
         ! phrase 2
         ! [2: repeat with item running through every thing in in the sweetgum tree begin]
          for (t_0=Prop_60(0), t_1=Prop_60(t_0): t_0: t_0=t_1, t_1=Prop_60(t_1))  {
              if (debug_rules>1) print "  [repetition with item set to ", (PrintShortName) t_0, "]^";
            ! phrase 3
            ! [3: place the item in scope]
             PlaceInScope(t_0, 0); 
            ! phrase 4
            ! [4: end repeat]
            }

           if (debug_rules>1) print "  [4: end repeat]^";
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1405, 1405, true);
   rfalse;
];
! No specific request
! After deciding the scope of the player when the player is in Visitor Center:
[ R_1428 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if ((((((I508_visitor_center == ContainerOf(player))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1428, 1428);
      ! phrase 1
      ! [1: repeat with item running through every thing in the hill begin]
       for (t_0=Prop_61(0), t_1=Prop_61(t_0): t_0: t_0=t_1, t_1=Prop_61(t_1))  {
           if (debug_rules>1) print "  [repetition with item set to ", (PrintShortName) t_0, "]^";
         ! phrase 2
         ! [2: place the item in scope]
          PlaceInScope(t_0, 0); 
         ! phrase 3
         ! [3: end repeat]
         }

        if (debug_rules>1) print "  [3: end repeat]^";
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1428, 1428, true);
   rfalse;
];
! No specific request
! After deciding the scope of the player when the location of the player is the station of the steam train:
[ R_1724 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if (((((( LocationOf(player)  == GProperty(9, I439_steam_train,p16_station))))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1724, 1724);
      ! phrase 1
      ! [1: place the steam train in scope]
       PlaceInScope(I439_steam_train, 0); 
      ! phrase 2
      ! [2: place the conductor in scope]
       PlaceInScope(I711_conductor, 0); 
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1724, 1724, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! After deciding the scope of the player:
[ R_911 ;
   if (((parameter_object == player) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_911, 911);
      ! phrase 1
      ! [1: place no-object in scope]
       PlaceInScope(I92_no_object, 0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_911, 911, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding whether all includes (B84_for_deciding_whether_all)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Rule for deciding whether all includes scenery while taking ( this is the exclude scenery from take all rule ):
!   === which is equally specific with ===
! Rule 2/8 ! Rule for deciding whether all includes fixed in place things while taking ( this is the exclude fixed in place things from take all rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 3/8 ! Rule for deciding whether all includes people while taking ( this is the exclude people from take all rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/8 ! Rule for deciding whether all includes no-object:
!   === which is equally specific with ===
! Rule 5/8 ! Rule for deciding whether all includes the flagpole:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 6/8 ! Rule for deciding whether all includes passkeys which are on a keychain ( this is the don't strip keys rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 7/8 ! Rule for deciding whether all includes something in the right pocket:
!   === which is equally specific with ===
! Rule 8/8 ! Rule for deciding whether all includes something in the left pocket:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes scenery while taking ( this is the exclude scenery from take all rule ):
[ R_62 ;
   if ((((Adj_57_t1_v9(parameter_object))))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_62, 62);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_62, 62, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes fixed in place things while taking ( this is the exclude fixed in place things from take all rule ):
[ R_64 ;
   if (((parameter_object ofclass K2_thing) && ((Adj_55_t1_v9(parameter_object))))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_64, 64);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_64, 64, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for deciding whether all includes people while taking ( this is the exclude people from take all rule ):
[ R_63 ;
   if (((parameter_object ofclass K8_person))) { ! Runs only when pattern matches
   if (((((action ==##Take) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_63, 63);
      ! phrase 1
      ! [1: rule fails]
       RulebookFails(); rtrue; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_63, 63, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Rule for deciding whether all includes no-object:
[ R_913 ;
   if (((parameter_object == I92_no_object) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_913, 913);
      ! phrase 1
      ! [1: it does not]
      RulebookFails(19, RBNO_11); rtrue;

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_913, 913, true);
   rfalse;
];
! No specific request
! Rule for deciding whether all includes the flagpole:
[ R_1301 ;
   if (((parameter_object == I490_flagpole) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1301, 1301);
      ! phrase 1
      ! [1: it does]
      RulebookSucceeds(19, RBNO_12); rtrue;

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1301, 1301, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Rule for deciding whether all includes passkeys which are on a keychain ( this is the don't strip keys rule ):
[ R_844 ;
   if (((parameter_object ofclass K18_passkey) && (SupporterOf(parameter_object) ofclass K19_keychain))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_844, 844);
      ! phrase 1
      ! [1: if the second noun is not a keychain , it does not]
       if (((~~((second ofclass K19_keychain))))) { RulebookFails(19, RBNO_11); rtrue;
  }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_844, 844, true);
   rfalse;
];
! No specific request
! Rule for deciding whether all includes something in the right pocket:
[ R_1211 ;
   if (((parameter_object ofclass K2_thing) && (I451_right_pocket == ContainerOf(parameter_object)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1211, 1211);
      ! phrase 1
      ! [1: it does not]
      RulebookFails(19, RBNO_11); rtrue;

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1211, 1211, true);
   rfalse;
];
! No specific request
! Rule for deciding whether all includes something in the left pocket:
[ R_1212 ;
   if (((parameter_object ofclass K2_thing) && (I452_left_pocket == ContainerOf(parameter_object)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1212, 1212);
      ! phrase 1
      ! [1: it does not]
      RulebookFails(19, RBNO_11); rtrue;

      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1212, 1212, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B96_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
!   === which is equally specific with ===
! Rule 2/9 ! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
!   === which is equally specific with ===
! Rule 3/9 ! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
!   === which is equally specific with ===
! Rule 4/9 ! Rule for supplying a missing noun while entering:
!   === which is equally specific with ===
! Rule 5/9 ! Rule for supplying a missing noun while spilling:
!   === which is equally specific with ===
! Rule 6/9 ! Rule for supplying a missing noun while drinking:
!   === which is equally specific with ===
! Rule 7/9 ! Rule for supplying a missing noun while entering:
!   === which is equally specific with ===
! Rule 8/9 ! Rule for supplying a missing noun while rowing:
! --- now the last-placed rules ---
! Rule 9/9 ! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor smelling ( this is the ambient odour rule ):
[ R_65 ;
   if (((((action ==##Smell) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_65, 65);
      ! phrase 1
      ! [1: now the noun is the location]
       noun = real_location; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_65, 65, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor listening ( this is the ambient sound rule ):
[ R_66 ;
   if (((((action ==##Listen) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_66, 66);
      ! phrase 1
      ! [1: now the noun is the location]
       noun = real_location; 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_66, 66, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while an actor going ( this is the block vaguely going rule ):
[ R_67 ;
   if (((((action ==##Go) && (act_requester==nothing))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_67, 67);
      ! phrase 1
      ! [1: issue library message going action number 7]
       GL__M(##Go,7,noun); 
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_67, 67, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing noun while entering:
[ R_1040 ;
   if (((((action ==##Enter) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1040, 1040);
      ! phrase 1
      ! [1: if the community center building is visible , now the noun is the community center building]
       if ((((Adj_3_t1_v9(I487_community_center_buildi))))) {  noun = I487_community_center_buildi;   }
      ! phrase 2
      ! [2: if the hut is visible , now the noun is the hut]
       if ((((Adj_3_t1_v9(I630_cinderblock_hut))))) {  noun = I630_cinderblock_hut;   }
      ! phrase 3
      ! [3: if the structure is visible , now the noun is the structure]
       if ((((Adj_3_t1_v9(I477_structure))))) {  noun = I477_structure;   }
      ! phrase 4
      ! [4: if the waterworks is visible , now the noun is the waterworks]
       if ((((Adj_3_t1_v9(I455_waterworks))))) {  noun = I455_waterworks;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1040, 1040, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing noun while spilling:
[ R_1131 
    t_0 ! Local variable e.g. 'drinkme' = fluid container
    ;
   if (((((action ==##A103_spilling) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1131, 1131);
      ! phrase 1
      ! [1: if a fluid container ( called drinkme ) is visible and drinkme is not empty , now the noun is drinkme]
       if (((Prop_62() && (t_0=deferred_calling_list-->0, true))) && (((~~(((Adj_16_t1_v9(t_0)))))))) {  noun = t_0;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1131, 1131, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing noun while drinking:
[ R_1132 
    t_0 ! Local variable e.g. 'drinkme' = liquid source
    ;
   if (((((action ==##Drink) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1132, 1132);
      ! phrase 1
      ! [1: if a fluid container ( called drinkme ) is visible and drinkme is not empty , now the noun is drinkme]
       if (((Prop_63() && (t_0=deferred_calling_list-->0, true))) && (((~~(((Adj_16_t1_v9(t_0)))))))) {  noun = t_0;   }
      ! phrase 2
      ! [2: if a liquid source ( called drinkme ) is visible , now the noun is drinkme]
       if ((Prop_64() && (t_0=deferred_calling_list-->0, true))) {  noun = t_0;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1132, 1132, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing noun while entering:
[ R_1143 ;
   if (((((action ==##Enter) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1143, 1143);
      ! phrase 1
      ! [1: if the player is in the station of the steam train , now the noun is the steam train]
       if (((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))) {  noun = I439_steam_train;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1143, 1143, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing noun while rowing:
[ R_1271 ;
   if (((((action ==##A114_rowing) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1271, 1271);
      ! phrase 1
      ! [1: say ~You have to specify which direction to row in.~]
      say__p=1;ParaContent();  print (PrintText) SC_920;  new_line; .L_Say580; .L_SayX554;
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1271, 1271, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Rule for supplying a missing noun while entering ( this is the find what to enter rule ):
[ R_148 
    t_0 ! Local variable e.g. 'box' = thing
    ;
   if (((((action ==##Enter) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_148, 148);
      ! phrase 1
      ! [1: if something enterable ( called the box ) is in the location , now the noun is the box]
       if ((Prop_65() && (t_0=deferred_calling_list-->0, true))) {  noun = t_0;   }
      ! phrase 2
      ! [2: otherwise continue the activity]
       else {  rfalse;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_148, 148, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing second noun (B99_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Rule for supplying a missing second noun when throwing something at something:
!   === which is equally specific with ===
! Rule 2/2 ! Rule for supplying a missing second noun while typing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Rule for supplying a missing second noun when throwing something at something:
[ R_1197 ;
   if (((((action ==##ThrowAt) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1197, 1197);
      ! phrase 1
      ! [1: if the dog is in the location of the player , now the second noun is the dog]
       if ((( LocationOf(player)  == ContainerOf(I443_dog)))) {  second = I443_dog;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1197, 1197, true);
   rfalse;
];
! No specific request
! Rule for supplying a missing second noun while typing:
[ R_1604 ;
   if (((((action ==##A132_typing) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1604, 1604);
      ! phrase 1
      ! [1: if the keypad is visible , now the second noun is the keypad]
       if ((((Adj_3_t1_v9(I644_keypad))))) {  second = I644_keypad;   }
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1604, 1604, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Handling the final question (B113_before_handling_the_fin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! This is the print the final question rule:
!   === which is equally specific with ===
! Rule 2/3 ! This is the print the final prompt rule:
! --- now the last-placed rules ---
! Rule 3/3: READ_FINAL_ANSWER_R
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the print the final question rule:
[ R_69 
    t_0 ! Local variable e.g. 'named options count' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let named options count be 0]
       t_0 = 0; 
      ! phrase 2
      ! [2: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_1=T0_final_question_options,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 3
         ! [3: if the only if victorious entry is false or the story has ended finally begin]
          if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (( (story_complete) )))  {
            ! phrase 4
            ! [4: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v29(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 5
               ! [5: if there is a final question wording entry , increase named options count by 1]
                if (( (ExistsTableLookUpEntry(ct_0,100,ct_1)) )) {  t_0 = t_0 + 1;   }
               ! phrase 6
               ! [6: end if]
               }

            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 9
      ! [9: if the named options count is less than 1 , abide by the immediately quit rule]
       if (((t_0 < 1))) {  if (ProcessRulebook(IMMEDIATELY_QUIT_R)) rtrue;   }
      ! phrase 10
      ! [10: say ~Would you like to ~]
      say__p=1;ParaContent();  print (PrintText) SC_921;  .L_Say581; .L_SayX555;
      ! phrase 11
      ! [11: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_1=T0_final_question_options,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 12
         ! [12: if the only if victorious entry is false or the story has ended finally begin]
          if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (( (story_complete) )))  {
            ! phrase 13
            ! [13: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v29(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 14
               ! [14: if there is a final question wording entry begin]
                if (( (ExistsTableLookUpEntry(ct_0,100,ct_1)) ))  {
                  ! phrase 15
                  ! [15: say final question wording entry]
                  say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,100,ct_1);  .L_Say582; .L_SayX556;
                  ! phrase 16
                  ! [16: decrease named options count by 1]
                   t_0 = t_0 - 1; 
                  ! phrase 17
                  ! [17: if the named options count is 0 begin]
                   if (((t_0 == 0)))  {
                     ! phrase 18
                     ! [18: say ~?[line break]~]
                     say__p=1;ParaContent();  print (PrintText) SC_922; ParaContent();  new_line;  .L_Say583; .L_SayX557;
                     ! phrase 19
                     ! [19: otherwise if the named options count is 1]
                      } else if (((t_0 == 1))) { 
                     ! phrase 20
                     ! [20: if the serial comma option is active , say ~,~]
                      if ((((Adj_22_t1_v15(5))))) { say__p=1;ParaContent();  print (PrintText) SC_923;  .L_Say584; .L_SayX558;  }
                     ! phrase 21
                     ! [21: say ~ or ~]
                     say__p=1;ParaContent();  print (PrintText) SC_924;  .L_Say585; .L_SayX559;
                     ! phrase 22
                     ! [22: otherwise]
                     } else {

                     ! phrase 23
                     ! [23: say ~, ~]
                     say__p=1;ParaContent();  print (PrintText) SC_291;  .L_Say586; .L_SayX560;
                     ! phrase 24
                     ! [24: end if]
                     }

                  ! phrase 25
                  ! [25: end if]
                  }

               ! phrase 26
               ! [26: end if]
               }

            ! phrase 27
            ! [27: end if]
            }

         ! phrase 28
         ! [28: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! No specific request
! From the Standard Rules
! This is the print the final prompt rule:
[ R_68 ;
      ! phrase 1
      ! [1: say ~> [run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_925; ParaContent();  RunParagraphOn();  .L_Say587; .L_SayX561;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Handling the final question (B114_for_handling_the_final_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the standard respond to final question rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! This is the standard respond to final question rule:
[ R_70 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through the table of final question options begin]
       @push ct_0; @push ct_1;
		for (t_0=T0_final_question_options,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 2
         ! [2: if the only if victorious entry is false or the story has ended finally begin]
          if (((((TableLookUpEntry(ct_0,101,ct_1) && true) == (0 && true)))) || (( (story_complete) )))  {
            ! phrase 3
            ! [3: if there is a final response rule entry or the final response activity entry is not empty begin]
             if ((( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) || (((~~(((Adj_16_t1_v29(TableLookUpEntry(ct_0,104,ct_1)))))))))  {
               ! phrase 4
               ! [4: if the player's command matches the topic entry begin]
                if (( (SnippetMatches(players_command, TableLookUpEntry(ct_0,102,ct_1))) ))  {
                  ! phrase 5
                  ! [5: if there is a final response rule entry , abide by final response rule entry]
                   if (( (ExistsTableLookUpEntry(ct_0,103,ct_1)) )) {  if (ProcessRulebook(TableLookUpEntry(ct_0,103,ct_1))) rtrue;   }
                  ! phrase 6
                  ! [6: otherwise carry out the final response activity entry activity]
                   else {  CarryOutActivity(TableLookUpEntry(ct_0,104,ct_1));   }
                  ! phrase 7
                  ! [7: rule succeeds]
                   RulebookSucceeds(); rtrue; 
                  ! phrase 8
                  ! [8: end if]
                  }

               ! phrase 9
               ! [9: end if]
               }

            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 12
      ! [12: issue miscellaneous library message number 8]
       GL__M(##Miscellany,8); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the locale description (B116_before_printing_the_loc)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Before printing the locale description ( this is the initialise locale description rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Before printing the locale description ( this is the find notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Before printing the locale description ( this is the initialise locale description rule ):
[ R_73 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: now the locale paragraph count is 0]
       (Global_Vars-->8) = 0; 
      ! phrase 2
      ! [2: repeat with item running through things begin]
       for (t_0=Prop_66(0), t_1=Prop_66(t_0): t_0: t_0=t_1, t_1=Prop_66(t_1))  {
         ! phrase 3
         ! [3: now the item is not mentioned]
          (Adj_65_t3_v9(t_0)); 
         ! phrase 4
         ! [4: end repeat]
         }

      ! phrase 5
      ! [5: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_0=T1_locale_priorities,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 6
         ! [6: blank out the whole row]
          TableBlankOutRow(ct_0, ct_1); 
         ! phrase 7
         ! [7: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! No specific request
! From the Standard Rules
! Before printing the locale description ( this is the find notable locale objects rule ):
[ R_74 
    t_0 ! Local variable e.g. 'domain' = object
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: carry out the choosing notable locale objects activity with the domain]
       CarryOutActivity(V30_choosing_notable_locale_, t_0); 
      ! phrase 3
      ! [3: continue the activity]
       rfalse; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the locale description (B117_for_printing_the_locale)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! For printing the locale description ( this is the interesting locale paragraphs rule ):
!   === which is equally specific with ===
! Rule 2/2 ! For printing the locale description ( this is the you-can-also-see rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For printing the locale description ( this is the interesting locale paragraphs rule ):
[ R_75 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: sort the table of locale priorities in locale description priority order]
       TableSort(T1_locale_priorities, 106, 1); 
      ! phrase 3
      ! [3: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_1=T1_locale_priorities,t_2=1,ct_0=t_1,ct_1=t_2:
			t_2<=TableRows(t_1):t_2++,ct_0=t_1,ct_1=t_2)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 4
         ! [4: carry out the printing a locale paragraph about activity with the notable-object entry]
          CarryOutActivity(V31_printing_a_locale_paragr, TableLookUpEntry(ct_0,105,ct_1)); 
         ! phrase 5
         ! [5: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 6
      ! [6: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing the locale description ( this is the you-can-also-see rule ):
[ R_76 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. 'mentionable count' = number
    t_2 ! Local variable e.g. '?-1,-1?' = object
    t_3 ! Local variable e.g. '?-1,-1?' = truth state
    t_4 ! Local variable e.g. '?-1,-1?' = thing
    t_5 ! Local variable e.g. '?-1,-1?' = thing
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: let the mentionable count be 0]
       t_1 = 0; 
      ! phrase 3
      ! [3: repeat with item running through things begin]
       for (t_2=Prop_67(0), t_3=Prop_67(t_2): t_2: t_2=t_3, t_3=Prop_67(t_3))  {
         ! phrase 4
         ! [4: now the item is not marked for listing]
          (Adj_63_t3_v9(t_2)); 
         ! phrase 5
         ! [5: end repeat]
         }

      ! phrase 6
      ! [6: repeat through the table of locale priorities begin]
       @push ct_0; @push ct_1;
		for (t_2=T1_locale_priorities,t_3=1,ct_0=t_2,ct_1=t_3:
			t_3<=TableRows(t_2):t_3++,ct_0=t_2,ct_1=t_3)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 7
         ! [7: if the locale description priority entry is greater than 0 , now the notable-object entry is marked for listing]
          if (((TableLookUpEntry(ct_0,106,ct_1) > 0))) {  (Adj_63_t2_v9(TableLookUpEntry(ct_0,105,ct_1)));   }
         ! phrase 8
         ! [8: increase the mentionable count by 1]
          t_1 = t_1 + 1; 
         ! phrase 9
         ! [9: end repeat]
         }
@pull ct_1; @pull ct_0;
      ! phrase 10
      ! [10: if the mentionable count is greater than 0 begin]
       if (((t_1 > 0)))  {
         ! phrase 11
         ! [11: repeat with item running through things begin]
          for (t_2=Prop_68(0), t_3=Prop_68(t_2): t_2: t_2=t_3, t_3=Prop_68(t_3))  {
            ! phrase 12
            ! [12: if the item is mentioned begin]
             if ((((Adj_65_t1_v9(t_2)))))  {
               ! phrase 13
               ! [13: now the item is not marked for listing]
                (Adj_63_t3_v9(t_2)); 
               ! phrase 14
               ! [14: end if]
               }

            ! phrase 15
            ! [15: end repeat]
            }

         ! phrase 16
         ! [16: begin the listing nondescript items activity with the domain]
          BeginActivity(V7_listing_nondescript_items, t_0); 
         ! phrase 17
         ! [17: if the number of marked for listing things is 0 begin]
          if ((( (Prop_69())  == 0)))  {
            ! phrase 18
            ! [18: abandon the listing nondescript items activity with the domain]
             AbandonActivity(V7_listing_nondescript_items, t_0); 
            ! phrase 19
            ! [19: otherwise]
            } else {

            ! phrase 20
            ! [20: if handling the listing nondescript items activity begin]
             if (( (~~(ForActivity(V7_listing_nondescript_items))) ))  {
               ! phrase 21
               ! [21: if the domain is a room begin]
                if (((t_0 ofclass K1_room)))  {
                  ! phrase 22
                  ! [22: if the domain is the location , say ~You ~]
                   if (((t_0 == real_location))) { say__p=1;ParaContent();  print (PrintText) SC_926;  .L_Say588; .L_SayX562;  }
                  ! phrase 23
                  ! [23: otherwise say ~In [the domain] you ~]
                   else { say__p=1;ParaContent();  print (PrintText) SC_927; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_928;  .L_Say589; .L_SayX563;  }
                  ! phrase 24
                  ! [24: otherwise if the domain is a supporter]
                   } else if (((t_0 ofclass K6_supporter))) { 
                  ! phrase 25
                  ! [25: say ~On [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_929; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_928;  .L_Say590; .L_SayX564;
                  ! phrase 26
                  ! [26: otherwise if the domain is an animal]
                   } else if (((t_0 ofclass K12_animal))) { 
                  ! phrase 27
                  ! [27: say ~On [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_929; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_928;  .L_Say591; .L_SayX565;
                  ! phrase 28
                  ! [28: otherwise]
                  } else {

                  ! phrase 29
                  ! [29: say ~In [the domain] you ~]
                  say__p=1;ParaContent();  print (PrintText) SC_927; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_928;  .L_Say592; .L_SayX566;
                  ! phrase 30
                  ! [30: end if]
                  }

               ! phrase 31
               ! [31: say ~can [if the locale paragraph count is greater than 0]also [end if]see ~]
               say__p=1;ParaContent();  print (PrintText) SC_930; 
	if (~~(((((Global_Vars-->8) > 0))))) jump L_Say593;
		ParaContent();  print (PrintText) SC_931; 
	.L_Say593; .L_SayX567;
		ParaContent();  print (PrintText) SC_932;  .L_Say594; .L_SayX568;
               ! phrase 32
               ! [32: let the common holder be nothing]
                t_2 = nothing; 
               ! phrase 33
               ! [33: let contents form of list be true]
                t_3 = 1; 
               ! phrase 34
               ! [34: repeat with list item running through marked for listing things begin]
                for (t_4=Prop_70(0), t_5=Prop_70(t_4): t_4: t_4=t_5, t_5=Prop_70(t_5))  {
                  ! phrase 35
                  ! [35: if the holder of the list item is not the common holder begin]
                   if (((~~(( (HolderOf(t_4))  == t_2)))))  {
                     ! phrase 36
                     ! [36: if the common holder is nothing , now the common holder is the holder of the list item]
                      if (((t_2 == nothing))) {  t_2 =  (HolderOf(t_4)) ;   }
                     ! phrase 37
                     ! [37: otherwise now contents form of list is false]
                      else {  t_3 = 0;   }
                     ! phrase 38
                     ! [38: end if]
                     }

                  ! phrase 39
                  ! [39: if the list item is mentioned , now the list item is not marked for listing]
                   if ((((Adj_65_t1_v9(t_4))))) {  (Adj_63_t3_v9(t_4));   }
                  ! phrase 40
                  ! [40: end repeat]
                  }

               ! phrase 41
               ! [41: filter list recursion to unmentioned things]
                list_filter_routine = Prop_71; 
               ! phrase 42
               ! [42: if contents form of list is true and the common holder is not nothing , list the contents of the common holder , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , listing marked items only]
                if (((((t_3 && true) == (1 && true)))) && (((~~((t_2 == nothing)))))) {  WriteListFrom(child(t_2), 2776);   }
               ! phrase 43
               ! [43: otherwise say ~[a list of marked for listing things including contents]~]
                else { say__p=1;ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && ((Adj_63_t1_v9(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+RECURSE_BIT+PARTINV_BIT+
			TERSE_BIT+CONCEAL_BIT);
		@pull subst__v;  .L_Say595; .L_SayX569;  }
               ! phrase 44
               ! [44: if the domain is the location , say ~ here~]
                if (((t_0 == real_location))) { say__p=1;ParaContent();  print (PrintText) SC_933;  .L_Say596; .L_SayX570;  }
               ! phrase 45
               ! [45: say ~.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say597; .L_SayX571;
               ! phrase 46
               ! [46: unfilter list recursion]
                list_filter_routine = 0; 
               ! phrase 47
               ! [47: end if]
               }

            ! phrase 48
            ! [48: end the listing nondescript items activity with the domain]
             EndActivity(V7_listing_nondescript_items, t_0); 
            ! phrase 49
            ! [49: end if]
            }

         ! phrase 50
         ! [50: end if]
         }

      ! phrase 51
      ! [51: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Choosing notable locale objects (B120_for_choosing_notable_lo)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! For choosing notable locale objects ( this is the standard notable locale objects rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For choosing notable locale objects ( this is the standard notable locale objects rule ):
[ R_77 
    t_0 ! Local variable e.g. 'domain' = object
    t_1 ! Local variable e.g. 'held item' = object
    ;
      ! phrase 1
      ! [1: let the domain be the parameter-object]
       t_0 = parameter_object; 
      ! phrase 2
      ! [2: let the held item be the first thing held by the domain]
       t_1 =  (child(t_0)) ; 
      ! phrase 3
      ! [3: while the held item is a thing begin]
       while (((t_1 ofclass K2_thing)))  {
         ! phrase 4
         ! [4: set the locale priority of the held item to 5]
         (PHR_72_r16 (t_1,5));
         ! phrase 5
         ! [5: now the held item is the next thing held after the held item]
          t_1 =  (sibling(t_1)) ; 
         ! phrase 6
         ! [6: end while]
         }

      ! phrase 7
      ! [7: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing a locale paragraph about (B123_for_printing_a_locale_p)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
!   === which is equally specific with ===
! Rule 2/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
!   === which is equally specific with ===
! Rule 3/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
!   === which is equally specific with ===
! Rule 4/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
!   === which is equally specific with ===
! Rule 5/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
!   === which is equally specific with ===
! Rule 6/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
!   === which is equally specific with ===
! Rule 7/7 ! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention player's supporter in room descriptions rule ):
[ R_78 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_78, 78);
      ! phrase 1
      ! [1: if the item encloses the player , set the locale priority of the item to 0]
       if (((IndirectlyContains(t_0,player)))) { (PHR_72_r16 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_78, 78, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention scenery in room descriptions rule ):
[ R_79 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_79, 79);
      ! phrase 1
      ! [1: if the item is scenery , set the locale priority of the item to 0]
       if ((((Adj_57_t1_v9(t_0))))) { (PHR_72_r16 (t_0,0));  }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_79, 79, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the don't mention undescribed items in room descriptions rule ):
[ R_80 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_80, 80);
      ! phrase 1
      ! [1: if the item is undescribed begin]
       if ((((Adj_62_t1_v9(t_0)))))  {
         ! phrase 2
         ! [2: set the locale priority of the item to 0]
         (PHR_72_r16 (t_0,0));
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_80, 80, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the set pronouns from items in room descriptions rule ):
[ R_81 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_81, 81);
      ! phrase 1
      ! [1: if the item is not mentioned , set pronouns from the item]
       if (((~~(((Adj_65_t1_v9(t_0))))))) {  PronounNotice(t_0);   }
      ! phrase 2
      ! [2: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_81, 81, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the offer items to writing a paragraph about rule ):
[ R_82 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_82, 82);
      ! phrase 1
      ! [1: if the item is not mentioned begin]
       if (((~~(((Adj_65_t1_v9(t_0)))))))  {
         ! phrase 2
         ! [2: if a paragraph break is pending , say ~[conditional paragraph break]~]
          if (( (say__p) )) { say__p=1;ParaContent();  DivideParagraphPoint();  .L_Say598; .L_SayX572;  }
         ! phrase 3
         ! [3: carry out the writing a paragraph about activity with the item]
          CarryOutActivity(V6_writing_a_paragraph_about, t_0); 
         ! phrase 4
         ! [4: if a paragraph break is pending begin]
          if (( (say__p) ))  {
            ! phrase 5
            ! [5: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 6
            ! [6: now the item is mentioned]
             (Adj_65_t2_v9(t_0)); 
            ! phrase 7
            ! [7: say ~[command clarification break]~]
            say__p=1;ParaContent();  CommandClarificationBreak();  .L_Say599; .L_SayX573;
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end if]
         }

      ! phrase 10
      ! [10: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_82, 82, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the use initial appearance in room descriptions rule ):
[ R_83 
    t_0 ! Local variable e.g. 'item' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    t_2 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_83, 83);
      ! phrase 1
      ! [1: if the item is not mentioned begin]
       if (((~~(((Adj_65_t1_v9(t_0)))))))  {
         ! phrase 2
         ! [2: if the item provides the property initial appearance and the item is not handled and the initial appearance of the item is not ~~ begin]
          if ((((WhetherProvides(t_0, false, initial)))) && ((((~~(((Adj_60_t1_v9(t_0))))))) && (((~~((GProperty(9, t_0,initial) == EMPTY_TEXT_VALUE)))))))  {
            ! phrase 3
            ! [3: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 4
            ! [4: say ~[initial appearance of the item]~]
            say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,initial); @pull self;  .L_Say600; .L_SayX574;
            ! phrase 5
            ! [5: say ~[paragraph break]~]
            say__p=1;ParaContent();  DivideParagraphPoint(); new_line;  .L_Say601; .L_SayX575;
            ! phrase 6
            ! [6: if a locale-supportable thing is on the item begin]
             if ((Prop_72(,t_0)))  {
               ! phrase 7
               ! [7: repeat with possibility running through things on the item begin]
                for (t_1=Prop_73(,t_0,0), t_2=Prop_73(,t_0,t_1): t_1: t_1=t_2, t_2=Prop_73(,t_0,t_2))  {
                  ! phrase 8
                  ! [8: now the possibility is marked for listing]
                   (Adj_63_t2_v9(t_1)); 
                  ! phrase 9
                  ! [9: if the possibility is mentioned begin]
                   if ((((Adj_65_t1_v9(t_1)))))  {
                     ! phrase 10
                     ! [10: now the possibility is not marked for listing]
                      (Adj_63_t3_v9(t_1)); 
                     ! phrase 11
                     ! [11: end if]
                     }

                  ! phrase 12
                  ! [12: end repeat]
                  }

               ! phrase 13
               ! [13: say ~On [the item] ~]
               say__p=1;ParaContent();  print (PrintText) SC_929; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_387;  .L_Say602; .L_SayX576;
               ! phrase 14
               ! [14: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
                WriteListFrom(child(t_0), 3800); 
               ! phrase 15
               ! [15: say ~.[paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say603; .L_SayX577;
               ! phrase 16
               ! [16: end if]
               }

            ! phrase 17
            ! [17: now the item is mentioned]
             (Adj_65_t2_v9(t_0)); 
            ! phrase 18
            ! [18: end if]
            }

         ! phrase 19
         ! [19: end if]
         }

      ! phrase 20
      ! [20: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_83, 83, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! For printing a locale paragraph about a thing ( called the item ) ( this is the describe what's on scenery supporters in room descriptions rule ):
[ R_85 
    t_0 ! Local variable e.g. 'item' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    t_2 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_85, 85);
      ! phrase 1
      ! [1: if the item is scenery and the item does not enclose the player begin]
       if (((((Adj_57_t1_v9(t_0))))) && (((~~((IndirectlyContains(t_0,player)))))))  {
         ! phrase 2
         ! [2: if a locale-supportable thing is on the item begin]
          if ((Prop_74(,t_0)))  {
            ! phrase 3
            ! [3: set pronouns from the item]
             PronounNotice(t_0); 
            ! phrase 4
            ! [4: repeat with possibility running through things on the item begin]
             for (t_1=Prop_75(,t_0,0), t_2=Prop_75(,t_0,t_1): t_1: t_1=t_2, t_2=Prop_75(,t_0,t_2))  {
               ! phrase 5
               ! [5: now the possibility is marked for listing]
                (Adj_63_t2_v9(t_1)); 
               ! phrase 6
               ! [6: if the possibility is mentioned begin]
                if ((((Adj_65_t1_v9(t_1)))))  {
                  ! phrase 7
                  ! [7: now the possibility is not marked for listing]
                   (Adj_63_t3_v9(t_1)); 
                  ! phrase 8
                  ! [8: end if]
                  }

               ! phrase 9
               ! [9: end repeat]
               }

            ! phrase 10
            ! [10: increase the locale paragraph count by 1]
             (Global_Vars-->8) = (Global_Vars-->8) + 1; 
            ! phrase 11
            ! [11: say ~On [the item] ~]
            say__p=1;ParaContent();  print (PrintText) SC_929; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_387;  .L_Say604; .L_SayX578;
            ! phrase 12
            ! [12: list the contents of the item , as a sentence , including contents , giving brief inventory information , tersely , not listing concealed items , prefacing with is/are , listing marked items only]
             WriteListFrom(child(t_0), 3800); 
            ! phrase 13
            ! [13: say ~.[paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say605; .L_SayX579;
            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

      ! phrase 16
      ! [16: continue the activity]
       rfalse; 
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_85, 85, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B126_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Carry out taking inventory ( this is the print standard inventory rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_86 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_86, 86);
      ! phrase 1
      ! [1: if the first thing held by the player is nothing , stop the action with library message taking inventory action number 1]
       if ((( (child(player))  == nothing))) {  return GL__M(##Inv,1,noun);   }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_86, 86, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_87 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_87, 87);
      ! phrase 1
      ! [1: issue library message taking inventory action number 2]
       GL__M(##Inv,2,noun); 
      ! phrase 2
      ! [2: say ~:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_934; ParaContent();  new_line;  .L_Say606; .L_SayX580;
      ! phrase 3
      ! [3: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
       WriteListFrom(child(player), 8215); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_87, 87, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B127_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_88 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_88, 88);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message taking inventory action number 5 for the actor]
       if (((~~((actor == player))))) {  AGL__M(##Inv,5,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_88, 88, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B128_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/13 ! Check taking the wooden drawer:
!   >>> I - Number of aspects constrained >>>
! Rule 2/13 ! Check an actor taking ( this is the can't take yourself rule ):
!   === which is equally specific with ===
! Rule 3/13 ! Check an actor taking ( this is the can't take other people rule ):
!   === which is equally specific with ===
! Rule 4/13 ! Check an actor taking ( this is the can't take component parts rule ):
!   === which is equally specific with ===
! Rule 5/13 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === which is equally specific with ===
! Rule 6/13 ! Check an actor taking ( this is the can't take items out of play rule ):
!   === which is equally specific with ===
! Rule 7/13 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === which is equally specific with ===
! Rule 8/13 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === which is equally specific with ===
! Rule 9/13 ! Check an actor taking ( this is the can't take scenery rule ):
!   === which is equally specific with ===
! Rule 10/13 ! Check an actor taking ( this is the can only take things rule ):
!   === which is equally specific with ===
! Rule 11/13 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   >>> III - Action requirement >>>
! Rule 12/13 ! This is the considerate player's holdall rule:
!   <<< III - Action requirement <<<
! Rule 13/13 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check taking the wooden drawer:
[ R_1467 ;
   if ( (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1467, 1467);
      ! phrase 1
      ! [1: if player is on the drawer bottom , say ~You can't take it while you're standing on it.~ instead]
       if (((I590_drawer_bottom == SupporterOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_935;  new_line; .L_Say607; .L_SayX581;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1467, 1467, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take yourself rule ):
[ R_89 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_89, 89);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message taking action number 2 for the noun]
       if (((actor == noun))) {  return GL__M(##Take,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_89, 89, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take other people rule ):
[ R_90 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_90, 90);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message taking action number 3 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Take,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_90, 90, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take component parts rule ):
[ R_91 
    t_0 ! Local variable e.g. 'whole' = thing
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_91, 91);
      ! phrase 1
      ! [1: if the noun is part of something ( called the whole ) , stop the action with library message taking action number 7 for the whole]
       if ((((noun.component_parent) ofclass K2_thing) && (t_0=((noun.component_parent)), true))) {  return GL__M(##Take,7,t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_91, 91, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_92 
    t_0 ! Local variable e.g. 'local ceiling' = object
    t_1 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_92, 92);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: let h be the not-counting-parts holder of the noun]
       t_1 =  (CoreOfParentOfCoreOf(noun)) ; 
      ! phrase 3
      ! [3: while h is not nothing and h is not the local ceiling begin]
       while ((((~~((t_1 == nothing))))) && (((~~((t_1 == t_0))))))  {
         ! phrase 4
         ! [4: if h is a person , stop the action with library message taking action number 6 for h]
          if (((t_1 ofclass K8_person))) {  return GL__M(##Take,6,t_1);   }
         ! phrase 5
         ! [5: let h be the not-counting-parts holder of h]
          t_1 =  (CoreOfParentOfCoreOf(t_1)) ; 
         ! phrase 6
         ! [6: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_92, 92, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take items out of play rule ):
[ R_93 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_93, 93);
      ! phrase 1
      ! [1: let h be the noun]
       t_0 = noun; 
      ! phrase 2
      ! [2: while h is not nothing and h is not a room begin]
       while ((((~~((t_0 == nothing))))) && (((~~((t_0 ofclass K1_room))))))  {
         ! phrase 3
         ! [3: let h be the not-counting-parts holder of h]
          t_0 =  (CoreOfParentOfCoreOf(t_0)) ; 
         ! phrase 4
         ! [4: end while]
         }

      ! phrase 5
      ! [5: if h is nothing , stop the action with library message taking action number 8 for the noun]
       if (((t_0 == nothing))) {  return GL__M(##Take,8,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_93, 93, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_94 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_94, 94);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message taking action number 4 for the noun]
       if (((t_0 == noun))) {  return GL__M(##Take,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_94, 94, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_95 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_95, 95);
      ! phrase 1
      ! [1: if the actor is carrying the noun , stop the action with library message taking action number 5 for the noun]
       if (((actor == CarrierOf(noun)))) {  return GL__M(##Take,5,noun);   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , stop the action with library message taking action number 5 for the noun]
       if (((actor == WearerOf(noun)))) {  return GL__M(##Take,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_95, 95, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take scenery rule ):
[ R_96 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_96, 96);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message taking action number 10 for the noun]
       if ((((Adj_57_t1_v9(noun))))) {  return GL__M(##Take,10,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_96, 96, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can only take things rule ):
[ R_97 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_97, 97);
      ! phrase 1
      ! [1: if the noun is not a thing , stop the action with library message taking action number 15 for the noun]
       if (((~~((noun ofclass K2_thing))))) {  return GL__M(##Take,15,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_97, 97, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_98 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_98, 98);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message taking action number 11 for the noun]
       if ((((Adj_55_t1_v9(noun))))) {  return GL__M(##Take,11,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_98, 98, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! This is the considerate player's holdall rule:
[ R_787 
    t_0 ! Local variable e.g. '?-1,-1?' = player's holdall
    t_1 ! Local variable e.g. '?-1,-1?' = player's holdall
    t_2 ! Local variable e.g. '?-1,-1?' = number
    t_3 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: if the number of things carried by the player is at least the carrying capacity of the player begin]
       if ((( (Prop_76())  >= GProperty(9, player,capacity))))  {
         ! phrase 2
         ! [2: now every player's holdall is chunavailable]
          Prop_77(); 
         ! phrase 3
         ! [3: repeat with current holdall running through player's holdalls enclosed by the player begin]
          for (t_0=Prop_78(0), t_1=Prop_78(t_0): t_0: t_0=t_1, t_1=Prop_78(t_1))  {
            ! phrase 4
            ! [4: follow the holdall rules for the current holdall]
             FollowRulebook(377, t_0, true); 
            ! phrase 5
            ! [5: if the outcome of the rulebook is the disallow stashing outcome , now the current holdall is chunavailable]
             if ((( (ResultOfRule())  == RBNO_15))) {  (Adj_87_t2_v9(t_0));   }
            ! phrase 6
            ! [6: if the outcome of the rulebook is the allow stashing outcome , now the current holdall is chavailable]
             if ((( (ResultOfRule())  == RBNO_13))) {  (Adj_86_t2_v9(t_0));   }
            ! phrase 7
            ! [7: end repeat]
            }

         ! phrase 8
         ! [8: repeat with current holdall running through chavailable player's holdalls begin]
          for (t_0=Prop_79(0), t_1=Prop_79(t_0): t_0: t_0=t_1, t_1=Prop_79(t_1))  {
            ! phrase 9
            ! [9: change considered holdall to current holdall]
             (Global_Vars-->10) = t_0; 
            ! phrase 10
            ! [10: repeat with item running through things carried by the player begin]
             for (t_2=Prop_80(0), t_3=Prop_80(t_2): t_2: t_2=t_3, t_3=Prop_80(t_3))  {
               ! phrase 11
               ! [11: follow the stashing rules for the item]
                FollowRulebook(378, t_2, true); 
               ! phrase 12
               ! [12: if the outcome of the rulebook is the disallow stashing outcome , now the item is chunviable]
                if ((( (ResultOfRule())  == RBNO_15))) {  (Adj_89_t2_v9(t_2));   }
               ! phrase 13
               ! [13: if the outcome of the rulebook is the allow stashing outcome , now the item is chviable]
                if ((( (ResultOfRule())  == RBNO_13))) {  (Adj_88_t2_v9(t_2));   }
               ! phrase 14
               ! [14: end repeat]
               }

            ! phrase 15
            ! [15: change the current stashable thing to a random forgotten-about chviable thing held by the player]
             (Global_Vars-->11) =  (Prop_81()) ; 
            ! phrase 16
            ! [16: if the current stashable thing is not a thing begin]
             if (((~~(((Global_Vars-->11) ofclass K2_thing)))))  {
               ! phrase 17
               ! [17: repeat through table of recent items in time order begin]
                @push ct_0; @push ct_1;
		for (t_2=T4_recent_items,t_3=TableNextRow(t_2,110,0,1),ct_0=t_2,ct_1=t_3:
			t_3~=0:
			t_3=TableNextRow(t_2,110,t_3,1),ct_0=t_2,ct_1=t_3)  {
                  ! phrase 18
                  ! [18: if the recent item entry is chviable and the recent item entry is carried by the player begin]
                   if (((((Adj_88_t1_v9(TableLookUpEntry(ct_0,109,ct_1)))))) && (((player == CarrierOf(TableLookUpEntry(ct_0,109,ct_1))))))  {
                     ! phrase 19
                     ! [19: change the current stashable thing to the recent item entry]
                      (Global_Vars-->11) = TableLookUpEntry(ct_0,109,ct_1); 
                     ! phrase 20
                     ! [20: break]
                      break; 
                     ! phrase 21
                     ! [21: end if]
                     }

                  ! phrase 22
                  ! [22: end repeat]
                  }
@pull ct_1; @pull ct_0;
               ! phrase 23
               ! [23: end if]
               }

            ! phrase 24
            ! [24: if the current stashable thing is a thing begin]
             if ((((Global_Vars-->11) ofclass K2_thing)))  {
               ! phrase 25
               ! [25: if using the inline implicit library option begin]
                if (( (TestUseOption(23)) ))  {
                  ! phrase 26
                  ! [26: spit inline library message as appropriate for the current stashable thing into the considered holdall]
                   SACK_OBJECT  = (Global_Vars-->10); #ifdef INLINE;  __stash((Global_Vars-->11)); #endif;
	
                  ! phrase 27
                  ! [27: if the current stashable thing is not inside the considered holdall , stop the action]
                   if (((~~(((Global_Vars-->10) == ContainerOf((Global_Vars-->11))))))) {  rtrue;   }
                  ! phrase 28
                  ! [28: otherwise]
                  } else {

                  ! phrase 29
                  ! [29: try silently inserting the current stashable thing into the considered holdall]
                   @push keep_silent; keep_silent=1; TryAction(0, player, ##Insert, (Global_Vars-->11), (Global_Vars-->10));; @pull keep_silent; 
                  ! phrase 30
                  ! [30: if the current stashable thing is not inside the considered holdall , stop the action]
                   if (((~~(((Global_Vars-->10) == ContainerOf((Global_Vars-->11))))))) {  rtrue;   }
                  ! phrase 31
                  ! [31: spit library message as appropriate for the current stashable thing into the considered holdall]
                   SACK_OBJECT  = (Global_Vars-->10); GL__M(##Take,13,(Global_Vars-->11));  
	
                  ! phrase 32
                  ! [32: end if]
                  }

               ! phrase 33
               ! [33: continue the action]
                rfalse; 
               ! phrase 34
               ! [34: end if]
               }

            ! phrase 35
            ! [35: end repeat]
            }

         ! phrase 36
         ! [36: spit library message for failure of holdalls instead]
          GL__M(##Take,12);  
	 rtrue;
         ! phrase 37
         ! [37: end if]
         }

   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_100 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_100, 100);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor , stop the action with library message taking action number 12 for the actor]
       if ((( (Prop_82())  >= GProperty(9, actor,capacity)))) {  return GL__M(##Take,12,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_100, 100, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B129_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor taking ( this is the standard taking rule ):
[ R_101 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_101, 101);
      ! phrase 1
      ! [1: now the actor carries the noun]
       MoveObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_101, 101, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B130_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking ( this is the standard report taking rule ):
[ R_102 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_102, 102);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking action number 1 for the noun]
       if (((actor == player))) {  GL__M(##Take,1,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message taking action number 16 for the noun]
       else {  AGL__M(##Take,16,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_102, 102, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B131_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_103 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_103, 103);
      ! phrase 1
      ! [1: if the holder of the noun is not the second noun , stop the action with library message removing it from action number 2 for the noun]
       if (((~~(( (HolderOf(noun))  == second))))) {  return GL__M(##Remove,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_103, 103, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_104 
    t_0 ! Local variable e.g. 'owner' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_104, 104);
      ! phrase 1
      ! [1: let the owner be the holder of the noun]
       t_0 =  (HolderOf(noun)) ; 
      ! phrase 2
      ! [2: if the owner is a person begin]
       if (((t_0 ofclass K8_person)))  {
         ! phrase 3
         ! [3: if the owner is the actor , convert to the taking off action on the noun]
          if (((t_0 == actor))) {  return GVS_Convert(##Disrobe,noun,0);   }
         ! phrase 4
         ! [4: stop the action with library message taking action number 6 for the owner]
          return GL__M(##Take,6,t_0); 
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_104, 104, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_105 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_105, 105);
      ! phrase 1
      ! [1: convert to the taking action on the noun]
       return GVS_Convert(##Take,noun,0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_105, 105, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B134_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_106 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_106, 106);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message putting it on action number 4]
       if (((noun == actor))) {  return GL__M(##PutOn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_106, 106, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_107 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_107, 107);
      ! phrase 1
      ! [1: if the noun is in the holder of the actor , stop the action with library message dropping action number 1 for the noun]
       if ((( (HolderOf(actor))  == ContainerOf(noun)))) {  return GL__M(##Drop,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_107, 107, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_108 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_108, 108);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: stop the action with library message dropping action number 2 for the noun]
       return GL__M(##Drop,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_108, 108, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_109 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_109, 109);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_109, 109, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_110 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_110, 110);
      ! phrase 1
      ! [1: let h be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if h is a room , continue the action]
       if (((t_0 ofclass K1_room))) {  rfalse;   }
      ! phrase 3
      ! [3: if h provides the property carrying capacity begin]
       if (((WhetherProvides(t_0, false, capacity))))  {
         ! phrase 4
         ! [4: if h is a supporter begin]
          if (((t_0 ofclass K6_supporter)))  {
            ! phrase 5
            ! [5: if the number of things on h is at least the carrying capacity of h begin]
             if ((( (Prop_83(,t_0))  >= GProperty(OBJECT_TY, t_0,capacity))))  {
               ! phrase 6
               ! [6: if the actor is the player , issue library message dropping action number 5 for h]
                if (((actor == player))) {  GL__M(##Drop,5,t_0);   }
               ! phrase 7
               ! [7: stop the action]
                rtrue; 
               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: otherwise if h is a container]
             } else if (((t_0 ofclass K5_container))) { 
            ! phrase 10
            ! [10: if the number of things in h is at least the carrying capacity of h begin]
             if ((( (Prop_84(,t_0))  >= GProperty(OBJECT_TY, t_0,capacity))))  {
               ! phrase 11
               ! [11: if the actor is the player , issue library message dropping action number 6 for h]
                if (((actor == player))) {  GL__M(##Drop,6,t_0);   }
               ! phrase 12
               ! [12: stop the action]
                rtrue; 
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_110, 110, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B135_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_111 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_111, 111);
      ! phrase 1
      ! [1: now the noun is in the holder of the actor]
       MoveObject(noun, (HolderOf(actor)) ); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_111, 111, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B136_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_112 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_112, 112);
      ! phrase 1
      ! [1: if the actor is the player , issue library message dropping action number 4 for the noun]
       if (((actor == player))) {  GL__M(##Drop,4,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message dropping action number 7 for the noun]
       else {  AGL__M(##Drop,7,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_112, 112, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B137_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 5/7 ! This is the can't put onto something being carried except keychains rule:
!   <<< I - Number of aspects constrained <<<
! Rule 6/7 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_113 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_113, 113);
      ! phrase 1
      ! [1: if the second noun is down or the actor is on the second noun , convert to the dropping action on the noun]
       if ((((second == I55_down))) || (((second == SupporterOf(actor))))) {  return GVS_Convert(##Drop,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_113, 113, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_114 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_114, 114);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: issue miscellaneous library message number 26 for the noun]
       GL__M(##Miscellany,26, noun); 
      ! phrase 4
      ! [4: silently try the actor taking the noun]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Take, noun, 0);; @pull keep_silent; 
      ! phrase 5
      ! [5: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 6
      ! [6: stop the action with library message putting it on action number 1 for the noun]
       return GL__M(##PutOn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_114, 114, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_115 
    t_0 ! Local variable e.g. 'noun-CPC' = object
    t_1 ! Local variable e.g. 'second-CPC' = object
    t_2 ! Local variable e.g. 'transfer ceiling' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_115, 115);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
       t_0 =  CoreOf(noun) ; 
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
       t_1 =  CoreOf(second) ; 
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
       t_2 =  (CommonAncestor(t_0, t_1)) ; 
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message putting it on action number 2 for the noun]
       if (((t_2 == t_0))) {  return GL__M(##PutOn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_115, 115, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_116 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_116, 116);
      ! phrase 1
      ! [1: if the second noun is not a supporter , stop the action with library message putting it on action number 3 for the second noun]
       if (((~~((second ofclass K6_supporter))))) {  return GL__M(##PutOn,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_116, 116, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the can't put onto something being carried except keychains rule:
[ R_842 ;
      ! phrase 1
      ! [1: if the second noun is not a keychain begin]
       if (((~~((second ofclass K19_keychain)))))  {
         ! phrase 2
         ! [2: abide by the can't put onto something being carried rule]
          if (ProcessRulebook(R_117)) rtrue; 
         ! phrase 3
         ! [3: end if]
         }

   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_118 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_118, 118);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message putting it on action number 5 for the noun]
          GL__M(##PutOn,5,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_118, 118, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_119 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_119, 119);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
       if (((WhetherProvides(second, false, capacity))))  {
         ! phrase 2
         ! [2: if the number of things on the second noun is at least the carrying capacity of the second noun , stop the action with library message putting it on action number 6 for the second noun]
          if ((( (Prop_85())  >= GProperty(OBJECT_TY, second,capacity)))) {  return GL__M(##PutOn,6,second);   }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_119, 119, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B138_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_120 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_120, 120);
      ! phrase 1
      ! [1: now the noun is on the second noun]
       MoveObject(noun,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_120, 120, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B139_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_121 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_121, 121);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message putting it on action number 7 for the noun]
       if ((((actor == player))) && (( (multiflag==1) ))) {  return GL__M(##PutOn,7,noun);   }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_121, 121, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_122 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_122, 122);
      ! phrase 1
      ! [1: if the actor is the player , issue library message putting it on action number 8 for the noun]
       if (((actor == player))) {  GL__M(##PutOn,8,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message putting it on action number 9 for the noun]
       else {  AGL__M(##PutOn,9,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_122, 122, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B140_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/8 ! Check inserting something into the mural:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/8 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === which is equally specific with ===
! Rule 3/8 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === which is equally specific with ===
! Rule 4/8 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === which is equally specific with ===
! Rule 5/8 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === which is equally specific with ===
! Rule 6/8 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === which is equally specific with ===
! Rule 7/8 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === which is equally specific with ===
! Rule 8/8 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check inserting something into the mural:
[ R_1299 ;
   if ( (actor==player) && ((noun ofclass K2_thing)) && ((second == I489_large_painted_mural) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1299, 1299);
      ! phrase 1
      ! [1: if the noun is not the flagpole , say ~[The noun] won't fit.~ instead]
       if (((~~((noun == I490_flagpole))))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_936;  new_line; .L_Say608; .L_SayX582;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1299, 1299, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_123 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_123, 123);
      ! phrase 1
      ! [1: if the second noun is down or the actor is in the second noun , convert to the dropping action on the noun]
       if ((((second == I55_down))) || (((second == ContainerOf(actor))))) {  return GVS_Convert(##Drop,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_123, 123, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_124 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_124, 124);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
       if (((actor == WearerOf(noun)))) {  rfalse;   }
      ! phrase 3
      ! [3: issue miscellaneous library message number 26 for the noun]
       GL__M(##Miscellany,26, noun); 
      ! phrase 4
      ! [4: silently try the actor taking the noun]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Take, noun, 0);; @pull keep_silent; 
      ! phrase 5
      ! [5: if the actor is carrying the noun , continue the action]
       if (((actor == CarrierOf(noun)))) {  rfalse;   }
      ! phrase 6
      ! [6: stop the action]
       rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_124, 124, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_125 
    t_0 ! Local variable e.g. 'noun-CPC' = object
    t_1 ! Local variable e.g. 'second-CPC' = object
    t_2 ! Local variable e.g. 'transfer ceiling' = object
    ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_125, 125);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
       t_0 =  CoreOf(noun) ; 
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
       t_1 =  CoreOf(second) ; 
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
       t_2 =  (CommonAncestor(t_0, t_1)) ; 
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message inserting it into action number 5 for the noun]
       if (((t_2 == t_0))) {  return GL__M(##Insert,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_125, 125, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_126 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_126, 126);
      ! phrase 1
      ! [1: if the second noun is a closed container , stop the action with library message inserting it into action number 3 for the second noun]
       if (((second ofclass K5_container) && ((Adj_71_t1_v9(second))))) {  return GL__M(##Insert,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_126, 126, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_127 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_127, 127);
      ! phrase 1
      ! [1: if the second noun is not a container , stop the action with library message inserting it into action number 2 for the second noun]
       if (((~~((second ofclass K5_container))))) {  return GL__M(##Insert,2,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_127, 127, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_128 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_128, 128);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message inserting it into action number 6 for the noun]
          GL__M(##Insert,6,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_128, 128, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_129 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_129, 129);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
       if (((WhetherProvides(second, false, capacity))))  {
         ! phrase 2
         ! [2: if the number of things in the second noun is at least the carrying capacity of the second noun , stop the action with library message inserting it into action number 7 for the second noun]
          if ((( (Prop_86())  >= GProperty(OBJECT_TY, second,capacity)))) {  return GL__M(##Insert,7,second);   }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_129, 129, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B141_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_130 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_130, 130);
      ! phrase 1
      ! [1: now the noun is in the second noun]
       MoveObject(noun,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_130, 130, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B142_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report inserting the flagpole into the brass metal pipe:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/3 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report inserting the flagpole into the brass metal pipe:
[ R_1657 ;
   if ( (actor==player) && ((noun == I490_flagpole) && (true)) && ((second == I657_brass_metal_pipe) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1657, 1657);
      ! phrase 1
      ! [1: say ~You thread the flagpole through [if the medium-sized wheel is on the brass metal pipe]the holes in the wheel and pipe, anchoring the wheel to the pipe[otherwise]the pipe[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_937; 
	if (~~((((I657_brass_metal_pipe == SupporterOf(I660_medium_sized_wheel)))))) jump L_Say609;
		ParaContent();  print (PrintText) SC_938; 
	jump L_SayX583; .L_Say609;
		ParaContent();  print (PrintText) SC_939; 
	.L_Say610; .L_SayX583;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say611; .L_SayX584;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1657, 1657, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_131 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_131, 131);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message inserting it into action number 8 for the noun]
       if ((((actor == player))) && (( (multiflag==1) ))) {  return GL__M(##Insert,8,noun);   }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_131, 131, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_132 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_132, 132);
      ! phrase 1
      ! [1: if the actor is the player , issue library message inserting it into action number 9 for the noun]
       if (((actor == player))) {  GL__M(##Insert,9,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message inserting it into action number 10 for the noun]
       else {  AGL__M(##Insert,10,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_132, 132, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B143_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_133 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_133, 133);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not edible , stop the action with library message eating action number 1 for the noun]
       if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_53_t1_v9(noun)))))))) {  return GL__M(##Eat,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_133, 133, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_134 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_134, 134);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: try the actor trying taking off the noun]
          TryAction(0, actor, ##Disrobe, noun, 0);; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_134, 134, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B144_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor eating ( this is the standard eating rule ):
[ R_135 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_135, 135);
      ! phrase 1
      ! [1: remove the noun from play]
       RemoveFromPlay(noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_135, 135, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B145_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor eating ( this is the standard report eating rule ):
[ R_136 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_136, 136);
      ! phrase 1
      ! [1: if the actor is the player , issue library message eating action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Eat,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message eating action number 3 for the noun]
       else {  AGL__M(##Eat,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_136, 136, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B146_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! Check going a direction ( called the way ) from Freshwater Crossing when the secretary is in Grassy Area:
!   >>> I - Number of aspects constrained >>>
! Rule 2/9 ! Check going west in Outside Waterworks:
!   === which is equally specific with ===
! Rule 3/9 ! Check going up in the Hill:
!   === which is equally specific with ===
! Rule 4/9 ! Check going east in Other Side of the Pond:
!   >>> I - Number of aspects constrained >>>
! Rule 5/9 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === which is equally specific with ===
! Rule 6/9 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === which is equally specific with ===
! Rule 7/9 ! Check an actor going ( this is the determine map connection rule ):
!   === which is equally specific with ===
! Rule 8/9 ! Check an actor going ( this is the can't go that way rule ):
!   >>> III - Action requirement >>>
! Rule 9/9 ! Check going:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check going a direction ( called the way ) from Freshwater Crossing when the secretary is in Grassy Area:
[ R_1516 
    t_0 ! Local variable e.g. 'way' = direction
    ;
   if ( (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K3_direction)))) && (((MStack-->MstVON(20007,0)) == I507_freshwater_crossing) && (true)) && ((MStack-->MstVON(20007,1)) ~= nothing) && (self=actor,true) && (((I509_grassy_area == ContainerOf(I545_secretary_of_water))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1516, 1516);
      ! phrase 1
      ! [1: if the way is southwest begin]
       if (((t_0 == I51_southwest)))  {
         ! phrase 2
         ! [2: continue the action]
          rfalse; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~You take a step to [the way], but then stop. [The secretary] had looked... agitated? nervous?, and you can't help feeling that you're part of the cause of her distress, and that maybe you shouldn't run away from her.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_940; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_941; ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_772;  new_line; rtrue; .L_Say612; .L_SayX585; rtrue;
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1516, 1516, true);
   rfalse;
];
! No specific request
! Check going west in Outside Waterworks:
[ R_1251 ;
   if ( (actor==player) && ((noun == I53_west) && (true)) && ((real_location == I447_outside_waterworks) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1251, 1251);
      ! phrase 1
      ! [1: if muddy beach is visited , try climbing the fence instead]
       if ((((Adj_49_t1_v9(I468_muddy_beach))))) {  TryAction(0, player, ##Climb, I473_chain_link_fence, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1251, 1251, true);
   rfalse;
];
! No specific request
! Check going up in the Hill:
[ R_1413 ;
   if ( (actor==player) && ((noun == I54_up) && (true)) && ((real_location == I441_hill) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1413, 1413);
      ! phrase 1
      ! [1: if the player is on the bench begin]
       if (((I552_bench == SupporterOf(player))))  {
         ! phrase 2
         ! [2: say ~From your position standing on the bench, you are just able to reach the bottom branch, and scramble up.~]
         say__p=1;ParaContent();  print (PrintText) SC_942;  new_line; .L_Say613; .L_SayX586;
         ! phrase 3
         ! [3: move the player to in the sweetgum tree]
          MoveObject(player, I442_in_the_sweetgum_tree, 0, false); 
         ! phrase 4
         ! [4: stop the action]
          rtrue; 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: if the player is on the drawer bottom begin]
       if (((I590_drawer_bottom == SupporterOf(player))))  {
         ! phrase 7
         ! [7: say ~You can [if the wooden drawer is on the bench]easily[otherwise]just[end if] reach the bottom branch from here; you scramble up into the tree.~]
         say__p=1;ParaContent();  print (PrintText) SC_943; 
	if (~~((((I552_bench == SupporterOf(I589_wooden_drawer)))))) jump L_Say614;
		ParaContent();  print (PrintText) SC_944; 
	jump L_SayX587; .L_Say614;
		ParaContent();  print (PrintText) SC_945; 
	.L_Say615; .L_SayX587;
		ParaContent();  print (PrintText) SC_946;  new_line; .L_Say616; .L_SayX588;
         ! phrase 8
         ! [8: move the player to in the sweetgum tree]
          MoveObject(player, I442_in_the_sweetgum_tree, 0, false); 
         ! phrase 9
         ! [9: stop the action]
          rtrue; 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if the player is not on the bench , say ~You try to grab the bottom branch, but you're just a foot or so short of being able to reach it.~ instead]
       if (((~~((I552_bench == SupporterOf(player)))))) { say__p=1;ParaContent();  print (PrintText) SC_947;  new_line; .L_Say617; .L_SayX589;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1413, 1413, true);
   rfalse;
];
! No specific request
! Check going east in Other Side of the Pond:
[ R_1542 ;
   if ( (actor==player) && ((noun == I52_east) && (true)) && ((real_location == I494_other_side_of_the_pond) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1542, 1542);
      ! phrase 1
      ! [1: if the player is not in the rowboat begin]
       if (((~~((I481_rowboat == ContainerOf(player))))))  {
         ! phrase 2
         ! [2: say ~You wade into the water a few steps, but retreat before it gets too deep.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_948;  new_line; rtrue; .L_Say618; .L_SayX590; rtrue;
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1542, 1542, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_139 
    t_0 ! Local variable e.g. 'H' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_139, 139);
      ! phrase 1
      ! [1: let h be the holder of the actor]
       t_0 =  (HolderOf(actor)) ; 
      ! phrase 2
      ! [2: if h is the room gone from , continue the action]
       if (((t_0 == (MStack-->MstVO(20007,0))))) {  rfalse;   }
      ! phrase 3
      ! [3: if h is the vehicle gone by , continue the action]
       if (((t_0 == (MStack-->MstVO(20007,3))))) {  rfalse;   }
      ! phrase 4
      ! [4: stop the action with library message going action number 1 for h]
       return GL__M(##Go,1,t_0); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_139, 139, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_141 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_141, 141);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is closed begin]
       if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_71_t1_v9((MStack-->MstVO(20007,2))))))))  {
         ! phrase 2
         ! [2: issue library message going action number 28 for the door gone through]
          GL__M(##Go,28,(MStack-->MstVO(20007,2))); 
         ! phrase 3
         ! [3: silently try the actor opening the door gone through]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Open, (MStack-->MstVO(20007,2)), 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the door gone through is open , continue the action]
          if ((((Adj_70_t1_v9((MStack-->MstVO(20007,2))))))) {  rfalse;   }
         ! phrase 5
         ! [5: stop the action]
          rtrue; 
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_141, 141, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the determine map connection rule ):
[ R_142 
    t_0 ! Local variable e.g. 'target' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_142, 142);
      ! phrase 1
      ! [1: let the target be nothing]
       t_0 = nothing; 
      ! phrase 2
      ! [2: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 3
         ! [3: let direction d be the noun]
          t_1 = noun; 
         ! phrase 4
         ! [4: let the target be the room-or-door direction d from the room gone from]
          t_0 = (Resolver_0(t_1,(MStack-->MstVO(20007,0)),"source", 1982)); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: if the noun is a door , let the target be the noun]
          if (((noun ofclass K4_door))) {  t_0 = noun;   }
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the target is a door begin]
       if (((t_0 ofclass K4_door)))  {
         ! phrase 9
         ! [9: now the target is the other side of the target from the room gone from]
          t_0 = (Resolver_1(t_0,(MStack-->MstVO(20007,0)),"source", 1986)); 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: now the room gone to is the target]
       (MStack-->MstVO(20007,1)) = t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_142, 142, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go that way rule ):
[ R_143 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_143, 143);
      ! phrase 1
      ! [1: if the room gone to is nothing begin]
       if ((((MStack-->MstVO(20007,1)) == nothing)))  {
         ! phrase 2
         ! [2: if the door gone through is nothing , stop the action with library message going action number 2 for the room gone from]
          if ((((MStack-->MstVO(20007,2)) == nothing))) {  return GL__M(##Go,2,(MStack-->MstVO(20007,0)));   }
         ! phrase 3
         ! [3: stop the action with library message going action number 6 for the door gone through]
          return GL__M(##Go,6,(MStack-->MstVO(20007,2))); 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_143, 143, true);
   rfalse;
];
! No specific request
! Check going:
[ R_1272 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1272, 1272);
      ! phrase 1
      ! [1: if the rowboat contains the player and the player is unboaty , say ~You can ROW a direction WITH something to paddle with.~ instead]
       if ((((I481_rowboat == ContainerOf(player)))) && ((((Adj_111_t1_v9(player)))))) { say__p=1;ParaContent();  print (PrintText) SC_949;  new_line; .L_Say619; .L_SayX591;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1272, 1272, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B147_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! First carry out going rule ( this is the Small Kindnesses store former location rule ):
! --- now the mid-placed rules ---
! Rule 2/5 ! Carry out going to the Boat House:
!   >>> I - Number of aspects constrained >>>
! Rule 3/5 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Carry out an actor going ( this is the move floating objects rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! First carry out going rule ( this is the Small Kindnesses store former location rule ):
[ R_746 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_746, 746);
      ! phrase 1
      ! [1: now the small kindnesses former location is the location]
       (Global_Vars-->9) = real_location; if (~~((Global_Vars-->9) ofclass K1_room)) RunTimeProblem(RTP_WRONGASSIGNEDKIND, (Global_Vars-->9), "now the small kindnesses former location is the location", "room");; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_746, 746, true);
   rfalse;
];
! No specific request
! Carry out going to the Boat House:
[ R_1276 ;
   if ( (actor==player) && (((MStack-->MstVON(20007,1)) == I479_boat_house) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1276, 1276);
      ! phrase 1
      ! [1: if the player is not in the rowboat , say ~You walk into something very wet, and just manage to catch your balance.~]
       if (((~~((I481_rowboat == ContainerOf(player)))))) { say__p=1;ParaContent();  print (PrintText) SC_950;  new_line; .L_Say620; .L_SayX592;  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1276, 1276, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_144 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_144, 144);
      ! phrase 1
      ! [1: if the vehicle gone by is nothing , surreptitiously move the actor to the room gone to during going]
       if ((((MStack-->MstVO(20007,3)) == nothing))) {  MoveDuringGoing(actor, (MStack-->MstVO(20007,1)));   }
      ! phrase 2
      ! [2: otherwise surreptitiously move the vehicle gone by to the room gone to during going]
       else {  MoveDuringGoing((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_144, 144, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the move floating objects rule ):
[ R_145 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_145, 145);
      ! phrase 1
      ! [1: if the actor is the player , update backdrop positions]
       if (((actor == player))) {  MoveFloatingObjects();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_145, 145, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor going ( this is the check light in new location rule ):
[ R_146 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_146, 146);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously reckon darkness]
       if (((actor == player))) {  SilentlyConsiderLight();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_146, 146, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B148_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report the dog going a direction ( called the way ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report the dog going a direction ( called the way ):
[ R_1552 
    t_0 ! Local variable e.g. 'way' = direction
    ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor == I443_dog) && (true)) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K3_direction))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1552, 1552);
      ! phrase 1
      ! [1: if the player is in the location of the dog , say ~The dog pads in from [the opposite of the way].~ instead]
       if ((( LocationOf(I443_dog)  == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_951; ParaContent(); @push self;  print (the) GProperty(9, self=t_0,p9_opposite); @pull self; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say621; .L_SayX593;  rtrue; }
      ! phrase 2
      ! [2: otherwise say ~The dog trots away to [the way].~ instead]
       else { say__p=1;ParaContent();  print (PrintText) SC_952; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say622; .L_SayX594;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1552, 1552, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor going ( this is the describe room gone into rule ):
[ R_147 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_147, 147);
      ! phrase 1
      ! [1: if the player is the actor begin]
       if (((player == actor)))  {
         ! phrase 2
         ! [2: produce a room description with going spacing conventions]
          LookAfterGoing(); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the noun is a direction begin]
          if (((noun ofclass K3_direction)))  {
            ! phrase 5
            ! [5: if the location is the room gone from begin]
             if (((real_location == (MStack-->MstVO(20007,0)))))  {
               ! phrase 6
               ! [6: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1)))))  {
                  ! phrase 7
                  ! [7: continue the action]
                   rfalse; 
                  ! phrase 8
                  ! [8: otherwise]
                  } else {

                  ! phrase 9
                  ! [9: if the noun is up begin]
                   if (((noun == I54_up)))  {
                     ! phrase 10
                     ! [10: issue actor-based library message going action number 8]
                      AGL__M(##Go,8,noun); 
                     ! phrase 11
                     ! [11: otherwise if the noun is down]
                      } else if (((noun == I55_down))) { 
                     ! phrase 12
                     ! [12: issue actor-based library message going action number 9]
                      AGL__M(##Go,9,noun); 
                     ! phrase 13
                     ! [13: otherwise]
                     } else {

                     ! phrase 14
                     ! [14: issue actor-based library message going action number 10 for the noun]
                      AGL__M(##Go,10,noun); 
                     ! phrase 15
                     ! [15: end if]
                     }

                  ! phrase 16
                  ! [16: end if]
                  }

               ! phrase 17
               ! [17: otherwise]
               } else {

               ! phrase 18
               ! [18: let the back way be the opposite of the noun]
                t_0 = GProperty(OBJECT_TY, noun,p9_opposite); 
               ! phrase 19
               ! [19: if the location is the room gone to begin]
                if (((real_location == (MStack-->MstVO(20007,1)))))  {
                  ! phrase 20
                  ! [20: let the room back the other way be the room back way from the location]
                   t_1 = (Resolver_7(t_0,real_location,"source", 2027)); 
                  ! phrase 21
                  ! [21: let the room normally this way be the room noun from the room gone from]
                   t_2 = (Resolver_8(noun,(MStack-->MstVO(20007,0)),"source", 2029)); 
                  ! phrase 22
                  ! [22: if the room back the other way is the room gone from or the room back the other way is the room normally this way begin]
                   if ((((t_1 == (MStack-->MstVO(20007,0))))) || (((t_1 == t_2))))  {
                     ! phrase 23
                     ! [23: if the back way is up begin]
                      if (((t_0 == I54_up)))  {
                        ! phrase 24
                        ! [24: issue actor-based library message going action number 11]
                         AGL__M(##Go,11,noun); 
                        ! phrase 25
                        ! [25: otherwise if the back way is down]
                         } else if (((t_0 == I55_down))) { 
                        ! phrase 26
                        ! [26: issue actor-based library message going action number 12]
                         AGL__M(##Go,12,noun); 
                        ! phrase 27
                        ! [27: otherwise]
                        } else {

                        ! phrase 28
                        ! [28: issue actor-based library message going action number 13 for the back way]
                         AGL__M(##Go,13,t_0); 
                        ! phrase 29
                        ! [29: end if]
                        }

                     ! phrase 30
                     ! [30: otherwise]
                     } else {

                     ! phrase 31
                     ! [31: issue actor-based library message going action number 14]
                      AGL__M(##Go,14,noun); 
                     ! phrase 32
                     ! [32: end if]
                     }

                  ! phrase 33
                  ! [33: otherwise]
                  } else {

                  ! phrase 34
                  ! [34: if the back way is up begin]
                   if (((t_0 == I54_up)))  {
                     ! phrase 35
                     ! [35: issue actor-based library message going action number 15 for the room gone to]
                      AGL__M(##Go,15,(MStack-->MstVO(20007,1))); 
                     ! phrase 36
                     ! [36: otherwise if the back way is down]
                      } else if (((t_0 == I55_down))) { 
                     ! phrase 37
                     ! [37: issue actor-based library message going action number 16 for the room gone to]
                      AGL__M(##Go,16,(MStack-->MstVO(20007,1))); 
                     ! phrase 38
                     ! [38: otherwise]
                     } else {

                     ! phrase 39
                     ! [39: issue actor-based library message going action number 17 for the room gone to and the back way]
                      AGL__M(##Go,17,(MStack-->MstVO(20007,1)),t_0); 
                     ! phrase 40
                     ! [40: end if]
                     }

                  ! phrase 41
                  ! [41: end if]
                  }

               ! phrase 42
               ! [42: end if]
               }

            ! phrase 43
            ! [43: otherwise if the location is the room gone from]
             } else if (((real_location == (MStack-->MstVO(20007,0))))) { 
            ! phrase 44
            ! [44: issue actor-based library message going action number 18 for the noun]
             AGL__M(##Go,18,noun); 
            ! phrase 45
            ! [45: otherwise]
            } else {

            ! phrase 46
            ! [46: issue actor-based library message going action number 19 for the noun]
             AGL__M(##Go,19,noun); 
            ! phrase 47
            ! [47: end if]
            }

         ! phrase 48
         ! [48: if the vehicle gone by is not nothing begin]
          if (((~~(((MStack-->MstVO(20007,3)) == nothing)))))  {
            ! phrase 49
            ! [49: say ~ ~]
            say__p=1;ParaContent();  print (PrintText) SC_387;  .L_Say623; .L_SayX595;
            ! phrase 50
            ! [50: if the vehicle gone by is a supporter , issue actor-based library message going action number 20 for the vehicle gone by]
             if ((((MStack-->MstVO(20007,3)) ofclass K6_supporter))) {  AGL__M(##Go,20,(MStack-->MstVO(20007,3)));   }
            ! phrase 51
            ! [51: otherwise issue actor-based library message going action number 21 for the vehicle gone by]
             else {  AGL__M(##Go,21,(MStack-->MstVO(20007,3)));   }
            ! phrase 52
            ! [52: end if]
            }

         ! phrase 53
         ! [53: if the thing gone with is not nothing begin]
          if (((~~(((MStack-->MstVO(20007,4)) == nothing)))))  {
            ! phrase 54
            ! [54: if the player is within the thing gone with begin]
             if ((((MStack-->MstVO(20007,4)) == ContainerOf(player))))  {
               ! phrase 55
               ! [55: issue actor-based library message going action number 22 for the thing gone with]
                AGL__M(##Go,22,(MStack-->MstVO(20007,4))); 
               ! phrase 56
               ! [56: otherwise if the player is within the vehicle gone by]
                } else if ((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) { 
               ! phrase 57
               ! [57: issue actor-based library message going action number 23 for the thing gone with]
                AGL__M(##Go,23,(MStack-->MstVO(20007,4))); 
               ! phrase 58
               ! [58: otherwise if the location is the room gone from]
                } else if (((real_location == (MStack-->MstVO(20007,0))))) { 
               ! phrase 59
               ! [59: issue actor-based library message going action number 24 for the thing gone with]
                AGL__M(##Go,24,(MStack-->MstVO(20007,4))); 
               ! phrase 60
               ! [60: otherwise]
               } else {

               ! phrase 61
               ! [61: issue actor-based library message going action number 25 for the thing gone with]
                AGL__M(##Go,25,(MStack-->MstVO(20007,4))); 
               ! phrase 62
               ! [62: end if]
               }

            ! phrase 63
            ! [63: end if]
            }

         ! phrase 64
         ! [64: if the player is within the vehicle gone by and the player is not within the thing gone with begin]
          if (((((MStack-->MstVO(20007,3)) == ContainerOf(player)))) && (((~~(((MStack-->MstVO(20007,4)) == ContainerOf(player)))))))  {
            ! phrase 65
            ! [65: issue actor-based library message going action number 26]
             AGL__M(##Go,26,noun); 
            ! phrase 66
            ! [66: say ~.~]
            say__p=1;ParaContent();  print (PrintText) SC_250;  new_line; .L_Say624; .L_SayX596;
            ! phrase 67
            ! [67: try looking]
             TryAction(0, player, ##Look, 0, 0);; 
            ! phrase 68
            ! [68: continue the action]
             rfalse; 
            ! phrase 69
            ! [69: end if]
            }

         ! phrase 70
         ! [70: say ~.~]
         say__p=1;ParaContent();  print (PrintText) SC_250;  new_line; .L_Say625; .L_SayX597;
         ! phrase 71
         ! [71: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_147, 147, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B149_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_149 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_149, 149);
      ! phrase 1
      ! [1: if the noun is a door , convert to the going action on the noun]
       if (((noun ofclass K4_door))) {  return GVS_Convert(##Go,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_149, 149, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_150 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_150, 150);
      ! phrase 1
      ! [1: if the noun is a direction , convert to the going action on the noun]
       if (((noun ofclass K3_direction))) {  return GVS_Convert(##Go,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_150, 150, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_151 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_151, 151);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message entering action number 1 for the noun]
       if (((t_0 == noun))) {  return GL__M(##Enter,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_151, 151, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_152 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_152, 152);
      ! phrase 1
      ! [1: if the noun is not enterable , stop the action with library message entering action number 2 for the noun]
       if (((~~(((Adj_67_t1_v9(noun))))))) {  return GL__M(##Enter,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_152, 152, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_153 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_153, 153);
      ! phrase 1
      ! [1: if the noun is a closed container , stop the action with library message entering action number 3 for the noun]
       if (((noun ofclass K5_container) && ((Adj_71_t1_v9(noun))))) {  return GL__M(##Enter,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_153, 153, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_154 
    t_0 ! Local variable e.g. 'local ceiling' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_154, 154);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 2
      ! [2: if the local ceiling is the actor , stop the action with library message entering action number 4 for the noun]
       if (((t_0 == actor))) {  return GL__M(##Enter,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_154, 154, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_155 
    t_0 ! Local variable e.g. 'local ceiling' = object
    t_1 ! Local variable e.g. 'target' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_155, 155);
      ! phrase 1
      ! [1: if the holder of the actor is the holder of the noun , continue the action]
       if ((( (HolderOf(actor))  ==  (HolderOf(noun)) ))) {  rfalse;   }
      ! phrase 2
      ! [2: let the local ceiling be the common ancestor of the actor with the noun]
       t_0 =  (CommonAncestor(actor, noun)) ; 
      ! phrase 3
      ! [3: while the holder of the actor is not the local ceiling begin]
       while (((~~(( (HolderOf(actor))  == t_0)))))  {
         ! phrase 4
         ! [4: let the target be the holder of the actor]
          t_1 =  (HolderOf(actor)) ; 
         ! phrase 5
         ! [5: issue library message entering action number 6 for the target]
          GL__M(##Enter,6,t_1); 
         ! phrase 6
         ! [6: silently try the actor trying exiting]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
         ! phrase 7
         ! [7: if the holder of the actor is the target , stop the action]
          if ((( (HolderOf(actor))  == t_1))) {  rtrue;   }
         ! phrase 8
         ! [8: end while]
         }

      ! phrase 9
      ! [9: if the holder of the actor is the noun , stop the action]
       if ((( (HolderOf(actor))  == noun))) {  rtrue;   }
      ! phrase 10
      ! [10: if the holder of the actor is the holder of the noun , continue the action]
       if ((( (HolderOf(actor))  ==  (HolderOf(noun)) ))) {  rfalse;   }
      ! phrase 11
      ! [11: let the target be the holder of the noun]
       t_1 =  (HolderOf(noun)) ; 
      ! phrase 12
      ! [12: if the noun is part of the target , let the target be the holder of the target]
       if (((t_1 == (noun.component_parent)))) {  t_1 =  (HolderOf(t_1)) ;   }
      ! phrase 13
      ! [13: while the target is a thing begin]
       while (((t_1 ofclass K2_thing)))  {
         ! phrase 14
         ! [14: if the holder of the target is the local ceiling begin]
          if ((( (HolderOf(t_1))  == t_0)))  {
            ! phrase 15
            ! [15: issue library message entering action number 7 for the target]
             GL__M(##Enter,7,t_1); 
            ! phrase 16
            ! [16: silently try the actor trying entering the target]
             @push keep_silent; keep_silent=1; TryAction(0, actor, ##Enter, t_1, 0);; @pull keep_silent; 
            ! phrase 17
            ! [17: if the holder of the actor is not the target , stop the action]
             if (((~~(( (HolderOf(actor))  == t_1))))) {  rtrue;   }
            ! phrase 18
            ! [18: convert to the entering action on the noun]
             return GVS_Convert(##Enter,noun,0); 
            ! phrase 19
            ! [19: continue the action]
             rfalse; 
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: let the target be the holder of the target]
          t_1 =  (HolderOf(t_1)) ; 
         ! phrase 22
         ! [22: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_155, 155, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B150_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor entering ( this is the standard entering rule ):
[ R_156 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_156, 156);
      ! phrase 1
      ! [1: surreptitiously move the actor to the noun]
       move actor to noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_156, 156, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B151_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Report entering the seat for the first time:
!   >>> I - Number of aspects constrained >>>
! Rule 2/4 ! Report entering the seat:
!   >>> I - Number of aspects constrained >>>
! Rule 3/4 ! Report an actor entering ( this is the standard report entering rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report entering the seat for the first time:
[ R_1734 ;
   if ((PAPR_7() && (((TimesActionHasHappened-->7) == 1) && (ActionCurrentlyHappeningFlag->7)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1734, 1734);
      ! phrase 1
      ! [1: if the seat is unexamined , say ~You sit down on one of the seats... it's certainly seen better days. The damage ranges from the clear evidence of spilled coffee to a few cigarette burns.~ instead]
       if ((((Adj_95_t1_v9(I707_seat))))) { say__p=1;ParaContent();  print (PrintText) SC_953;  new_line; .L_Say626; .L_SayX598;  rtrue; }
      ! phrase 2
      ! [2: otherwise continue the action]
       else {  rfalse;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1734, 1734, true);
   rfalse;
];
! No specific request
! Report entering the seat:
[ R_1735 ;
   if ( (actor==player) && ((noun == I707_seat) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1735, 1735);
      ! phrase 1
      ! [1: say ~You sit down on one of the dingy seats.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_954;  new_line; rtrue; .L_Say627; .L_SayX599; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1735, 1735, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor entering ( this is the standard report entering rule ):
[ R_157 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_157, 157);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message entering action number 5 for the noun]
          GL__M(##Enter,5,noun); 
         ! phrase 3
         ! [3: otherwise if the noun is a container]
          } else if (((noun ofclass K5_container))) { 
         ! phrase 4
         ! [4: issue actor-based library message entering action number 8 for the noun]
          AGL__M(##Enter,8,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message entering action number 9 for the noun]
          AGL__M(##Enter,9,noun); 
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_157, 157, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_158 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_158, 158);
      ! phrase 1
      ! [1: if the actor is the player , describe locale for the noun]
       if (((actor == player))) { (PHR_71_r17 (noun));  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_158, 158, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B152_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor exiting ( this is the Small Kindnesses exit leaves when there's only one way to go rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Check an actor exiting ( this is the Small Kindnesses exit leaves when there's only one way to go rule ):
[ R_742 
    t_0 ! Local variable e.g. 'local room' = object
    t_1 ! Local variable e.g. '?-1,-1?' = object
    ;
   if (TRUE) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_742, 742);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
       if ((((MStack-->MstVO(20009,0)) == t_0)))  {
         ! phrase 3
         ! [3: if the actor is the player and the count of indirectly-adjacent rooms is 1 begin]
          if ((((actor == player))) && ((((PHR_743_r18 ()) == 1))))  {
            ! phrase 4
            ! [4: let way be best route from location to the first indirectly-adjacent room , using even locked doors]
             t_1 =  MapRouteTo(real_location,(PHR_744_r19 ()),0,2) ; 
            ! phrase 5
            ! [5: if way is inside begin]
             if (((t_1 == in_obj)))  {
               ! phrase 6
               ! [6: issue library message going action number 2 for the local room]
                GL__M(##Go,2,t_0); 
               ! phrase 7
               ! [7: stop the action]
                rtrue; 
               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: if way is a direction , convert to the going action on way]
             if (((t_1 ofclass K3_direction))) {  return GVS_Convert(##Go,t_1,0);   }
            ! phrase 10
            ! [10: otherwise if the room-or-door outside from the local room is not nothing]
             } else if (((~~(((Resolver_9(out_obj,t_0,"source", 44)) == nothing))))) { 
            ! phrase 11
            ! [11: convert to the going action on the outside]
             return GVS_Convert(##Go,out_obj,0); 
            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_742, 742, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_161 
    t_0 ! Local variable e.g. 'local room' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_161, 161);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room , stop the action with library message exiting action number 1 for the actor]
       if ((((MStack-->MstVO(20009,0)) == t_0))) {  return GL__M(##Exit,1,actor);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_161, 161, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_162 
    t_0 ! Local variable e.g. 'cage' = container
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_162, 162);
      ! phrase 1
      ! [1: if the actor is in a closed container ( called the cage ) , stop the action with library message exiting action number 2 for the cage]
       if (((ContainerOf(actor) ofclass K5_container) && (t_0=(ContainerOf(actor)), true) && ((Adj_71_t1_v9(ContainerOf(actor)))))) {  return GL__M(##Exit,2,t_0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_162, 162, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_163 
    t_0 ! Local variable e.g. 'platform' = supporter
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_163, 163);
      ! phrase 1
      ! [1: if the actor is on a supporter ( called the platform ) , convert to the getting off action on the platform]
       if (((SupporterOf(actor) ofclass K6_supporter) && (t_0=(SupporterOf(actor)), true))) {  return GVS_Convert(##GetOff,t_0,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_163, 163, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B153_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_164 
    t_0 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_164, 164);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the container exited from]
       t_0 =  (CoreOfParentOfCoreOf((MStack-->MstVO(20009,0)))) ; 
      ! phrase 2
      ! [2: surreptitiously move the actor to the former exterior]
       move actor to t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_164, 164, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B154_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_165 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_165, 165);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the container exited from]
          GL__M(##Exit,3,(MStack-->MstVO(20009,0))); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: issue actor-based library message exiting action number 6 for the container exited from]
          AGL__M(##Exit,6,(MStack-->MstVO(20009,0))); 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_165, 165, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_166 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_166, 166);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
       if (((actor == player))) {  LookAfterGoing();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_166, 166, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B155_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the new can't get off things rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! This is the new can't get off things rule:
[ R_745 ;
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
       if (((noun == SupporterOf(actor)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
       if (((noun == CarrierOf(actor)))) {  rfalse;   }
      ! phrase 3
      ! [3: if the actor is in the noun , continue the action]
       if (((noun == ContainerOf(actor)))) {  rfalse;   }
      ! phrase 4
      ! [4: stop the action with library message getting off action number 1 for the noun]
       return GL__M(##GetOff,1,noun); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B156_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_168 
    t_0 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_168, 168);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the noun]
       t_0 =  (CoreOfParentOfCoreOf(noun)) ; 
      ! phrase 2
      ! [2: surreptitiously move the actor to the former exterior]
       move actor to t_0; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_168, 168, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B157_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_169 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_169, 169);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the noun]
          GL__M(##Exit,3,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: issue actor-based library message exiting action number 5 for the noun]
          AGL__M(##Exit,5,noun); 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_169, 169, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_170 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_170, 170);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
       if (((actor == player))) {  LookAfterGoing();   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_170, 170, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B159_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Carry out looking ( this is the room description heading rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Carry out looking ( this is the room description body text rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Carry out looking ( this is the check new arrival rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description heading rule ):
[ R_172 
    t_0 ! Local variable e.g. 'intermediate level' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_172, 172);
      ! phrase 1
      ! [1: say bold type]
      say__p=1;ParaContent();  style bold;  .L_Say628; .L_SayX600;
      ! phrase 2
      ! [2: if the visibility level count is 0 begin]
       if ((((MStack-->MstVO(20011,2)) == 0)))  {
         ! phrase 3
         ! [3: begin the printing the name of a dark room activity]
          BeginActivity(V8_printing_the_name_of_a_da); 
         ! phrase 4
         ! [4: if handling the printing the name of a dark room activity , issue miscellaneous library message number 71]
          if (( (~~(ForActivity(V8_printing_the_name_of_a_da))) )) {  GL__M(##Miscellany,71);   }
         ! phrase 5
         ! [5: end the printing the name of a dark room activity]
          EndActivity(V8_printing_the_name_of_a_da); 
         ! phrase 6
         ! [6: otherwise if the visibility ceiling is the location]
          } else if ((((MStack-->MstVO(20011,3)) == real_location))) { 
         ! phrase 7
         ! [7: say ~[visibility ceiling]~]
         say__p=1;ParaContent();  print (PrintShortName) (MStack-->MstVO(20011,3));  .L_Say629; .L_SayX601;
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: say ~[The visibility ceiling]~]
         say__p=1;ParaContent();  print (The) (MStack-->MstVO(20011,3));  .L_Say630; .L_SayX602;
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: say roman type]
      say__p=1;ParaContent();  style roman;  .L_Say631; .L_SayX603;
      ! phrase 12
      ! [12: let intermediate level be the visibility-holder of the actor]
       t_0 =  VisibilityParent(actor) ; 
      ! phrase 13
      ! [13: repeat with intermediate level count running from 2 to the visibility level count begin]
       for (t_1=2: t_1<=(MStack-->MstVO(20011,2)): t_1++)  {
         ! phrase 14
         ! [14: issue library message looking action number 8 for the intermediate level]
          GL__M(##Look,8,t_0); 
         ! phrase 15
         ! [15: let the intermediate level be the visibility-holder of the intermediate level]
          t_0 =  VisibilityParent(t_0) ; 
         ! phrase 16
         ! [16: end repeat]
         }

      ! phrase 17
      ! [17: say line break]
      say__p=1;ParaContent();  new_line;  .L_Say632; .L_SayX604;
      ! phrase 18
      ! [18: say run paragraph on with special look spacing]
      say__p=1;ParaContent();  SpecialLookSpacingBreak();  .L_Say633; .L_SayX605;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_172, 172, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description body text rule ):
[ R_173 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_173, 173);
      ! phrase 1
      ! [1: if the visibility level count is 0 begin]
       if ((((MStack-->MstVO(20011,2)) == 0)))  {
         ! phrase 2
         ! [2: if set to abbreviated room descriptions , continue the action]
          if (( (lookmode == 3) )) {  rfalse;   }
         ! phrase 3
         ! [3: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and darkness witnessed is true , continue the action]
          if ((( (lookmode == 1) )) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && (((((Global_Vars-->0) && true) == (1 && true)))))) {  rfalse;   }
         ! phrase 4
         ! [4: begin the printing the description of a dark room activity]
          BeginActivity(V9_printing_the_description_); 
         ! phrase 5
         ! [5: if handling the printing the description of a dark room activity , issue miscellaneous library message number 17]
          if (( (~~(ForActivity(V9_printing_the_description_))) )) {  GL__M(##Miscellany,17);   }
         ! phrase 6
         ! [6: end the printing the description of a dark room activity]
          EndActivity(V9_printing_the_description_); 
         ! phrase 7
         ! [7: otherwise if the visibility ceiling is the location]
          } else if ((((MStack-->MstVO(20011,3)) == real_location))) { 
         ! phrase 8
         ! [8: if set to abbreviated room descriptions , continue the action]
          if (( (lookmode == 3) )) {  rfalse;   }
         ! phrase 9
         ! [9: if set to sometimes abbreviated room descriptions and abbreviated form allowed is true and the location is visited , continue the action]
          if ((( (lookmode == 1) )) && ((((((MStack-->MstVO(20011,1)) && true) == (1 && true)))) && ((((Adj_49_t1_v9(real_location))))))) {  rfalse;   }
         ! phrase 10
         ! [10: print the location's description]
          PrintOrRun(location, description); 
         ! phrase 11
         ! [11: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_173, 173, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_174 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_174, 174);
      ! phrase 1
      ! [1: if the visibility level count is greater than 0 begin]
       if ((((MStack-->MstVO(20011,2)) > 0)))  {
         ! phrase 2
         ! [2: let the intermediate position be the actor]
          t_0 = actor; 
         ! phrase 3
         ! [3: let the ip count be the visibility level count]
          t_1 = (MStack-->MstVO(20011,2)); 
         ! phrase 4
         ! [4: while the ip count is greater than 0 begin]
          while (((t_1 > 0)))  {
            ! phrase 5
            ! [5: now the intermediate position is marked for listing]
             (Adj_63_t2_v9(t_0)); 
            ! phrase 6
            ! [6: let the intermediate position be the visibility-holder of the intermediate position]
             t_0 =  VisibilityParent(t_0) ; 
            ! phrase 7
            ! [7: decrease the ip count by 1]
             t_1 = t_1 - 1; 
            ! phrase 8
            ! [8: end while]
            }

         ! phrase 9
         ! [9: let the top-down ip count be the visibility level count]
          t_2 = (MStack-->MstVO(20011,2)); 
         ! phrase 10
         ! [10: while the top-down ip count is greater than 0 begin]
          while (((t_2 > 0)))  {
            ! phrase 11
            ! [11: let the intermediate position be the actor]
             t_0 = actor; 
            ! phrase 12
            ! [12: let the ip count be 0]
             t_1 = 0; 
            ! phrase 13
            ! [13: while the ip count is less than the top-down ip count begin]
             while (((t_1 < t_2)))  {
               ! phrase 14
               ! [14: let the intermediate position be the visibility-holder of the intermediate position]
                t_0 =  VisibilityParent(t_0) ; 
               ! phrase 15
               ! [15: increase the ip count by 1]
                t_1 = t_1 + 1; 
               ! phrase 16
               ! [16: end while]
               }

            ! phrase 17
            ! [17: describe locale for the intermediate position]
            (PHR_71_r17 (t_0));
            ! phrase 18
            ! [18: decrease the top-down ip count by 1]
             t_2 = t_2 - 1; 
            ! phrase 19
            ! [19: end while]
            }

         ! phrase 20
         ! [20: end if]
         }

      ! phrase 21
      ! [21: continue the action]
       rfalse; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_174, 174, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out looking ( this is the check new arrival rule ):
[ R_175 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_175, 175);
      ! phrase 1
      ! [1: if in darkness begin]
       if (( (location==thedark) ))  {
         ! phrase 2
         ! [2: now the darkness witnessed is true]
          (Global_Vars-->0) = 1; 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the location is a room , now the location is visited]
          if (((real_location ofclass K1_room))) {  (Adj_49_t2_v9(real_location));   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_175, 175, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B160_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor looking ( this is the other people looking rule ):
[ R_176 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_176, 176);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message looking action number 9]
       if (((~~((actor == player))))) {  AGL__M(##Look,9,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_176, 176, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B162_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Carry out examining ( this is the standard examining rule ):
!   === which is equally specific with ===
! Rule 2/6 ! Carry out examining ( this is the examine directions rule ):
!   === which is equally specific with ===
! Rule 3/6 ! Carry out examining ( this is the examine containers rule ):
!   === which is equally specific with ===
! Rule 4/6 ! Carry out examining ( this is the examine supporters rule ):
!   === which is equally specific with ===
! Rule 5/6 ! Carry out examining ( this is the examine devices rule ):
!   === which is equally specific with ===
! Rule 6/6 ! Carry out examining ( this is the examine undescribed things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out examining ( this is the standard examining rule ):
[ R_177 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_177, 177);
      ! phrase 1
      ! [1: if the noun provides the property description and the description of the noun is not ~~ begin]
       if ((((WhetherProvides(noun, false, description)))) && (((~~((GProperty(OBJECT_TY, noun,description) == EMPTY_TEXT_VALUE))))))  {
         ! phrase 2
         ! [2: say ~[the description of the noun][line break]~]
         say__p=1;ParaContent(); @push self;  print (PrintText) GProperty(OBJECT_TY, self=noun,description); @pull self; ParaContent();  new_line;  .L_Say634; .L_SayX606;
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_177, 177, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine directions rule ):
[ R_178 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_178, 178);
      ! phrase 1
      ! [1: if the noun is a direction begin]
       if (((noun ofclass K3_direction)))  {
         ! phrase 2
         ! [2: issue library message examining action number 5 for the noun]
          GL__M(##Examine,5,noun); 
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_178, 178, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine containers rule ):
[ R_179 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_179, 179);
      ! phrase 1
      ! [1: if the noun is a container begin]
       if (((noun ofclass K5_container)))  {
         ! phrase 2
         ! [2: if the noun is open or the noun is transparent begin]
          if (((((Adj_70_t1_v9(noun))))) || ((((Adj_69_t1_v9(noun))))))  {
            ! phrase 3
            ! [3: if something described which is not scenery is in the noun and something which is not the player is in the noun begin]
             if (((Prop_87())) && ((Prop_88())))  {
               ! phrase 4
               ! [4: issue library message searching action number 7 for the noun]
                GL__M(##Search,7,noun); 
               ! phrase 5
               ! [5: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1; 
               ! phrase 6
               ! [6: otherwise if examine text printed is false]
                } else if (((((MStack-->MstVO(20012,0)) && true) == (0 && true)))) { 
               ! phrase 7
               ! [7: if the player is in the noun begin]
                if (((noun == ContainerOf(player))))  {
                  ! phrase 8
                  ! [8: make no decision]
                   rfalse; 
                  ! phrase 9
                  ! [9: end if]
                  }

               ! phrase 10
               ! [10: issue library message searching action number 6 for the noun]
                GL__M(##Search,6,noun); 
               ! phrase 11
               ! [11: now examine text printed is true]
                (MStack-->MstVO(20012,0)) = 1; 
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_179, 179, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine supporters rule ):
[ R_180 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_180, 180);
      ! phrase 1
      ! [1: if the noun is a supporter begin]
       if (((noun ofclass K6_supporter)))  {
         ! phrase 2
         ! [2: if something described which is not scenery is on the noun and something which is not the player is on the noun begin]
          if (((Prop_89())) && ((Prop_90())))  {
            ! phrase 3
            ! [3: issue library message looking action number 4 for the noun]
             GL__M(##Look,4,noun); 
            ! phrase 4
            ! [4: now examine text printed is true]
             (MStack-->MstVO(20012,0)) = 1; 
            ! phrase 5
            ! [5: end if]
            }

         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_180, 180, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine devices rule ):
[ R_181 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_181, 181);
      ! phrase 1
      ! [1: if the noun is a device begin]
       if (((noun ofclass K13_device)))  {
         ! phrase 2
         ! [2: issue library message examining action number 3 for the noun]
          GL__M(##Examine,3,noun); 
         ! phrase 3
         ! [3: now examine text printed is true]
          (MStack-->MstVO(20012,0)) = 1; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_181, 181, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out examining ( this is the examine undescribed things rule ):
[ R_182 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_182, 182);
      ! phrase 1
      ! [1: if examine text printed is false begin]
       if (((((MStack-->MstVO(20012,0)) && true) == (0 && true))))  {
         ! phrase 2
         ! [2: issue library message examining action number 2 for the noun]
          GL__M(##Examine,2,noun); 
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_182, 182, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B163_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor examining ( this is the report other people examining rule ):
[ R_183 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_183, 183);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message examining action number 4 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##Examine,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_183, 183, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B165_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_184 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_184, 184);
      ! phrase 1
      ! [1: stop the action with library message looking under action number 2 for the noun]
       return GL__M(##LookUnder,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_184, 184, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B166_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_185 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_185, 185);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message looking under action number 3 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##LookUnder,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_185, 185, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B167_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_186 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_186, 186);
      ! phrase 1
      ! [1: if the noun is not a container and the noun is not a supporter , stop the action with library message searching action number 4 for the noun]
       if ((((~~((noun ofclass K5_container))))) && (((~~((noun ofclass K6_supporter)))))) {  return GL__M(##Search,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_186, 186, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_187 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_187, 187);
      ! phrase 1
      ! [1: if the noun is a closed opaque container , stop the action with library message searching action number 5 for the noun]
       if (((noun ofclass K5_container) && ((Adj_71_t1_v9(noun))) && ((Adj_68_t1_v9(noun))))) {  return GL__M(##Search,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_187, 187, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B169_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report searching a container ( this is the standard search containers rule ):
[ R_188 ;
   if ( (actor==player) && ((noun ofclass K5_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_188, 188);
      ! phrase 1
      ! [1: if the noun contains a described thing which is not scenery , issue library message searching action number 7 for the noun]
       if ((Prop_91())) {  GL__M(##Search,7,noun);   }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 6 for the noun]
       else {  GL__M(##Search,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_188, 188, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_189 ;
   if ( (actor==player) && ((noun ofclass K6_supporter))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_189, 189);
      ! phrase 1
      ! [1: if the noun supports a described thing which is not scenery , issue library message searching action number 3 for the noun]
       if ((Prop_92())) {  GL__M(##Search,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 2 for the noun]
       else {  GL__M(##Search,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_189, 189, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor searching ( this is the report other people searching rule ):
[ R_190 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_190, 190);
      ! phrase 1
      ! [1: if the actor is not the player , issue actor-based library message searching action number 8 for the noun]
       if (((~~((actor == player))))) {  AGL__M(##Search,8,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_190, 190, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B172_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_191 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_191, 191);
      ! phrase 1
      ! [1: if the actor is the player , issue library message consulting it about action number 1 for the noun]
       if (((actor == player))) {  GL__M(##Consult,1,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message consulting it about action number 2 for the noun]
       else {  AGL__M(##Consult,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_191, 191, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B173_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 4/5 ! This is the right second rule:
!   === which is equally specific with ===
! Rule 5/5 ! Check locking it with:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_192 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_192, 192);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_74_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message locking it with action number 1 for the noun]
       return GL__M(##Lock,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_192, 192, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_193 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_193, 193);
      ! phrase 1
      ! [1: if the noun is locked , stop the action with library message locking it with action number 2 for the noun]
       if ((((Adj_75_t1_v9(noun))))) {  return GL__M(##Lock,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_193, 193, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_194 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_194, 194);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message locking it with action number 3 for the noun]
       if ((((Adj_70_t1_v9(noun))))) {  return GL__M(##Lock,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_194, 194, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the right second rule:
[ R_824 ;
      ! phrase 1
      ! [1: if the noun provides the property matching key begin]
       if (((WhetherProvides(noun, false, with_key))))  {
         ! phrase 2
         ! [2: if the second noun is not the matching key of the noun , say ~[The second noun] does not fit [the noun].~ instead]
          if (((~~((second == GProperty(OBJECT_TY, noun,with_key)))))) { say__p=1;ParaContent();  print (The) second; ParaContent();  print (PrintText) SC_955; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say635; .L_SayX607;  rtrue; }
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The second noun] does not fit [the noun].~ instead]
         say__p=1;ParaContent();  print (The) second; ParaContent();  print (PrintText) SC_955; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; rtrue; .L_Say636; .L_SayX608; rtrue;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Check locking it with:
[ R_829 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_829, 829);
      ! phrase 1
      ! [1: abide by the must have accessible the second noun rule]
       if (ProcessRulebook(R_850)) rtrue; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_829, 829, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B174_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out locking something with a passkey ( this is the standard passkey locking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Carry out locking something with a passkey ( this is the standard passkey locking rule ):
[ R_839 ;
   if ( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K18_passkey))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_839, 839);
      ! phrase 1
      ! [1: if the second noun is the matching key of the noun , now the second noun unbolts the noun]
       if (((second == GProperty(OBJECT_TY, noun,with_key)))) {  noun.p67_unbolting = second;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_839, 839, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_196 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_196, 196);
      ! phrase 1
      ! [1: now the noun is locked]
       (Adj_75_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_196, 196, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B175_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report locking it with when the second noun is the screwdriver:
!   >>> II - When/while requirement >>>
! Rule 2/3 ! Report someone trying locking something with a passkey ( this is the observe someone locking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 3/3 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report locking it with when the second noun is the screwdriver:
[ R_1047 ;
   if (actor == player) {
   if ((((((second == I636_screwdriver)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1047, 1047);
      ! phrase 1
      ! [1: say ~You screw the [noun] back into place.~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_956; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_957;  new_line; rtrue; .L_Say637; .L_SayX609; rtrue;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1047, 1047, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Report someone trying locking something with a passkey ( this is the observe someone locking rule ):
[ R_840 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && ((second ofclass K18_passkey))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_840, 840);
      ! phrase 1
      ! [1: now the second noun unbolts the noun]
       noun.p67_unbolting = second; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_840, 840, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_197 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_197, 197);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message locking it with action number 5 for the noun]
          GL__M(##Lock,5,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , issue actor-based library message locking it with action number 6 for the noun]
          if ((((Adj_3_t1_v9(actor))))) {  AGL__M(##Lock,6,noun);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_197, 197, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B176_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/4 ! This is the right second rule:
!   === which is equally specific with ===
! Rule 4/4 ! Check unlocking it with ( this is the must be able to reach the key rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_198 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_198, 198);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_74_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message unlocking it with action number 1 for the noun]
       return GL__M(##Unlock,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_198, 198, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_199 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_199, 199);
      ! phrase 1
      ! [1: if the noun is not locked , stop the action with library message unlocking it with action number 2 for the noun]
       if (((~~(((Adj_75_t1_v9(noun))))))) {  return GL__M(##Unlock,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_199, 199, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Check unlocking it with ( this is the must be able to reach the key rule ):
[ R_823 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_823, 823);
      ! phrase 1
      ! [1: abide by the must have accessible the second noun rule]
       if (ProcessRulebook(R_850)) rtrue; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_823, 823, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B177_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out unlocking something with a passkey ( this is the standard passkey unlocking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 2/2 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Carry out unlocking something with a passkey ( this is the standard passkey unlocking rule ):
[ R_837 ;
   if ( (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K18_passkey))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_837, 837);
      ! phrase 1
      ! [1: if the second noun is the matching key of the noun , now the second noun unbolts the noun]
       if (((second == GProperty(OBJECT_TY, noun,with_key)))) {  noun.p67_unbolting = second;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_837, 837, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_201 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_201, 201);
      ! phrase 1
      ! [1: now the noun is not locked]
       (Adj_75_t3_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_201, 201, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B178_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report unlocking it with when the second noun is the screwdriver:
!   >>> II - When/while requirement >>>
! Rule 2/3 ! Report someone trying unlocking something with a passkey ( this is the observe someone unlocking rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 3/3 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report unlocking it with when the second noun is the screwdriver:
[ R_1046 ;
   if (actor == player) {
   if ((((((second == I636_screwdriver)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_1046, 1046);
      ! phrase 1
      ! [1: say ~You unscrew the [noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_958; ParaContent();  print (PrintShortName) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say638; .L_SayX610;
      ! phrase 2
      ! [2: if the noun is the plate , try opening the plate]
       if (((noun == I635_metal_plate))) {  TryAction(0, player, ##Open, I635_metal_plate, 0);;   }
      ! phrase 3
      ! [3: stop the action]
       rtrue; 
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_1046, 1046, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Report someone trying unlocking something with a passkey ( this is the observe someone unlocking rule ):
[ R_838 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person)) && ((noun ofclass K2_thing)) && ((second ofclass K18_passkey))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_838, 838);
      ! phrase 1
      ! [1: now the second noun unbolts the noun]
       noun.p67_unbolting = second; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_838, 838, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_202 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_202, 202);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message unlocking it with action number 4 for the noun]
          GL__M(##Unlock,4,noun); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , issue actor-based library message unlocking it with action number 5 for the noun]
          if ((((Adj_3_t1_v9(actor))))) {  AGL__M(##Unlock,5,noun);   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_202, 202, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B179_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check switching on a gizmo:
!   >>> I - Number of aspects constrained >>>
! Rule 2/3 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check switching on a gizmo:
[ R_1346 ;
   if ( (actor==player) && ((noun ofclass K28_gizmo))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1346, 1346);
      ! phrase 1
      ! [1: if the noun is broken , say ~It doesn't seem to turn on with that [random visible thing that is part of the noun].~ instead]
       if ((((Adj_121_t1_v9(noun))))) { say__p=1;ParaContent();  print (PrintText) SC_959; ParaContent();  print (PrintShortName)  (Prop_93()) ; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say639; .L_SayX611;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1346, 1346, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_203 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_203, 203);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
       if (((WhetherProvides(noun, true, on)))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message switching on action number 1 for the noun]
       return GL__M(##SwitchOn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_203, 203, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_204 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_204, 204);
      ! phrase 1
      ! [1: if the noun is switched on , stop the action with library message switching on action number 2 for the noun]
       if ((((Adj_80_t1_v9(noun))))) {  return GL__M(##SwitchOn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_204, 204, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B180_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_205 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_205, 205);
      ! phrase 1
      ! [1: now the noun is switched on]
       (Adj_80_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_205, 205, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B181_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_206 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_206, 206);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching on action number 3 for the noun]
       if (((actor == player))) {  GL__M(##SwitchOn,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message switching on action number 4 for the noun]
       else {  AGL__M(##SwitchOn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_206, 206, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B182_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_207 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_207, 207);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
       if (((WhetherProvides(noun, true, on)))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message switching off action number 1 for the noun]
       return GL__M(##SwitchOff,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_207, 207, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_208 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_208, 208);
      ! phrase 1
      ! [1: if the noun is switched off , stop the action with library message switching off action number 2 for the noun]
       if ((((Adj_81_t1_v9(noun))))) {  return GL__M(##SwitchOff,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_208, 208, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B183_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_209 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_209, 209);
      ! phrase 1
      ! [1: now the noun is switched off]
       (Adj_81_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_209, 209, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B184_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_210 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_210, 210);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching off action number 3 for the noun]
       if (((actor == player))) {  GL__M(##SwitchOff,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message switching off action number 4 for the noun]
       else {  AGL__M(##SwitchOff,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_210, 210, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B185_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check opening the secret panel:
!   >>> I - Number of aspects constrained >>>
! Rule 2/4 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check opening the secret panel:
[ R_1483 ;
   if ( (actor==player) && ((noun == I591_secret_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1483, 1483);
      ! phrase 1
      ! [1: if the secret panel has been open , continue the action]
       if (TestSinglePastState(0, 52, false, 5)) {  rfalse;   }
      ! phrase 2
      ! [2: otherwise say ~You press firmly on the outline, but you can't get the wood to budge with your fingers; you need more leverage.~ instead]
       else { say__p=1;ParaContent();  print (PrintText) SC_960;  new_line; .L_Say640; .L_SayX612;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1483, 1483, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_211 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_211, 211);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
       if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_72_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message opening action number 1 for the noun]
       return GL__M(##Open,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_211, 211, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_212 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_212, 212);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is locked , stop the action with library message opening action number 2 for the noun]
       if ((((WhetherProvides(noun, true, lockable)))) && ((((Adj_75_t1_v9(noun)))))) {  return GL__M(##Open,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_212, 212, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_213 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_213, 213);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message opening action number 3 for the noun]
       if ((((Adj_70_t1_v9(noun))))) {  return GL__M(##Open,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_213, 213, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B186_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor opening ( this is the standard opening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor opening ( this is the standard opening rule ):
[ R_214 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_214, 214);
      ! phrase 1
      ! [1: now the noun is open]
       (Adj_70_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_214, 214, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B187_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Report opening the vending machine:
!   === which is equally specific with ===
! Rule 2/4 ! Report opening the access panel:
!   >>> I - Number of aspects constrained >>>
! Rule 3/4 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report opening the vending machine:
[ R_1439 ;
   if ( (actor==player) && ((noun == I580_vending_machine) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1439, 1439);
      ! phrase 1
      ! [1: say ~You open the vending machine, revealing [a list of things in the vending machine].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_961; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I580_vending_machine == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; rtrue; .L_Say641; .L_SayX613; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1439, 1439, true);
   rfalse;
];
! No specific request
! Report opening the access panel:
[ R_1752 ;
   if ( (actor==player) && ((noun == I709_access_panel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1752, 1752);
      ! phrase 1
      ! [1: say ~[if the conductor is visible]You sneak a glance at the conductor -- he's still wrapped up talking about trains, and doesn't seem to be paying attention to you. Feeling a bit guilty, y[otherwise]Y[end if]ou open [the access panel], revealing [a list of things contained by the access panel].~ instead]
      say__p=1;
	if (~~(((((Adj_3_t1_v9(I711_conductor))))))) jump L_Say642;
		ParaContent();  print (PrintText) SC_962; 
	jump L_SayX614; .L_Say642;
		ParaContent();  print (PrintText) SC_963; 
	.L_Say643; .L_SayX614;
		ParaContent();  print (PrintText) SC_964; ParaContent();  print (the) I709_access_panel; ParaContent();  print (PrintText) SC_965; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I709_access_panel == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; rtrue; .L_Say644; .L_SayX615; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1752, 1752, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_215 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_215, 215);
      ! phrase 1
      ! [1: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor , stop the action with library message opening action number 4 for the noun]
       if ((((actor == player))) && ((((noun ofclass K5_container) && ((Adj_68_t1_v9(noun))))) && ((((~~(( (child(noun))  == nothing))))) && (((~~((IndirectlyContains(noun,actor))))))))) {  return GL__M(##Open,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_215, 215, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor opening ( this is the standard report opening rule ):
[ R_216 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_216, 216);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message opening action number 5 for the noun]
          GL__M(##Open,5,noun); 
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
          } else if (((TestVisibility(player,actor)))) { 
         ! phrase 4
         ! [4: issue actor-based library message opening action number 6 for the noun]
          AGL__M(##Open,6,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message opening action number 7 for the noun]
          AGL__M(##Open,7,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_216, 216, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B188_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_217 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_217, 217);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
       if ((((WhetherProvides(noun, true, openable)))) && ((((Adj_72_t1_v9(noun)))))) {  rfalse;   }
      ! phrase 2
      ! [2: stop the action with library message closing action number 1 for the noun]
       return GL__M(##Close,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_217, 217, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_218 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_218, 218);
      ! phrase 1
      ! [1: if the noun is closed , stop the action with library message closing action number 2 for the noun]
       if ((((Adj_71_t1_v9(noun))))) {  return GL__M(##Close,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_218, 218, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B189_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor closing ( this is the standard closing rule ):
[ R_219 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_219, 219);
      ! phrase 1
      ! [1: now the noun is closed]
       (Adj_71_t2_v9(noun)); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_219, 219, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B190_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor closing ( this is the standard report closing rule ):
[ R_220 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_220, 220);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message closing action number 3 for the noun]
          GL__M(##Close,3,noun); 
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
          } else if (((TestVisibility(player,actor)))) { 
         ! phrase 4
         ! [4: issue actor-based library message closing action number 4 for the noun]
          AGL__M(##Close,4,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message closing action number 5 for the noun]
          AGL__M(##Close,5,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_220, 220, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B191_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_221 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_221, 221);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not wearable , stop the action with library message wearing action number 1 for the noun]
       if ((((~~((noun ofclass K2_thing))))) || (((~~(((Adj_58_t1_v9(noun)))))))) {  return GL__M(##Wear,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_221, 221, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_222 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_222, 222);
      ! phrase 1
      ! [1: if the holder of the noun is not the actor , stop the action with library message wearing action number 2 for the noun]
       if (((~~(( (HolderOf(noun))  == actor))))) {  return GL__M(##Wear,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_222, 222, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_223 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_223, 223);
      ! phrase 1
      ! [1: if the actor is wearing the noun , stop the action with library message wearing action number 3 for the noun]
       if (((actor == WearerOf(noun)))) {  return GL__M(##Wear,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_223, 223, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B192_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_224 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_224, 224);
      ! phrase 1
      ! [1: now the actor wears the noun]
       WearObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_224, 224, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B193_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_225 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_225, 225);
      ! phrase 1
      ! [1: if the actor is the player , issue library message wearing action number 4 for the noun]
       if (((actor == player))) {  GL__M(##Wear,4,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message wearing action number 5 for the noun]
       else {  AGL__M(##Wear,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_225, 225, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B194_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_226 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_226, 226);
      ! phrase 1
      ! [1: if the actor is not wearing the noun , stop the action with library message taking off action number 1 for the noun]
       if (((~~((actor == WearerOf(noun)))))) {  return GL__M(##Disrobe,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_226, 226, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B195_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_227 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_227, 227);
      ! phrase 1
      ! [1: now the actor carries the noun]
       MoveObject(noun,actor); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_227, 227, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B196_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_228 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_228, 228);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking off action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Disrobe,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message taking off action number 3 for the noun]
       else {  AGL__M(##Disrobe,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_228, 228, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B197_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor giving something to ( this is the can't give clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor giving something to ( this is the block giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_229 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_229, 229);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message giving it to action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Give,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_229, 229, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_230 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_230, 230);
      ! phrase 1
      ! [1: if the actor is the second noun , stop the action with library message giving it to action number 2 for the noun]
       if (((actor == second))) {  return GL__M(##Give,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_230, 230, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_231 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_231, 231);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message giving it to action number 4 for the second noun]
       if (((~~((second ofclass K8_person))))) {  return GL__M(##Give,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_231, 231, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the can't give clothes being worn rule ):
[ R_232 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_232, 232);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_232, 232, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor giving something to ( this is the block giving rule ):
[ R_233 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_233, 233);
      ! phrase 1
      ! [1: stop the action with library message giving it to action number 3 for the second noun]
       return GL__M(##Give,3,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_233, 233, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B198_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_234 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_234, 234);
      ! phrase 1
      ! [1: move the noun to the second noun]
       MoveObject(noun, second, 0, false); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_234, 234, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B199_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_235 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_235, 235);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: issue library message giving it to action number 5 for the noun]
          GL__M(##Give,5,noun); 
         ! phrase 3
         ! [3: otherwise if the second noun is the player]
          } else if (((second == player))) { 
         ! phrase 4
         ! [4: issue actor-based library message giving it to action number 6 for the noun]
          AGL__M(##Give,6,noun); 
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: issue actor-based library message giving it to action number 7 for the noun]
          AGL__M(##Give,7,noun); 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_235, 235, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B200_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_236 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_236, 236);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message showing it to action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Show,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_236, 236, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_237 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_237, 237);
      ! phrase 1
      ! [1: if the actor is the second noun , convert to the examining action on the noun]
       if (((actor == second))) {  return GVS_Convert(##Examine,noun,0);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_237, 237, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor showing something to ( this is the block showing rule ):
[ R_238 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_238, 238);
      ! phrase 1
      ! [1: stop the action with library message showing it to action number 2 for the second noun]
       return GL__M(##Show,2,second); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_238, 238, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B203_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waking ( this is the block waking rule ):
[ R_239 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_239, 239);
      ! phrase 1
      ! [1: stop the action with library message waking action number 1 for the noun]
       return GL__M(##WakeOther,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_239, 239, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B206_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_240 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_240, 240);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
       if (((actor == WearerOf(noun))))  {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
          GL__M(##Drop,3,noun); 
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
          @push keep_silent; keep_silent=1; TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent; 
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
          if (((actor == WearerOf(noun)))) {  rtrue;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_240, 240, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_241 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_241, 241);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message throwing it at action number 1 for the second noun]
       if (((~~((second ofclass K8_person))))) {  return GL__M(##ThrowAt,1,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_241, 241, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_242 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_242, 242);
      ! phrase 1
      ! [1: stop the action with library message throwing it at action number 2 for the noun]
       return GL__M(##ThrowAt,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_242, 242, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Throwing it at (B207_carry_out_throwing_it_a)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out throwing something at the dog:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out throwing something at the dog:
[ R_1194 ;
   if ( (actor==player) && ((noun ofclass K2_thing)) && ((second == I443_dog) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1194, 1194);
      ! phrase 1
      ! [1: say ~You throw [the noun] a few feet. The dog runs toward it, picks it up, and returns it to you.~]
      say__p=1;ParaContent();  print (PrintText) SC_966; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_967;  new_line; .L_Say645; .L_SayX616;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1194, 1194, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B209_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor attacking ( this is the block attacking rule ):
[ R_243 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_243, 243);
      ! phrase 1
      ! [1: stop the action with library message attacking action number 1 for the noun]
       return GL__M(##Attack,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_243, 243, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B212_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_244 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_244, 244);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message touching action number 3 for the noun]
       if (((noun == actor))) {  return GL__M(##Touch,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_244, 244, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor kissing ( this is the block kissing rule ):
[ R_245 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_245, 245);
      ! phrase 1
      ! [1: stop the action with library message kissing action number 1 for the noun]
       return GL__M(##Kiss,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_245, 245, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B217_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor answering something that ( this is the block answering rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor answering something that ( this is the block answering rule ):
[ R_246 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_246, 246);
      ! phrase 1
      ! [1: stop the action with library message answering it that action number 1 for the noun]
       return GL__M(##Answer,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_246, 246, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B218_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_247 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_247, 247);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message telling it about action number 1 for the noun]
       if (((actor == noun))) {  return GL__M(##Tell,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_247, 247, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B220_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor telling something about ( this is the block telling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor telling something about ( this is the block telling rule ):
[ R_248 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_248, 248);
      ! phrase 1
      ! [1: stop the action with library message telling it about action number 2 for the noun]
       return GL__M(##Tell,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_248, 248, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B223_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor asking something about ( this is the block asking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor asking something about ( this is the block asking rule ):
[ R_249 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_249, 249);
      ! phrase 1
      ! [1: stop the action with library message asking it about action number 1 for the noun]
       return GL__M(##Ask,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_249, 249, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B224_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_250 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_250, 250);
      ! phrase 1
      ! [1: if the actor is the noun and the actor is the player , try taking inventory instead]
       if ((((actor == noun))) && (((actor == player)))) {  TryAction(0, player, ##Inv, 0, 0);;   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_250, 250, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_251 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_251, 251);
      ! phrase 1
      ! [1: convert to request of the noun to perform giving it to action with the second noun and the actor]
       TryAction(true, noun, ##Give, second, actor); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_251, 251, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B229_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_252 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_252, 252);
      ! phrase 1
      ! [1: if the actor is the player , stop the action with library message waiting action number 1 for the actor]
       if (((actor == player))) {  return GL__M(##Wait,1,actor);   }
      ! phrase 2
      ! [2: issue actor-based library message waiting action number 2]
       AGL__M(##Wait,2,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_252, 252, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B232_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching yourself rule ):
[ R_253 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_253, 253);
      ! phrase 1
      ! [1: if the noun is the actor begin]
       if (((noun == actor)))  {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 3 for the noun]
          if (((actor == player))) {  GL__M(##Touch,3,noun);   }
         ! phrase 3
         ! [3: otherwise issue actor-based library message touching action number 4]
          else {  AGL__M(##Touch,4,noun);   }
         ! phrase 4
         ! [4: stop the action]
          rtrue; 
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_253, 253, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching other people rule ):
[ R_254 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_254, 254);
      ! phrase 1
      ! [1: if the noun is a person begin]
       if (((noun ofclass K8_person)))  {
         ! phrase 2
         ! [2: if the actor is the player begin]
          if (((actor == player)))  {
            ! phrase 3
            ! [3: issue library message touching action number 1 for the noun]
             GL__M(##Touch,1,noun); 
            ! phrase 4
            ! [4: otherwise if the noun is the player]
             } else if (((noun == player))) { 
            ! phrase 5
            ! [5: issue actor-based library message touching action number 5]
             AGL__M(##Touch,5,noun); 
            ! phrase 6
            ! [6: otherwise]
            } else {

            ! phrase 7
            ! [7: issue actor-based library message touching action number 6 for the noun]
             AGL__M(##Touch,6,noun); 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: stop the action]
          rtrue; 
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: continue the action]
       rfalse; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_254, 254, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Report an actor touching ( this is the report touching things rule ):
[ R_255 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_255, 255);
      ! phrase 1
      ! [1: if the actor is the player , issue library message touching action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Touch,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message touching action number 6 for the noun]
       else {  AGL__M(##Touch,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_255, 255, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B233_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_256 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_256, 256);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message waving action number 1 for the noun]
       if (((~~((actor ==  (HolderOf(noun)) ))))) {  return GL__M(##Wave,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_256, 256, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B235_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor waving ( this is the report waving things rule ):
[ R_257 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_257, 257);
      ! phrase 1
      ! [1: if the actor is the player , issue library message waving action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Wave,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message waving action number 3 for the noun]
       else {  AGL__M(##Wave,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_257, 257, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B236_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_258 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_258, 258);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pulling action number 1 for the noun]
       if ((((Adj_55_t1_v9(noun))))) {  return GL__M(##Pull,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_258, 258, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_259 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_259, 259);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pulling action number 2 for the noun]
       if ((((Adj_57_t1_v9(noun))))) {  return GL__M(##Pull,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_259, 259, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pulling ( this is the can't pull people rule ):
[ R_260 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_260, 260);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pulling action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Pull,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_260, 260, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B238_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor pulling ( this is the report pulling rule ):
[ R_261 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_261, 261);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pulling action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Pull,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message pulling action number 5 for the noun]
       else {  AGL__M(##Pull,5,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_261, 261, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B239_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_262 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_262, 262);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pushing action number 1 for the noun]
       if ((((Adj_55_t1_v9(noun))))) {  return GL__M(##Push,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_262, 262, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_263 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_263, 263);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pushing action number 2 for the noun]
       if ((((Adj_57_t1_v9(noun))))) {  return GL__M(##Push,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_263, 263, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something ( this is the can't push people rule ):
[ R_264 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_264, 264);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pushing action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Push,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_264, 264, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B241_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor pushing something ( this is the report pushing rule ):
[ R_265 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_265, 265);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pushing action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Push,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message pushing action number 6 for the noun]
       else {  AGL__M(##Push,6,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_265, 265, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B242_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check turning the wooden drawer:
!   >>> I - Number of aspects constrained >>>
! Rule 2/4 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check turning the wooden drawer:
[ R_1459 ;
   if ( (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1459, 1459);
      ! phrase 1
      ! [1: if the drawer is not held , try taking the drawer]
       if (((~~(((Adj_2_t1_v9(I589_wooden_drawer))))))) {  TryAction(0, player, ##Take, I589_wooden_drawer, 0);;   }
      ! phrase 2
      ! [2: if the drawer is not held , say ~You have to be holding it.~ instead]
       if (((~~(((Adj_2_t1_v9(I589_wooden_drawer))))))) { say__p=1;ParaContent();  print (PrintText) SC_968;  new_line; .L_Say646; .L_SayX617;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1459, 1459, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_266 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_266, 266);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message turning action number 1 for the noun]
       if ((((Adj_55_t1_v9(noun))))) {  return GL__M(##Turn,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_266, 266, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_267 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_267, 267);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message turning action number 2 for the noun]
       if ((((Adj_57_t1_v9(noun))))) {  return GL__M(##Turn,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_267, 267, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor turning ( this is the can't turn people rule ):
[ R_268 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_268, 268);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message turning action number 4 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Turn,4,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_268, 268, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B244_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor turning ( this is the report turning rule ):
[ R_269 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_269, 269);
      ! phrase 1
      ! [1: if the actor is the player , issue library message turning action number 3 for the noun]
       if (((actor == player))) {  GL__M(##Turn,3,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message turning action number 7 for the noun]
       else {  AGL__M(##Turn,7,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_269, 269, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B245_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor pushing something to ( this is the can't push unpushable things rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor pushing something to ( this is the can't push to non-directions rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor pushing something to ( this is the can't push vertically rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor pushing something to ( this is the standard pushing in directions rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push unpushable things rule ):
[ R_270 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_270, 270);
      ! phrase 1
      ! [1: if the noun is not pushable between rooms , stop the action with library message pushing it to action number 1 for the noun]
       if (((~~(((Adj_59_t1_v9(noun))))))) {  return GL__M(##PushDir,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_270, 270, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push to non-directions rule ):
[ R_271 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_271, 271);
      ! phrase 1
      ! [1: if the second noun is not a direction , stop the action with library message pushing it to action number 2 for the noun]
       if (((~~((second ofclass K3_direction))))) {  return GL__M(##PushDir,2,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_271, 271, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the can't push vertically rule ):
[ R_272 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_272, 272);
      ! phrase 1
      ! [1: if the second noun is up or the second noun is down , stop the action with library message pushing it to action number 3 for the noun]
       if ((((second == I54_up))) || (((second == I55_down)))) {  return GL__M(##PushDir,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_272, 272, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the standard pushing in directions rule ):
[ R_273 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_273, 273);
      ! phrase 1
      ! [1: convert to special going-with-push action]
       ConvertToGoingWithPush(); rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_273, 273, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_274 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_274, 274);
      ! phrase 1
      ! [1: stop the action with library message pushing it to action number 1 for the noun]
       return GL__M(##PushDir,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_274, 274, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B248_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_275 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_275, 275);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message squeezing action number 1 for the noun]
       if (((noun ofclass K8_person))) {  return GL__M(##Squeeze,1,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_275, 275, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B250_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_276 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_276, 276);
      ! phrase 1
      ! [1: if the actor is the player , issue library message squeezing action number 2 for the noun]
       if (((actor == player))) {  GL__M(##Squeeze,2,noun);   }
      ! phrase 2
      ! [2: otherwise issue actor-based library message squeezing action number 3 for the noun]
       else {  AGL__M(##Squeeze,3,noun);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_276, 276, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B251_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_277 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_277, 277);
      ! phrase 1
      ! [1: stop the action with library message saying yes action number 1]
       return GL__M(##Yes,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_277, 277, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B254_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying no ( this is the block saying no rule ):
[ R_278 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_278, 278);
      ! phrase 1
      ! [1: stop the action with library message saying no action number 1]
       return GL__M(##No,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_278, 278, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B257_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor burning ( this is the block burning rule ):
[ R_279 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_279, 279);
      ! phrase 1
      ! [1: stop the action with library message burning action number 1]
       return GL__M(##Burn,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_279, 279, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B260_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waking up ( this is the block waking up rule ):
[ R_280 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_280, 280);
      ! phrase 1
      ! [1: stop the action with library message waking up action number 1]
       return GL__M(##Wake,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_280, 280, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B263_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor thinking ( this is the block thinking rule ):
[ R_281 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_281, 281);
      ! phrase 1
      ! [1: stop the action with library message thinking action number 1]
       return GL__M(##Think,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_281, 281, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Smelling (B266_check_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor smelling ( this is the block smelling rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor smelling ( this is the block smelling rule ):
[ R_282 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_282, 282);
      ! phrase 1
      ! [1: stop the action with library message smelling action number 1 for the noun]
       return GL__M(##Smell,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_282, 282, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Listening to (B269_check_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor listening ( this is the block listening rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor listening ( this is the block listening rule ):
[ R_283 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_283, 283);
      ! phrase 1
      ! [1: stop the action with library message listening to action number 1 for the noun]
       return GL__M(##Listen,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_283, 283, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tasting (B272_check_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tasting ( this is the block tasting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor tasting ( this is the block tasting rule ):
[ R_284 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_284, 284);
      ! phrase 1
      ! [1: stop the action with library message tasting action number 1 for the noun]
       return GL__M(##Taste,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_284, 284, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B275_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor cutting ( this is the block cutting rule ):
[ R_285 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_285, 285);
      ! phrase 1
      ! [1: stop the action with library message cutting action number 1 for the noun]
       return GL__M(##Cut,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_285, 285, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Jumping (B278_check_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor jumping ( this is the block jumping rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor jumping ( this is the block jumping rule ):
[ R_286 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_286, 286);
      ! phrase 1
      ! [1: stop the action with library message jumping action number 1]
       return GL__M(##Jump,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_286, 286, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B281_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying something to ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor tying something to ( this is the block tying rule ):
[ R_287 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_287, 287);
      ! phrase 1
      ! [1: stop the action with library message tying it to action number 1 for the noun]
       return GL__M(##Tie,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_287, 287, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B284_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor drinking ( this is the block drinking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor drinking ( this is the block drinking rule ):
[ R_288 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_288, 288);
      ! phrase 1
      ! [1: stop the action with library message drinking action number 1 for the noun]
       return GL__M(##Drink,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_288, 288, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B287_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_289 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_289, 289);
      ! phrase 1
      ! [1: stop the action with library message saying sorry action number 1]
       return GL__M(##Sorry,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_289, 289, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing obscenely (B290_check_swearing_obscenel)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
[ R_290 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_290, 290);
      ! phrase 1
      ! [1: stop the action with library message swearing obscenely action number 1]
       return GL__M(##Strong,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_290, 290, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing mildly (B293_check_swearing_mildly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing mildly ( this is the block swearing mildly rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swearing mildly ( this is the block swearing mildly rule ):
[ R_291 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_291, 291);
      ! phrase 1
      ! [1: stop the action with library message swearing mildly action number 1]
       return GL__M(##Mild,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_291, 291, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B296_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor swinging ( this is the block swinging rule ):
[ R_292 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_292, 292);
      ! phrase 1
      ! [1: stop the action with library message swinging action number 1 for the noun]
       return GL__M(##Swing,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_292, 292, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B299_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor rubbing ( this is the block rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor rubbing ( this is the block rubbing rule ):
[ R_293 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_293, 293);
      ! phrase 1
      ! [1: stop the action with library message rubbing action number 1 for the noun]
       return GL__M(##Rub,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_293, 293, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B302_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_294 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_294, 294);
      ! phrase 1
      ! [1: stop the action with library message setting it to action number 1 for the noun]
       return GL__M(##SetTo,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_294, 294, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving hands (B305_check_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving hands ( this is the block waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor waving hands ( this is the block waving hands rule ):
[ R_295 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_295, 295);
      ! phrase 1
      ! [1: stop the action with library message waving hands action number 1]
       return GL__M(##WaveHands,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_295, 295, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B308_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor buying ( this is the block buying rule ):
[ R_296 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_296, 296);
      ! phrase 1
      ! [1: stop the action with library message buying action number 1 for the noun]
       return GL__M(##Buy,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_296, 296, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Singing (B311_check_singing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor singing ( this is the block singing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From the Standard Rules
! Check an actor singing ( this is the block singing rule ):
[ R_297 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_297, 297);
      ! phrase 1
      ! [1: stop the action with library message singing action number 1]
       return GL__M(##Sing,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_297, 297, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B314_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check climbing the chain-link fence:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check climbing the chain-link fence:
[ R_1247 ;
   if ( (actor==player) && ((noun == I473_chain_link_fence) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1247, 1247);
      ! phrase 1
      ! [1: say ~You manage to pull yourself up to the top of the fence and drop down on the other side, without causing yourself too much damage.~]
      say__p=1;ParaContent();  print (PrintText) SC_969;  new_line; .L_Say647; .L_SayX618;
      ! phrase 2
      ! [2: if four pumps are switched off , change the wetness level to ~just beachy~]
       if ((Prop_94())) {  (Global_Vars-->22) = SC_294;   }
      ! phrase 3
      ! [3: record ~climbing the fence~ as achieved]
      (PHR_1164_r6 (SC_184));
      ! phrase 4
      ! [4: if the location is outside waterworks , move the player to muddy beach instead]
       if (((real_location == I447_outside_waterworks))) {  MoveObject(player, I468_muddy_beach, 0, false);   rtrue; }
      ! phrase 5
      ! [5: if the location is not outside waterworks , move the player to outside waterworks instead]
       if (((~~((real_location == I447_outside_waterworks))))) {  MoveObject(player, I447_outside_waterworks, 0, false);   rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1247, 1247, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor climbing ( this is the block climbing rule ):
[ R_298 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_298, 298);
      ! phrase 1
      ! [1: stop the action with library message climbing action number 1 for the noun]
       return GL__M(##Climb,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_298, 298, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Requesting the score (B345_carry_out_requesting_th)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! This is the complete scoring rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! This is the complete scoring rule:
[ R_1165 ;
      ! phrase 1
      ! [1: try requesting the full score]
       TryAction(0, player, ##A110_requesting_the_full_sco, 0, 0);; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Retreating (B366_carry_out_retreating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out retreating ( this is the Small Kindnesses carry out retreating rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Carry out retreating ( this is the Small Kindnesses carry out retreating rule ):
[ R_747 
    t_0 ! Local variable e.g. 'way' = object
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_747, 747);
      ! phrase 1
      ! [1: let way be the best route from the location to the small kindnesses former location through visited rooms , using even locked doors]
       t_0 =  MapRouteTo(real_location,(Global_Vars-->9),Prop_95,2) ; 
      ! phrase 2
      ! [2: if way is a direction begin]
       if (((t_0 ofclass K3_direction)))  {
         ! phrase 3
         ! [3: try going way]
          TryAction(0, player, ##Go, t_0, 0);; 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: issue library message going action number 7]
          GL__M(##Go,7,noun); 
         ! phrase 6
         ! [6: stop the action]
          rtrue; 
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_747, 747, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Overly elaborate looking (B369_carry_out_overly_elabor)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out overly elaborate looking ( this is the Small Kindnesses overly elaborate looking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Carry out overly elaborate looking ( this is the Small Kindnesses overly elaborate looking rule ):
[ R_749 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_749, 749);
      ! phrase 1
      ! [1: instead try looking]
       TryAction(0, player, ##Look, 0, 0);;  rtrue;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_749, 749, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Listing exits (B372_carry_out_listing_exits)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out listing exits ( this is the Small Kindnesses count exits rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Carry out listing exits ( this is the Small Kindnesses count exits rule ):
[ R_754 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_754, 754);
      ! phrase 1
      ! [1: now count of exits is the number of viable directions]
       (MStack-->MstVO(20082,0)) =  (Prop_96()) ; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_754, 754, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Listing exits (B373_report_listing_exits)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report listing exits when count of exits is 0 ( this is the Small Kindnesses report on no exits rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report listing exits when count of exits is 1 ( this is the Small Kindnesses report on one exit rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report listing exits when count of exits > 1 ( this is the Small Kindnesses report on exits rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Report listing exits when count of exits is 0 ( this is the Small Kindnesses report on no exits rule ):
[ R_755 ;
   if (actor == player) {
   if (((((((MStack-->MstVO(20082,0)) == 0)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_755, 755);
      ! phrase 1
      ! [1: say the message corresponding to a rule name of small kindnesses report on no exits rule in the table of small kindnesses responses]
      say__p=1;ParaContent();  print (PrintText) TableLookUpCorr(T2_small_kindnesses_response,108,107,R_755);  .L_Say648; .L_SayX619;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_755, 755, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Report listing exits when count of exits is 1 ( this is the Small Kindnesses report on one exit rule ):
[ R_756 ;
   if (actor == player) {
   if (((((((MStack-->MstVO(20082,0)) == 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_756, 756);
      ! phrase 1
      ! [1: say the message corresponding to a rule name of small kindnesses report on one exit rule in the table of small kindnesses responses]
      say__p=1;ParaContent();  print (PrintText) TableLookUpCorr(T2_small_kindnesses_response,108,107,R_756);  .L_Say649; .L_SayX620;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_756, 756, true);
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Report listing exits when count of exits > 1 ( this is the Small Kindnesses report on exits rule ):
[ R_757 ;
   if (actor == player) {
   if (((((((MStack-->MstVO(20082,0)) > 1)))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_757, 757);
      ! phrase 1
      ! [1: say the message corresponding to a rule name of small kindnesses report on exits rule in the table of small kindnesses responses]
      say__p=1;ParaContent();  print (PrintText) TableLookUpCorr(T2_small_kindnesses_response,108,107,R_757);  .L_Say650; .L_SayX621;
   } ! Runs only when actor is the player
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_757, 757, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Using (B375_carry_out_using)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out using ( this is the Small Kindnesses carry out using rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Carry out using ( this is the Small Kindnesses carry out using rule ):
[ R_762 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_762, 762);
      ! phrase 1
      ! [1: say the message corresponding to a rule name of small kindnesses carry out using rule in the table of small kindnesses responses]
      say__p=1;ParaContent();  print (PrintText) TableLookUpCorr(T2_small_kindnesses_response,108,107,R_762);  .L_Say651; .L_SayX622;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_762, 762, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: holdall (B377_holdall)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Holdall rule for a thing ( called the item ) when multi ( this is the remove all from a holdall rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/6 ! Holdall rule for a thing not enclosed by the player:
!   === which is equally specific with ===
! Rule 3/6 ! Holdall rule for a thing not enclosed by the player:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 4/6 ! Holdall rule for a closed player's holdall ( this is the require an open holdall rule ):
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 5/6 ! A holdall rule for a thing ( called the item ) ( this is the check the size of a holdall rule ):
! --- now the last-placed rules ---
! Rule 6/6 ! The last holdall rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Holdall rule for a thing ( called the item ) when multi ( this is the remove all from a holdall rule ):
[ R_776 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if ((((( (multiflag) ))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_776, 776);
      ! phrase 1
      ! [1: if taking something inside the item , disallow stashing]
       if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (t_0 == ContainerOf(noun)))) { RulebookFails(19, RBNO_15); rtrue;
  }
   } ! Runs only when pattern matches
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_776, 776, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Holdall rule for a thing not enclosed by the player:
[ R_775 ;
   if (((parameter_object ofclass K2_thing) && (~~((IndirectlyContains(player,parameter_object)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_775, 775);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_775, 775, true);
   rfalse;
];
! No specific request
! Holdall rule for a thing not enclosed by the player:
[ R_1205 ;
   if (((parameter_object ofclass K2_thing) && (~~((IndirectlyContains(player,parameter_object)))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1205, 1205);
      ! phrase 1
      ! [1: if the thing is a pocket and the player is wearing the coat , allow stashing]
       if ((((I451_right_pocket ofclass K2_thing))) && (((player == WearerOf(I450_your_coat))))) { RulebookSucceeds(19, RBNO_13); rtrue;
  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1205, 1205, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Holdall rule for a closed player's holdall ( this is the require an open holdall rule ):
[ R_777 ;
   if (((parameter_object ofclass K15_player_s_holdall) && ((Adj_71_t1_v9(parameter_object))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_777, 777);
      ! phrase 1
      ! [1: if not using the inline implicit library option , disallow stashing]
       if (~~(( (TestUseOption(23)) ))) { RulebookFails(19, RBNO_15); rtrue;
  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_777, 777, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! A holdall rule for a thing ( called the item ) ( this is the check the size of a holdall rule ):
[ R_778 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_778, 778);
      ! phrase 1
      ! [1: if item provides the property carrying capacity and the number of things in item is at least the carrying capacity of item , disallow stashing]
       if ((((WhetherProvides(t_0, false, capacity)))) && ((( (Prop_97(,t_0))  >= GProperty(9, t_0,capacity))))) { RulebookFails(19, RBNO_15); rtrue;
  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_778, 778, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! The last holdall rule:
[ R_779 ;
      ! phrase 1
      ! [1: allow stashing]
      RulebookSucceeds(19, RBNO_13); rtrue;

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: stashing (B378_stashing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! First stashing rule for thing ( called the item ):
! --- now the mid-placed rules ---
! Rule 2/9 ! A stashing rule for the wide stick:
!   === which is equally specific with ===
! Rule 3/9 ! A stashing rule for the wooden drawer:
!   === which is equally specific with ===
! Rule 4/9 ! A stashing rule for the flagpole:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 5/9 ! Stashing rule for the considered holdall:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 6/9 ! Stashing rule for something enclosing the considered holdall:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 7/9 ! Stashing rule for a body-part thing:
!   >>> III.1 - Object To Which Rule Applies >>>
! Rule 8/9 ! A stashing rule for a fluid container:
! --- now the last-placed rules ---
! Rule 9/9 ! The last stashing rule:
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Considerate Holdall" by Jon Ingold
! First stashing rule for thing ( called the item ):
[ R_782 
    t_0 ! Local variable e.g. 'item' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_782, 782);
      ! phrase 1
      ! [1: if the item is unstashable , disallow stashing]
       if ((((Adj_85_t1_v9(t_0))))) { RulebookFails(19, RBNO_15); rtrue;
  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_782, 782, true);
   rfalse;
];
! No specific request
! A stashing rule for the wide stick:
[ R_1208 ;
   if (((parameter_object == I476_wide_stick) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1208, 1208);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1208, 1208, true);
   rfalse;
];
! No specific request
! A stashing rule for the wooden drawer:
[ R_1209 ;
   if (((parameter_object == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1209, 1209);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1209, 1209, true);
   rfalse;
];
! No specific request
! A stashing rule for the flagpole:
[ R_1210 ;
   if (((parameter_object == I490_flagpole) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1210, 1210);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1210, 1210, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Stashing rule for the considered holdall:
[ R_783 ;
   if (((parameter_object == (Global_Vars-->10)) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_783, 783);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_783, 783, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Stashing rule for something enclosing the considered holdall:
[ R_784 ;
   if (((parameter_object ofclass K2_thing) && (IndirectlyContains(parameter_object,(Global_Vars-->10))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_784, 784);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_784, 784, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Stashing rule for a body-part thing:
[ R_785 ;
   if (((parameter_object ofclass K2_thing) && ((Adj_35_t1_v9(parameter_object))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_785, 785);
      ! phrase 1
      ! [1: disallow stashing]
      RulebookFails(19, RBNO_15); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_785, 785, true);
   rfalse;
];
! No specific request
! A stashing rule for a fluid container:
[ R_1207 ;
   if (((parameter_object ofclass K25_fluid_container))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1207, 1207);
      ! phrase 1
      ! [1: if the fluid container is not empty , disallow stashing]
       if ((Prop_98())) { RulebookFails(19, RBNO_15); rtrue;
  }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1207, 1207, true);
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! The last stashing rule:
[ R_786 ;
      ! phrase 1
      ! [1: allow stashing]
      RulebookSucceeds(19, RBNO_13); rtrue;

   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Mounting (B379_check_mounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor mounting ( this is the can't mount when mounted on an animal rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor mounting ( this is the can't mount when mounted on a vehicle rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor mounting ( this is the can't mount something unrideable rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor mounting ( this is the can't mount something carried rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor mounting ( this is the can't mount something unreachable rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount when mounted on an animal rule ):
[ R_798 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_798, 798);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal ( called the steed ) begin]
       if (((CarrierOf(actor) ofclass K16_rideable_animal) && (t_0=(CarrierOf(actor)), true)))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~You are already riding [the steed].~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_970; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say652; .L_SayX623;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_798, 798, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount when mounted on a vehicle rule ):
[ R_799 
    t_0 ! Local variable e.g. 'conveyance' = rideable vehicle
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_799, 799);
      ! phrase 1
      ! [1: if the actor is on a rideable vehicle ( called the conveyance ) begin]
       if (((SupporterOf(actor) ofclass K17_rideable_vehicle) && (t_0=(SupporterOf(actor)), true)))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~You are already riding [the conveyance].~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_970; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say653; .L_SayX624;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_799, 799, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount something unrideable rule ):
[ R_800 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_800, 800);
      ! phrase 1
      ! [1: if the noun is not a rideable animal and the noun is not a rideable vehicle begin]
       if ((((~~((noun ofclass K16_rideable_animal))))) && (((~~((noun ofclass K17_rideable_vehicle))))))  {
         ! phrase 2
         ! [2: if the actor is the player , say ~[The noun] cannot be ridden.~ instead]
          if (((actor == player))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_389;  new_line; .L_Say654; .L_SayX625;  rtrue; }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_800, 800, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount something carried rule ):
[ R_801 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_801, 801);
      ! phrase 1
      ! [1: abide by the can't enter something carried rule]
       if (ProcessRulebook(R_154)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_801, 801, true);
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor mounting ( this is the can't mount something unreachable rule ):
[ R_802 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_802, 802);
      ! phrase 1
      ! [1: abide by the implicitly pass through other barriers rule]
       if (ProcessRulebook(R_155)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_802, 802, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Mounting (B380_carry_out_mounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor mounting ( this is the standard mounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Carry out an actor mounting ( this is the standard mounting rule ):
[ R_803 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_803, 803);
      ! phrase 1
      ! [1: surreptitiously move the actor to the noun]
       move actor to noun; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_803, 803, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Mounting (B381_report_mounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor mounting ( this is the standard report mounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Report an actor mounting ( this is the standard report mounting rule ):
[ R_804 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_804, 804);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: say ~You mount [the noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_971; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say655; .L_SayX626;
         ! phrase 3
         ! [3: describe locale for the noun]
         (PHR_71_r17 (noun));
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~[The actor] mount[s] [the noun].~ instead]
         say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_972; ParaContent();  STextSubstitution(); ParaContent();  print (PrintText) SC_387; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; rtrue; .L_Say656; .L_SayX627; rtrue;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_804, 804, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dismounting (B382_check_dismounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor dismounting ( this is the can't dismount when not mounted rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Check an actor dismounting ( this is the can't dismount when not mounted rule ):
[ R_806 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_806, 806);
      ! phrase 1
      ! [1: if the actor is not carried by a rideable animal and the actor is not on a rideable vehicle begin]
       if (((Prop_99())) && ((Prop_100())))  {
         ! phrase 2
         ! [2: if the actor is a player , say ~You are not riding anything.~]
          if (((actor == player))) { say__p=1;ParaContent();  print (PrintText) SC_973;  new_line; .L_Say657; .L_SayX628;  }
         ! phrase 3
         ! [3: stop the action]
          rtrue; 
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_806, 806, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dismounting (B383_carry_out_dismounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dismounting ( this is the standard dismounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Carry out an actor dismounting ( this is the standard dismounting rule ):
[ R_807 
    t_0 ! Local variable e.g. 'steed' = rideable animal
    t_1 ! Local variable e.g. 'conveyance' = rideable vehicle
    t_2 ! Local variable e.g. 'former exterior' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_807, 807);
      ! phrase 1
      ! [1: if the actor is carried by a rideable animal ( called the steed ) , now the noun is the steed]
       if (((CarrierOf(actor) ofclass K16_rideable_animal) && (t_0=(CarrierOf(actor)), true))) {  noun = t_0;   }
      ! phrase 2
      ! [2: if the actor is on a rideable vehicle ( called the conveyance ) , now the noun is the conveyance]
       if (((SupporterOf(actor) ofclass K17_rideable_vehicle) && (t_1=(SupporterOf(actor)), true))) {  noun = t_1;   }
      ! phrase 3
      ! [3: let the former exterior be the holder of the noun]
       t_2 =  (HolderOf(noun)) ; 
      ! phrase 4
      ! [4: surreptitiously move the actor to the former exterior]
       move actor to t_2; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_807, 807, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dismounting (B384_report_dismounting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dismounting ( this is the standard report dismounting rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Report an actor dismounting ( this is the standard report dismounting rule ):
[ R_808 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_808, 808);
      ! phrase 1
      ! [1: if the actor is the player begin]
       if (((actor == player)))  {
         ! phrase 2
         ! [2: say ~You dismount [the noun].[line break][run paragraph on]~]
         say__p=1;ParaContent();  print (PrintText) SC_974; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250; ParaContent();  new_line; ParaContent();  RunParagraphOn();  .L_Say658; .L_SayX629;
         ! phrase 3
         ! [3: produce a room description with going spacing conventions]
          LookAfterGoing(); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~[The actor] dismount[s] [the noun].~]
         say__p=1;ParaContent();  print (The) actor; ParaContent();  print (PrintText) SC_975; ParaContent();  STextSubstitution(); ParaContent();  print (PrintText) SC_387; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say659; .L_SayX630;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_808, 808, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Refusing keys (B386_for_refusing_keys)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for refusing keys of something ( called locked-thing ) ( this is the standard printing key lack rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Rule for refusing keys of something ( called locked-thing ) ( this is the standard printing key lack rule ):
[ R_821 
    t_0 ! Local variable e.g. 'locked-thing' = thing
    ;
   if ((t_0 = parameter_object, (((t_0=(parameter_object), true) && (parameter_object ofclass K2_thing))))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_821, 821);
      ! phrase 1
      ! [1: say ~You lack a key that fits [the locked-thing].~]
      say__p=1;ParaContent();  print (PrintText) SC_976; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say660; .L_SayX631;
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_821, 821, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking keylessly (B388_check_unlocking_keyless)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check someone trying unlocking keylessly ( this is the check someone else keylessly unlocking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Check unlocking keylessly ( this is the check keylessly unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Check someone trying unlocking keylessly ( this is the check someone else keylessly unlocking rule ):
[ R_827 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_827, 827);
      ! phrase 1
      ! [1: abide by the can't unlock without a lock rule]
       if (ProcessRulebook(R_198)) rtrue; 
      ! phrase 2
      ! [2: abide by the can't unlock what's already unlocked rule]
       if (ProcessRulebook(R_199)) rtrue; 
      ! phrase 3
      ! [3: abide by the need a matching key rule]
       if (ProcessRulebook(R_819)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_827, 827, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Check unlocking keylessly ( this is the check keylessly unlocking rule ):
[ R_825 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_825, 825);
      ! phrase 1
      ! [1: abide by the can't unlock without a lock rule]
       if (ProcessRulebook(R_198)) rtrue; 
      ! phrase 2
      ! [2: abide by the can't unlock what's already unlocked rule]
       if (ProcessRulebook(R_199)) rtrue; 
      ! phrase 3
      ! [3: abide by the need a matching key rule]
       if (ProcessRulebook(R_819)) rtrue; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_825, 825, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking keylessly (B389_carry_out_unlocking_key)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out someone trying unlocking keylessly ( this is the standard someone else keylessly unlocking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out unlocking keylessly ( this is the standard keylessly unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Carry out someone trying unlocking keylessly ( this is the standard someone else keylessly unlocking rule ):
[ R_828 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_828, 828);
      ! phrase 1
      ! [1: try the person asked trying unlocking the noun with the matching key of the noun]
       TryAction(0, actor, ##Unlock, noun, GProperty(OBJECT_TY, noun,with_key));; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_828, 828, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Carry out unlocking keylessly ( this is the standard keylessly unlocking rule ):
[ R_826 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_826, 826);
      ! phrase 1
      ! [1: if sequential action option is active , do nothing]
       if ((((Adj_22_t1_v15(24))))) {  ;   }
      ! phrase 2
      ! [2: otherwise say ~(with [the matching key of the noun])[command clarification break]~]
       else { say__p=1;ParaContent();  print (PrintText) SC_977; ParaContent(); @push self;  print (the) GProperty(OBJECT_TY, self=noun,with_key); @pull self; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say661; .L_SayX632;  }
      ! phrase 3
      ! [3: try unlocking the noun with the matching key of the noun]
       TryAction(0, player, ##Unlock, noun, GProperty(OBJECT_TY, noun,with_key));; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_826, 826, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking keylessly (B391_check_locking_keylessly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check someone trying locking keylessly ( this is the check someone keylessly locking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Check locking keylessly ( this is the check keylessly locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Check someone trying locking keylessly ( this is the check someone keylessly locking rule ):
[ R_832 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_832, 832);
      ! phrase 1
      ! [1: abide by the can't lock without a lock rule]
       if (ProcessRulebook(R_192)) rtrue; 
      ! phrase 2
      ! [2: abide by the can't lock what's already locked rule]
       if (ProcessRulebook(R_193)) rtrue; 
      ! phrase 3
      ! [3: abide by the can't lock what's open rule]
       if (ProcessRulebook(R_194)) rtrue; 
      ! phrase 4
      ! [4: abide by the need a matching key rule]
       if (ProcessRulebook(R_819)) rtrue; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_832, 832, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Check locking keylessly ( this is the check keylessly locking rule ):
[ R_830 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_830, 830);
      ! phrase 1
      ! [1: abide by the can't lock without a lock rule]
       if (ProcessRulebook(R_192)) rtrue; 
      ! phrase 2
      ! [2: abide by the can't lock what's already locked rule]
       if (ProcessRulebook(R_193)) rtrue; 
      ! phrase 3
      ! [3: abide by the can't lock what's open rule]
       if (ProcessRulebook(R_194)) rtrue; 
      ! phrase 4
      ! [4: abide by the need a matching key rule]
       if (ProcessRulebook(R_819)) rtrue; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_830, 830, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking keylessly (B392_carry_out_locking_keyle)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out someone trying locking keylessly ( this is the standard someone keylessly locking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out locking keylessly ( this is the standard keylessly locking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Carry out someone trying locking keylessly ( this is the standard someone keylessly locking rule ):
[ R_833 ;
   if ( (actor~=player) && (act_requester==nothing) && ((actor ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_833, 833);
      ! phrase 1
      ! [1: try the person asked trying locking the noun with the matching key of the noun]
       TryAction(0, actor, ##Lock, noun, GProperty(OBJECT_TY, noun,with_key));; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_833, 833, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Carry out locking keylessly ( this is the standard keylessly locking rule ):
[ R_831 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_831, 831);
      ! phrase 1
      ! [1: if sequential action option is active , do nothing]
       if ((((Adj_22_t1_v15(24))))) {  ;   }
      ! phrase 2
      ! [2: otherwise say ~(with [the matching key of the noun])[command clarification break]~]
       else { say__p=1;ParaContent();  print (PrintText) SC_977; ParaContent(); @push self;  print (the) GProperty(OBJECT_TY, self=noun,with_key); @pull self; ParaContent();  print (PrintText) SC_413; ParaContent();  CommandClarificationBreak();  .L_Say662; .L_SayX633;  }
      ! phrase 3
      ! [3: try locking the noun with the matching key of the noun]
       TryAction(0, player, ##Lock, noun, GProperty(OBJECT_TY, noun,with_key));; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_831, 831, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Universal unlocking (B395_carry_out_universal_unl)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out universal unlocking ( this is the lock debugging rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Carry out universal unlocking ( this is the lock debugging rule ):
[ R_851 
    t_0 ! Local variable e.g. '?-1,-1?' = thing
    t_1 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_851, 851);
      ! phrase 1
      ! [1: repeat with item running through locked things begin]
       for (t_0=Prop_101(0), t_1=Prop_101(t_0): t_0: t_0=t_1, t_1=Prop_101(t_1))  {
         ! phrase 2
         ! [2: now the item is unlocked]
          (Adj_76_t2_v9(t_0)); 
         ! phrase 3
         ! [3: say ~Unlocking [the item].~]
         say__p=1;ParaContent();  print (PrintText) SC_978; ParaContent();  print (the) t_0; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say663; .L_SayX634;
         ! phrase 4
         ! [4: end repeat]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_851, 851, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Universal unlocking (B396_report_universal_unlock)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report universal unlocking ( this is the report universal unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Locksmith" by Emily Short
! Report universal unlocking ( this is the report universal unlocking rule ):
[ R_852 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_852, 852);
      ! phrase 1
      ! [1: say ~A loud stereophonic click assures you that everything in the game has been unlocked.~]
      say__p=1;ParaContent();  print (PrintText) SC_979;  new_line; .L_Say664; .L_SayX635;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_852, 852, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: should the game choose (B397_should_the_game_choose)
! ----------------------------------------------------------------------------------------------------
! Rule 1/31 ! Should the game choose doing something with running water when also only considering the pond:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/31 ! Should the game choose taking a small rock when a small rock is in Rocky Beach:
!   >>> I - Number of aspects constrained >>>
! Rule 3/31 ! Should the game choose taking running water with the beer bottle:
!   === which is equally specific with ===
! Rule 4/31 ! Should the game choose filling the beer bottle with running water:
!   === which is equally specific with ===
! Rule 5/31 ! Should the game choose taking the old key with the magnet:
!   === which is equally specific with ===
! Rule 6/31 ! Should the game choose putting the medium-sized wheel on the wheel holes:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 7/31 ! Should the game choose doing something other than taking with a small rock held by the player:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 8/31 ! Should the game choose pouring running water into something:
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 9/31 ! Should the game choose examining the fountain:
!   === which is equally specific with ===
! Rule 10/31 ! Should the game choose drinking running water:
!   === which is equally specific with ===
! Rule 11/31 ! Should the game choose rowing toward the real crystal spire:
!   === which is equally specific with ===
! Rule 12/31 ! Should the game choose examining the complicated pump:
!   === which is equally specific with ===
! Rule 13/31 ! Should the game choose switching on the complicated pump:
!   === which is equally specific with ===
! Rule 14/31 ! Should the game choose taking the rock selection:
!   === which is equally specific with ===
! Rule 15/31 ! Should the game choose taking off the rock selection:
!   === which is equally specific with ===
! Rule 16/31 ! Should the game choose turning the medium-sized wheel:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 17/31 ! Should the game choose doing something other than opening to the wooden drawer:
!   >>> III.4.1 - Action/How/What Happens >>>
! Rule 18/31 ! Should the game choose doing something to the wind chimes:
!   === which is equally specific with ===
! Rule 19/31 ! Should the game choose doing something to the structure:
!   === which is equally specific with ===
! Rule 20/31 ! Should the game choose doing something to the real crystal spire:
!   === which is equally specific with ===
! Rule 21/31 ! Should the game choose doing something to the green switch:
!   === which is equally specific with ===
! Rule 22/31 ! Should the game choose doing something to the blue lever:
!   === which is equally specific with ===
! Rule 23/31 ! Should the game choose doing something to the blue switch:
!   === which is equally specific with ===
! Rule 24/31 ! Should the game choose doing something to the engineer's blueprint:
!   === which is equally specific with ===
! Rule 25/31 ! Should the game choose doing something with the anchor:
!   === which is equally specific with ===
! Rule 26/31 ! Should the game choose doing something to the medium-sized wheel:
!   === which is equally specific with ===
! Rule 27/31 ! Should the game choose doing something to the pipe holes:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 28/31 ! Should the game choose spilling a fluid container:
!   === which is equally specific with ===
! Rule 29/31 ! Should the game choose taking off the pinecone:
!   === which is equally specific with ===
! Rule 30/31 ! Should the game choose taking off a small rock:
!   === which is equally specific with ===
! Rule 31/31 ! Should the game choose skipping a small rock:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Should the game choose doing something with running water when also only considering the pond:
[ R_1107 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I462_running_water) && (true)) && (self=actor,true) && (( IncludedInMatchList(I463_pond, 1)	))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1107, 1107);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1107, 1107, true);
   rfalse;
];
! No specific request
! Should the game choose taking a small rock when a small rock is in Rocky Beach:
[ R_1485 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K24_small_rock)) && (self=actor,true) && ((Prop_102()))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1485, 1485);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1485, 1485, true);
   rfalse;
];
! No specific request
! Should the game choose taking running water with the beer bottle:
[ R_1105 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I462_running_water) && (true)) && ((second == I472_beer_bottle) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1105, 1105);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1105, 1105, true);
   rfalse;
];
! No specific request
! Should the game choose filling the beer bottle with running water:
[ R_1106 ;
   if ((action ==##A100_filling_it_with) &&  (actor==player) && ((noun == I472_beer_bottle) && (true)) && ((second == I462_running_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1106, 1106);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1106, 1106, true);
   rfalse;
];
! No specific request
! Should the game choose taking the old key with the magnet:
[ R_1578 ;
   if ((action ==##A130_taking_it_with) &&  (actor==player) && ((noun == I640_old_key) && (true)) && ((second == I604_large_magnet) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1578, 1578);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1578, 1578, true);
   rfalse;
];
! No specific request
! Should the game choose putting the medium-sized wheel on the wheel holes:
[ R_1660 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true)) && ((second == I661_wheel_holes) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1660, 1660);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1660, 1660, true);
   rfalse;
];
! No specific request
! Should the game choose doing something other than taking with a small rock held by the player:
[ R_1489 ;
   if ((action ~=##A130_taking_it_with) &&  (actor==player) && ((second ofclass K24_small_rock) && (player == HolderOf(second)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1489, 1489);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1489, 1489, true);
   rfalse;
];
! No specific request
! Should the game choose pouring running water into something:
[ R_1104 ;
   if ((action ==##A101_pouring_it_into) &&  (actor==player) && ((noun == I462_running_water) && (true)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1104, 1104);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1104, 1104, true);
   rfalse;
];
! No specific request
! Should the game choose examining the fountain:
[ R_1227 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I461_water_fountain) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1227, 1227);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1227, 1227, true);
   rfalse;
];
! No specific request
! Should the game choose drinking running water:
[ R_1232 ;
   if ((action ==##Drink) &&  (actor==player) && ((noun == I462_running_water) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1232, 1232);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1232, 1232, true);
   rfalse;
];
! No specific request
! Should the game choose rowing toward the real crystal spire:
[ R_1312 ;
   if ((action ==##A116_rowing_toward) &&  (actor==player) && ((noun == I495_real_crystal_spire) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1312, 1312);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1312, 1312, true);
   rfalse;
];
! No specific request
! Should the game choose examining the complicated pump:
[ R_1332 ;
   if ((action ==##Examine) &&  (actor==player) && ((noun == I416_complicated_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1332, 1332);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1332, 1332, true);
   rfalse;
];
! No specific request
! Should the game choose switching on the complicated pump:
[ R_1333 ;
   if ((action ==##SwitchOn) &&  (actor==player) && ((noun == I416_complicated_pump) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1333, 1333);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1333, 1333, true);
   rfalse;
];
! No specific request
! Should the game choose taking the rock selection:
[ R_1484 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == I601_rock_selection) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1484, 1484);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1484, 1484, true);
   rfalse;
];
! No specific request
! Should the game choose taking off the rock selection:
[ R_1488 ;
   if ((action ==##Disrobe) &&  (actor==player) && ((noun == I601_rock_selection) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1488, 1488);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1488, 1488, true);
   rfalse;
];
! No specific request
! Should the game choose turning the medium-sized wheel:
[ R_1639 ;
   if ((action ==##Turn) &&  (actor==player) && ((noun == I660_medium_sized_wheel) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1639, 1639);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1639, 1639, true);
   rfalse;
];
! No specific request
! Should the game choose doing something other than opening to the wooden drawer:
[ R_1329 ;
   if ((action ~=##Open) &&  (actor==player) && ((noun == I589_wooden_drawer) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1329, 1329);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1329, 1329, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the wind chimes:
[ R_1189 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I563_metal_wind_chimes) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1189, 1189);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1189, 1189, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the structure:
[ R_1260 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I477_structure) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1260, 1260);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1260, 1260, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the real crystal spire:
[ R_1305 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I495_real_crystal_spire) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1305, 1305);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1305, 1305, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the green switch:
[ R_1354 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I693_green_switch) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1354, 1354);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1354, 1354, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the blue lever:
[ R_1365 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I538_blue_lever) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1365, 1365);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1365, 1365, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the blue switch:
[ R_1366 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I691_blue_switch) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1366, 1366);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1366, 1366, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the engineer's blueprint:
[ R_1472 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I592_engineer_s_blueprint) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1472, 1472);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1472, 1472, true);
   rfalse;
];
! No specific request
! Should the game choose doing something with the anchor:
[ R_1537 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I619_anchor) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1537, 1537);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1537, 1537, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the medium-sized wheel:
[ R_1638 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I660_medium_sized_wheel) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1638, 1638);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1638, 1638, true);
   rfalse;
];
! No specific request
! Should the game choose doing something to the pipe holes:
[ R_1651 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I662_pipe_holes) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1651, 1651);
      ! phrase 1
      ! [1: it is a good choice]
      RulebookSucceeds(19, RBNO_17); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1651, 1651, true);
   rfalse;
];
! No specific request
! Should the game choose spilling a fluid container:
[ R_1114 ;
   if ((action ==##A103_spilling) &&  (actor==player) && ((noun ofclass K25_fluid_container))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1114, 1114);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1114, 1114, true);
   rfalse;
];
! No specific request
! Should the game choose taking off the pinecone:
[ R_1420 ;
   if ((action ==##Disrobe) &&  (actor==player) && ((noun ofclass K30_pinecone))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1420, 1420);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1420, 1420, true);
   rfalse;
];
! No specific request
! Should the game choose taking off a small rock:
[ R_1487 ;
   if ((action ==##Disrobe) &&  (actor==player) && ((noun ofclass K24_small_rock))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1487, 1487);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1487, 1487, true);
   rfalse;
];
! No specific request
! Should the game choose skipping a small rock:
[ R_1493 ;
   if ((action ==##A127_skipping) &&  (actor==player) && ((noun ofclass K24_small_rock))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1493, 1493);
      ! phrase 1
      ! [1: it is an excellent choice]
      RulebookSucceeds(19, RBNO_16); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1493, 1493, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Should the game suggest (B398_should_the_game_suggest)
! ----------------------------------------------------------------------------------------------------
! Rule 1/38 ! The first should the game suggest rule when the noun is yourself and testing the noun ( this is the never suggest yourself rule ):
!   === which is equally specific with ===
! Rule 2/38 ! The first should the game suggest removing something from something when the noun is not inside the second noun and the noun is not on the second noun ( this is the don't expect to remove items from things they're not in rule ):
!   === which is equally specific with ===
! Rule 3/38 ! The first Should the game suggest putting something on something when the noun is the second noun ( this is the don't suggest putting something into itself rule ):
!   === which is equally specific with ===
! Rule 4/38 ! The first Should the game suggest inserting something into something when the noun is the second noun ( this is the don't expecting inserting something into itself rule ):
!   === which is equally specific with ===
! Rule 5/38 ! The first Should the game suggest putting something on something when the noun is on the second noun ( this is the don't suggest putting somewhere it already is rule ):
!   === which is equally specific with ===
! Rule 6/38 ! The first Should the game suggest inserting something into something when the noun is inside the second noun ( this is the don't suggest inserting somewhere it already is rule ):
!   === which is equally specific with ===
! Rule 7/38 ! The first Should the game suggest dropping something carried by the player ( this is the drop what's you've got rule ):
! --- now the mid-placed rules ---
! Rule 8/38 ! Should the game suggest giving something carried by the player to someone when testing noun ( this is the suggest giving held things rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 9/38 ! Should the game suggest showing something to someone when testing second noun ( this is the expect animate nouns for giving rule ):
!   === which is equally specific with ===
! Rule 10/38 ! Should the game suggest giving something to someone when testing second noun ( this is the expect animate nouns for showing rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 11/38 ! Should the game suggest putting something on something when the second noun is a supporter and testing second noun ( this is the suggest putting on a supporter rule ):
!   === which is equally specific with ===
! Rule 12/38 ! Should the game suggest inserting something into something when the noun is carried and testing noun ( this is the expect to put held things into rule ):
!   === which is equally specific with ===
! Rule 13/38 ! Should the game suggest putting something on something when the noun is carried and testing noun ( this is the suggest to put held things on rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 14/38 ! Should the game suggest showing something to something when testing second noun ( this is the reject inanimate nouns for giving rule ):
!   === which is equally specific with ===
! Rule 15/38 ! Should the game suggest giving something to something when testing second noun ( this is the reject inanimate nouns for showing rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 16/38 ! Should the game suggest removing from something when the second noun is not a container and the second noun is not a supporter and testing second noun ( this is the don't expect to remove from items not including other items rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 17/38 ! Should the game suggest inserting into something when the second noun is not a container and testing second noun ( this is the don't suggest inserting into a non-container rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 18/38 ! Should the game suggest inserting into something when the second noun is a container and testing second noun ( this is the suggest inserting into a container rule ):
!   >>> III.5.2 - Action/When/Circumstances >>>
! Rule 19/38 ! Should the game suggest removing from something when the noun is inside the second noun or the noun is on the second noun ( this is the expect to remove items from things they are in rule ):
!   >>> III.3.1 - Action/What/Second Thing Acted On >>>
! Rule 20/38 ! Should the game suggest unlocking a thing ( called x ) with when testing noun ( this is the standard suggest unlocking rule ):
!   === which is equally specific with ===
! Rule 21/38 ! Should the game suggest locking a thing ( called x ) with when testing noun ( this is the standard suggest locking rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 22/38 ! Should the game suggest doing something with no-object:
!   === which is equally specific with ===
! Rule 23/38 ! Should the game suggest doing something to the drawer bottom:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 24/38 ! Should the game suggest taking the player ( this is the don't suggest taking yourself rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 25/38 ! Should the game suggest taking something enclosed by a person ( this is the don't suggest taking something someone's got rule ):
!   === which is equally specific with ===
! Rule 26/38 ! Should the game suggest dropping something not enclosed by the player ( this is the don't suggest dropping something you've not got rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 27/38 ! Should the game suggest taking something carried by the player ( this is the don't suggest to take what's carried rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 28/38 ! Should the game suggest taking something scenery ( this is the don't suggest taking the scenery rule ):
!   === which is equally specific with ===
! Rule 29/38 ! Should the game suggest taking something fixed in place ( this is the don't suggest taking something fixed rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 30/38 ! Should the game suggest taking a person ( this is the don't suggest taking a person rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 31/38 ! Should the game suggest closing a thing ( called x ) ( this is the standard suggest closing rule ):
!   === which is equally specific with ===
! Rule 32/38 ! Should the game suggest opening a thing ( called x ) ( this is the standard suggestion opening rule ):
!   === which is equally specific with ===
! Rule 33/38 ! Should the game suggest entering something ( called x ) ( this is the standard suggest entering rule ):
!   === which is equally specific with ===
! Rule 34/38 ! Should the game suggest getting off something ( called x ) ( this is the standard suggest getting off rule ):
!   === which is equally specific with ===
! Rule 35/38 ! Should the game suggest wearing something ( called x ) ( this is the standard suggest wearing rule ):
!   === which is equally specific with ===
! Rule 36/38 ! Should the game suggest eating something ( called x ) ( this is the standard suggest eating rule ):
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 37/38 ! Should the game suggest putting on when the second noun is not a supporter and testing second noun ( this is the don't suggest putting into a non-supporter rule ):
! --- now the last-placed rules ---
! Rule 38/38 ! The last Should the game suggest taking something portable ( this is the suggest to take portable things rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first should the game suggest rule when the noun is yourself and testing the noun ( this is the never suggest yourself rule ):
[ R_903 ;
   if (((((((noun == selfobj))) && (( (TestingNoun()) )))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_903, 903);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_903, 903, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first should the game suggest removing something from something when the noun is not inside the second noun and the noun is not on the second noun ( this is the don't expect to remove items from things they're not in rule ):
[ R_901 ;
   if ((action ==##Remove) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && ((((~~((second == ContainerOf(noun)))))) && (((~~((second == SupporterOf(noun)))))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_901, 901);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_901, 901, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first Should the game suggest putting something on something when the noun is the second noun ( this is the don't suggest putting something into itself rule ):
[ R_898 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((noun == second)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_898, 898);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_898, 898, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first Should the game suggest inserting something into something when the noun is the second noun ( this is the don't expecting inserting something into itself rule ):
[ R_897 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((noun == second)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_897, 897);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_897, 897, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first Should the game suggest putting something on something when the noun is on the second noun ( this is the don't suggest putting somewhere it already is rule ):
[ R_896 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((second == SupporterOf(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_896, 896);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_896, 896, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first Should the game suggest inserting something into something when the noun is inside the second noun ( this is the don't suggest inserting somewhere it already is rule ):
[ R_895 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((second == ContainerOf(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_895, 895);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_895, 895, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The first Should the game suggest dropping something carried by the player ( this is the drop what's you've got rule ):
[ R_888 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_888, 888);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_888, 888, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest giving something carried by the player to someone when testing noun ( this is the suggest giving held things rule ):
[ R_899 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun))) && ((second ofclass K8_person)) && (self=actor,true) && (( (TestingNoun()) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_899, 899);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_899, 899, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest showing something to someone when testing second noun ( this is the expect animate nouns for giving rule ):
[ R_868 ;
   if ((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)) && (self=actor,true) && (((PHR_867_r20 ())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_868, 868);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_868, 868, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest giving something to someone when testing second noun ( this is the expect animate nouns for showing rule ):
[ R_869 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K8_person)) && (self=actor,true) && (((PHR_867_r20 ())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_869, 869);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_869, 869, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest putting something on something when the second noun is a supporter and testing second noun ( this is the suggest putting on a supporter rule ):
[ R_892 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && ((((second ofclass K6_supporter))) && (((PHR_867_r20 ()))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_892, 892);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_892, 892, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest inserting something into something when the noun is carried and testing noun ( this is the expect to put held things into rule ):
[ R_893 ;
   if ((action ==##Insert) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((((Adj_1_t1_v9(noun))))) && (( (TestingNoun()) )))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_893, 893);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_893, 893, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest putting something on something when the noun is carried and testing noun ( this is the suggest to put held things on rule ):
[ R_894 ;
   if ((action ==##PutOn) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((((Adj_1_t1_v9(noun))))) && (( (TestingNoun()) )))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_894, 894);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_894, 894, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest showing something to something when testing second noun ( this is the reject inanimate nouns for giving rule ):
[ R_870 ;
   if ((action ==##Show) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((PHR_867_r20 ())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_870, 870);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_870, 870, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest giving something to something when testing second noun ( this is the reject inanimate nouns for showing rule ):
[ R_871 ;
   if ((action ==##Give) &&  (actor==player) && ((noun ofclass K2_thing)) && ((second ofclass K2_thing)) && (self=actor,true) && (((PHR_867_r20 ())))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_871, 871);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_871, 871, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest removing from something when the second noun is not a container and the second noun is not a supporter and testing second noun ( this is the don't expect to remove from items not including other items rule ):
[ R_900 ;
   if ((action ==##Remove) &&  (actor==player) && ((second ofclass K2_thing)) && (self=actor,true) && ((((~~((second ofclass K5_container))))) && ((((~~((second ofclass K6_supporter))))) && (((PHR_867_r20 ())))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_900, 900);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_900, 900, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest inserting into something when the second noun is not a container and testing second noun ( this is the don't suggest inserting into a non-container rule ):
[ R_889 ;
   if ((action ==##Insert) &&  (actor==player) && ((second ofclass K2_thing)) && (self=actor,true) && ((((~~((second ofclass K5_container))))) && (((PHR_867_r20 ()))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_889, 889);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_889, 889, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest inserting into something when the second noun is a container and testing second noun ( this is the suggest inserting into a container rule ):
[ R_891 ;
   if ((action ==##Insert) &&  (actor==player) && ((second ofclass K2_thing)) && (self=actor,true) && ((((second ofclass K5_container))) && (((PHR_867_r20 ()))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_891, 891);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_891, 891, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest removing from something when the noun is inside the second noun or the noun is on the second noun ( this is the expect to remove items from things they are in rule ):
[ R_902 ;
   if ((action ==##Remove) &&  (actor==player) && ((second ofclass K2_thing)) && (self=actor,true) && ((((second == ContainerOf(noun)))) || (((second == SupporterOf(noun)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_902, 902);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_902, 902, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest unlocking a thing ( called x ) with when testing noun ( this is the standard suggest unlocking rule ):
[ R_874 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Unlock) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing)))) && (self=actor,true) && (( (TestingNoun()) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_874, 874);
      ! phrase 1
      ! [1: if x is not lockable , it is a bad suggestion]
       if (((~~(((Adj_74_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 2
      ! [2: if x is unlocked , it is a passable suggestion]
       if ((((Adj_76_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 3
      ! [3: if x is locked , it is a good suggestion]
       if ((((Adj_75_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_21); rtrue;
  }
RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_874, 874, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest locking a thing ( called x ) with when testing noun ( this is the standard suggest locking rule ):
[ R_875 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Lock) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing)))) && (self=actor,true) && (( (TestingNoun()) ))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_875, 875);
      ! phrase 1
      ! [1: if x is not lockable , it is a bad suggestion]
       if (((~~(((Adj_74_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 2
      ! [2: if x is locked , it is a passable suggestion]
       if ((((Adj_75_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 3
      ! [3: if x is unlocked , it is a good suggestion]
       if ((((Adj_76_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_21); rtrue;
  }
RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_875, 875, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest doing something with no-object:
[ R_912 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I92_no_object) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_912, 912);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_912, 912, true);
   rfalse;
];
! No specific request
! Should the game suggest doing something to the drawer bottom:
[ R_1458 ;
   if ( (actor==player) &&  (noun) && (noun == inp1) && ((noun == I590_drawer_bottom) && (true))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_1458, 1458);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1458, 1458, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest taking the player ( this is the don't suggest taking yourself rule ):
[ R_880 ;
   if ((action ==##Take) &&  (actor==player) && ((noun == player) && (true))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_880, 880);
      ! phrase 1
      ! [1: never]
      RulebookSucceeds(19, RBNO_19); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_880, 880, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest taking something enclosed by a person ( this is the don't suggest taking something someone's got rule ):
[ R_881 ;
   if ((action ==##Take) &&  (actor==player) && (Prop_103(noun))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_881, 881);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_881, 881, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest dropping something not enclosed by the player ( this is the don't suggest dropping something you've not got rule ):
[ R_887 ;
   if ((action ==##Drop) &&  (actor==player) && ((noun ofclass K2_thing) && (~~((IndirectlyContains(player,noun)))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_887, 887);
      ! phrase 1
      ! [1: if the noun is portable , it is a passable suggestion]
       if ((((Adj_56_t1_v9(noun))))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 2
      ! [2: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_887, 887, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest taking something carried by the player ( this is the don't suggest to take what's carried rule ):
[ R_886 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == CarrierOf(noun)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_886, 886);
      ! phrase 1
      ! [1: it is a passable suggestion]
      RulebookSucceeds(19, RBNO_22); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_886, 886, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest taking something scenery ( this is the don't suggest taking the scenery rule ):
[ R_882 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_57_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_882, 882);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_882, 882, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest taking something fixed in place ( this is the don't suggest taking something fixed rule ):
[ R_883 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_55_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_883, 883);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_883, 883, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest taking a person ( this is the don't suggest taking a person rule ):
[ R_885 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K8_person))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_885, 885);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_885, 885, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest closing a thing ( called x ) ( this is the standard suggest closing rule ):
[ R_872 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Close) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_872, 872);
      ! phrase 1
      ! [1: if x is not openable , it is a bad suggestion]
       if (((~~(((Adj_72_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 2
      ! [2: if x is closed , it is a passable suggestion]
       if ((((Adj_71_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 3
      ! [3: if x is open , it is a good suggestion]
       if ((((Adj_70_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_21); rtrue;
  }
RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_872, 872, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest opening a thing ( called x ) ( this is the standard suggestion opening rule ):
[ R_873 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Open) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_873, 873);
      ! phrase 1
      ! [1: if x is not openable , it is a bad suggestion]
       if (((~~(((Adj_72_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 2
      ! [2: if x is open , it is a passable suggestion]
       if ((((Adj_70_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 3
      ! [3: if x is closed , it is a good suggestion]
       if ((((Adj_71_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_21); rtrue;
  }
RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_873, 873, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest entering something ( called x ) ( this is the standard suggest entering rule ):
[ R_876 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Enter) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_876, 876);
      ! phrase 1
      ! [1: if x is not enterable , it is a bad suggestion]
       if (((~~(((Adj_67_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 2
      ! [2: if the player is enclosing x , it is a bad suggestion]
       if (((IndirectlyContains(player,t_0)))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 3
      ! [3: if the player is in x or the player is on x , it is a passable suggestion]
       if ((((t_0 == ContainerOf(player)))) || (((t_0 == SupporterOf(player))))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 4
      ! [4: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_876, 876, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest getting off something ( called x ) ( this is the standard suggest getting off rule ):
[ R_877 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##GetOff) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_877, 877);
      ! phrase 1
      ! [1: if the noun is not enterable , it is a bad suggestion]
       if (((~~(((Adj_67_t1_v9(noun))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 2
      ! [2: if the player is in x or the player is on x , it is a good suggestion]
       if ((((t_0 == ContainerOf(player)))) || (((t_0 == SupporterOf(player))))) { RulebookSucceeds(19, RBNO_21); rtrue;
  }
      ! phrase 3
      ! [3: it is a passable suggestion]
      RulebookSucceeds(19, RBNO_22); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_877, 877, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest wearing something ( called x ) ( this is the standard suggest wearing rule ):
[ R_878 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Wear) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_878, 878);
      ! phrase 1
      ! [1: if x is scenery , never]
       if ((((Adj_57_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_19); rtrue;
  }
      ! phrase 2
      ! [2: if x is not wearable , it is a bad suggestion]
       if (((~~(((Adj_58_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 3
      ! [3: if the player is wearing x , it is a passable suggestion]
       if (((player == WearerOf(t_0)))) { RulebookSucceeds(19, RBNO_22); rtrue;
  }
      ! phrase 4
      ! [4: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_878, 878, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest eating something ( called x ) ( this is the standard suggest eating rule ):
[ R_879 
    t_0 ! Local variable e.g. 'x' = thing
    ;
   if ((action ==##Eat) &&  (actor==player) && (t_0 = noun, (((t_0=(noun), true) && (noun ofclass K2_thing))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_879, 879);
      ! phrase 1
      ! [1: if x is scenery , never]
       if ((((Adj_57_t1_v9(t_0))))) { RulebookSucceeds(19, RBNO_19); rtrue;
  }
      ! phrase 2
      ! [2: if x is not edible , it is a bad suggestion]
       if (((~~(((Adj_53_t1_v9(t_0))))))) { RulebookFails(19, RBNO_23); rtrue;
  }
      ! phrase 3
      ! [3: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_879, 879, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! Should the game suggest putting on when the second noun is not a supporter and testing second noun ( this is the don't suggest putting into a non-supporter rule ):
[ R_890 ;
   if ((action ==##PutOn) &&  (actor==player) && (self=actor,true) && ((((~~((second ofclass K6_supporter))))) && (((PHR_867_r20 ()))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_890, 890);
      ! phrase 1
      ! [1: it is a bad suggestion]
      RulebookFails(19, RBNO_23); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_890, 890, true);
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! The last Should the game suggest taking something portable ( this is the suggest to take portable things rule ):
[ R_884 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && ((Adj_56_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_884, 884);
      ! phrase 1
      ! [1: it is a good suggestion]
      RulebookSucceeds(19, RBNO_21); rtrue;

RulebookFails(19, RBNO_23); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_884, 884, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Commenting (B401_carry_out_commenting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out commenting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out commenting:
[ R_1034 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1034, 1034);
      ! phrase 1
      ! [1: say ~Noted.~]
      say__p=1;ParaContent();  print (PrintText) SC_980;  new_line; .L_Say665; .L_SayX636;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1034, 1034, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Greeting (B404_carry_out_greeting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out greeting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out greeting:
[ R_1043 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1043, 1043);
      ! phrase 1
      ! [1: try asking the noun about ~hello~]
       TryAction(32, player, ##Ask, noun, SC_981);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1043, 1043, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Facing (B416_carry_out_facing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out facing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out facing:
[ R_1064 
    t_0 ! Local variable e.g. 'viewed item' = object
    t_1 ! Local variable e.g. 'viewed door' = object
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1064, 1064);
      ! phrase 1
      ! [1: let the viewed item be the room noun from the location]
       t_0 = (Resolver_7(noun,real_location,"source", 189)); 
      ! phrase 2
      ! [2: if the viewed item is not a room , say ~You can't see anything promising that way.~ instead]
       if (((~~((t_0 ofclass K1_room))))) { say__p=1;ParaContent();  print (PrintText) SC_982;  new_line; .L_Say666; .L_SayX637;  rtrue; }
      ! phrase 3
      ! [3: let the viewed door be the door noun from the location]
       t_1 = (Resolver_10(noun,real_location,"source", 191)); 
      ! phrase 4
      ! [4: if the viewed door is a door begin]
       if (((t_1 ofclass K4_door)))  {
         ! phrase 5
         ! [5: say ~You see [the viewed door] to [the noun].~]
         say__p=1;ParaContent();  print (PrintText) SC_983; ParaContent();  print (the) t_1; ParaContent();  print (PrintText) SC_984; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say667; .L_SayX638;
         ! phrase 6
         ! [6: try examining the viewed door instead]
          TryAction(0, player, ##Examine, t_1, 0);;  rtrue;
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: try looking toward the viewed item]
       TryAction(0, player, ##A95_looking_toward, t_0, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1064, 1064, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking toward (B419_carry_out_looking_towar)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out looking toward:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out looking toward:
[ R_1066 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1066, 1066);
      ! phrase 1
      ! [1: say ~You see [the noun in lower case] to [the best route from the location to the noun].~]
      say__p=1;ParaContent();  print (PrintText) SC_983; ParaContent(); (Resolver_11(noun,"source", 204));ParaContent();  print (PrintText) SC_984; ParaContent();  print (the)  MapRouteTo(real_location,noun,0,0) ; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say668; .L_SayX639;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1066, 1066, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Following (B421_check_following)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check following:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check following:
[ R_1067 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1067, 1067);
      ! phrase 1
      ! [1: if the noun is the player , say ~But you're already here!~ instead]
       if (((noun == player))) { say__p=1;ParaContent();  print (PrintText) SC_985;  new_line; .L_Say669; .L_SayX640;  rtrue; }
      ! phrase 2
      ! [2: if the noun is visible , say ~[The noun] is right here.~ instead]
       if ((((Adj_3_t1_v9(noun))))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_986;  new_line; .L_Say670; .L_SayX641;  rtrue; }
      ! phrase 3
      ! [3: if the last location of the noun is not the location , say ~You don't know where [the noun] has gone.~ instead]
       if (((~~((GProperty(OBJECT_TY, noun,p13_last_location) == real_location))))) { say__p=1;ParaContent();  print (PrintText) SC_987; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_988;  new_line; .L_Say671; .L_SayX642;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1067, 1067, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Following (B422_carry_out_following)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out following:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out following:
[ R_1068 
    t_0 ! Local variable e.g. 'destination' = object
    t_1 ! Local variable e.g. 'aim' = object
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1068, 1068);
      ! phrase 1
      ! [1: let the destination be the location of the noun]
       t_0 =  LocationOf(noun) ; 
      ! phrase 2
      ! [2: if the destination is not a room , say ~[The noun] isn't anywhere you can follow.~ instead]
       if (((~~((t_0 ofclass K1_room))))) { say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_989;  new_line; .L_Say672; .L_SayX643;  rtrue; }
      ! phrase 3
      ! [3: let aim be the best route from the location to the destination]
       t_1 =  MapRouteTo(real_location,t_0,0,0) ; 
      ! phrase 4
      ! [4: say ~(heading [aim], following [the noun])[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_990; ParaContent();  print (PrintShortName) t_1; ParaContent();  print (PrintText) SC_991; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_413; ParaContent();  new_line;  .L_Say673; .L_SayX644;
      ! phrase 5
      ! [5: try going aim]
       TryAction(0, player, ##Go, t_1, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1068, 1068, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Vehicle-exiting (B425_carry_out_vehicle_exiti)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out vehicle-exiting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out vehicle-exiting:
[ R_1072 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1072, 1072);
      ! phrase 1
      ! [1: try exiting]
       TryAction(0, player, ##Exit, 0, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1072, 1072, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Supporter-exiting (B428_carry_out_supporter_exi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out supporter-exiting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out supporter-exiting:
[ R_1071 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1071, 1071);
      ! phrase 1
      ! [1: try exiting]
       TryAction(0, player, ##Exit, 0, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1071, 1071, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when First Pump begins (B430_when_first_pump_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When First Pump begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When First Pump begins:
[ R_1082 ;
      ! phrase 1
      ! [1: now the printed name of grassy area is ~Wet Area~]
       WriteGProperty(9, I509_grassy_area,short_name,SC_992); 
      ! phrase 2
      ! [2: now the pondy crystal spire is part of the pond]
       MakePart(I498_pondy_crystal_spire,I463_pond); 
      ! phrase 3
      ! [3: now the warning light is part of the waterworks door]
       MakePart(I459_warning_light,I516_door_to_the_waterworks); 
      ! phrase 4
      ! [4: now the wetness level is ~shaking and quaking~]
       (Global_Vars-->22) = SC_993; 
      ! phrase 5
      ! [5: record ~turning on the underground pump~ as achieved]
      (PHR_1164_r6 (SC_194));
      ! phrase 6
      ! [6: now the liquid of the metal pipe is pond water]
       WriteGProperty(9, I614_metal_pipe,p85_liquid,I437_pond_water); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Lever-action begins (B432_when_lever_action_begin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Lever-action begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Lever-action begins:
[ R_1085 ;
      ! phrase 1
      ! [1: say ~The complicated pump starts to hum[if Gizmo-action is not happening or Gadget-action is not happening], but still doesn't seem to be fully on[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_994; 
	if (~~(((((~~(((scene_status-->(I426_gizmo_action-1)==1)))))) || (((~~(((scene_status-->(I427_gadget_action-1)==1))))))))) jump L_Say674;
		ParaContent();  print (PrintText) SC_995; 
	.L_Say674; .L_SayX645;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say675; .L_SayX646;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Gizmo-action begins (B434_when_gizmo_action_begin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Gizmo-action begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Gizmo-action begins:
[ R_1086 ;
      ! phrase 1
      ! [1: say ~The complicated pump starts to shudder[if Lever-action is not happening or Gadget-action is not happening], but still doesn't seem to be fully on[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_996; 
	if (~~(((((~~(((scene_status-->(I425_lever_action-1)==1)))))) || (((~~(((scene_status-->(I427_gadget_action-1)==1))))))))) jump L_Say676;
		ParaContent();  print (PrintText) SC_995; 
	.L_Say676; .L_SayX647;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say677; .L_SayX648;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Gadget-action begins (B436_when_gadget_action_begi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Gadget-action begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Gadget-action begins:
[ R_1087 ;
      ! phrase 1
      ! [1: say ~The complicated pump starts to thump against the floor[if Lever-action is not happening or Gadget-action is not happening], but still doesn't seem to be fully on[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_997; 
	if (~~(((((~~(((scene_status-->(I425_lever_action-1)==1)))))) || (((~~(((scene_status-->(I427_gadget_action-1)==1))))))))) jump L_Say678;
		ParaContent();  print (PrintText) SC_995; 
	.L_Say678; .L_SayX649;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say679; .L_SayX650;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Hose-action begins (B438_when_hose_action_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Hose-action begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Hose-action begins:
[ R_1088 ;
      ! phrase 1
      ! [1: say ~The pump shakes and whirrs[if the hose is plugged] to life[otherwise]... for a moment you think you've gotten it working, but then you see that one of the hoses on the pump has a small hole in it, and water is pouring out of the hole instead of traversing the pump[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_998; 
	if (~~(((((Adj_118_t1_v9(I526_leaky_hose))))))) jump L_Say680;
		ParaContent();  print (PrintText) SC_999; 
	jump L_SayX651; .L_Say680;
		ParaContent();  print (PrintText) SC_1000; 
	.L_Say681; .L_SayX651;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say682; .L_SayX652;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Second Pump begins (B440_when_second_pump_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Second Pump begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Second Pump begins:
[ R_1089 ;
      ! phrase 1
      ! [1: record ~turning on the complicated pump~ as achieved]
      (PHR_1164_r6 (SC_198));
      ! phrase 2
      ! [2: now the complicated pump is switched on]
       (Adj_80_t2_v9(I416_complicated_pump)); 
      ! phrase 3
      ! [3: now the printed name of grassy area is ~Marsh~]
       WriteGProperty(9, I509_grassy_area,short_name,SC_1001); 
      ! phrase 4
      ! [4: say ~The pump whirrs to life, shaking as it starts up. It gurgles, and shudders, and stomps.~]
      say__p=1;ParaContent();  print (PrintText) SC_1002;  new_line; .L_Say683; .L_SayX653;
      ! phrase 5
      ! [5: now the wetness level is ~gushing along~]
       (Global_Vars-->22) = SC_1003; 
      ! phrase 6
      ! [6: now the stain is in inside waterworks]
       MoveObject(I646_stain,I506_inside_waterworks); 
      ! phrase 7
      ! [7: now the liquid of the small rusty pipe is pond water]
       WriteGProperty(9, I613_small_rusty_pipe,p85_liquid,I437_pond_water); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Third Pump begins (B442_when_third_pump_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Third Pump begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Third Pump begins:
[ R_1090 ;
      ! phrase 1
      ! [1: record ~turning on the big pump~ as achieved]
      (PHR_1164_r6 (SC_199));
      ! phrase 2
      ! [2: say ~The tank starts to shudder violently. Below you, you hear a loud grinding noise that seems to spread into the pond -- in fact, it looks like the pond [bold type]itself[roman type] is starting to shudder --[paragraph break]It is definitely moving, shaking and quivering, water spilling out onto the beaches.[if the rowboat is in Other Side of the Pond][paragraph break]Even your boat is carried away by the shuddering waves, floating and bobbing back to the boat house.[paragraph break][end if] The crystal spire rises several feet more out of the water, and something else, too. A weird, lumpy island, rising up from the pond to the north of the spire.~]
      say__p=1;ParaContent();  print (PrintText) SC_1004; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1005; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1006; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1007;  new_line;
	if (~~((((I494_other_side_of_the_pond == ContainerOf(I481_rowboat)))))) jump L_Say684;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1008; ParaContent();  DivideParagraphPoint(); new_line; 
	.L_Say684; .L_SayX654;
		ParaContent();  print (PrintText) SC_1009;  new_line; .L_Say685; .L_SayX655;
      ! phrase 3
      ! [3: change the north exit of floating on the pond to weedy island]
       AssertMapConnection(I466_floating_on_the_pond,I46_north,I504_weedy_island); 
      ! phrase 4
      ! [4: change the north exit of spireland to weedy island]
       AssertMapConnection(I465_spireland,I46_north,I504_weedy_island); 
      ! phrase 5
      ! [5: change the south exit of weedy island to floating on the pond]
       AssertMapConnection(I504_weedy_island,I49_south,I466_floating_on_the_pond); 
      ! phrase 6
      ! [6: now the printed name of rocky beach is ~Wet Beach~]
       WriteGProperty(9, I470_rocky_beach,short_name,SC_1010); 
      ! phrase 7
      ! [7: now sandy beach is flooded]
       (Adj_136_t2_v9(I474_sandy_beach)); 
      ! phrase 8
      ! [8: now the printed name of muddy beach is ~Wet Beach~]
       WriteGProperty(9, I468_muddy_beach,short_name,SC_1010); 
      ! phrase 9
      ! [9: if the rowboat is in other side of the pond , now the rowboat is moved]
       if (((I494_other_side_of_the_pond == ContainerOf(I481_rowboat)))) {  (Adj_104_t2_v9(I481_rowboat));   }
      ! phrase 10
      ! [10: if the waterstained door is open , move the rowboat to the boat house]
       if ((((Adj_70_t1_v9(I482_waterstained_door))))) {  MoveObject(I481_rowboat, I479_boat_house, 0, false);   }
      ! phrase 11
      ! [11: if the waterstained door is closed , move the rowboat to floating on the pond]
       if ((((Adj_71_t1_v9(I482_waterstained_door))))) {  MoveObject(I481_rowboat, I466_floating_on_the_pond, 0, false);   }
      ! phrase 12
      ! [12: now the sticks are off-stage]
       (Adj_9_t3_v9(I475_sticks)); 
      ! phrase 13
      ! [13: now the rock selection is off-stage]
       (Adj_9_t3_v9(I601_rock_selection)); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when conductor's story begins (B444_when_conductor_s_story_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When the conductor's story begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When the conductor's story begins:
[ R_1091 ;
      ! phrase 1
      ! [1: now other side of the pond is flooded]
       (Adj_136_t2_v9(I494_other_side_of_the_pond)); 
      ! phrase 2
      ! [2: now the station of the steam train is the steam train]
       WriteGProperty(9, I439_steam_train,p16_station,I439_steam_train); 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Fourth Pump begins (B446_when_fourth_pump_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When Fourth Pump begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When Fourth Pump begins:
[ R_1098 ;
      ! phrase 1
      ! [1: record ~turning on the underwater pump~ as achieved]
      (PHR_1164_r6 (SC_201));
      ! phrase 2
      ! [2: say ~The pump rumbles and vibrates to life, and suddenly the ground beneath you is violently rocked. You can feel the hydraulics beneath you start to turn, and push the island upward.[paragraph break]You see the muddy water of what's left of the pond gurgle, and spin outwards, forced out of the pond and over the shoreline -- or what used to be the shoreline --[paragraph break]The water level rises over the boathouse, over the Waterworks, over the forest, over the tank, and you see the large wooden boat rising, floating on the water, sails unfurling, everyone in it, [the secretary] and the conductor and the family and even the dog, floating away from their homes, going who knows where.[paragraph break]And meanwhile the city is rising, rising up above the water, crystal vehicles on translucent streets, Vivian holding your hand and her family standing near as you all break through and reach the surface, taking off your masks and breathing grateful gasps of fresh muddy air.~]
      say__p=1;ParaContent();  print (PrintText) SC_1011; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1012; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1013; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1014; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1015;  new_line; .L_Say686; .L_SayX656;
      ! phrase 3
      ! [3: end the story finally saying ~You have restored the Crystal City!~]
       deadflag=SC_1016; story_complete=true; 
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Liquid-drinking (B449_carry_out_liquid_drinki)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out liquid-drinking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out liquid-drinking:
[ R_1108 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1108, 1108);
      ! phrase 1
      ! [1: try drinking the second noun]
       TryAction(0, player, ##Drink, second, 0);; 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1108, 1108, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Filling it with (B452_carry_out_filling_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out filling it with:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out filling it with:
[ R_1115 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1115, 1115);
      ! phrase 1
      ! [1: try pouring the second noun into the noun instead]
       TryAction(0, player, ##A101_pouring_it_into, second, noun);;  rtrue;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1115, 1115, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pouring it into (B454_check_pouring_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check pouring it into:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check pouring it into:
[ R_1116 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1116, 1116);
      ! phrase 1
      ! [1: if the noun is not a fluid container and the noun is not a liquid source , say ~You can't pour [the noun].~ instead]
       if ((((~~((noun ofclass K25_fluid_container))))) && (((~~((noun ofclass K26_liquid_source)))))) { say__p=1;ParaContent();  print (PrintText) SC_1017; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say687; .L_SayX657;  rtrue; }
      ! phrase 2
      ! [2: if the second noun is not a fluid container , say ~Putting liquids on [the second noun] seems pretty pointless.~ instead]
       if (((~~((second ofclass K25_fluid_container))))) { say__p=1;ParaContent();  print (PrintText) SC_1018; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_1019;  new_line; .L_Say688; .L_SayX658;  rtrue; }
      ! phrase 3
      ! [3: if the noun is the second noun , say ~You can hardly pour [the noun] into itself.~ instead]
       if (((noun == second))) { say__p=1;ParaContent();  print (PrintText) SC_1020; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1021;  new_line; .L_Say689; .L_SayX659;  rtrue; }
      ! phrase 4
      ! [4: if the liquid of the noun is not the liquid of the second noun begin]
       if (((~~((GProperty(OBJECT_TY, noun,p85_liquid) == GProperty(OBJECT_TY, second,p85_liquid))))))  {
         ! phrase 5
         ! [5: if the second noun is empty , now the liquid of the second noun is the liquid of the noun]
          if ((((Adj_16_t1_v9(second))))) {  WriteGProperty(OBJECT_TY, second,p85_liquid,GProperty(OBJECT_TY, noun,p85_liquid));   }
         ! phrase 6
         ! [6: otherwise say ~Mixing [the liquid of the noun] with [the liquid of the second noun] would give unsavory results.~ instead]
          else { say__p=1;ParaContent();  print (PrintText) SC_1022; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_1023; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=second,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_1024;  new_line; .L_Say690; .L_SayX660;  rtrue; }
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the noun is empty , say ~No more [liquid of the noun] remains in [the noun].~ instead]
       if ((((Adj_16_t1_v9(noun))))) { say__p=1;ParaContent();  print (PrintText) SC_1025; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_1026; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say691; .L_SayX661;  rtrue; }
      ! phrase 9
      ! [9: if the second noun contains something , say ~You can't fill [the second noun] with [the liquid of the noun] while [the second noun] still contains [a list of things in the second noun].~]
       if ((Prop_104())) { say__p=1;ParaContent();  print (PrintText) SC_1027; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_1023; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_1028; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_1029; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (second == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say692; .L_SayX662;  }
      ! phrase 10
      ! [10: if the second noun is full , say ~[The second noun] cannot contain any more than it already holds.~ instead]
       if ((((Adj_19_t1_v9(second))))) { say__p=1;ParaContent();  print (The) second; ParaContent();  print (PrintText) SC_1030;  new_line; .L_Say693; .L_SayX663;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1116, 1116, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Pouring it into (B455_carry_out_pouring_it_in)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Carry out pouring a liquid source into something:
!   >>> I - Number of aspects constrained >>>
! Rule 2/2 ! Carry out pouring it into:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out pouring a liquid source into something:
[ R_1119 ;
   if ( (actor==player) && ((noun ofclass K26_liquid_source)) && ((second ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1119, 1119);
      ! phrase 1
      ! [1: now the current volume of the noun is 3276.7 fl oz]
       WriteGProperty(OBJECT_TY, noun,p15_current_volume,32767); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1119, 1119, true);
   rfalse;
];
! No specific request
! Carry out pouring it into:
[ R_1117 
    t_0 ! Local variable e.g. 'available capacity' = volume
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1117, 1117);
      ! phrase 1
      ! [1: let available capacity be the fluid capacity of the second noun minus the current volume of the second noun]
       t_0 =  (GProperty(OBJECT_TY, second,p14_fluid_capacity)-GProperty(OBJECT_TY, second,p15_current_volume)) ; 
      ! phrase 2
      ! [2: if the available capacity is greater than the current volume of the noun , now the available capacity is the current volume of the noun]
       if (((t_0 > GProperty(OBJECT_TY, noun,p15_current_volume)))) {  t_0 = GProperty(OBJECT_TY, noun,p15_current_volume);   }
      ! phrase 3
      ! [3: increase the current volume of the second noun by available capacity]
       WriteGProperty(OBJECT_TY, second,p15_current_volume,GProperty(OBJECT_TY, second,p15_current_volume) + t_0); 
      ! phrase 4
      ! [4: decrease the current volume of the noun by available capacity]
       WriteGProperty(OBJECT_TY, noun,p15_current_volume,GProperty(OBJECT_TY, noun,p15_current_volume) - t_0); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1117, 1117, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pouring it into (B456_report_pouring_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report pouring it into:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report pouring it into:
[ R_1118 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1118, 1118);
      ! phrase 1
      ! [1: say ~[if the noun is empty][The noun] is now empty;[otherwise][The noun] now contains [current volume of the noun in rough terms] of [liquid of the noun]; [end if]~]
      say__p=1;
	if (~~(((((Adj_16_t1_v9(noun))))))) jump L_Say694;
		ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_1031; 
	jump L_SayX664; .L_Say694;
		ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_1032; ParaContent(); @push self; (PHR_1100_r14 (GProperty(OBJECT_TY, self=noun,p15_current_volume)));@pull self; ParaContent();  print (PrintText) SC_902; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_682; 
	.L_Say695; .L_SayX664;
		 .L_Say696; .L_SayX665;
      ! phrase 2
      ! [2: say ~[the second noun] contains [current volume of the second noun in rough terms] of [liquid of the second noun][if the second noun is full], and is now full[end if].~]
      say__p=1;ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_901; ParaContent(); @push self; (PHR_1100_r14 (GProperty(OBJECT_TY, self=second,p15_current_volume)));@pull self; ParaContent();  print (PrintText) SC_902; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=second,p85_liquid); @pull self; 
	if (~~(((((Adj_19_t1_v9(second))))))) jump L_Say697;
		ParaContent();  print (PrintText) SC_1033; 
	.L_Say697; .L_SayX666;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say698; .L_SayX667;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1118, 1118, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Spilling (B460_check_spilling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check spilling something:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check spilling something:
[ R_1129 ;
   if ( (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1129, 1129);
      ! phrase 1
      ! [1: if the noun is not a fluid container , say ~You can't spill that!~ instead]
       if (((~~((noun ofclass K25_fluid_container))))) { say__p=1;ParaContent();  print (PrintText) SC_1034;  new_line; .L_Say699; .L_SayX668;  rtrue; }
      ! phrase 2
      ! [2: if the noun is empty , say ~It's empty.~ instead]
       if ((((Adj_16_t1_v9(noun))))) { say__p=1;ParaContent();  print (PrintText) SC_1035;  new_line; .L_Say700; .L_SayX669;  rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1129, 1129, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Spilling (B461_carry_out_spilling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out spilling something:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out spilling something:
[ R_1130 ;
   if ( (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1130, 1130);
      ! phrase 1
      ! [1: now the current volume of the noun is 0.0 fl oz]
       WriteGProperty(OBJECT_TY, noun,p15_current_volume,0); 
      ! phrase 2
      ! [2: say ~You pour the [liquid of the noun] out on the [if the location is outdoors]ground[otherwise]floor[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_1036; ParaContent(); @push self;  print (T70) GProperty(OBJECT_TY, self=noun,p85_liquid); @pull self; ParaContent();  print (PrintText) SC_1037; 
	if (~~(((((Adj_99_t1_v9(real_location))))))) jump L_Say701;
		ParaContent();  print (PrintText) SC_1038; 
	jump L_SayX670; .L_Say701;
		ParaContent();  print (PrintText) SC_1039; 
	.L_Say702; .L_SayX670;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say703; .L_SayX671;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1130, 1130, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Boarding (B464_carry_out_boarding)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out boarding:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out boarding:
[ R_1145 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1145, 1145);
      ! phrase 1
      ! [1: if the player is in the station of the steam train , move the player to the steam train]
       if (((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))) {  MoveObject(player, I439_steam_train, 0, false);   }
      ! phrase 2
      ! [2: otherwise say ~You don't see a train here.~]
       else { say__p=1;ParaContent();  print (PrintText) SC_423;  new_line; .L_Say704; .L_SayX672;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1145, 1145, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Train-waiting (B466_check_train_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check train-waiting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check train-waiting:
[ R_1155 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1155, 1155);
      ! phrase 1
      ! [1: if the player is in the steam train , say ~You're in it!~ instead]
       if (((I439_steam_train == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_237;  new_line; .L_Say705; .L_SayX673;  rtrue; }
      ! phrase 2
      ! [2: if other side of the pond is flooded , say ~The train is no longer running.~ instead]
       if ((((Adj_136_t1_v9(I494_other_side_of_the_pond))))) { say__p=1;ParaContent();  print (PrintText) SC_1040;  new_line; .L_Say706; .L_SayX674;  rtrue; }
      ! phrase 3
      ! [3: if the player is not in freshwater crossing and the player is not in other side of the pond , say ~You're not likely to have much luck waiting for a train here.~ instead]
       if ((((~~((I507_freshwater_crossing == ContainerOf(player)))))) && (((~~((I494_other_side_of_the_pond == ContainerOf(player))))))) { say__p=1;ParaContent();  print (PrintText) SC_1041;  new_line; .L_Say707; .L_SayX675;  rtrue; }
      ! phrase 4
      ! [4: if the player is in the station of the steam train , say ~The train is already here.~ instead]
       if (((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_1042;  new_line; .L_Say708; .L_SayX676;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1155, 1155, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Train-waiting (B467_carry_out_train_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out train-waiting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out train-waiting:
[ R_1156 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1156, 1156);
      ! phrase 1
      ! [1: say ~You stand around, keeping an eye out for the train.~]
      say__p=1;ParaContent();  print (PrintText) SC_1043;  new_line; .L_Say709; .L_SayX677;
      ! phrase 2
      ! [2: while the station of the steam train is not the location of the player begin]
       while (((~~((GProperty(9, I439_steam_train,p16_station) ==  LocationOf(player) )))))  {
         ! phrase 3
         ! [3: follow the turn sequence rules]
          FollowRulebook(2); 
         ! phrase 4
         ! [4: end while]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1156, 1156, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waiting more (B469_check_waiting_more)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check waiting more:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check waiting more:
[ R_1159 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1159, 1159);
      ! phrase 1
      ! [1: if the time understood is greater than one hour , say ~You really haven't got that kind of patience.~ instead]
       if (((parsed_number > 60))) { say__p=1;ParaContent();  print (PrintText) SC_1044;  new_line; .L_Say710; .L_SayX678;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1159, 1159, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Waiting more (B470_carry_out_waiting_more)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out waiting more:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out waiting more:
[ R_1157 
    t_0 ! Local variable e.g. 'target time' = time
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1157, 1157);
      ! phrase 1
      ! [1: let the target time be the time of day plus the time understood]
       t_0 =  (the_time+parsed_number) ; 
      ! phrase 2
      ! [2: decrease the target time by one minute]
       t_0 = t_0 - 1; 
      ! phrase 3
      ! [3: while the time of day is not the target time begin]
       while (((~~((the_time == t_0)))))  {
         ! phrase 4
         ! [4: follow the turn sequence rules]
          FollowRulebook(2); 
         ! phrase 5
         ! [5: end while]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1157, 1157, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting more (B471_report_waiting_more)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report waiting more:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report waiting more:
[ R_1158 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1158, 1158);
      ! phrase 1
      ! [1: say ~It is now [the minutes part of the time of day + 1 minute] after the hour, according to your waterproof watch.~]
      say__p=1;ParaContent();  print (PrintText) SC_1045; ParaContent();  print (say__n= ( (the_time+1) %ONE_HOUR) ); ParaContent();  print (PrintText) SC_1046;  new_line; .L_Say711; .L_SayX679;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1158, 1158, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Asking for help (B473_carry_out_asking_for_he)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out asking for help ( this is the help request rule ):
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out asking for help ( this is the help request rule ):
[ R_1161 ;blockv_stack-->(blockv_sp+3) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 4;
    blockv_stack-->(blockv_sp++) = R_SHELL_0(blockv_sp-4);
    blockv_sp = blockv_sp - 5;
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+4);
];
[ R_SHELL_0 I7BASPL ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1161, 1161);
      ! phrase 1
      ! [1: say ~[bold type]Wetlands[roman type] is an interactive quagmire, interactive fiction, or text adventure game.	[paragraph break]If you're new to the genre: Emily Short has written a great introduction to playing IF, available at http://inform-fiction.org/I7Downloads/Examples/dm/IntroductionToIF.pdf.	[paragraph break]More specifically: try simple commands like GO NORTH, EXAMINE [the printed name of a random thing that can be seen by the player in upper case], ASK [if at least one person who is not the player is visible][the printed name of a random visible person in upper case][otherwise]SOMEONE[end if] ABOUT SOMETHING, INVENTORY, SLEEP, WAIT X MINUTES, PUSH SOMETHING, CLIMB SOMETHING, TURN SOMETHING ON, JUMP, SCORE, UNDO and more...	[paragraph break]There are not actually any time limits in this game. Nothing important will pass you by irrevocably, and it shouldn't be possible to get yourself [italic type]really[roman type] stuck (unless you do something obviously dumb like throw out stuff you've found). There are fatal mistakes, but it should be clear when you're about to make them and you can always UNDO if necessary. Or SAVE your game to a file to return to your current situation later.	[paragraph break]Places you've been, things you've seen, and people  you've talked to may change somewhat as your actions in-game affect them and their situations, so you should occasionally wander back to places you've already been, and places that might have seemed like dead ends may open up as you change the state of the world.	[paragraph break]If you're stuck, try opening things, examining things, going in all the directions you can, thinking of unique ways objects can be used, revisiting old locations to see if your actions have changed them... and if all else fails, email the author for hints at clara.raubertas@@64gmail.com. [paragraph break]Type CREDITS for game credits.~]
      say__p=1;ParaContent();  style bold; ParaContent();  print (PrintText) SC_1047; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1048; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1049; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1050; ParaContent();  print (INDEXED_TEXT_TY_Say)  IT_CharactersToCase((blockv_stack-->(I7BASPL+0)), BlkValueCast((blockv_stack-->(I7BASPL+1)),INDEXED_TEXT_TY,TEXT_TY,GProperty(9,  (Prop_105()) ,short_name)), 1) ; ParaContent();  print (PrintText) SC_1051; 
	if (~~(((Prop_106())))) jump L_Say712;
		ParaContent();  print (INDEXED_TEXT_TY_Say)  IT_CharactersToCase((blockv_stack-->(I7BASPL+2)), BlkValueCast((blockv_stack-->(I7BASPL+3)),INDEXED_TEXT_TY,TEXT_TY,GProperty(9,  (Prop_107()) ,short_name)), 1) ; 
	jump L_SayX680; .L_Say712;
		ParaContent();  print (PrintText) SC_1052; 
	.L_Say713; .L_SayX680;
		ParaContent();  print (PrintText) SC_1053; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1054; ParaContent();  style underline; ParaContent();  print (PrintText) SC_1055; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1056; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1057; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1058; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1059;  new_line; .L_Say714; .L_SayX681;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1161, 1161, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Crediting (B476_carry_out_crediting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out crediting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out crediting:
[ R_1162 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1162, 1162);
      ! phrase 1
      ! [1: say ~[bold type]Wetlands[roman type] is written and programmed by Clara Raubertas, copyright 2011. Clara is a programmer and musician living in New England; she welcomes comments or bug reports on Wetlands at clara.raubertas@@64gmail.com.	[paragraph break]Wetlands is written in Inform 7; thanks to the creators of this great tool and of the several extensions used in this game.	[line break]Constant alpha-testing and valuable advice provided by Jesse Raber. Beta-testing by Michael Fransioli, Chris Conley, Tucker Bennett, Eric Purdy, Katherine McFall, Alex Amann, Ashley Meyer, Ruth Raubertas and Dan Pratt.~]
      say__p=1;ParaContent();  style bold; ParaContent();  print (PrintText) SC_1047; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1060; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1061; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1062;  new_line; .L_Say715; .L_SayX682;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1162, 1162, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Hinting (B479_carry_out_hinting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out hinting:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out hinting:
[ R_1163 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1163, 1163);
      ! phrase 1
      ! [1: say ~Sorry, this release of this game has no hints.~]
      say__p=1;ParaContent();  print (PrintText) SC_1063;  new_line; .L_Say716; .L_SayX683;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1163, 1163, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Requesting the full score (B482_carry_out_requesting_th)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out requesting the full score:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out requesting the full score:
[ R_1167 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1167, 1167);
      ! phrase 1
      ! [1: say ~Things seem to be [the scoring wetness level] right now![paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) SC_1064; ParaContent(); (PHR_1166_r21 ());ParaContent();  print (PrintText) SC_1065; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say717; .L_SayX684;
      ! phrase 2
      ! [2: if the score is 0 , say ~Nothing very interesting has happened yet -- your score is 0 out of [maximum score].~ instead]
       if (((score == 0))) { say__p=1;ParaContent();  print (PrintText) SC_1066; ParaContent();  print (say__n=MAX_SCORE); ParaContent();  print (PrintText) SC_250;  new_line; .L_Say718; .L_SayX685;  rtrue; }
      ! phrase 3
      ! [3: say ~You have completed:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_1067; ParaContent();  new_line;  .L_Say719; .L_SayX686;
      ! phrase 4
      ! [4: repeat through the table of tasks achieved in reverse time order begin]
       @push ct_0; @push ct_1;
		for (t_0=T11_tasks_achieved,t_1=TableNextRow(t_0,110,0,-1),ct_0=t_0,ct_1=t_1:
			t_1~=0:
			t_1=TableNextRow(t_0,110,t_1,-1),ct_0=t_0,ct_1=t_1)  {
           if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
         ! phrase 5
         ! [5: say ~[citation entry] ([points entry] points)[line break]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,119,ct_1); ParaContent();  print (PrintText) SC_1068; ParaContent();  print (say__n=TableLookUpEntry(ct_0,118,ct_1)); ParaContent();  print (PrintText) SC_1069; ParaContent();  new_line;  .L_Say720; .L_SayX687;
         ! phrase 6
         ! [6: end repeat]
         }
@pull ct_1; @pull ct_0;
        if (debug_rules>1) print "  [6: end repeat]^";
      ! phrase 7
      ! [7: say ~[line break]total score: [score] points (out of [maximum score] possible)[paragraph break]~]
      say__p=1;ParaContent();  new_line; ParaContent();  print (PrintText) SC_1070; ParaContent();  print (say__n=score); ParaContent();  print (PrintText) SC_1071; ParaContent();  print (say__n=MAX_SCORE); ParaContent();  print (PrintText) SC_1072; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say721; .L_SayX688;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1167, 1167, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Xyzzy (B485_carry_out_xyzzy)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out xyzzy:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out xyzzy:
[ R_1178 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1178, 1178);
      ! phrase 1
      ! [1: if the pond is visible begin]
       if ((((Adj_3_t1_v9(I463_pond)))))  {
         ! phrase 2
         ! [2: say ~[one of]You hear a splash, and turn to the pond -- you catch just a glimpse of a heron's wings as it dives underwater[or]A noise in the pond catches your attention -- you turn and just see a shining flying fish leap out and back in[at random].~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->44 =
	i7_soo_ran(I7_ST_say_one_of-->44, 2);
	switch((I7_ST_say_one_of-->44)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1073; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1074; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say722; .L_SayX689;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the player is in a room that is outdoors , say ~[one of]A black squirrel skitters by you[or]A chipmunk chatters at you and then zips away[at random].~]
          if (((ContainerOf(player) ofclass K1_room) && ((Adj_99_t1_v9(ContainerOf(player)))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->45 =
	i7_soo_ran(I7_ST_say_one_of-->45, 2);
	switch((I7_ST_say_one_of-->45)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1075; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1076; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say723; .L_SayX690;  }
         ! phrase 5
         ! [5: otherwise say ~You feel a faint chill, like the echo of a hollow voice.~]
          else { say__p=1;ParaContent();  print (PrintText) SC_1077;  new_line; .L_Say724; .L_SayX691;  }
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1178, 1178, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Knocking on (B489_report_knocking_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report knocking on something soft:
!   >>> III.3.2 - Action/What/Thing Acted On >>>
! Rule 2/2 ! Report knocking on something:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Report knocking on something soft:
[ R_1218 ;
   if ( (actor==player) && ((noun ofclass K2_thing) && ((Adj_108_t1_v9(noun))))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1218, 1218);
      ! phrase 1
      ! [1: say ~Your knuckles make no sound against [the noun].~ instead]
      say__p=1;ParaContent();  print (PrintText) SC_1078; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  new_line; rtrue; .L_Say725; .L_SayX692; rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1218, 1218, true);
   rfalse;
];
! No specific request
! Report knocking on something:
[ R_1219 ;
   if ( (actor==player) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_1219, 1219);
      ! phrase 1
      ! [1: say ~You rap your knuckles against [the noun], to no effect.~]
      say__p=1;ParaContent();  print (PrintText) SC_1079; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1080;  new_line; .L_Say726; .L_SayX693;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_1219, 1219, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rowing (B493_check_rowing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check rowing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check rowing:
[ R_1274 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1274, 1274);
      ! phrase 1
      ! [1: if the player is not in the rowboat , say ~You're not in anything rowable.~ instead]
       if (((~~((I481_rowboat == ContainerOf(player)))))) { say__p=1;ParaContent();  print (PrintText) SC_1081;  new_line; .L_Say727; .L_SayX694;  rtrue; }
      ! phrase 2
      ! [2: if the player does not carry the second noun , say ~You don't have that!~ instead]
       if (((~~((player == CarrierOf(second)))))) { say__p=1;ParaContent();  print (PrintText) SC_1082;  new_line; .L_Say728; .L_SayX695;  rtrue; }
      ! phrase 3
      ! [3: if the second noun is not the wide stick , say ~That's not suitable to paddle with.~ instead]
       if (((~~((second == I476_wide_stick))))) { say__p=1;ParaContent();  print (PrintText) SC_1083;  new_line; .L_Say729; .L_SayX696;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1274, 1274, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Rowing (B494_carry_out_rowing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out rowing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out rowing:
[ R_1275 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1275, 1275);
      ! phrase 1
      ! [1: now the player is boaty]
       (Adj_110_t2_v9(player)); 
      ! phrase 2
      ! [2: if the noun is outside and the location is boat house , try going west]
       if ((((noun == out_obj))) && (((real_location == I479_boat_house)))) {  TryAction(0, player, ##Go, I53_west, 0);;   }
      ! phrase 3
      ! [3: otherwise try going the noun]
       else {  TryAction(0, player, ##Go, noun, 0);;   }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1275, 1275, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dancing (B497_carry_out_dancing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out dancing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out dancing:
[ R_1303 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1303, 1303);
      ! phrase 1
      ! [1: say ~You twirl around.~]
      say__p=1;ParaContent();  print (PrintText) SC_1084;  new_line; .L_Say730; .L_SayX697;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1303, 1303, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Plugging it with (B505_check_plugging_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check plugging it with:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check plugging it with:
[ R_1336 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1336, 1336);
      ! phrase 1
      ! [1: if the noun is the leaky hose and the leaky hose is plugged begin]
       if ((((noun == I526_leaky_hose))) && ((((Adj_118_t1_v9(I526_leaky_hose))))))  {
         ! phrase 2
         ! [2: say ~The hose is already plugged.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_1085;  new_line; rtrue; .L_Say731; .L_SayX698; rtrue;
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: if the noun is not the leaky hose begin]
       if (((~~((noun == I526_leaky_hose)))))  {
         ! phrase 5
         ! [5: say ~That seems pointless.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_1086;  new_line; rtrue; .L_Say732; .L_SayX699; rtrue;
         ! phrase 6
         ! [6: end if]
         }

      ! phrase 7
      ! [7: if the second noun is not the clump of sap begin]
       if (((~~((second == I576_clump_of_sap)))))  {
         ! phrase 8
         ! [8: say ~You can't seem to plug [the noun] with that.~ instead]
         say__p=1;ParaContent();  print (PrintText) SC_1087; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1088;  new_line; rtrue; .L_Say733; .L_SayX700; rtrue;
         ! phrase 9
         ! [9: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1336, 1336, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Plugging it with (B506_carry_out_plugging_it_w)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out plugging it with:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out plugging it with:
[ R_1338 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1338, 1338);
      ! phrase 1
      ! [1: if the clump of sap is in the beer bottle , move the clump of sap to the location]
       if (((I472_beer_bottle == ContainerOf(I576_clump_of_sap)))) {  MoveObject(I576_clump_of_sap, real_location, 0, false);   }
      ! phrase 2
      ! [2: now the clump of sap is part of the leaky hose]
       MakePart(I576_clump_of_sap,I526_leaky_hose); 
      ! phrase 3
      ! [3: now the leaky hose is plugged]
       (Adj_118_t2_v9(I526_leaky_hose)); 
      ! phrase 4
      ! [4: say ~You push the clump of sap up against the hole in the leaky hose. The flow of water strains against the makeshift seal -- and the seal holds.~]
      say__p=1;ParaContent();  print (PrintText) SC_1089;  new_line; .L_Say734; .L_SayX701;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1338, 1338, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Lever-examining (B511_check_lever_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check lever-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check lever-examining:
[ R_1359 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1359, 1359);
      ! phrase 1
      ! [1: if no levers are visible , say ~You don't see any levers.~ instead]
       if ((Prop_108())) { say__p=1;ParaContent();  print (PrintText) SC_1090;  new_line; .L_Say735; .L_SayX702;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1359, 1359, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Lever-examining (B512_carry_out_lever_examini)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out lever-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out lever-examining:
[ R_1362 
    t_0 ! Local variable e.g. '?-1,-1?' = lever
    t_1 ! Local variable e.g. '?-1,-1?' = lever
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1362, 1362);
      ! phrase 1
      ! [1: say ~Visible on the pump are:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_1091; ParaContent();  new_line;  .L_Say736; .L_SayX703;
      ! phrase 2
      ! [2: repeat with item running through visible levers begin]
       for (t_0=Prop_109(0), t_1=Prop_109(t_0): t_0: t_0=t_1, t_1=Prop_109(t_1))  {
           if (debug_rules>1) print "  [repetition with item set to ", (PrintShortName) t_0, "]^";
         ! phrase 3
         ! [3: say ~    [A item][line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_1092; ParaContent();  CIndefArt(t_0); ParaContent();  new_line;  .L_Say737; .L_SayX704;
         ! phrase 4
         ! [4: end repeat]
         }

        if (debug_rules>1) print "  [4: end repeat]^";
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1362, 1362, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switch-examining (B514_check_switch_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check switch-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check switch-examining:
[ R_1361 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1361, 1361);
      ! phrase 1
      ! [1: if no switches are visible , say ~You don't see any switches.~ instead]
       if ((Prop_110())) { say__p=1;ParaContent();  print (PrintText) SC_1093;  new_line; .L_Say738; .L_SayX705;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1361, 1361, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switch-examining (B515_carry_out_switch_examin)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out switch-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out switch-examining:
[ R_1363 
    t_0 ! Local variable e.g. '?-1,-1?' = switch
    t_1 ! Local variable e.g. '?-1,-1?' = switch
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1363, 1363);
      ! phrase 1
      ! [1: say ~Visible on the pump are:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_1091; ParaContent();  new_line;  .L_Say739; .L_SayX706;
      ! phrase 2
      ! [2: repeat with item running through visible switches begin]
       for (t_0=Prop_111(0), t_1=Prop_111(t_0): t_0: t_0=t_1, t_1=Prop_111(t_1))  {
           if (debug_rules>1) print "  [repetition with item set to ", (PrintShortName) t_0, "]^";
         ! phrase 3
         ! [3: say ~    [A item][line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_1092; ParaContent();  CIndefArt(t_0); ParaContent();  new_line;  .L_Say740; .L_SayX707;
         ! phrase 4
         ! [4: end repeat]
         }

        if (debug_rules>1) print "  [4: end repeat]^";
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1363, 1363, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Gizmo-examining (B517_check_gizmo_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check gizmo-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check gizmo-examining:
[ R_1360 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1360, 1360);
      ! phrase 1
      ! [1: if no gizmoes are visible , say ~You don't see any gizmoes.~ instead]
       if ((Prop_112())) { say__p=1;ParaContent();  print (PrintText) SC_1094;  new_line; .L_Say741; .L_SayX708;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1360, 1360, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Gizmo-examining (B518_carry_out_gizmo_examini)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out gizmo-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out gizmo-examining:
[ R_1364 
    t_0 ! Local variable e.g. '?-1,-1?' = gizmo
    t_1 ! Local variable e.g. '?-1,-1?' = gizmo
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1364, 1364);
      ! phrase 1
      ! [1: say ~Visible on the pump are:[line break]~]
      say__p=1;ParaContent();  print (PrintText) SC_1091; ParaContent();  new_line;  .L_Say742; .L_SayX709;
      ! phrase 2
      ! [2: repeat with item running through visible gizmoes begin]
       for (t_0=Prop_113(0), t_1=Prop_113(t_0): t_0: t_0=t_1, t_1=Prop_113(t_1))  {
           if (debug_rules>1) print "  [repetition with item set to ", (PrintShortName) t_0, "]^";
         ! phrase 3
         ! [3: say ~    [Description of item][line break]~]
         say__p=1;ParaContent();  print (PrintText) SC_1092; ParaContent(); @push self;  print (PrintText) GProperty(9, self=t_0,description); @pull self; ParaContent();  new_line;  .L_Say743; .L_SayX710;
         ! phrase 4
         ! [4: end repeat]
         }

        if (debug_rules>1) print "  [4: end repeat]^";
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1364, 1364, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Flipping (B520_check_flipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check flipping:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check flipping:
[ R_1369 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1369, 1369);
      ! phrase 1
      ! [1: if the noun is not a lever and the noun is not a switch , try turning the noun instead]
       if ((((~~((noun ofclass K27_lever))))) && (((~~((noun ofclass K29_switch)))))) {  TryAction(0, player, ##Turn, noun, 0);;   rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1369, 1369, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Flipping (B521_carry_out_flipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out flipping:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out flipping:
[ R_1370 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1370, 1370);
      ! phrase 1
      ! [1: say ~You flip [the noun] [if the noun is flipped up]down[otherwise]up[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_1095; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_387; 
	if (~~(((((Adj_124_t1_v9(noun))))))) jump L_Say744;
		ParaContent();  print (PrintText) SC_918; 
	jump L_SayX711; .L_Say744;
		ParaContent();  print (PrintText) SC_917; 
	.L_Say745; .L_SayX711;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say746; .L_SayX712;
      ! phrase 2
      ! [2: if the noun is flipped up begin]
       if ((((Adj_124_t1_v9(noun)))))  {
         ! phrase 3
         ! [3: now the noun is flipped down]
          (Adj_125_t2_v9(noun)); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: now the noun is flipped up]
          (Adj_124_t2_v9(noun)); 
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1370, 1370, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Prying it with (B529_check_prying_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check prying it with:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check prying it with:
[ R_1478 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1478, 1478);
      ! phrase 1
      ! [1: if the noun is not the secret panel , say ~That doesn't seem necessary~ instead]
       if (((~~((noun == I591_secret_panel))))) { say__p=1;ParaContent();  print (PrintText) SC_1096;  .L_Say747; .L_SayX713;  rtrue; }
      ! phrase 2
      ! [2: if the second noun is not the screwdriver , say ~You can't get enough leverage using that.~ instead]
       if (((~~((second == I636_screwdriver))))) { say__p=1;ParaContent();  print (PrintText) SC_1097;  new_line; .L_Say748; .L_SayX714;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1478, 1478, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Prying it with (B530_carry_out_prying_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out prying it with:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out prying it with:
[ R_1476 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1476, 1476);
      ! phrase 1
      ! [1: say ~With the help of the screwdriver, you are able to slide open what turns out to be a secret panel in the drawer, and reveal the small hiding space below it -- which contains [a list of things contained by the secret panel].~]
      say__p=1;ParaContent();  print (PrintText) SC_1098; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I591_secret_panel == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  new_line; .L_Say749; .L_SayX715;
      ! phrase 2
      ! [2: record ~opening a secret panel~ as achieved]
      (PHR_1164_r6 (SC_202));
      ! phrase 3
      ! [3: now the printed name of the secret panel is ~secret panel~]
       WriteGProperty(9, I591_secret_panel,short_name,SC_1099); 
      ! phrase 4
      ! [4: now the secret panel is open]
       (Adj_70_t2_v9(I591_secret_panel)); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1476, 1476, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Skipping (B532_check_skipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check skipping:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check skipping:
[ R_1492 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1492, 1492);
      ! phrase 1
      ! [1: if the noun is not a small rock , say ~You can't skip that!~ instead]
       if (((~~((noun ofclass K24_small_rock))))) { say__p=1;ParaContent();  print (PrintText) SC_1100;  new_line; .L_Say750; .L_SayX716;  rtrue; }
      ! phrase 2
      ! [2: if the pond is not visible , say ~You can't skip the rock without water to skip it on.~ instead]
       if (((~~(((Adj_3_t1_v9(I463_pond))))))) { say__p=1;ParaContent();  print (PrintText) SC_1101;  new_line; .L_Say751; .L_SayX717;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1492, 1492, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Skipping (B533_carry_out_skipping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out skipping:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out skipping:
[ R_1495 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1495, 1495);
      ! phrase 1
      ! [1: say ~You skip the small, disclike rock across the smooth service of the water -- [a random number between 2 and 15] hops.~]
      say__p=1;ParaContent();  print (PrintText) SC_1102; ParaContent();  print (say__n= R_DecimalNumber(2, 15) ); ParaContent();  print (PrintText) SC_1103;  new_line; .L_Say752; .L_SayX718;
      ! phrase 2
      ! [2: now the noun is in rock limbo]
       MoveObject(noun,I595_rock_limbo); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1495, 1495, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when secretary's story begins (B535_when_secretary_s_story_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When the secretary's story begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When the secretary's story begins:
[ R_1523 ;
      ! phrase 1
      ! [1: say ~[The secretary] turns and looks at you. 'Oh!' she says, and her brown eyes widen. You think she's shaking a little bit. 'You're the one looking for the city.'[paragraph break]~]
      say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1104; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say753; .L_SayX719;
      ! phrase 2
      ! [2: say ~You squelch knee-deep in the marsh, which is getting wetter every moment.~]
      say__p=1;ParaContent();  print (PrintText) SC_1105;  new_line; .L_Say754; .L_SayX720;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Barking (B538_carry_out_barking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out barking:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out barking:
[ R_1551 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1551, 1551);
      ! phrase 1
      ! [1: if the dog is not visible , say ~You bark your best imitation of a dog. [if a person who is not the player is visible][The random visible person who is not the player] looks at you like you are crazy[otherwise]Nothing seems to happen[end if].~]
       if (((~~(((Adj_3_t1_v9(I443_dog))))))) { say__p=1;ParaContent();  print (PrintText) SC_1106; 
	if (~~(((Prop_114())))) jump L_Say755;
		ParaContent();  print (The)  (Prop_115()) ; ParaContent();  print (PrintText) SC_1107; 
	jump L_SayX721; .L_Say755;
		ParaContent();  print (PrintText) SC_1108; 
	.L_Say756; .L_SayX721;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say757; .L_SayX722;  }
      ! phrase 2
      ! [2: otherwise say ~You bark. The dog barks back. [the dog-action]~]
       else { say__p=1;ParaContent();  print (PrintText) SC_1109; ParaContent(); (PHR_1554_r4 ()); .L_Say758; .L_SayX723;  }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1551, 1551, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Typing (B549_check_typing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check typing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check typing:
[ R_1602 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1602, 1602);
      ! phrase 1
      ! [1: if the second noun is not the keypad , say ~You can't type on that!~ instead]
       if (((~~((second == I644_keypad))))) { say__p=1;ParaContent();  print (PrintText) SC_1110;  new_line; .L_Say759; .L_SayX724;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1602, 1602, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Typing (B550_carry_out_typing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out typing:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out typing:
[ R_1603 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1603, 1603);
      ! phrase 1
      ! [1: if the number understood is 30359 begin]
       if (((parsed_number == 30359)))  {
         ! phrase 2
         ! [2: say ~[one of]You hear a 'click' from the hut... and then a moment later, the door slides open.[or]You hear a click from the hut, but since the door is already open, nothing further happens.[stopping]~]
         say__p=1;ParaContent();  I7_ST_say_one_of-->46 =
	i7_soo_stop(I7_ST_say_one_of-->46, 2);
	switch((I7_ST_say_one_of-->46)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1111;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1112;  new_line;ParaContent();  }  .L_Say760; .L_SayX725;
         ! phrase 3
         ! [3: now inside the cinderblock hut is unkeyed]
          (Adj_135_t2_v9(I637_inside_the_cinderblock_)); 
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~You hear a 'bzzt' from what sounds like deep within the boulder, but nothing else happens.~]
         say__p=1;ParaContent();  print (PrintText) SC_1113;  new_line; .L_Say761; .L_SayX726;
         ! phrase 6
         ! [6: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1603, 1603, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Switch-action begins (B559_when_switch_action_begi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When switch-action begins:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When switch-action begins:
[ R_1713 ;
      ! phrase 1
      ! [1: say ~Something inside the pump whirrs to life, and it starts to rumble.[paragraph break][one of]Doug looks startled, then smiles. 'So [bold type]that's[roman type] how this works!'[or]Doug smiles.[stopping]~]
      say__p=1;ParaContent();  print (PrintText) SC_1114; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  I7_ST_say_one_of-->47 =
	i7_soo_stop(I7_ST_say_one_of-->47, 2);
	switch((I7_ST_say_one_of-->47)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1115; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1116; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1117;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1118;  new_line;ParaContent();  }  .L_Say762; .L_SayX727;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: when Switch-action ends (B560_when_switch_action_ends)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! When switch-action ends:
! ----------------------------------------------------------------------------------------------------
! No specific request
! When switch-action ends:
[ R_1714 ;
      ! phrase 1
      ! [1: say ~The pump stops rumbling. Vivian looks disappointed.~]
      say__p=1;ParaContent();  print (PrintText) SC_1119;  new_line; .L_Say763; .L_SayX728;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Train-moving (B561_check_train_moving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check train-moving:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check train-moving:
[ R_1720 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1720, 1720);
      ! phrase 1
      ! [1: if the player is in the steam train , say ~You're in it!~ instead]
       if (((I439_steam_train == ContainerOf(player)))) { say__p=1;ParaContent();  print (PrintText) SC_237;  new_line; .L_Say764; .L_SayX729;  rtrue; }
      ! phrase 2
      ! [2: if the player is not in the station of the steam train and the steam train does not approach the location of the player , say ~You don't see a train here.~ instead]
       if ((((~~((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))))) && (((~~(((Relation_TestVtoV(I439_steam_train,Rel_Record_69, LocationOf(player) ,false)))))))) { say__p=1;ParaContent();  print (PrintText) SC_423;  new_line; .L_Say765; .L_SayX730;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1720, 1720, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Train-moving (B562_carry_out_train_moving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out train-moving:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out train-moving:
[ R_1721 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1721, 1721);
      ! phrase 1
      ! [1: say ~That seems pointless.~]
      say__p=1;ParaContent();  print (PrintText) SC_1086;  new_line; .L_Say766; .L_SayX731;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1721, 1721, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Train-examining (B564_check_train_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check train-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Check train-examining:
[ R_1722 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1722, 1722);
      ! phrase 1
      ! [1: if the location is the steam train , say ~You're in it!~ instead]
       if (((real_location == I439_steam_train))) { say__p=1;ParaContent();  print (PrintText) SC_237;  new_line; .L_Say767; .L_SayX732;  rtrue; }
      ! phrase 2
      ! [2: if the player is not in the station of the steam train and the steam train does not approach the location of the player , say ~You don't see a train here.~ instead]
       if ((((~~((GProperty(9, I439_steam_train,p16_station) == ContainerOf(player)))))) && (((~~(((Relation_TestVtoV(I439_steam_train,Rel_Record_69, LocationOf(player) ,false)))))))) { say__p=1;ParaContent();  print (PrintText) SC_423;  new_line; .L_Say768; .L_SayX733;  rtrue; }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1722, 1722, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Train-examining (B565_carry_out_train_examini)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out train-examining:
! ----------------------------------------------------------------------------------------------------
! No specific request
! Carry out train-examining:
[ R_1723 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_1723, 1723);
      ! phrase 1
      ! [1: say ~An old-fashioned steam train, with a rounded engine and a single moss-colored car dotted with windows; [if the conductor is in the Steam Train]a conductor is standing in the car's open door[otherwise]the train is completely closed and silent[end if]. [if the steam train approaches the location]The train is slowing down as it approaches you[otherwise]The train is stopped here on the tracks, puffing steam[end if].~]
      say__p=1;ParaContent();  print (PrintText) SC_1120; 
	if (~~((((I439_steam_train == ContainerOf(I711_conductor)))))) jump L_Say769;
		ParaContent();  print (PrintText) SC_1121; 
	jump L_SayX734; .L_Say769;
		ParaContent();  print (PrintText) SC_1122; 
	.L_Say770; .L_SayX734;
		ParaContent();  print (PrintText) SC_579; 
	if (~~(((((Relation_TestVtoV(I439_steam_train,Rel_Record_69,real_location,false))))))) jump L_Say771;
		ParaContent();  print (PrintText) SC_1123; 
	jump L_SayX735; .L_Say771;
		ParaContent();  print (PrintText) SC_1124; 
	.L_Say772; .L_SayX735;
		ParaContent();  print (PrintText) SC_250;  new_line; .L_Say773; .L_SayX736;
      ! phrase 2
      ! [2: set pronouns from the steam train]
       PronounNotice(I439_steam_train); 
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_1723, 1723, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! No specific request
! From the Standard Rules
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_99 
    t_0 ! Local variable e.g. 'current working sack' = player's holdall
    t_1 ! Local variable e.g. '?-1,-1?' = object
    t_2 ! Local variable e.g. '?-1,-1?' = thing
    t_3 ! Local variable e.g. '?-1,-1?' = thing
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_99, 99);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
       if ((( (Prop_116())  >= GProperty(9, actor,capacity))))  {
         ! phrase 2
         ! [2: if the actor is holding a player's holdall ( called the current working sack ) begin]
          if ((Prop_117() && (t_0=deferred_calling_list-->0, true)))  {
            ! phrase 3
            ! [3: let the transferred item be nothing]
             t_1 = nothing; 
            ! phrase 4
            ! [4: repeat with the possible item running through things carried by the actor begin]
             for (t_2=Prop_118(0), t_3=Prop_118(t_2): t_2: t_2=t_3, t_3=Prop_118(t_3))  {
               ! phrase 5
               ! [5: if the possible item is not lit and the possible item is not the current working sack , let the transferred item be the possible item]
                if ((((~~(((Adj_51_t1_v9(t_2))))))) && (((~~((t_2 == t_0)))))) {  t_1 = t_2;   }
               ! phrase 6
               ! [6: end repeat]
               }

            ! phrase 7
            ! [7: if the transferred item is not nothing begin]
             if (((~~((t_1 == nothing)))))  {
               ! phrase 8
               ! [8: issue library message taking action number 13 for the transferred item and the current working sack]
                GL__M(##Take,13,t_1,t_0); 
               ! phrase 9
               ! [9: silently try the actor trying inserting the transferred item into the current working sack]
                @push keep_silent; keep_silent=1; TryAction(0, actor, ##Insert, t_1, t_0);; @pull keep_silent; 
               ! phrase 10
               ! [10: if the transferred item is not in the current working sack , stop the action]
                if (((~~((t_0 == ContainerOf(t_1)))))) {  rtrue;   }
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_99, 99, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto something being carried rule ):
[ R_117 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_117, 117);
      ! phrase 1
      ! [1: if the actor encloses the second noun , stop the action with library message putting it on action number 4 for the second noun]
       if (((IndirectlyContains(actor,second)))) {  return GL__M(##PutOn,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_117, 117, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going when the actor is on a supporter ( called the chaise ) ( this is the stand up before going rule ):
[ R_138 
    t_0 ! Local variable e.g. 'chaise' = supporter
    ;
   if ((act_requester==nothing) && (self=actor,true) && (((SupporterOf(actor) ofclass K6_supporter) && (t_0=(SupporterOf(actor)), true)))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_138, 138);
      ! phrase 1
      ! [1: issue library message going action number 27 for the chaise]
       GL__M(##Go,27,t_0); 
      ! phrase 2
      ! [2: silently try the actor exiting]
       @push keep_silent; keep_silent=1; TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent; 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_138, 138, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor going ( this is the can't go through undescribed doors rule ):
[ R_140 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_140, 140);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is undescribed , stop the action with library message going action number 2 for the room gone from]
       if ((((~~(((MStack-->MstVO(20007,2)) == nothing))))) && ((((Adj_62_t1_v9((MStack-->MstVO(20007,2)))))))) {  return GL__M(##Go,2,(MStack-->MstVO(20007,0)));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_140, 140, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_160 
    t_0 ! Local variable e.g. 'local room' = object
    ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_160, 160);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
       t_0 =  LocationOf(actor) ; 
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
       if ((((MStack-->MstVO(20009,0)) == t_0)))  {
         ! phrase 3
         ! [3: if the room-or-door outside from the local room is not nothing , convert to the going action on the outside]
          if (((~~(((Resolver_9(out_obj,t_0,"source", 2185)) == nothing))))) {  return GVS_Convert(##Go,out_obj,0);   }
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_160, 160, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor getting off ( this is the can't get off things rule ):
[ R_167 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_167, 167);
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
       if (((noun == SupporterOf(actor)))) {  rfalse;   }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
       if (((noun == CarrierOf(actor)))) {  rfalse;   }
      ! phrase 3
      ! [3: stop the action with library message getting off action number 1 for the noun]
       return GL__M(##GetOff,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_167, 167, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_195 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_195, 195);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message locking it with action number 4 for the second noun]
       if ((((~~(( (HolderOf(second))  == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))) {  return GL__M(##Lock,4,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_195, 195, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_200 ;
   if ((act_requester==nothing) && ((noun ofclass K2_thing))) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_200, 200);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the noun does not provide the property matching key or the matching key of the noun is not the second noun , stop the action with library message unlocking it with action number 3 for the second noun]
       if ((((~~(( (HolderOf(second))  == actor))))) || ((((~~((WhetherProvides(noun, false, with_key)))))) || (((~~((GProperty(OBJECT_TY, noun,with_key) == second))))))) {  return GL__M(##Unlock,3,second);   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_200, 200, true);
   rfalse;
];
! No specific request
! From the Standard Rules
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_299 ;
   if ((act_requester==nothing)) { ! Runs only when pattern matches
self = noun;
   if (debug_rules) DB_Rule(R_299, 299);
      ! phrase 1
      ! [1: stop the action with library message sleeping action number 1]
       return GL__M(##Sleep,1,noun); 
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_299, 299, true);
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the need a matching key rule:
[ R_819 
    t_0 ! Local variable e.g. '?-1,-1?' = object
    ;
      ! phrase 1
      ! [1: if the noun provides the property matching key begin]
       if (((WhetherProvides(noun, false, with_key))))  {
         ! phrase 2
         ! [2: let the item be the matching key of the noun]
          t_0 = GProperty(OBJECT_TY, noun,with_key); 
         ! phrase 3
         ! [3: if the person asked encloses the item begin]
          if (((IndirectlyContains(actor,t_0))))  {
            ! phrase 4
            ! [4: now the second noun is the item]
             second = t_0; 
            ! phrase 5
            ! [5: abide by the must have accessible the second noun rule]
             if (ProcessRulebook(R_850)) rtrue; 
            ! phrase 6
            ! [6: otherwise]
            } else {

            ! phrase 7
            ! [7: if the item is a passkey and the item unbolts the noun and the item is visible begin]
             if ((((t_0 ofclass K18_passkey))) && ((((t_0 == (noun.p67_unbolting)))) && ((((Adj_3_t1_v9(t_0)))))))  {
               ! phrase 8
               ! [8: now the second noun is the item]
                second = t_0; 
               ! phrase 9
               ! [9: abide by the must have accessible the second noun rule]
                if (ProcessRulebook(R_850)) rtrue; 
               ! phrase 10
               ! [10: otherwise]
               } else {

               ! phrase 11
               ! [11: if the player is the person asked , say ~[key-refusal for noun]~]
                if (((player == actor))) { say__p=1;ParaContent(); (PHR_820_r22 (noun)); .L_Say774; .L_SayX737;  }
               ! phrase 12
               ! [12: stop the action]
                rtrue; 
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: otherwise]
         } else {

         ! phrase 16
         ! [16: if the player is the person asked , say ~[key-refusal for noun]~]
          if (((player == actor))) { say__p=1;ParaContent(); (PHR_820_r22 (noun)); .L_Say775; .L_SayX738;  }
         ! phrase 17
         ! [17: stop the action]
          rtrue; 
         ! phrase 18
         ! [18: end if]
         }

   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the noun autotaking rule:
[ R_845 ;
      ! phrase 1
      ! [1: if sequential action option is active begin]
       if ((((Adj_22_t1_v15(24)))))  {
         ! phrase 2
         ! [2: if the player is the person asked begin]
          if (((player == actor)))  {
            ! phrase 3
            ! [3: try taking the noun]
             TryAction(0, player, ##Take, noun, 0);; 
            ! phrase 4
            ! [4: otherwise]
            } else {

            ! phrase 5
            ! [5: try the person asked trying taking the noun]
             TryAction(0, actor, ##Take, noun, 0);; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: if the player is the person asked begin]
          if (((player == actor)))  {
            ! phrase 9
            ! [9: say ~(first taking [the noun])~]
            say__p=1;ParaContent();  print (PrintText) SC_1125; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_413;  .L_Say776; .L_SayX739;
            ! phrase 10
            ! [10: silently try taking the noun]
             @push keep_silent; keep_silent=1; TryAction(0, player, ##Take, noun, 0);; @pull keep_silent; 
            ! phrase 11
            ! [11: otherwise]
            } else {

            ! phrase 12
            ! [12: try the person asked trying taking the noun]
             TryAction(0, actor, ##Take, noun, 0);; 
            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the second noun autotaking rule:
[ R_846 ;
      ! phrase 1
      ! [1: if sequential action option is active begin]
       if ((((Adj_22_t1_v15(24)))))  {
         ! phrase 2
         ! [2: if the player is the person asked begin]
          if (((player == actor)))  {
            ! phrase 3
            ! [3: try taking the second noun]
             TryAction(0, player, ##Take, second, 0);; 
            ! phrase 4
            ! [4: otherwise]
            } else {

            ! phrase 5
            ! [5: try the person asked trying taking the second noun]
             TryAction(0, actor, ##Take, second, 0);; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: if the player is the person asked begin]
          if (((player == actor)))  {
            ! phrase 9
            ! [9: say ~(first taking [the second noun])~]
            say__p=1;ParaContent();  print (PrintText) SC_1125; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_413;  .L_Say777; .L_SayX740;
            ! phrase 10
            ! [10: silently try taking the second noun]
             @push keep_silent; keep_silent=1; TryAction(0, player, ##Take, second, 0);; @pull keep_silent; 
            ! phrase 11
            ! [11: otherwise]
            } else {

            ! phrase 12
            ! [12: try the person asked trying taking the second noun]
             TryAction(0, actor, ##Take, second, 0);; 
            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the must hold the noun rule:
[ R_847 ;
      ! phrase 1
      ! [1: if the person asked does not have the noun , follow the noun autotaking rule]
       if (((~~((actor == OwnerOf(noun)))))) {  FollowRulebook(R_845);   }
      ! phrase 2
      ! [2: if the person asked does not have the noun , stop the action]
       if (((~~((actor == OwnerOf(noun)))))) {  rtrue;   }
      ! phrase 3
      ! [3: make no decision]
       rfalse; 
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the must hold the second noun rule:
[ R_848 ;
      ! phrase 1
      ! [1: if the person asked does not have the second noun , follow the second noun autotaking rule]
       if (((~~((actor == OwnerOf(second)))))) {  FollowRulebook(R_846);   }
      ! phrase 2
      ! [2: if the person asked does not have the second noun , stop the action]
       if (((~~((actor == OwnerOf(second)))))) {  rtrue;   }
      ! phrase 3
      ! [3: make no decision]
       rfalse; 
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the must have accessible the noun rule:
[ R_849 
    t_0 ! Local variable e.g. 'containing keychain' = keychain
    ;
      ! phrase 1
      ! [1: if the noun is not key-accessible begin]
       if (((~~(((Adj_37_t1_v9(noun)))))))  {
         ! phrase 2
         ! [2: if the noun is on a keychain ( called the containing keychain ) , now the noun is the containing keychain]
          if (((SupporterOf(noun) ofclass K19_keychain) && (t_0=(SupporterOf(noun)), true))) {  noun = t_0;   }
         ! phrase 3
         ! [3: follow the noun autotaking rule]
          FollowRulebook(R_845); 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if the noun is not key-accessible begin]
       if (((~~(((Adj_37_t1_v9(noun)))))))  {
         ! phrase 6
         ! [6: if the player is the person asked , say ~Without holding [the noun], you can do nothing.~]
          if (((player == actor))) { say__p=1;ParaContent();  print (PrintText) SC_1126; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1127;  new_line; .L_Say778; .L_SayX741;  }
         ! phrase 7
         ! [7: stop the action]
          rtrue; 
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: make no decision]
       rfalse; 
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! This is the must have accessible the second noun rule:
[ R_850 
    t_0 ! Local variable e.g. 'containing keychain' = keychain
    ;
      ! phrase 1
      ! [1: if the second noun is not key-accessible begin]
       if (((~~(((Adj_37_t1_v9(second)))))))  {
         ! phrase 2
         ! [2: if the second noun is on a keychain ( called the containing keychain ) , now the second noun is the containing keychain]
          if (((SupporterOf(second) ofclass K19_keychain) && (t_0=(SupporterOf(second)), true))) {  second = t_0;   }
         ! phrase 3
         ! [3: follow the second noun autotaking rule]
          FollowRulebook(R_846); 
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: if the second noun is not key-accessible begin]
       if (((~~(((Adj_37_t1_v9(second)))))))  {
         ! phrase 6
         ! [6: if the player is the person asked , say ~Without holding [the second noun], you can do nothing.~]
          if (((player == actor))) { say__p=1;ParaContent();  print (PrintText) SC_1126; ParaContent();  print (the) second; ParaContent();  print (PrintText) SC_1127;  new_line; .L_Say779; .L_SayX742;  }
         ! phrase 7
         ! [7: stop the action]
          rtrue; 
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: make no decision]
       rfalse; 
   rfalse;
];
! No specific request
! From "Disambiguation Control" by Jon Ingold
! This is the disambiguation printing rule:
[ R_906 ;
      ! phrase 1
      ! [1: say the message text corresponding to a message-id of the message-id-requested in the table of disambiguation messages]
      say__p=1;ParaContent();  print (PrintText) TableLookUpCorr(T5_disambiguation_messages,112,111,(Global_Vars-->12));  .L_Say780; .L_SayX743;
   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the print library message rule:
[ R_919 
    t_0 ! Local variable e.g. 'n1' = number
    t_1 ! Local variable e.g. 'n2' = number
    t_2 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let n1 be 1]
       t_0 = 1; 
      ! phrase 2
      ! [2: let n2 be the number of rows in the table of library messages]
       t_1 =  TableRows(T7_library_messages) ; 
      ! phrase 3
      ! [3: change libmsg_printed to 0]
       (Global_Vars-->16) = 0; 
      ! phrase 4
      ! [4: while n1 <= n2 begin]
       while (((t_0 <= t_1)))  {
         ! phrase 5
         ! [5: let mid be n1 plus n2]
          t_2 =  (t_0+t_1) ; 
         ! phrase 6
         ! [6: change mid to mid divided by 2]
          t_2 =  (IntegerDivide(t_2,2)) ; 
         ! phrase 7
         ! [7: choose row mid in the table of library messages]
          ct_0 = T7_library_messages; ct_1 = t_2; 
         ! phrase 8
         ! [8: if the message id entry is library-message-id begin]
          if (((TableLookUpEntry(ct_0,113,ct_1) == (Global_Vars-->15))))  {
            ! phrase 9
            ! [9: if the message text entry is not ~@@126~ begin]
             if (((~~((TableLookUpEntry(ct_0,112,ct_1) == SC_181)))))  {
               ! phrase 10
               ! [10: if library message debug is dbg_on , say ~{[library-message-id] - custom}[line break]~]
                if ((((Adj_90_t1_v9(I409_library_message_debug))))) { say__p=1;ParaContent();  print (PrintText) SC_1128; ParaContent();  print (T62) (Global_Vars-->15); ParaContent();  print (PrintText) SC_1129; ParaContent();  new_line;  .L_Say781; .L_SayX744;  }
               ! phrase 11
               ! [11: say the message text entry]
               say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,112,ct_1);  .L_Say782; .L_SayX745;
               ! phrase 12
               ! [12: change libmsg_printed to 1]
                (Global_Vars-->16) = 1; 
               ! phrase 13
               ! [13: otherwise]
               } else {

               ! phrase 14
               ! [14: if library message debug is dbg_on , say ~{[library-message-id]}[line break]~]
                if ((((Adj_90_t1_v9(I409_library_message_debug))))) { say__p=1;ParaContent();  print (PrintText) SC_1128; ParaContent();  print (T62) (Global_Vars-->15); ParaContent();  print (PrintText) SC_1130; ParaContent();  new_line;  .L_Say783; .L_SayX746;  }
               ! phrase 15
               ! [15: end if]
               }

            ! phrase 16
            ! [16: change n1 to n2 + 1]
             t_0 =  (t_1+1) ; 
            ! phrase 17
            ! [17: end if]
            }

         ! phrase 18
         ! [18: if the message id entry < library-message-id , change n1 to mid plus 1]
          if (((TableLookUpEntry(ct_0,113,ct_1) < (Global_Vars-->15)))) {  t_0 =  (t_2+1) ;   }
         ! phrase 19
         ! [19: if the message id entry > library-message-id , change n2 to mid minus 1]
          if (((TableLookUpEntry(ct_0,113,ct_1) > (Global_Vars-->15)))) {  t_1 =  (t_2-1) ;   }
         ! phrase 20
         ! [20: end while]
         }

   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the custom_internal_i6 reveal any newly visible exterior rule:
[ R_935 ;
      ! phrase 1
      ! [1: display libmsg <reveal any newly visible exterior initial text> / the fake_newly_visible_exterior rule]
      (PHR_934_r23 (I306_libmsg__reveal_any_newl,R_936));
      ! phrase 2
      ! [2: if there is no newly visible exterior begin]
       if (( WriteListFrom(child(lm_o), ENGLISH_BIT+TERSE_BIT+CONCEAL_BIT) == 0 ))  {
         ! phrase 3
         ! [3: display libmsg <no newly visible exterior> / the fake_newly_visible_exterior_nothing rule]
         (PHR_934_r23 (I307_libmsg__no_newly_visibl,R_937));
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~.~]
         say__p=1;ParaContent();  print (PrintText) SC_250;  new_line; .L_Say784; .L_SayX747;
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the fake_newly_visible_exterior rule:
[ R_936 ;
      ! phrase 1
      ! [1: say ~You open [the main object], revealing [run paragraph on]~]
      say__p=1;ParaContent();  print (PrintText) SC_1131; ParaContent();  print (the) (Global_Vars-->17); ParaContent();  print (PrintText) SC_965; ParaContent();  RunParagraphOn();  .L_Say785; .L_SayX748;
   rfalse;
];
! No specific request
! From "Default Messages" by David Fisher
! This is the fake_newly_visible_exterior_nothing rule:
[ R_937 ;
      ! phrase 1
      ! [1: say ~nothing.~]
      say__p=1;ParaContent();  print (PrintText) SC_1132;  new_line; .L_Say786; .L_SayX749;
   rfalse;
];
! No specific request
! At the time when the cavity hides:
[ R_1702 ;
      ! phrase 1
      ! [1: say ~The cavity in the metal wheel slips below the smooth crystal surface of the pump.~]
      say__p=1;ParaContent();  print (PrintText) SC_1133;  new_line; .L_Say787; .L_SayX750;
      ! phrase 2
      ! [2: now the cavity is inaccessible]
       (Adj_141_t2_v9(I701_cavity)); 
   rfalse;
];
! No specific request
! At the time when the cavity continues:
[ R_1703 ;
      ! phrase 1
      ! [1: say ~The pump gives off a [if a random thing in the cavity is metal]crunching[otherwise]banging[end if] sound, weirdly distorted by the water.~]
      say__p=1;ParaContent();  print (PrintText) SC_1134; 
	if (~~(((((Adj_102_t1_v9( (Prop_119()) ))))))) jump L_Say788;
		ParaContent();  print (PrintText) SC_1135; 
	jump L_SayX751; .L_Say788;
		ParaContent();  print (PrintText) SC_1136; 
	.L_Say789; .L_SayX751;
		ParaContent();  print (PrintText) SC_1137;  new_line; .L_Say790; .L_SayX752;
   rfalse;
];
! No specific request
! At the time when the cavity continues yet again:
[ R_1704 ;
      ! phrase 1
      ! [1: say ~The giant metal wheel grates along, slower than usual.~]
      say__p=1;ParaContent();  print (PrintText) SC_1138;  new_line; .L_Say791; .L_SayX753;
   rfalse;
];
! No specific request
! At the time when the crystal gear approaches:
[ R_1705 ;
      ! phrase 1
      ! [1: say ~The crystal gear starts to turn counterclockwise, and approaches the metal wheel.~]
      say__p=1;ParaContent();  print (PrintText) SC_1139;  new_line; .L_Say792; .L_SayX754;
   rfalse;
];
! No specific request
! At the time when the gears catch:
[ R_1710 ;
      ! phrase 1
      ! [1: say ~The gears of the crystal wheel catch another gear inside the pump, and another. Soon the pump is vibrating as wheels within wheels turn and turn each other.[paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) SC_1140; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say793; .L_SayX755;
      ! phrase 2
      ! [2: say ~Vivian is jumping lightly on her toes.~]
      say__p=1;ParaContent();  print (PrintText) SC_1141;  new_line; .L_Say794; .L_SayX756;
   rfalse;
];
! No specific request
! At the time when the conductor says the second train monologue:
[ R_1744 ;
      ! phrase 1
      ! [1: if the conductor is visible and the player is awake and the conductor is distracted , say ~[one of]'This track here is narrow gauge; it's just Pondside local, so we don't join up with the national system or anything. Oh, and check out this rolling stock!' He kicks the floor of the train with a pleased smile. 'Decades old and still solid as a rock. All steel!'[or]The conductor continues to ramble.[stopping]~]
       if (((((Adj_3_t1_v9(I711_conductor))))) && (((((Adj_147_t1_v9(player))))) && ((((Adj_144_t1_v9(I711_conductor))))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->48 =
	i7_soo_stop(I7_ST_say_one_of-->48, 2);
	switch((I7_ST_say_one_of-->48)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1142;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1143;  new_line;ParaContent();  }  .L_Say795; .L_SayX757;  }
   rfalse;
];
! No specific request
! At the time when the conductor says the third train monologue:
[ R_1745 ;
      ! phrase 1
      ! [1: if the conductor is visible and the player is awake and the conductor is distracted , say ~[one of]'This locomotive is a 2-6-2, you know. Originally designed to work with a tender, but we just refill the boiler every run since we have plenty of water around here! And we got a mechanical stoker, so I can take a break from that to come out here and talk the ears off of the passengers.'[or]The conductor's train monologue goes on. He points to some things in the train, trying to explain them; you nod noncommittally, but he seems to be ignoring you anyway.[stopping]~]
       if (((((Adj_3_t1_v9(I711_conductor))))) && (((((Adj_147_t1_v9(player))))) && ((((Adj_144_t1_v9(I711_conductor))))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->49 =
	i7_soo_stop(I7_ST_say_one_of-->49, 2);
	switch((I7_ST_say_one_of-->49)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1144;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1145;  new_line;ParaContent();  }  .L_Say796; .L_SayX758;  }
   rfalse;
];
! No specific request
! At the time when the conductor shuts up:
[ R_1746 ;
      ! phrase 1
      ! [1: if the conductor is visible and the player is awake and the conductor is distracted , say ~[one of]The conductor seems to remember where he is, with a bit of a start. 'Oh, sorry for boring you with all that. Sometimes I forget not everyone finds this stuff so fascinating!'[or]The conductor looks up at you and realizes you weren't following his explanations. 'Sorry for nerding out,' he says sheepishly.[or]The conductor looks at you and seems to be startled by your presence. He apologizes for boring you.[stopping]~]
       if (((((Adj_3_t1_v9(I711_conductor))))) && (((((Adj_147_t1_v9(player))))) && ((((Adj_144_t1_v9(I711_conductor))))))) { say__p=1;ParaContent();  I7_ST_say_one_of-->50 =
	i7_soo_stop(I7_ST_say_one_of-->50, 3);
	switch((I7_ST_say_one_of-->50)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1146;  new_line;ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1147;  new_line;ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1148;  new_line;ParaContent();  }  .L_Say797; .L_SayX759;  }
      ! phrase 2
      ! [2: now the conductor is undistracted]
       (Adj_145_t2_v9(I711_conductor)); 
   rfalse;
];
! Definitions of adjectives

! No specific request
! From the Standard Rules
! Definition:
[ R_0 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_1 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_2 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_3 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_4 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_5 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_6 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_7 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_37 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_38 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_39 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_40 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_41 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_42 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_43 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_44 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_45 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_46 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_47 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_48 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_49 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_50 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_51 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_52 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_53 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_54 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_55 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_56 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From the Standard Rules
! Definition:
[ R_84 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Definition:
[ R_753 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Definition:
[ R_758 
    t_0 ! Call parameter 'it' = object
    ;
      ! phrase 1
      ! [1: if it provides the property switched on , yes]
       if (((WhetherProvides(t_0, true, on)))) {  rtrue;   }
   rfalse;
];
! No specific request
! From "Small Kindnesses" by Aaron Reed
! Definition:
[ R_763 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Definition:
[ R_771 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Considerate Holdall" by Jon Ingold
! Definition:
[ R_781 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Rideable Vehicles" by Graham Nelson
! Definition:
[ R_791 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Definition:
[ R_822 
    t_0 ! Call parameter 'it' = object
    ;
      ! phrase 1
      ! [1: if the person asked carries it , yes]
       if (((actor == CarrierOf(t_0)))) {  rtrue;   }
      ! phrase 2
      ! [2: if it is on a keychain which is carried by the person asked , yes]
       if (((SupporterOf(t_0) ofclass K19_keychain) && (actor == CarrierOf(SupporterOf(t_0))))) {  rtrue;   }
      ! phrase 3
      ! [3: no]
       rfalse; 
   rfalse;
];
! No specific request
! From "Locksmith" by Emily Short
! Definition:
[ R_834 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_1059 
    t_0 ! Call parameter 'it' = object
    ;
      ! phrase 1
      ! [1: if it is not adjacent , no]
       if (((~~(((Adj_11_t1_v9(t_0))))))) {  rfalse;   }
      ! phrase 2
      ! [2: if it is indoors and the location is outdoors , no]
       if (((((Adj_98_t1_v9(t_0))))) && ((((Adj_99_t1_v9(real_location)))))) {  rfalse;   }
      ! phrase 3
      ! [3: if it is outdoors and the location is indoors , yes]
       if (((((Adj_99_t1_v9(t_0))))) && ((((Adj_98_t1_v9(real_location)))))) {  rtrue;   }
      ! phrase 4
      ! [4: if the number of rooms adjacent to it is greater than the number of rooms adjacent to the location , yes]
       if ((( (Prop_120(,t_0))  >  (Prop_121()) ))) {  rtrue;   }
      ! phrase 5
      ! [5: otherwise no]
       else {  rfalse;   }
   rfalse;
];
! No specific request
! Definition:
[ R_1060 
    t_0 ! Call parameter 'it' = object
    ;
      ! phrase 1
      ! [1: if it is not adjacent , no]
       if (((~~(((Adj_11_t1_v9(t_0))))))) {  rfalse;   }
      ! phrase 2
      ! [2: if it is outdoors and the location is indoors , no]
       if (((((Adj_99_t1_v9(t_0))))) && ((((Adj_98_t1_v9(real_location)))))) {  rfalse;   }
      ! phrase 3
      ! [3: if it is indoors and the location is outdoors , yes]
       if (((((Adj_98_t1_v9(t_0))))) && ((((Adj_99_t1_v9(real_location)))))) {  rtrue;   }
      ! phrase 4
      ! [4: if the number of rooms adjacent to it is less than the number of rooms adjacent to the location , yes]
       if ((( (Prop_122(,t_0))  <  (Prop_123()) ))) {  rtrue;   }
      ! phrase 5
      ! [5: otherwise no]
       else {  rfalse;   }
   rfalse;
];
! No specific request
! Definition:
[ R_1102 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
! No specific request
! Definition:
[ R_1103 
    t_0 ! Call parameter 'it' = object
    ;
   rfalse;
];
[ Adj_0_t1_v9 ! meaning of "worn"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == WearerOf(t_0)))));
    rfalse;
];

[ Adj_1_t1_v9 ! meaning of "carried"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == CarrierOf(t_0)))));
    rfalse;
];

[ Adj_2_t1_v9 ! meaning of "held"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == HolderOf(t_0)))));
    rfalse;
];

[ Adj_3_t1_v9 ! meaning of "visible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestVisibility(player,t_0)))));
    rfalse;
];

[ Adj_4_t1_v9 ! meaning of "invisible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestVisibility(player,t_0)))))));
    rfalse;
];

[ Adj_5_t1_v9 ! meaning of "touchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestTouchability(player,t_0)))));
    rfalse;
];

[ Adj_6_t1_v9 ! meaning of "untouchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestTouchability(player,t_0)))))));
    rfalse;
];

[ Adj_7_t1_v9 ! meaning of "concealed"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((TestConcealment( (HolderOf(t_0)) ,t_0)))));
    rfalse;
];

[ Adj_8_t1_v9 ! meaning of "unconcealed"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (~~(((((TestConcealment( (HolderOf(t_0)) ,t_0)))))));
    rfalse;
];

[ Adj_9_t1_v9 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, -1)));
    rfalse;
];

[ Adj_10_t1_v9 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return (~~(((OnStage(t_0, -1)))));
    rfalse;
];

[ Adj_11_t1_v9 ! meaning of "adjacent"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return ((((TestAdjacency(real_location,t_0)))));
    rfalse;
];

[ Adj_12_t1_v10 ! meaning of "even"

    t_0 ! Call parameter 'it' = number
    ;
return (((( (IntegerRemainder(t_0,2))  == 0))));
    rfalse;
];

[ Adj_13_t1_v10 ! meaning of "odd"

    t_0 ! Call parameter 'it' = number
    ;
return (~~((((( (IntegerRemainder(t_0,2))  == 0))))));
    rfalse;
];

[ Adj_14_t1_v10 ! meaning of "positive"

    t_0 ! Call parameter 'it' = number
    ;
return ((((t_0 > 0))));
    rfalse;
];

[ Adj_15_t1_v10 ! meaning of "negative"

    t_0 ! Call parameter 'it' = number
    ;
return ((((t_0 < 0))));
    rfalse;
];

[ Adj_16_t1_v12 ! meaning of "empty"

    t_0 ! Call parameter 'it' = text
    ;
return ((((t_0 == EMPTY_TEXT_VALUE))));
    rfalse;
];

[ Adj_16_t1_v13 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((INDEXED_TEXT_TY_Empty(t_0)));
    rfalse;
];

[ Adj_16_t1_v17 ! meaning of "empty"

    t_0 ! Call parameter 'it' = table name
    ;
return (((( TableFilledRows(t_0)  == 0))));
    rfalse;
];

[ Adj_16_t1_v28 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RulebookEmpty(t_0)));
    rfalse;
];

[ Adj_16_t1_v29 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((ActivityEmpty(t_0)));
    rfalse;
];

[ Adj_16_t1_v30 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((LIST_OF_TY_Empty(t_0)));
    rfalse;
];

[ Adj_16_t1_v26 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, -1)));
    rfalse;
];

[ Adj_16_t1_v9 ! meaning of "empty"

    t_0 ! Call parameter 'it' = fluid container
    ;
  if (t_0 ofclass K25_fluid_container) return ((((GProperty(9, t_0,p15_current_volume) == 0))));
    rfalse;
];

[ Adj_17_t1_v12 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = text
    ;
return (~~(((((t_0 == EMPTY_TEXT_VALUE))))));
    rfalse;
];

[ Adj_17_t1_v13 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((INDEXED_TEXT_TY_Empty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v17 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = table name
    ;
return (~~((((( TableFilledRows(t_0)  == 0))))));
    rfalse;
];

[ Adj_17_t1_v28 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((RulebookEmpty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v29 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((ActivityEmpty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v30 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((LIST_OF_TY_Empty(t_0)))));
    rfalse;
];

[ Adj_17_t1_v26 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((RELATION_TY_Empty(t_0, -1)))));
    rfalse;
];

[ Adj_18_t1_v39 ! meaning of "happening"

    t_0 ! Call parameter 'it' = scene
    ;
return ((scene_status-->(t_0-1)==1));
    rfalse;
];

[ Adj_19_t1_v17 ! meaning of "full"

    t_0 ! Call parameter 'it' = table name
    ;
return (((( TableBlankRows(t_0)  == 0))));
    rfalse;
];

[ Adj_19_t1_v9 ! meaning of "full"

    t_0 ! Call parameter 'it' = fluid container
    ;
  if (t_0 ofclass K25_fluid_container) return ((((GProperty(9, t_0,p15_current_volume) == GProperty(9, t_0,p14_fluid_capacity)))));
    rfalse;
];

[ Adj_20_t1_v17 ! meaning of "non-full"

    t_0 ! Call parameter 'it' = table name
    ;
return (~~((((( TableBlankRows(t_0)  == 0))))));
    rfalse;
];

[ Adj_21_t1_v29 ! meaning of "going on"

    t_0 ! Call parameter 'it' = number
    ;
return ((TestActivity(t_0)));
    rfalse;
];

[ Adj_22_t1_v15 ! meaning of "active"

    t_0 ! Call parameter 'it' = number
    ;
return ((TestUseOption(t_0)));
    rfalse;
];

[ Adj_23_t1_v15 ! meaning of "inactive"

    t_0 ! Call parameter 'it' = number
    ;
return (~~(((TestUseOption(t_0)))));
    rfalse;
];

[ Adj_24_t1_v26 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, -1)));
    rfalse;
];

[ Adj_25_t1_v26 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, -1)));
    rfalse;
];

[ Adj_26_t1_v26 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, -1)));
    rfalse;
];

[ Adj_27_t1_v26 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, -1)));
    rfalse;
];

[ Adj_28_t1_v26 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, -1)));
    rfalse;
];

[ Adj_29_t1_v26 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, -1)));
    rfalse;
];

[ Adj_30_t1_v9 ! meaning of "locale-supportable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (((((~~(((Adj_57_t1_v9(t_0))))))) && ((((~~(((Adj_65_t1_v9(t_0))))))) && (((~~(((Adj_62_t1_v9(t_0))))))))));
    rfalse;
];

[ Adj_31_t1_v9 ! meaning of "viable"

    t_0 ! Call parameter 'it' = direction
    ;
  if (t_0 ofclass K3_direction) return (((((Resolver_4(t_0,real_location,"source", 157)) ofclass K1_room))));
    rfalse;
];

[ Adj_32_t1_v9 ! meaning of "switchable"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((R_758(t_0)));
    rfalse;
];

[ Adj_33_t1_v9 ! meaning of "occupied"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((IndirectlyContains(t_0,player)))));
    rfalse;
];

[ Adj_34_t1_v9 ! meaning of "forgotten-about"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((PHR_770_r24 (t_0)))));
    rfalse;
];

[ Adj_35_t1_v9 ! meaning of "a body-part"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((((player == (t_0.component_parent)))));
    rfalse;
];

[ Adj_36_t1_v9 ! meaning of "vehicular"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return (((((t_0 ofclass K14_vehicle))) || ((((t_0 ofclass K16_rideable_animal))) || (((t_0 ofclass K17_rideable_vehicle))))));
    rfalse;
];

[ Adj_37_t1_v9 ! meaning of "key-accessible"

    t_0 ! Call parameter 'it' = thing
    ;
  if (t_0 ofclass K2_thing) return ((R_822(t_0)));
    rfalse;
];

[ Adj_38_t1_v9 ! meaning of "identified"

    t_0 ! Call parameter 'it' = passkey
    ;
  if (t_0 ofclass K18_passkey) return (((Prop_124(,t_0))));
    rfalse;
];

[ Adj_39_t1_v9 ! meaning of "outward"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return ((R_1059(t_0)));
    rfalse;
];

[ Adj_40_t1_v9 ! meaning of "inward"

    t_0 ! Call parameter 'it' = room
    ;
  if (t_0 ofclass K1_room) return ((R_1060(t_0)));
    rfalse;
];

[ Adj_41_t1_v9 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_42_t1_v9 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pluralname) == false);
    rfalse;
];

[ Adj_43_t1_v9 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_44_t1_v9 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, proper) == false);
    rfalse;
];

[ Adj_45_t1_v9 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_46_t1_v9 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, privately_named) == false);
    rfalse;
];

[ Adj_47_t1_v9 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_48_t1_v9 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];

[ Adj_49_t1_v9 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_50_t1_v9 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, visited) == false);
    rfalse;
];

[ Adj_51_t1_v9 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_52_t1_v9 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, light) == false);
    rfalse;
];

[ Adj_53_t1_v9 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_54_t1_v9 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, edible) == false);
    rfalse;
];

[ Adj_55_t1_v9 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_56_t1_v9 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, static) == false);
    rfalse;
];

[ Adj_57_t1_v9 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, scenery));
    rfalse;
];

[ Adj_58_t1_v9 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, clothing));
    rfalse;
];

[ Adj_59_t1_v9 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, pushable));
    rfalse;
];

[ Adj_60_t1_v9 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, moved));
    rfalse;
];

[ Adj_61_t1_v9 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, concealed) == false);
    rfalse;
];

[ Adj_62_t1_v9 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_63_t1_v9 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_64_t1_v9 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, workflag) == false);
    rfalse;
];

[ Adj_65_t1_v9 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_66_t1_v9 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mentioned) == false);
    rfalse;
];

[ Adj_67_t1_v9 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, enterable));
    rfalse;
];

[ Adj_68_t1_v9 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, transparent) == false);
    rfalse;
];

[ Adj_69_t1_v9 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_70_t1_v9 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_71_t1_v9 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, open) == false);
    rfalse;
];

[ Adj_72_t1_v9 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_73_t1_v9 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, openable) == false);
    rfalse;
];

[ Adj_74_t1_v9 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, lockable));
    rfalse;
];

[ Adj_75_t1_v9 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_76_t1_v9 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, locked) == false);
    rfalse;
];

[ Adj_77_t1_v9 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_78_t1_v9 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, female) == false);
    rfalse;
];

[ Adj_79_t1_v9 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, neuter));
    rfalse;
];

[ Adj_80_t1_v9 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_81_t1_v9 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, on) == false);
    rfalse;
];

[ Adj_82_t1_v39 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p59_recurring));
    rfalse;
];

[ Adj_83_t1_v39 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (GProperty(SCENE_TY, t_0, p59_recurring) == false);
    rfalse;
];

[ Adj_84_t1_v9 ! meaning of "stashable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p61_stashable));
    rfalse;
];

[ Adj_85_t1_v9 ! meaning of "unstashable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p61_stashable) == false);
    rfalse;
];

[ Adj_86_t1_v9 ! meaning of "CHavailable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p63_chavailable));
    rfalse;
];

[ Adj_87_t1_v9 ! meaning of "CHunavailable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p63_chavailable) == false);
    rfalse;
];

[ Adj_88_t1_v9 ! meaning of "CHviable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p65_chviable));
    rfalse;
];

[ Adj_89_t1_v9 ! meaning of "CHunviable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p65_chviable) == false);
    rfalse;
];

[ Adj_90_t1_v9 ! meaning of "dbg_on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p69_dbg_on));
    rfalse;
];

[ Adj_91_t1_v9 ! meaning of "dbg_off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p69_dbg_on) == false);
    rfalse;
];

[ Adj_92_t1_v9 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p71_ambiguously_plural));
    rfalse;
];

[ Adj_93_t1_v9 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p71_ambiguously_plural) == false);
    rfalse;
];

[ Adj_94_t1_v9 ! meaning of "examined"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p73_examined));
    rfalse;
];

[ Adj_95_t1_v9 ! meaning of "unexamined"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p73_examined) == false);
    rfalse;
];

[ Adj_96_t1_v9 ! meaning of "accessed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p75_accessed));
    rfalse;
];

[ Adj_97_t1_v9 ! meaning of "unaccessed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p75_accessed) == false);
    rfalse;
];

[ Adj_98_t1_v9 ! meaning of "indoors"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p77_indoors));
    rfalse;
];

[ Adj_99_t1_v9 ! meaning of "outdoors"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p77_indoors) == false);
    rfalse;
];

[ Adj_100_t1_v9 ! meaning of "pocketed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p79_pocketed));
    rfalse;
];

[ Adj_101_t1_v9 ! meaning of "unpocketed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p79_pocketed) == false);
    rfalse;
];

[ Adj_102_t1_v9 ! meaning of "metal"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p81_metal));
    rfalse;
];

[ Adj_103_t1_v9 ! meaning of "nonmetal"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p81_metal) == false);
    rfalse;
];

[ Adj_104_t1_v9 ! meaning of "moved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p83_moved));
    rfalse;
];

[ Adj_105_t1_v9 ! meaning of "unmoved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p83_moved) == false);
    rfalse;
];

[ Adj_106_t1_v9 ! meaning of "clean water"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p85_liquid) == 1);
      if (t_0) return (GProperty(9, t_0, p85_liquid) == 1);
      if (t_0) return (GProperty(9, t_0, p85_liquid) == 1);
    rfalse;
];

[ Adj_107_t1_v9 ! meaning of "pond water"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GProperty(9, t_0, p85_liquid) == 2);
      if (t_0) return (GProperty(9, t_0, p85_liquid) == 2);
      if (t_0) return (GProperty(9, t_0, p85_liquid) == 2);
    rfalse;
];

[ Adj_108_t1_v9 ! meaning of "soft"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p86_soft));
    rfalse;
];

[ Adj_109_t1_v9 ! meaning of "hard"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p86_soft) == false);
    rfalse;
];

[ Adj_110_t1_v9 ! meaning of "boaty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p88_boaty));
    rfalse;
];

[ Adj_111_t1_v9 ! meaning of "unboaty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p88_boaty) == false);
    rfalse;
];

[ Adj_112_t1_v9 ! meaning of "peeled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p90_peeled));
    rfalse;
];

[ Adj_113_t1_v9 ! meaning of "unpeeled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p90_peeled) == false);
    rfalse;
];

[ Adj_114_t1_v9 ! meaning of "irked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p92_irked));
    rfalse;
];

[ Adj_115_t1_v9 ! meaning of "calm"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p92_irked) == false);
    rfalse;
];

[ Adj_116_t1_v9 ! meaning of "curious"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p94_curious));
    rfalse;
];

[ Adj_117_t1_v9 ! meaning of "incurious"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p94_curious) == false);
    rfalse;
];

[ Adj_118_t1_v9 ! meaning of "plugged"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p96_plugged));
    rfalse;
];

[ Adj_119_t1_v9 ! meaning of "unplugged"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p96_plugged) == false);
    rfalse;
];

[ Adj_120_t1_v9 ! meaning of "fixed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p98_fixed));
    rfalse;
];

[ Adj_121_t1_v9 ! meaning of "broken"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p98_fixed) == false);
    rfalse;
];

[ Adj_122_t1_v9 ! meaning of "secure"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p100_secure));
    rfalse;
];

[ Adj_123_t1_v9 ! meaning of "insecure"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p100_secure) == false);
    rfalse;
];

[ Adj_124_t1_v9 ! meaning of "flipped up"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p102_flipped_up));
    rfalse;
];

[ Adj_125_t1_v9 ! meaning of "flipped down"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p102_flipped_up) == false);
    rfalse;
];

[ Adj_126_t1_v9 ! meaning of "important"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p104_important));
    rfalse;
];

[ Adj_127_t1_v9 ! meaning of "unimportant"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p104_important) == false);
    rfalse;
];

[ Adj_128_t1_v9 ! meaning of "upside-down"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p106_upside_down));
    rfalse;
];

[ Adj_129_t1_v9 ! meaning of "right-side-up"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p106_upside_down) == false);
    rfalse;
];

[ Adj_130_t1_v9 ! meaning of "trapped"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p108_trapped));
    rfalse;
];

[ Adj_131_t1_v9 ! meaning of "free"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p108_trapped) == false);
    rfalse;
];

[ Adj_132_t1_v9 ! meaning of "roaming"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p110_roaming));
    rfalse;
];

[ Adj_133_t1_v9 ! meaning of "still"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p110_roaming) == false);
    rfalse;
];

[ Adj_134_t1_v9 ! meaning of "keyed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p112_keyed));
    rfalse;
];

[ Adj_135_t1_v9 ! meaning of "unkeyed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p112_keyed) == false);
    rfalse;
];

[ Adj_136_t1_v9 ! meaning of "flooded"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p114_flooded));
    rfalse;
];

[ Adj_137_t1_v9 ! meaning of "safe"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p114_flooded) == false);
    rfalse;
];

[ Adj_138_t1_v9 ! meaning of "spinning"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p116_spinning));
    rfalse;
];

[ Adj_139_t1_v9 ! meaning of "stopped"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p116_spinning) == false);
    rfalse;
];

[ Adj_140_t1_v9 ! meaning of "accessible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p118_accessible));
    rfalse;
];

[ Adj_141_t1_v9 ! meaning of "inaccessible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p118_accessible) == false);
    rfalse;
];

[ Adj_142_t1_v9 ! meaning of "satisfied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p121_satisfied));
    rfalse;
];

[ Adj_143_t1_v9 ! meaning of "unsatisfied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p121_satisfied) == false);
    rfalse;
];

[ Adj_144_t1_v9 ! meaning of "distracted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p123_distracted));
    rfalse;
];

[ Adj_145_t1_v9 ! meaning of "undistracted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p123_distracted) == false);
    rfalse;
];

[ Adj_146_t1_v9 ! meaning of "asleep"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p125_asleep));
    rfalse;
];

[ Adj_147_t1_v9 ! meaning of "awake"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, p125_asleep) == false);
    rfalse;
];

[ Adj_148_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, worn));
    rfalse;
];

[ Adj_149_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, absent));
    rfalse;
];

[ Adj_150_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];

[ Adj_151_t1_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (GetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];

[ Adj_9_t2_v9 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];

[ Adj_10_t2_v9 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];

[ Adj_16_t2_v26 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];

[ Adj_17_t2_v26 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];

[ Adj_24_t2_v26 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, true)));
    rfalse;
];

[ Adj_25_t2_v26 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, true)));
    rfalse;
];

[ Adj_26_t2_v26 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, true)));
    rfalse;
];

[ Adj_27_t2_v26 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, true)));
    rfalse;
];

[ Adj_28_t2_v26 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, true)));
    rfalse;
];

[ Adj_29_t2_v26 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, true)));
    rfalse;
];

[ Adj_41_t2_v9 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_42_t2_v9 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];

[ Adj_43_t2_v9 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_44_t2_v9 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];

[ Adj_45_t2_v9 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_46_t2_v9 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];

[ Adj_47_t2_v9 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_48_t2_v9 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_49_t2_v9 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_50_t2_v9 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];

[ Adj_51_t2_v9 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_52_t2_v9 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_53_t2_v9 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_54_t2_v9 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];

[ Adj_55_t2_v9 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_56_t2_v9 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];

[ Adj_57_t2_v9 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, scenery));
    rfalse;
];

[ Adj_58_t2_v9 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, clothing));
    rfalse;
];

[ Adj_59_t2_v9 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pushable));
    rfalse;
];

[ Adj_60_t2_v9 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, moved));
    rfalse;
];

[ Adj_61_t2_v9 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];

[ Adj_62_t2_v9 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_63_t2_v9 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_64_t2_v9 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];

[ Adj_65_t2_v9 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_66_t2_v9 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];

[ Adj_67_t2_v9 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, enterable));
    rfalse;
];

[ Adj_68_t2_v9 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];

[ Adj_69_t2_v9 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_70_t2_v9 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_71_t2_v9 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];

[ Adj_72_t2_v9 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_73_t2_v9 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];

[ Adj_74_t2_v9 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, lockable));
    rfalse;
];

[ Adj_75_t2_v9 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_76_t2_v9 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];

[ Adj_77_t2_v9 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_78_t2_v9 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];

[ Adj_79_t2_v9 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, neuter));
    rfalse;
];

[ Adj_80_t2_v9 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_81_t2_v9 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];

[ Adj_82_t2_v39 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p59_recurring, true));
    rfalse;
];

[ Adj_83_t2_v39 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p59_recurring));
    rfalse;
];

[ Adj_84_t2_v9 ! meaning of "stashable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p61_stashable));
    rfalse;
];

[ Adj_85_t2_v9 ! meaning of "unstashable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p61_stashable, true));
    rfalse;
];

[ Adj_86_t2_v9 ! meaning of "CHavailable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p63_chavailable));
    rfalse;
];

[ Adj_87_t2_v9 ! meaning of "CHunavailable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p63_chavailable, true));
    rfalse;
];

[ Adj_88_t2_v9 ! meaning of "CHviable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p65_chviable));
    rfalse;
];

[ Adj_89_t2_v9 ! meaning of "CHunviable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p65_chviable, true));
    rfalse;
];

[ Adj_90_t2_v9 ! meaning of "dbg_on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_dbg_on));
    rfalse;
];

[ Adj_91_t2_v9 ! meaning of "dbg_off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_dbg_on, true));
    rfalse;
];

[ Adj_92_t2_v9 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural));
    rfalse;
];

[ Adj_93_t2_v9 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural, true));
    rfalse;
];

[ Adj_94_t2_v9 ! meaning of "examined"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p73_examined));
    rfalse;
];

[ Adj_95_t2_v9 ! meaning of "unexamined"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p73_examined, true));
    rfalse;
];

[ Adj_96_t2_v9 ! meaning of "accessed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_accessed));
    rfalse;
];

[ Adj_97_t2_v9 ! meaning of "unaccessed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_accessed, true));
    rfalse;
];

[ Adj_98_t2_v9 ! meaning of "indoors"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p77_indoors));
    rfalse;
];

[ Adj_99_t2_v9 ! meaning of "outdoors"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p77_indoors, true));
    rfalse;
];

[ Adj_100_t2_v9 ! meaning of "pocketed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p79_pocketed));
    rfalse;
];

[ Adj_101_t2_v9 ! meaning of "unpocketed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p79_pocketed, true));
    rfalse;
];

[ Adj_102_t2_v9 ! meaning of "metal"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p81_metal));
    rfalse;
];

[ Adj_103_t2_v9 ! meaning of "nonmetal"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p81_metal, true));
    rfalse;
];

[ Adj_104_t2_v9 ! meaning of "moved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p83_moved));
    rfalse;
];

[ Adj_105_t2_v9 ! meaning of "unmoved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p83_moved, true));
    rfalse;
];

[ Adj_106_t2_v9 ! meaning of "clean water"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p85_liquid, 1));
      if (t_0) return (WriteGProperty(9, t_0, p85_liquid, 1));
      if (t_0) return (WriteGProperty(9, t_0, p85_liquid, 1));
    rfalse;
];

[ Adj_107_t2_v9 ! meaning of "pond water"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (WriteGProperty(9, t_0, p85_liquid, 2));
      if (t_0) return (WriteGProperty(9, t_0, p85_liquid, 2));
      if (t_0) return (WriteGProperty(9, t_0, p85_liquid, 2));
    rfalse;
];

[ Adj_108_t2_v9 ! meaning of "soft"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p86_soft));
    rfalse;
];

[ Adj_109_t2_v9 ! meaning of "hard"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p86_soft, true));
    rfalse;
];

[ Adj_110_t2_v9 ! meaning of "boaty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p88_boaty));
    rfalse;
];

[ Adj_111_t2_v9 ! meaning of "unboaty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p88_boaty, true));
    rfalse;
];

[ Adj_112_t2_v9 ! meaning of "peeled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p90_peeled));
    rfalse;
];

[ Adj_113_t2_v9 ! meaning of "unpeeled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p90_peeled, true));
    rfalse;
];

[ Adj_114_t2_v9 ! meaning of "irked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p92_irked));
    rfalse;
];

[ Adj_115_t2_v9 ! meaning of "calm"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p92_irked, true));
    rfalse;
];

[ Adj_116_t2_v9 ! meaning of "curious"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p94_curious));
    rfalse;
];

[ Adj_117_t2_v9 ! meaning of "incurious"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p94_curious, true));
    rfalse;
];

[ Adj_118_t2_v9 ! meaning of "plugged"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p96_plugged));
    rfalse;
];

[ Adj_119_t2_v9 ! meaning of "unplugged"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p96_plugged, true));
    rfalse;
];

[ Adj_120_t2_v9 ! meaning of "fixed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p98_fixed));
    rfalse;
];

[ Adj_121_t2_v9 ! meaning of "broken"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p98_fixed, true));
    rfalse;
];

[ Adj_122_t2_v9 ! meaning of "secure"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p100_secure));
    rfalse;
];

[ Adj_123_t2_v9 ! meaning of "insecure"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p100_secure, true));
    rfalse;
];

[ Adj_124_t2_v9 ! meaning of "flipped up"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p102_flipped_up));
    rfalse;
];

[ Adj_125_t2_v9 ! meaning of "flipped down"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p102_flipped_up, true));
    rfalse;
];

[ Adj_126_t2_v9 ! meaning of "important"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p104_important));
    rfalse;
];

[ Adj_127_t2_v9 ! meaning of "unimportant"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p104_important, true));
    rfalse;
];

[ Adj_128_t2_v9 ! meaning of "upside-down"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p106_upside_down));
    rfalse;
];

[ Adj_129_t2_v9 ! meaning of "right-side-up"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p106_upside_down, true));
    rfalse;
];

[ Adj_130_t2_v9 ! meaning of "trapped"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p108_trapped));
    rfalse;
];

[ Adj_131_t2_v9 ! meaning of "free"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p108_trapped, true));
    rfalse;
];

[ Adj_132_t2_v9 ! meaning of "roaming"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p110_roaming));
    rfalse;
];

[ Adj_133_t2_v9 ! meaning of "still"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p110_roaming, true));
    rfalse;
];

[ Adj_134_t2_v9 ! meaning of "keyed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p112_keyed));
    rfalse;
];

[ Adj_135_t2_v9 ! meaning of "unkeyed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p112_keyed, true));
    rfalse;
];

[ Adj_136_t2_v9 ! meaning of "flooded"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p114_flooded));
    rfalse;
];

[ Adj_137_t2_v9 ! meaning of "safe"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p114_flooded, true));
    rfalse;
];

[ Adj_138_t2_v9 ! meaning of "spinning"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p116_spinning));
    rfalse;
];

[ Adj_139_t2_v9 ! meaning of "stopped"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p116_spinning, true));
    rfalse;
];

[ Adj_140_t2_v9 ! meaning of "accessible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p118_accessible));
    rfalse;
];

[ Adj_141_t2_v9 ! meaning of "inaccessible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p118_accessible, true));
    rfalse;
];

[ Adj_142_t2_v9 ! meaning of "satisfied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p121_satisfied));
    rfalse;
];

[ Adj_143_t2_v9 ! meaning of "unsatisfied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p121_satisfied, true));
    rfalse;
];

[ Adj_144_t2_v9 ! meaning of "distracted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p123_distracted));
    rfalse;
];

[ Adj_145_t2_v9 ! meaning of "undistracted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p123_distracted, true));
    rfalse;
];

[ Adj_146_t2_v9 ! meaning of "asleep"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p125_asleep));
    rfalse;
];

[ Adj_147_t2_v9 ! meaning of "awake"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p125_asleep, true));
    rfalse;
];

[ Adj_148_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, worn));
    rfalse;
];

[ Adj_149_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, absent));
    rfalse;
];

[ Adj_150_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_room));
    rfalse;
];

[ Adj_151_t2_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing));
    rfalse;
];

[ Adj_9_t3_v9 ! meaning of "on-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, false)));
    rfalse;
];

[ Adj_10_t3_v9 ! meaning of "off-stage"

    t_0 ! Call parameter 'it' = number
    ;
  if (t_0 ofclass K2_thing) return ((OnStage(t_0, true)));
    rfalse;
];

[ Adj_16_t3_v26 ! meaning of "empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, false)));
    rfalse;
];

[ Adj_17_t3_v26 ! meaning of "non-empty"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_Empty(t_0, true)));
    rfalse;
];

[ Adj_24_t3_v26 ! meaning of "equivalence"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_EquivalenceAdjective(t_0, false)));
    rfalse;
];

[ Adj_25_t3_v26 ! meaning of "symmetric"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_SymmetricAdjective(t_0, false)));
    rfalse;
];

[ Adj_26_t3_v26 ! meaning of "one-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToOAdjective(t_0, false)));
    rfalse;
];

[ Adj_27_t3_v26 ! meaning of "one-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_OToVAdjective(t_0, false)));
    rfalse;
];

[ Adj_28_t3_v26 ! meaning of "various-to-one"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToOAdjective(t_0, false)));
    rfalse;
];

[ Adj_29_t3_v26 ! meaning of "various-to-various"

    t_0 ! Call parameter 'it' = number
    ;
return ((RELATION_TY_VToVAdjective(t_0, false)));
    rfalse;
];

[ Adj_41_t3_v9 ! meaning of "plural-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname, true));
    rfalse;
];

[ Adj_42_t3_v9 ! meaning of "singular-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pluralname));
    rfalse;
];

[ Adj_43_t3_v9 ! meaning of "proper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper, true));
    rfalse;
];

[ Adj_44_t3_v9 ! meaning of "improper-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, proper));
    rfalse;
];

[ Adj_45_t3_v9 ! meaning of "privately-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named, true));
    rfalse;
];

[ Adj_46_t3_v9 ! meaning of "publically-named"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, privately_named));
    rfalse;
];

[ Adj_47_t3_v9 ! meaning of "lighted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_48_t3_v9 ! meaning of "dark"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_49_t3_v9 ! meaning of "visited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited, true));
    rfalse;
];

[ Adj_50_t3_v9 ! meaning of "unvisited"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, visited));
    rfalse;
];

[ Adj_51_t3_v9 ! meaning of "lit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light, true));
    rfalse;
];

[ Adj_52_t3_v9 ! meaning of "unlit"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, light));
    rfalse;
];

[ Adj_53_t3_v9 ! meaning of "edible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible, true));
    rfalse;
];

[ Adj_54_t3_v9 ! meaning of "inedible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, edible));
    rfalse;
];

[ Adj_55_t3_v9 ! meaning of "fixed in place"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static, true));
    rfalse;
];

[ Adj_56_t3_v9 ! meaning of "portable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, static));
    rfalse;
];

[ Adj_57_t3_v9 ! meaning of "scenery"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, scenery, true));
    rfalse;
];

[ Adj_58_t3_v9 ! meaning of "wearable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, clothing, true));
    rfalse;
];

[ Adj_59_t3_v9 ! meaning of "pushable between rooms"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, pushable, true));
    rfalse;
];

[ Adj_60_t3_v9 ! meaning of "handled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, moved, true));
    rfalse;
];

[ Adj_61_t3_v9 ! meaning of "described"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed));
    rfalse;
];

[ Adj_62_t3_v9 ! meaning of "undescribed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, concealed, true));
    rfalse;
];

[ Adj_63_t3_v9 ! meaning of "marked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag, true));
    rfalse;
];

[ Adj_64_t3_v9 ! meaning of "unmarked for listing"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, workflag));
    rfalse;
];

[ Adj_65_t3_v9 ! meaning of "mentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned, true));
    rfalse;
];

[ Adj_66_t3_v9 ! meaning of "unmentioned"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mentioned));
    rfalse;
];

[ Adj_67_t3_v9 ! meaning of "enterable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, enterable, true));
    rfalse;
];

[ Adj_68_t3_v9 ! meaning of "opaque"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent));
    rfalse;
];

[ Adj_69_t3_v9 ! meaning of "transparent"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, transparent, true));
    rfalse;
];

[ Adj_70_t3_v9 ! meaning of "open"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open, true));
    rfalse;
];

[ Adj_71_t3_v9 ! meaning of "closed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, open));
    rfalse;
];

[ Adj_72_t3_v9 ! meaning of "openable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable, true));
    rfalse;
];

[ Adj_73_t3_v9 ! meaning of "unopenable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, openable));
    rfalse;
];

[ Adj_74_t3_v9 ! meaning of "lockable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, lockable, true));
    rfalse;
];

[ Adj_75_t3_v9 ! meaning of "locked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked, true));
    rfalse;
];

[ Adj_76_t3_v9 ! meaning of "unlocked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, locked));
    rfalse;
];

[ Adj_77_t3_v9 ! meaning of "female"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female, true));
    rfalse;
];

[ Adj_78_t3_v9 ! meaning of "male"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, female));
    rfalse;
];

[ Adj_79_t3_v9 ! meaning of "neuter"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, neuter, true));
    rfalse;
];

[ Adj_80_t3_v9 ! meaning of "switched on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on, true));
    rfalse;
];

[ Adj_81_t3_v9 ! meaning of "switched off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, on));
    rfalse;
];

[ Adj_82_t3_v39 ! meaning of "recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p59_recurring));
    rfalse;
];

[ Adj_83_t3_v39 ! meaning of "non-recurring"

    t_0 ! Call parameter 'it' = scene
    ;
return (WriteGProperty(SCENE_TY, t_0, p59_recurring, true));
    rfalse;
];

[ Adj_84_t3_v9 ! meaning of "stashable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p61_stashable, true));
    rfalse;
];

[ Adj_85_t3_v9 ! meaning of "unstashable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p61_stashable));
    rfalse;
];

[ Adj_86_t3_v9 ! meaning of "CHavailable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p63_chavailable, true));
    rfalse;
];

[ Adj_87_t3_v9 ! meaning of "CHunavailable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p63_chavailable));
    rfalse;
];

[ Adj_88_t3_v9 ! meaning of "CHviable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p65_chviable, true));
    rfalse;
];

[ Adj_89_t3_v9 ! meaning of "CHunviable"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p65_chviable));
    rfalse;
];

[ Adj_90_t3_v9 ! meaning of "dbg_on"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_dbg_on, true));
    rfalse;
];

[ Adj_91_t3_v9 ! meaning of "dbg_off"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p69_dbg_on));
    rfalse;
];

[ Adj_92_t3_v9 ! meaning of "ambiguously plural"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural, true));
    rfalse;
];

[ Adj_93_t3_v9 ! meaning of "ordinarily enumerated"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p71_ambiguously_plural));
    rfalse;
];

[ Adj_94_t3_v9 ! meaning of "examined"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p73_examined, true));
    rfalse;
];

[ Adj_95_t3_v9 ! meaning of "unexamined"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p73_examined));
    rfalse;
];

[ Adj_96_t3_v9 ! meaning of "accessed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_accessed, true));
    rfalse;
];

[ Adj_97_t3_v9 ! meaning of "unaccessed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p75_accessed));
    rfalse;
];

[ Adj_98_t3_v9 ! meaning of "indoors"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p77_indoors, true));
    rfalse;
];

[ Adj_99_t3_v9 ! meaning of "outdoors"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p77_indoors));
    rfalse;
];

[ Adj_100_t3_v9 ! meaning of "pocketed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p79_pocketed, true));
    rfalse;
];

[ Adj_101_t3_v9 ! meaning of "unpocketed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p79_pocketed));
    rfalse;
];

[ Adj_102_t3_v9 ! meaning of "metal"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p81_metal, true));
    rfalse;
];

[ Adj_103_t3_v9 ! meaning of "nonmetal"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p81_metal));
    rfalse;
];

[ Adj_104_t3_v9 ! meaning of "moved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p83_moved, true));
    rfalse;
];

[ Adj_105_t3_v9 ! meaning of "unmoved"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p83_moved));
    rfalse;
];

[ Adj_108_t3_v9 ! meaning of "soft"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p86_soft, true));
    rfalse;
];

[ Adj_109_t3_v9 ! meaning of "hard"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p86_soft));
    rfalse;
];

[ Adj_110_t3_v9 ! meaning of "boaty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p88_boaty, true));
    rfalse;
];

[ Adj_111_t3_v9 ! meaning of "unboaty"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p88_boaty));
    rfalse;
];

[ Adj_112_t3_v9 ! meaning of "peeled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p90_peeled, true));
    rfalse;
];

[ Adj_113_t3_v9 ! meaning of "unpeeled"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p90_peeled));
    rfalse;
];

[ Adj_114_t3_v9 ! meaning of "irked"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p92_irked, true));
    rfalse;
];

[ Adj_115_t3_v9 ! meaning of "calm"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p92_irked));
    rfalse;
];

[ Adj_116_t3_v9 ! meaning of "curious"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p94_curious, true));
    rfalse;
];

[ Adj_117_t3_v9 ! meaning of "incurious"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p94_curious));
    rfalse;
];

[ Adj_118_t3_v9 ! meaning of "plugged"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p96_plugged, true));
    rfalse;
];

[ Adj_119_t3_v9 ! meaning of "unplugged"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p96_plugged));
    rfalse;
];

[ Adj_120_t3_v9 ! meaning of "fixed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p98_fixed, true));
    rfalse;
];

[ Adj_121_t3_v9 ! meaning of "broken"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p98_fixed));
    rfalse;
];

[ Adj_122_t3_v9 ! meaning of "secure"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p100_secure, true));
    rfalse;
];

[ Adj_123_t3_v9 ! meaning of "insecure"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p100_secure));
    rfalse;
];

[ Adj_124_t3_v9 ! meaning of "flipped up"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p102_flipped_up, true));
    rfalse;
];

[ Adj_125_t3_v9 ! meaning of "flipped down"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p102_flipped_up));
    rfalse;
];

[ Adj_126_t3_v9 ! meaning of "important"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p104_important, true));
    rfalse;
];

[ Adj_127_t3_v9 ! meaning of "unimportant"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p104_important));
    rfalse;
];

[ Adj_128_t3_v9 ! meaning of "upside-down"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p106_upside_down, true));
    rfalse;
];

[ Adj_129_t3_v9 ! meaning of "right-side-up"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p106_upside_down));
    rfalse;
];

[ Adj_130_t3_v9 ! meaning of "trapped"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p108_trapped, true));
    rfalse;
];

[ Adj_131_t3_v9 ! meaning of "free"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p108_trapped));
    rfalse;
];

[ Adj_132_t3_v9 ! meaning of "roaming"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p110_roaming, true));
    rfalse;
];

[ Adj_133_t3_v9 ! meaning of "still"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p110_roaming));
    rfalse;
];

[ Adj_134_t3_v9 ! meaning of "keyed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p112_keyed, true));
    rfalse;
];

[ Adj_135_t3_v9 ! meaning of "unkeyed"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p112_keyed));
    rfalse;
];

[ Adj_136_t3_v9 ! meaning of "flooded"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p114_flooded, true));
    rfalse;
];

[ Adj_137_t3_v9 ! meaning of "safe"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p114_flooded));
    rfalse;
];

[ Adj_138_t3_v9 ! meaning of "spinning"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p116_spinning, true));
    rfalse;
];

[ Adj_139_t3_v9 ! meaning of "stopped"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p116_spinning));
    rfalse;
];

[ Adj_140_t3_v9 ! meaning of "accessible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p118_accessible, true));
    rfalse;
];

[ Adj_141_t3_v9 ! meaning of "inaccessible"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p118_accessible));
    rfalse;
];

[ Adj_142_t3_v9 ! meaning of "satisfied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p121_satisfied, true));
    rfalse;
];

[ Adj_143_t3_v9 ! meaning of "unsatisfied"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p121_satisfied));
    rfalse;
];

[ Adj_144_t3_v9 ! meaning of "distracted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p123_distracted, true));
    rfalse;
];

[ Adj_145_t3_v9 ! meaning of "undistracted"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p123_distracted));
    rfalse;
];

[ Adj_146_t3_v9 ! meaning of "asleep"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p125_asleep, true));
    rfalse;
];

[ Adj_147_t3_v9 ! meaning of "awake"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, p125_asleep));
    rfalse;
];

[ Adj_148_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, worn, true));
    rfalse;
];

[ Adj_149_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, absent, true));
    rfalse;
];

[ Adj_150_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_room, true));
    rfalse;
];

[ Adj_151_t3_v9 ! meaning of "<nameless>"

    t_0 ! Call parameter 'it' = object
    ;
  if (t_0) return (SetEitherOrProperty(t_0, mark_as_thing, true));
    rfalse;
];



Array TimedEventsTable table 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;

Array TimedEventTimesTable table 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;



Array rulebooks_array --> B0_procedural B1_startup B2_turn_sequence B3_shutdown B4_scene_changing B5_when_play_begins B6_when_play_ends B7_when_scene_begins B8_when_scene_ends B9_every_turn B10_action_processing B11_setting_action_variables B12_specific_action_processi B13_player_s_action_awarenes B14_accessibility B15_reaching_inside B16_reaching_outside B17_visibility B18_persuasion B19_unsuccessful_attempt_by B20_before B21_instead B22_check B23_carry_out B24_after B25_report B26_does_the_player_mean B27_when_entire_game_begins B28_when_entire_game_ends B29_before_printing_the_name B30_for_printing_the_name B31_after_printing_the_name B32_before_printing_the_plur B33_for_printing_the_plural_ B34_after_printing_the_plura B35_before_printing_a_number B36_for_printing_a_number B37_after_printing_a_number B38_before_printing_room_des B39_for_printing_room_descri B40_after_printing_room_desc B41_before_listing_contents B42_for_listing_contents B43_after_listing_contents B44_before_grouping_together B45_for_grouping_together B46_after_grouping_together B47_before_writing_a_paragra B48_for_writing_a_paragraph_ B49_after_writing_a_paragrap B50_before_listing_nondescri B51_for_listing_nondescript_ B52_after_listing_nondescrip B53_before_printing_the_name B54_for_printing_the_name_of B55_after_printing_the_name_ B56_before_printing_the_desc B57_for_printing_the_descrip B58_after_printing_the_descr B59_before_printing_the_anno B60_for_printing_the_announc B61_after_printing_the_annou B62_before_printing_the_anno B63_for_printing_the_announc B64_after_printing_the_annou B65_before_printing_a_refusa B66_for_printing_a_refusal_t B67_after_printing_a_refusal B68_before_constructing_the_ B69_for_constructing_the_sta B70_after_constructing_the_s B71_before_printing_the_bann B72_for_printing_the_banner_ B73_after_printing_the_banne B74_before_reading_a_command B75_for_reading_a_command B76_after_reading_a_command B77_before_deciding_the_scop B78_for_deciding_the_scope B79_after_deciding_the_scope B80_before_deciding_the_conc B81_for_deciding_the_conceal B82_after_deciding_the_conce B83_before_deciding_whether_ B84_for_deciding_whether_all B85_after_deciding_whether_a B86_before_clarifying_the_pa B87_for_clarifying_the_parse B88_after_clarifying_the_par B89_before_asking_which_do_y B90_for_asking_which_do_you_ B91_after_asking_which_do_yo B92_before_printing_a_parser B93_for_printing_a_parser_er B94_after_printing_a_parser_ B95_before_supplying_a_missi B96_for_supplying_a_missing_ B97_after_supplying_a_missin B98_before_supplying_a_missi B99_for_supplying_a_missing_ B100_after_supplying_a_missi B101_before_implicitly_takin B102_for_implicitly_taking B103_after_implicitly_taking B104_before_starting_the_vir B105_for_starting_the_virtua B106_after_starting_the_virt B107_before_amusing_a_victor B108_for_amusing_a_victoriou B109_after_amusing_a_victori B110_before_printing_the_pla B111_for_printing_the_player B112_after_printing_the_play B113_before_handling_the_fin B114_for_handling_the_final_ B115_after_handling_the_fina B116_before_printing_the_loc B117_for_printing_the_locale B118_after_printing_the_loca B119_before_choosing_notable B120_for_choosing_notable_lo B121_after_choosing_notable_ B122_before_printing_a_local B123_for_printing_a_locale_p B124_after_printing_a_locale B125_check_taking_inventory B126_carry_out_taking_invent B127_report_taking_inventory B128_check_taking B129_carry_out_taking B130_report_taking B131_check_removing_it_from B132_carry_out_removing_it_f B133_report_removing_it_from B134_check_dropping B135_carry_out_dropping B136_report_dropping B137_check_putting_it_on B138_carry_out_putting_it_on B139_report_putting_it_on B140_check_inserting_it_into B141_carry_out_inserting_it_ B142_report_inserting_it_int B143_check_eating B144_carry_out_eating B145_report_eating B146_check_going B147_carry_out_going B148_report_going B149_check_entering B150_carry_out_entering B151_report_entering B152_check_exiting B153_carry_out_exiting B154_report_exiting B155_check_getting_off B156_carry_out_getting_off B157_report_getting_off B158_check_looking B159_carry_out_looking B160_report_looking B161_check_examining B162_carry_out_examining B163_report_examining B164_check_looking_under B165_carry_out_looking_under B166_report_looking_under B167_check_searching B168_carry_out_searching B169_report_searching B170_check_consulting_it_abo B171_carry_out_consulting_it B172_report_consulting_it_ab B173_check_locking_it_with B174_carry_out_locking_it_wi B175_report_locking_it_with B176_check_unlocking_it_with B177_carry_out_unlocking_it_ B178_report_unlocking_it_wit B179_check_switching_on B180_carry_out_switching_on B181_report_switching_on B182_check_switching_off B183_carry_out_switching_off B184_report_switching_off B185_check_opening B186_carry_out_opening B187_report_opening B188_check_closing B189_carry_out_closing B190_report_closing B191_check_wearing B192_carry_out_wearing B193_report_wearing B194_check_taking_off B195_carry_out_taking_off B196_report_taking_off B197_check_giving_it_to B198_carry_out_giving_it_to B199_report_giving_it_to B200_check_showing_it_to B201_carry_out_showing_it_to B202_report_showing_it_to B203_check_waking B204_carry_out_waking B205_report_waking B206_check_throwing_it_at B207_carry_out_throwing_it_a B208_report_throwing_it_at B209_check_attacking B210_carry_out_attacking B211_report_attacking B212_check_kissing B213_carry_out_kissing B214_report_kissing B215_check_answering_it_that B216_carry_out_answering_it_ B217_report_answering_it_tha B218_check_telling_it_about B219_carry_out_telling_it_ab B220_report_telling_it_about B221_check_asking_it_about B222_carry_out_asking_it_abo B223_report_asking_it_about B224_check_asking_it_for B225_carry_out_asking_it_for B226_report_asking_it_for B227_check_waiting B228_carry_out_waiting B229_report_waiting B230_check_touching B231_carry_out_touching B232_report_touching B233_check_waving B234_carry_out_waving B235_report_waving B236_check_pulling B237_carry_out_pulling B238_report_pulling B239_check_pushing B240_carry_out_pushing B241_report_pushing B242_check_turning B243_carry_out_turning B244_report_turning B245_check_pushing_it_to B246_carry_out_pushing_it_to B247_report_pushing_it_to B248_check_squeezing B249_carry_out_squeezing B250_report_squeezing B251_check_saying_yes B252_carry_out_saying_yes B253_report_saying_yes B254_check_saying_no B255_carry_out_saying_no B256_report_saying_no B257_check_burning B258_carry_out_burning B259_report_burning B260_check_waking_up B261_carry_out_waking_up B262_report_waking_up B263_check_thinking B264_carry_out_thinking B265_report_thinking B266_check_smelling B267_carry_out_smelling B268_report_smelling B269_check_listening_to B270_carry_out_listening_to B271_report_listening_to B272_check_tasting B273_carry_out_tasting B274_report_tasting B275_check_cutting B276_carry_out_cutting B277_report_cutting B278_check_jumping B279_carry_out_jumping B280_report_jumping B281_check_tying_it_to B282_carry_out_tying_it_to B283_report_tying_it_to B284_check_drinking B285_carry_out_drinking B286_report_drinking B287_check_saying_sorry B288_carry_out_saying_sorry B289_report_saying_sorry B290_check_swearing_obscenel B291_carry_out_swearing_obsc B292_report_swearing_obscene B293_check_swearing_mildly B294_carry_out_swearing_mild B295_report_swearing_mildly B296_check_swinging B297_carry_out_swinging B298_report_swinging B299_check_rubbing B300_carry_out_rubbing B301_report_rubbing B302_check_setting_it_to B303_carry_out_setting_it_to B304_report_setting_it_to B305_check_waving_hands B306_carry_out_waving_hands B307_report_waving_hands B308_check_buying B309_carry_out_buying B310_report_buying B311_check_singing B312_carry_out_singing B313_report_singing B314_check_climbing B315_carry_out_climbing B316_report_climbing B317_check_sleeping B318_carry_out_sleeping B319_report_sleeping B320_check_quitting_the_game B321_carry_out_quitting_the_ B322_report_quitting_the_gam B323_check_saving_the_game B324_carry_out_saving_the_ga B325_report_saving_the_game B326_check_restoring_the_gam B327_carry_out_restoring_the B328_report_restoring_the_ga B329_check_restarting_the_ga B330_carry_out_restarting_th B331_report_restarting_the_g B332_check_verifying_the_sto B333_carry_out_verifying_the B334_report_verifying_the_st B335_check_switching_the_sto B336_carry_out_switching_the B337_report_switching_the_st B338_check_switching_the_sto B339_carry_out_switching_the B340_report_switching_the_st B341_check_requesting_the_st B342_carry_out_requesting_th B343_report_requesting_the_s B344_check_requesting_the_sc B345_carry_out_requesting_th B346_report_requesting_the_s B347_check_preferring_abbrev B348_carry_out_preferring_ab B349_report_preferring_abbre B350_check_preferring_unabbr B351_carry_out_preferring_un B352_report_preferring_unabb B353_check_preferring_someti B354_carry_out_preferring_so B355_report_preferring_somet B356_check_switching_score_n B357_carry_out_switching_sco B358_report_switching_score_ B359_check_switching_score_n B360_carry_out_switching_sco B361_report_switching_score_ B362_check_requesting_the_pr B363_carry_out_requesting_th B364_report_requesting_the_p B365_check_retreating B366_carry_out_retreating B367_report_retreating B368_check_overly_elaborate_ B369_carry_out_overly_elabor B370_report_overly_elaborate B371_check_listing_exits B372_carry_out_listing_exits B373_report_listing_exits B374_check_using B375_carry_out_using B376_report_using B377_holdall B378_stashing B379_check_mounting B380_carry_out_mounting B381_report_mounting B382_check_dismounting B383_carry_out_dismounting B384_report_dismounting B385_before_refusing_keys B386_for_refusing_keys B387_after_refusing_keys B388_check_unlocking_keyless B389_carry_out_unlocking_key B390_report_unlocking_keyles B391_check_locking_keylessly B392_carry_out_locking_keyle B393_report_locking_keylessl B394_check_universal_unlocki B395_carry_out_universal_unl B396_report_universal_unlock B397_should_the_game_choose B398_should_the_game_suggest B399_bypass_disambiguation B400_check_commenting B401_carry_out_commenting B402_report_commenting B403_check_greeting B404_carry_out_greeting B405_report_greeting B406_check_praying B407_carry_out_praying B408_report_praying B409_check_blowing B410_carry_out_blowing B411_report_blowing B412_check_shouting B413_carry_out_shouting B414_report_shouting B415_check_facing B416_carry_out_facing B417_report_facing B418_check_looking_toward B419_carry_out_looking_towar B420_report_looking_toward B421_check_following B422_carry_out_following B423_report_following B424_check_vehicle_exiting B425_carry_out_vehicle_exiti B426_report_vehicle_exiting B427_check_supporter_exiting B428_carry_out_supporter_exi B429_report_supporter_exitin B430_when_first_pump_begins B431_when_first_pump_ends B432_when_lever_action_begin B433_when_lever_action_ends B434_when_gizmo_action_begin B435_when_gizmo_action_ends B436_when_gadget_action_begi B437_when_gadget_action_ends B438_when_hose_action_begins B439_when_hose_action_ends B440_when_second_pump_begins B441_when_second_pump_ends B442_when_third_pump_begins B443_when_third_pump_ends B444_when_conductor_s_story_ B445_when_conductor_s_story_ B446_when_fourth_pump_begins B447_when_fourth_pump_ends B448_check_liquid_drinking B449_carry_out_liquid_drinki B450_report_liquid_drinking B451_check_filling_it_with B452_carry_out_filling_it_wi B453_report_filling_it_with B454_check_pouring_it_into B455_carry_out_pouring_it_in B456_report_pouring_it_into B457_check_swimming B458_carry_out_swimming B459_report_swimming B460_check_spilling B461_carry_out_spilling B462_report_spilling B463_check_boarding B464_carry_out_boarding B465_report_boarding B466_check_train_waiting B467_carry_out_train_waiting B468_report_train_waiting B469_check_waiting_more B470_carry_out_waiting_more B471_report_waiting_more B472_check_asking_for_help B473_carry_out_asking_for_he B474_report_asking_for_help B475_check_crediting B476_carry_out_crediting B477_report_crediting B478_check_hinting B479_carry_out_hinting B480_report_hinting B481_check_requesting_the_fu B482_carry_out_requesting_th B483_report_requesting_the_f B484_check_xyzzy B485_carry_out_xyzzy B486_report_xyzzy B487_check_knocking_on B488_carry_out_knocking_on B489_report_knocking_on B490_check_wading B491_carry_out_wading B492_report_wading B493_check_rowing B494_carry_out_rowing B495_report_rowing B496_check_dancing B497_carry_out_dancing B498_report_dancing B499_check_rowing_toward B500_carry_out_rowing_toward B501_report_rowing_toward B502_check_looking_up B503_carry_out_looking_up B504_report_looking_up B505_check_plugging_it_with B506_carry_out_plugging_it_w B507_report_plugging_it_with B508_check_tightening B509_carry_out_tightening B510_report_tightening B511_check_lever_examining B512_carry_out_lever_examini B513_report_lever_examining B514_check_switch_examining B515_carry_out_switch_examin B516_report_switch_examining B517_check_gizmo_examining B518_carry_out_gizmo_examini B519_report_gizmo_examining B520_check_flipping B521_carry_out_flipping B522_report_flipping B523_check_shaking B524_carry_out_shaking B525_report_shaking B526_check_playing B527_carry_out_playing B528_report_playing B529_check_prying_it_with B530_carry_out_prying_it_wit B531_report_prying_it_with B532_check_skipping B533_carry_out_skipping B534_report_skipping B535_when_secretary_s_story_ B536_when_secretary_s_story_ B537_check_barking B538_carry_out_barking B539_report_barking B540_check_thing_barking B541_carry_out_thing_barking B542_report_thing_barking B543_check_taking_it_with B544_carry_out_taking_it_wit B545_report_taking_it_with B546_check_magnet_waving B547_carry_out_magnet_waving B548_report_magnet_waving B549_check_typing B550_carry_out_typing B551_report_typing B552_check_boat_examining B553_carry_out_boat_examinin B554_report_boat_examining B555_when_vivian_s_story_beg B556_when_vivian_s_story_end B557_when_endgame_begins B558_when_endgame_ends B559_when_switch_action_begi B560_when_switch_action_ends B561_check_train_moving B562_carry_out_train_moving B563_report_train_moving B564_check_train_examining B565_carry_out_train_examini B566_report_train_examining B567_check_lock_picking B568_carry_out_lock_picking B569_report_lock_picking B570_check_double_lock_picki B571_carry_out_double_lock_p B572_report_double_lock_pick 0;

Constant B0_procedural = EMPTY_RULEBOOK;
Array B1_startup --> INITIALISE_MEMORY_R VIRTUAL_MACHINE_STARTUP_R SEED_RANDOM_NUMBER_GENERATOR_R UPDATE_CHRONOLOGICAL_RECORDS_R POSITION_PLAYER_IN_MODEL_R R_8 R_9 R_10 R_11 R_12 NULL; ! 10 rule(s)
Array B2_turn_sequence --> PARSE_COMMAND_R GENERATE_ACTION_R R_14 R_13 TIMED_EVENTS_R ADVANCE_TIME_R UPDATE_CHRONOLOGICAL_RECORDS_R R_15 ADJUST_LIGHT_R NOTE_OBJECT_ACQUISITIONS_R R_16 NULL; ! 11 rule(s)
Array B3_shutdown --> R_17 RESURRECT_PLAYER_IF_ASKED_R R_18 ASK_FINAL_QUESTION_R NULL; ! 4 rule(s)
Array B4_scene_changing --> DetectSceneChange NULL; ! 1 rule(s)
Array B5_when_play_begins --> R_915 R_1199 R_1200 NULL; ! 3 rule(s)
Constant B6_when_play_ends = EMPTY_RULEBOOK;
Array B7_when_scene_begins --> R_57 NULL; ! 1 rule(s)
Constant B8_when_scene_ends = EMPTY_RULEBOOK;
Array B9_every_turn --> (-2) (-2) 31 R_1187 R_1077 R_1079 R_1553 R_1453 R_1546 R_1565 R_1555 R_1679 R_1680 R_1147 R_1148 R_1149 R_1150 R_1151 R_1152 R_1153 R_1154 R_1343 R_1454 R_1526 R_1608 R_1083 R_1557 R_1686 R_1711 R_1715 R_1716 R_1078 R_1094 R_1095 (-2) 24 R_1096 R_1173 R_1174 R_1201 R_1202 R_1331 R_1342 R_1520 R_1521 R_1544 R_1609 R_1613 R_1614 R_1708 R_1513 R_1514 R_1515 R_1344 R_1470 R_1471 R_1556 R_1566 R_1607 R_1615 NULL; ! 55 rule(s)
Array B10_action_processing --> R_20 R_19 R_21 R_1004 BASIC_VISIBILITY_R BASIC_ACCESSIBILITY_R R_843 R_22 REQUESTED_ACTIONS_REQUIRE_R CARRY_OUT_REQUESTED_ACTIONS_R DESCEND_TO_SPECIFIC_ACTION_R R_23 NULL; ! 12 rule(s)
Array B11_setting_action_variables --> R_137 R_171 R_792 R_159 NULL; ! 4 rule(s)
Array B12_specific_action_processi --> WORK_OUT_DETAILS_OF_SPECIFIC_R R_24 R_25 R_26 R_27 R_28 R_29 R_30 NULL; ! 8 rule(s)
Array B13_player_s_action_awarenes --> R_31 R_32 R_33 R_34 NULL; ! 4 rule(s)
Array B14_accessibility --> ACCESS_THROUGH_BARRIERS_R NULL; ! 1 rule(s)
Array B15_reaching_inside --> R_1136 R_1137 R_1138 R_1374 CANT_REACH_INSIDE_ROOMS_R CANT_REACH_INSIDE_CLOSED_R NULL; ! 6 rule(s)
Array B16_reaching_outside --> CANT_REACH_OUTSIDE_CLOSED_R NULL; ! 1 rule(s)
Array B17_visibility --> R_35 NULL; ! 1 rule(s)
Constant B18_persuasion = EMPTY_RULEBOOK;
Array B19_unsuccessful_attempt_by --> R_805 R_809 NULL; ! 2 rule(s)
Array B20_before --> (-2) ##Go 11 R_1545 R_1382 R_1298 R_1691 R_815 R_1264 R_1385 R_1409 R_1662 R_1384 R_1383 ##Insert R_1446 ##Take R_1490 ##Go 3 R_1140 R_1141 R_1142 ##Take R_1406 (-2) R_1397 ##A127_skipping R_1494 (-2) 2 R_772 R_773 ##Go R_811 ##Insert R_1128 ##Lock 2 R_816 R_812 ##SwitchOn R_1229 ##SwitchOff R_1230 ##Take R_1457 ##A87_locking_keylessly R_817 ##Open R_818 ##Eat R_760 ##Wear R_761 ##A87_locking_keylessly R_813 ##Open R_814 ##Go R_810 ##Enter 2 R_793 R_794 ##GetOff 2 R_795 R_796 ##Go R_1069 ##A104_boarding R_1736 ##Exit R_797 ##A104_boarding R_1146 ##A114_rowing R_1273 ##A116_rowing_toward R_1310 NULL; ! 45 rule(s)
Array B21_instead --> (-2) ##Go 31 R_1600 R_1225 R_1280 R_1293 R_1670 R_1233 R_1234 R_1235 R_1236 R_1294 R_1295 R_1296 R_1599 R_1527 R_1528 R_1669 R_1530 R_1308 R_1543 R_1220 R_1224 R_1252 R_1253 R_1254 R_1255 R_1256 R_1257 R_1258 R_1279 R_1282 R_1287 ##Go 31 R_1289 R_1290 R_1291 R_1314 R_1375 R_1387 R_1388 R_1393 R_1394 R_1395 R_1412 R_1421 R_1426 R_1427 R_1448 R_1449 R_1450 R_1451 R_1452 R_1496 R_1497 R_1498 R_1499 R_1500 R_1501 R_1504 R_1506 R_1511 R_1512 R_1517 R_1518 ##Go 16 R_1559 R_1560 R_1563 R_1564 R_1568 R_1569 R_1629 R_1631 R_1632 R_1633 R_1661 R_1671 R_1674 R_1675 R_1692 R_1695 ##Exit R_1259 ##Go 22 R_1529 R_1292 R_1311 R_1398 R_1415 R_1425 R_1510 R_1539 R_1562 R_1570 R_1605 R_1630 R_1676 R_1696 R_1203 R_1567 R_1386 R_1531 R_1610 R_1611 R_1612 R_1740 ##A102_swimming R_1246 ##Insert R_1456 ##PutOn 2 R_1582 R_1583 ##A130_taking_it_with R_1595 ##PutOn R_1648 ##Insert 4 R_1654 R_1650 R_1436 R_1655 ##A130_taking_it_with 2 R_1587 R_1594 ##A86_unlocking_keylessly 2 R_1268 R_1283 ##Go R_1063 ##Turn 2 R_1641 R_1647 ##A112_knocking_on R_1216 ##Open R_1263 ##A86_unlocking_keylessly 2 R_1269 R_1284 ##Examine R_1241 ##Turn 2 R_1643 R_1646 ##Take R_1649 ##A124_shaking R_1682 ##Take R_1186 ##Drop R_1195 ##Enter R_1221 ##A94_facing 2 R_1222 R_1223 ##Take R_1304 ##Open R_1317 ##Take R_1337 ##Examine R_1373 ##Go R_1465 ##Open R_1575 ##Take R_1577 ##Search R_1597 ##Turn R_1642 ##A94_facing R_1677 ##A124_shaking 2 R_1683 R_1685 ##Disrobe R_1694 ##A94_facing R_1733 (-2) 10 R_1751 R_1572 R_1571 R_1635 R_1636 R_1637 R_1742 R_1461 R_1469 R_1706 ##Take R_1320 (-2) 3 R_1754 R_1700 R_1725 ##Take R_1486 ##Drop R_1196 ##Examine R_1440 ##Drop 2 R_1408 R_1684 ##Go 2 R_1547 R_1061 ##Exit R_1288 ##Jump 2 R_1399 R_1414 (-2) R_1634 ##A102_swimming R_1126 ##Give 3 R_1033 R_1044 R_1045 ##PutOn R_1340 ##Insert R_1424 ##Unlock R_1479 ##A130_taking_it_with R_1589 ##Insert R_1596 ##PutOn R_1659 ##Give 2 R_1748 R_1749 ##Insert 2 R_1475 R_1653 ##PutOn R_1658 ##Give 2 R_1381 R_1750 ##ThrowAt R_1058 ##A101_pouring_it_into R_1122 ##Insert R_1323 ##A101_pouring_it_into R_1325 ##ThrowAt R_1327 ##PutOn R_1339 ##Insert 2 R_1348 R_1349 ##Give R_1380 ##Insert R_1443 ##Give R_1550 ##Insert 3 R_1579 R_1652 R_1709 ##Give R_1747 ##Insert 2 R_1250 R_1656 ##A130_taking_it_with 3 R_1581 R_1590 R_1591 ##PutOn R_841 ##A101_pouring_it_into R_1123 ##Insert R_1124 ##A130_taking_it_with R_1580 ##Show R_1042 ##Insert R_1101 ##A101_pouring_it_into 2 R_1121 R_1245 ##Insert 2 R_1248 R_1249 ##Unlock 3 R_1262 R_1266 R_1350 ##Lock R_1352 ##Remove R_1423 ##Unlock 2 R_1444 R_1477 ##A130_taking_it_with R_1586 ##PutOn R_1592 ##Insert R_1593 ##Unlock R_1729 ##A130_taking_it_with 2 R_1588 R_1585 ##Kiss 2 R_1052 R_1053 ##Attack R_1054 ##A94_facing R_1065 ##Push R_1080 ##Enter R_1144 ##Wave 2 R_1184 R_1185 ##Listen R_1188 ##Take R_1190 ##Rub R_1192 ##Touch R_1193 ##Disrobe R_1213 ##Drink R_1231 ##A124_shaking R_1237 ##Push R_1238 ##Attack R_1239 ##Enter R_1265 ##Take R_1270 ##Touch R_1285 ##Enter R_1286 ##Take 2 R_1300 R_1302 ##Touch 2 R_1306 R_1307 ##Open R_1316 ##Close R_1318 ##Attack R_1321 ##Climb R_1324 ##Touch R_1326 ##A86_unlocking_keylessly R_1351 ##Examine R_1372 ##Attack R_1379 ##Smell 2 R_1389 R_1390 ##Take R_1391 ##Enter R_1392 ##A125_playing R_1401 ##Listen R_1402 ##A124_shaking R_1404 ##Take R_1407 ##Climb 2 R_1410 R_1411 ##Take 2 R_1417 R_1418 ##Climb R_1419 ##Take R_1422 ##Open R_1429 ##Close R_1430 ##Examine R_1431 ##Attack 2 R_1432 R_1433 ##Push R_1434 ##A124_shaking 2 R_1435 R_1437 ##Push R_1438 ##Rub 2 R_1441 R_1442 ##A86_unlocking_keylessly R_1445 ##Enter R_1455 ##Turn R_1460 ##Enter R_1463 ##GetOff R_1464 ##Climb R_1468 ##Drop R_1474 ##Take R_1480 ##Touch R_1481 ##Push R_1482 ##Take R_1491 ##Search R_1502 ##Take R_1503 ##Search R_1505 ##Take R_1507 ##Climb R_1508 ##Take R_1509 ##Touch 2 R_1535 R_1536 ##Enter R_1541 ##Take R_1558 ##Climb R_1561 ##Open R_1573 ##Touch R_1574 ##Examine R_1576 ##Turn R_1598 ##Enter R_1601 ##SwitchOff R_1616 ##Enter R_1625 ##Climb 2 R_1626 R_1628 ##Turn R_1640 ##Push 2 R_1644 R_1645 ##Attack R_1664 ##Take R_1665 ##Attack 3 R_1687 R_1688 R_1689 ##Wave R_1693 ##Touch R_1699 ##Attack R_1712 ##SwitchOn R_1717 ##SwitchOff R_1718 ##Examine R_1726 ##Enter R_1727 ##A86_unlocking_keylessly R_1728 ##Open R_1730 ##Attack R_1753 (-2) 17 R_1242 R_1244 R_1322 R_1371 R_1533 R_1534 R_1538 R_1620 R_1621 R_1622 R_1623 R_1624 R_1522 R_1057 R_1697 R_1698 R_1328 ##GetOff R_751 ##Take R_1319 ##Attack R_1707 ##A112_knocking_on 2 R_1214 R_1215 ##Kiss R_1051 ##Drink 2 R_1110 R_1111 ##Taste 2 R_1112 R_1113 ##Search R_1133 ##Attack R_1217 ##SwitchOn R_1334 ##SwitchOff R_1335 ##Turn 2 R_1355 R_1356 ##Pull R_1367 ##Push R_1368 ##Smell R_1416 ##Cut R_1037 ##Burn R_1038 ##Search R_1041 ##Drink R_1109 ##A125_playing R_1400 ##A124_shaking R_1403 ##Exit 2 R_1062 R_1376 ##Listen R_1181 ##A104_boarding R_1737 ##Exit R_1070 ##Sleep R_1093 ##Exit R_1139 ##Listen R_1180 ##Jump 2 R_1309 R_1330 ##Exit R_1466 ##Jump R_1627 ##Smell R_1667 ##Drink R_1668 ##A117_looking_up R_1678 ##A102_swimming R_1690 ##A104_boarding 2 R_1738 R_1739 (-2) 11 R_1378 R_1672 R_1681 R_1719 R_1377 R_1548 R_1617 R_1618 R_1619 R_1673 R_1743 ##Go R_752 ##Exit R_1281 ##Strong R_1035 ##Mild R_1036 ##Think R_1048 ##A91_praying R_1049 ##A92_blowing R_1050 ##Sing R_1055 ##A93_shouting R_1056 ##A102_swimming R_1127 ##Jump R_1177 ##Smell R_1179 ##Listen R_1182 ##WaveHands R_1183 ##Inv R_1204 ##A113_wading R_1261 ##A117_looking_up R_1313 ##A119_tightening R_1345 ##A129_thing_barking R_1549 ##A131_magnet_waving R_1584 ##A133_boat_examining R_1663 ##A136_lock_picking R_1731 ##A137_double_lock_picking R_1732 ##Sleep R_1755 NULL; ! 433 rule(s)
Constant B22_check = EMPTY_RULEBOOK;
Constant B23_carry_out = EMPTY_RULEBOOK;
Array B24_after --> (-2) ##Look R_1540 ##Go 2 R_1277 R_1315 ##Examine 2 R_1240 R_1473 ##Wear R_1666 ##Open R_1278 ##A123_flipping R_1084 ##Go 3 R_1175 R_1176 R_1297 ##Insert 2 R_1447 R_1073 ##Remove R_1074 ##Insert R_1701 ##A101_pouring_it_into R_1120 ##Unlock 2 R_1267 R_1353 ##SwitchOn R_1081 ##Take 6 R_1168 R_1169 R_1170 R_1171 R_1172 R_1191 ##Examine R_1206 ##SwitchOn R_1226 ##SwitchOff R_1228 ##Examine 2 R_1243 R_1341 ##SwitchOn R_1606 ##Examine R_836 ##SwitchOff R_1075 ##SwitchOn R_1076 ##Examine R_1099 ##SwitchOn R_1347 ##Examine R_1039 ##A104_boarding R_1741 NULL; ! 38 rule(s)
Constant B25_report = EMPTY_RULEBOOK;
Array B26_does_the_player_mean --> R_36 NULL; ! 1 rule(s)
Constant B27_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B28_when_entire_game_ends = EMPTY_RULEBOOK;
Array B29_before_printing_the_name --> R_58 NULL; ! 1 rule(s)
Array B30_for_printing_the_name --> R_1125 STANDARD_NAME_PRINTING_R NULL; ! 2 rule(s)
Array B31_after_printing_the_name --> R_1462 R_1525 R_835 R_1357 R_1358 R_1005 R_939 NULL; ! 7 rule(s)
Constant B32_before_printing_the_plur = EMPTY_RULEBOOK;
Array B33_for_printing_the_plural_ --> R_59 NULL; ! 1 rule(s)
Constant B34_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B35_before_printing_a_number = EMPTY_RULEBOOK;
Array B36_for_printing_a_number --> R_60 NULL; ! 1 rule(s)
Constant B37_after_printing_a_number = EMPTY_RULEBOOK;
Constant B38_before_printing_room_des = EMPTY_RULEBOOK;
Constant B39_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B40_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B41_before_listing_contents = EMPTY_RULEBOOK;
Array B42_for_listing_contents --> STANDARD_CONTENTS_LISTING_R NULL; ! 1 rule(s)
Constant B43_after_listing_contents = EMPTY_RULEBOOK;
Constant B44_before_grouping_together = EMPTY_RULEBOOK;
Constant B45_for_grouping_together = EMPTY_RULEBOOK;
Constant B46_after_grouping_together = EMPTY_RULEBOOK;
Constant B47_before_writing_a_paragra = EMPTY_RULEBOOK;
Constant B48_for_writing_a_paragraph_ = EMPTY_RULEBOOK;
Constant B49_after_writing_a_paragrap = EMPTY_RULEBOOK;
Constant B50_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B51_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B52_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B53_before_printing_the_name = EMPTY_RULEBOOK;
Constant B54_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B55_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B56_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B57_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B58_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B59_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B60_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B61_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B62_before_printing_the_anno = EMPTY_RULEBOOK;
Array B63_for_printing_the_announc --> R_61 NULL; ! 1 rule(s)
Constant B64_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B65_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B66_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B67_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B68_before_constructing_the_ = EMPTY_RULEBOOK;
Array B69_for_constructing_the_sta --> R_1198 NULL; ! 1 rule(s)
Constant B70_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B71_before_printing_the_bann = EMPTY_RULEBOOK;
Constant B72_for_printing_the_banner_ = EMPTY_RULEBOOK;
Array B73_after_printing_the_banne --> R_1160 NULL; ! 1 rule(s)
Constant B74_before_reading_a_command = EMPTY_RULEBOOK;
Constant B75_for_reading_a_command = EMPTY_RULEBOOK;
Constant B76_after_reading_a_command = EMPTY_RULEBOOK;
Constant B77_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B78_for_deciding_the_scope = EMPTY_RULEBOOK;
Array B79_after_deciding_the_scope --> R_1135 R_748 R_750 R_759 R_1134 R_1405 R_1428 R_1724 R_911 NULL; ! 9 rule(s)
Constant B80_before_deciding_the_conc = EMPTY_RULEBOOK;
Constant B81_for_deciding_the_conceal = EMPTY_RULEBOOK;
Constant B82_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B83_before_deciding_whether_ = EMPTY_RULEBOOK;
Array B84_for_deciding_whether_all --> R_62 R_64 R_63 R_913 R_1301 R_844 R_1211 R_1212 NULL; ! 8 rule(s)
Constant B85_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B86_before_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B87_for_clarifying_the_parse = EMPTY_RULEBOOK;
Constant B88_after_clarifying_the_par = EMPTY_RULEBOOK;
Constant B89_before_asking_which_do_y = EMPTY_RULEBOOK;
Constant B90_for_asking_which_do_you_ = EMPTY_RULEBOOK;
Constant B91_after_asking_which_do_yo = EMPTY_RULEBOOK;
Constant B92_before_printing_a_parser = EMPTY_RULEBOOK;
Constant B93_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B94_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B95_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B96_for_supplying_a_missing_ --> R_65 R_66 R_67 R_1040 R_1131 R_1132 R_1143 R_1271 R_148 NULL; ! 9 rule(s)
Constant B97_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B98_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B99_for_supplying_a_missing_ --> R_1197 R_1604 NULL; ! 2 rule(s)
Constant B100_after_supplying_a_missi = EMPTY_RULEBOOK;
Constant B101_before_implicitly_takin = EMPTY_RULEBOOK;
Constant B102_for_implicitly_taking = EMPTY_RULEBOOK;
Constant B103_after_implicitly_taking = EMPTY_RULEBOOK;
Constant B104_before_starting_the_vir = EMPTY_RULEBOOK;
Array B105_for_starting_the_virtua --> ENABLE_GLULX_ACCEL_R NULL; ! 1 rule(s)
Constant B106_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B107_before_amusing_a_victor = EMPTY_RULEBOOK;
Constant B108_for_amusing_a_victoriou = EMPTY_RULEBOOK;
Constant B109_after_amusing_a_victori = EMPTY_RULEBOOK;
Constant B110_before_printing_the_pla = EMPTY_RULEBOOK;
Array B111_for_printing_the_player --> PRINT_OBITUARY_HEADLINE_R PRINT_FINAL_SCORE_R DISPLAY_FINAL_STATUS_LINE_R NULL; ! 3 rule(s)
Constant B112_after_printing_the_play = EMPTY_RULEBOOK;
Array B113_before_handling_the_fin --> R_69 R_68 READ_FINAL_ANSWER_R NULL; ! 3 rule(s)
Array B114_for_handling_the_final_ --> R_70 NULL; ! 1 rule(s)
Constant B115_after_handling_the_fina = EMPTY_RULEBOOK;
Array B116_before_printing_the_loc --> R_73 R_74 NULL; ! 2 rule(s)
Array B117_for_printing_the_locale --> R_75 R_76 NULL; ! 2 rule(s)
Constant B118_after_printing_the_loca = EMPTY_RULEBOOK;
Constant B119_before_choosing_notable = EMPTY_RULEBOOK;
Array B120_for_choosing_notable_lo --> R_77 NULL; ! 1 rule(s)
Constant B121_after_choosing_notable_ = EMPTY_RULEBOOK;
Constant B122_before_printing_a_local = EMPTY_RULEBOOK;
Array B123_for_printing_a_locale_p --> R_78 R_79 R_80 R_81 R_82 R_83 R_85 NULL; ! 7 rule(s)
Constant B124_after_printing_a_locale = EMPTY_RULEBOOK;
Constant B125_check_taking_inventory = EMPTY_RULEBOOK;
Array B126_carry_out_taking_invent --> R_86 R_87 NULL; ! 2 rule(s)
Array B127_report_taking_inventory --> R_88 NULL; ! 1 rule(s)
Array B128_check_taking --> R_1467 R_89 R_90 R_91 R_92 R_93 R_94 R_95 R_96 R_97 R_98 R_787 R_100 NULL; ! 13 rule(s)
Array B129_carry_out_taking --> R_101 NULL; ! 1 rule(s)
Array B130_report_taking --> R_102 NULL; ! 1 rule(s)
Array B131_check_removing_it_from --> R_91 R_103 R_104 R_105 NULL; ! 4 rule(s)
Constant B132_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B133_report_removing_it_from = EMPTY_RULEBOOK;
Array B134_check_dropping --> R_106 R_107 R_108 R_109 R_110 NULL; ! 5 rule(s)
Array B135_carry_out_dropping --> R_111 NULL; ! 1 rule(s)
Array B136_report_dropping --> R_112 NULL; ! 1 rule(s)
Array B137_check_putting_it_on --> R_113 R_114 R_115 R_116 R_842 R_118 R_119 NULL; ! 7 rule(s)
Array B138_carry_out_putting_it_on --> R_120 NULL; ! 1 rule(s)
Array B139_report_putting_it_on --> R_121 R_122 NULL; ! 2 rule(s)
Array B140_check_inserting_it_into --> R_1299 R_123 R_124 R_125 R_126 R_127 R_128 R_129 NULL; ! 8 rule(s)
Array B141_carry_out_inserting_it_ --> R_130 NULL; ! 1 rule(s)
Array B142_report_inserting_it_int --> R_1657 R_131 R_132 NULL; ! 3 rule(s)
Array B143_check_eating --> R_133 R_134 NULL; ! 2 rule(s)
Array B144_carry_out_eating --> R_135 NULL; ! 1 rule(s)
Array B145_report_eating --> R_136 NULL; ! 1 rule(s)
Array B146_check_going --> R_1516 R_1251 R_1413 R_1542 R_139 R_141 R_142 R_143 R_1272 NULL; ! 9 rule(s)
Array B147_carry_out_going --> R_746 R_1276 R_144 R_145 R_146 NULL; ! 5 rule(s)
Array B148_report_going --> R_1552 R_147 NULL; ! 2 rule(s)
Array B149_check_entering --> R_149 R_150 R_151 R_152 R_153 R_154 R_155 NULL; ! 7 rule(s)
Array B150_carry_out_entering --> R_156 NULL; ! 1 rule(s)
Array B151_report_entering --> R_1734 R_1735 R_157 R_158 NULL; ! 4 rule(s)
Array B152_check_exiting --> R_742 R_161 R_162 R_163 NULL; ! 4 rule(s)
Array B153_carry_out_exiting --> R_164 NULL; ! 1 rule(s)
Array B154_report_exiting --> R_165 R_166 NULL; ! 2 rule(s)
Array B155_check_getting_off --> R_745 NULL; ! 1 rule(s)
Array B156_carry_out_getting_off --> R_168 NULL; ! 1 rule(s)
Array B157_report_getting_off --> R_169 R_170 NULL; ! 2 rule(s)
Constant B158_check_looking = EMPTY_RULEBOOK;
Array B159_carry_out_looking --> R_172 R_173 R_174 R_175 NULL; ! 4 rule(s)
Array B160_report_looking --> R_176 NULL; ! 1 rule(s)
Constant B161_check_examining = EMPTY_RULEBOOK;
Array B162_carry_out_examining --> R_177 R_178 R_179 R_180 R_181 R_182 NULL; ! 6 rule(s)
Array B163_report_examining --> R_183 NULL; ! 1 rule(s)
Constant B164_check_looking_under = EMPTY_RULEBOOK;
Array B165_carry_out_looking_under --> R_184 NULL; ! 1 rule(s)
Array B166_report_looking_under --> R_185 NULL; ! 1 rule(s)
Array B167_check_searching --> R_186 R_187 NULL; ! 2 rule(s)
Constant B168_carry_out_searching = EMPTY_RULEBOOK;
Array B169_report_searching --> R_188 R_189 R_190 NULL; ! 3 rule(s)
Constant B170_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B171_carry_out_consulting_it = EMPTY_RULEBOOK;
Array B172_report_consulting_it_ab --> R_191 NULL; ! 1 rule(s)
Array B173_check_locking_it_with --> R_192 R_193 R_194 R_824 R_829 NULL; ! 5 rule(s)
Array B174_carry_out_locking_it_wi --> R_839 R_196 NULL; ! 2 rule(s)
Array B175_report_locking_it_with --> R_1047 R_840 R_197 NULL; ! 3 rule(s)
Array B176_check_unlocking_it_with --> R_198 R_199 R_824 R_823 NULL; ! 4 rule(s)
Array B177_carry_out_unlocking_it_ --> R_837 R_201 NULL; ! 2 rule(s)
Array B178_report_unlocking_it_wit --> R_1046 R_838 R_202 NULL; ! 3 rule(s)
Array B179_check_switching_on --> R_1346 R_203 R_204 NULL; ! 3 rule(s)
Array B180_carry_out_switching_on --> R_205 NULL; ! 1 rule(s)
Array B181_report_switching_on --> R_206 NULL; ! 1 rule(s)
Array B182_check_switching_off --> R_207 R_208 NULL; ! 2 rule(s)
Array B183_carry_out_switching_off --> R_209 NULL; ! 1 rule(s)
Array B184_report_switching_off --> R_210 NULL; ! 1 rule(s)
Array B185_check_opening --> R_1483 R_211 R_212 R_213 NULL; ! 4 rule(s)
Array B186_carry_out_opening --> R_214 NULL; ! 1 rule(s)
Array B187_report_opening --> R_1439 R_1752 R_215 R_216 NULL; ! 4 rule(s)
Array B188_check_closing --> R_217 R_218 NULL; ! 2 rule(s)
Array B189_carry_out_closing --> R_219 NULL; ! 1 rule(s)
Array B190_report_closing --> R_220 NULL; ! 1 rule(s)
Array B191_check_wearing --> R_221 R_222 R_223 NULL; ! 3 rule(s)
Array B192_carry_out_wearing --> R_224 NULL; ! 1 rule(s)
Array B193_report_wearing --> R_225 NULL; ! 1 rule(s)
Array B194_check_taking_off --> R_226 NULL; ! 1 rule(s)
Array B195_carry_out_taking_off --> R_227 NULL; ! 1 rule(s)
Array B196_report_taking_off --> R_228 NULL; ! 1 rule(s)
Array B197_check_giving_it_to --> R_229 R_230 R_231 R_232 R_233 NULL; ! 5 rule(s)
Array B198_carry_out_giving_it_to --> R_234 NULL; ! 1 rule(s)
Array B199_report_giving_it_to --> R_235 NULL; ! 1 rule(s)
Array B200_check_showing_it_to --> R_236 R_237 R_238 NULL; ! 3 rule(s)
Constant B201_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B202_report_showing_it_to = EMPTY_RULEBOOK;
Array B203_check_waking --> R_239 NULL; ! 1 rule(s)
Constant B204_carry_out_waking = EMPTY_RULEBOOK;
Constant B205_report_waking = EMPTY_RULEBOOK;
Array B206_check_throwing_it_at --> R_240 R_241 R_242 NULL; ! 3 rule(s)
Array B207_carry_out_throwing_it_a --> R_1194 NULL; ! 1 rule(s)
Constant B208_report_throwing_it_at = EMPTY_RULEBOOK;
Array B209_check_attacking --> R_243 NULL; ! 1 rule(s)
Constant B210_carry_out_attacking = EMPTY_RULEBOOK;
Constant B211_report_attacking = EMPTY_RULEBOOK;
Array B212_check_kissing --> R_244 R_245 NULL; ! 2 rule(s)
Constant B213_carry_out_kissing = EMPTY_RULEBOOK;
Constant B214_report_kissing = EMPTY_RULEBOOK;
Constant B215_check_answering_it_that = EMPTY_RULEBOOK;
Constant B216_carry_out_answering_it_ = EMPTY_RULEBOOK;
Array B217_report_answering_it_tha --> R_246 NULL; ! 1 rule(s)
Array B218_check_telling_it_about --> R_247 NULL; ! 1 rule(s)
Constant B219_carry_out_telling_it_ab = EMPTY_RULEBOOK;
Array B220_report_telling_it_about --> R_248 NULL; ! 1 rule(s)
Constant B221_check_asking_it_about = EMPTY_RULEBOOK;
Constant B222_carry_out_asking_it_abo = EMPTY_RULEBOOK;
Array B223_report_asking_it_about --> R_249 NULL; ! 1 rule(s)
Array B224_check_asking_it_for --> R_250 R_251 NULL; ! 2 rule(s)
Constant B225_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B226_report_asking_it_for = EMPTY_RULEBOOK;
Constant B227_check_waiting = EMPTY_RULEBOOK;
Constant B228_carry_out_waiting = EMPTY_RULEBOOK;
Array B229_report_waiting --> R_252 NULL; ! 1 rule(s)
Constant B230_check_touching = EMPTY_RULEBOOK;
Constant B231_carry_out_touching = EMPTY_RULEBOOK;
Array B232_report_touching --> R_253 R_254 R_255 NULL; ! 3 rule(s)
Array B233_check_waving --> R_256 NULL; ! 1 rule(s)
Constant B234_carry_out_waving = EMPTY_RULEBOOK;
Array B235_report_waving --> R_257 NULL; ! 1 rule(s)
Array B236_check_pulling --> R_258 R_259 R_260 NULL; ! 3 rule(s)
Constant B237_carry_out_pulling = EMPTY_RULEBOOK;
Array B238_report_pulling --> R_261 NULL; ! 1 rule(s)
Array B239_check_pushing --> R_262 R_263 R_264 NULL; ! 3 rule(s)
Constant B240_carry_out_pushing = EMPTY_RULEBOOK;
Array B241_report_pushing --> R_265 NULL; ! 1 rule(s)
Array B242_check_turning --> R_1459 R_266 R_267 R_268 NULL; ! 4 rule(s)
Constant B243_carry_out_turning = EMPTY_RULEBOOK;
Array B244_report_turning --> R_269 NULL; ! 1 rule(s)
Array B245_check_pushing_it_to --> R_270 R_271 R_272 R_273 R_274 NULL; ! 5 rule(s)
Constant B246_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B247_report_pushing_it_to = EMPTY_RULEBOOK;
Array B248_check_squeezing --> R_275 NULL; ! 1 rule(s)
Constant B249_carry_out_squeezing = EMPTY_RULEBOOK;
Array B250_report_squeezing --> R_276 NULL; ! 1 rule(s)
Array B251_check_saying_yes --> R_277 NULL; ! 1 rule(s)
Constant B252_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B253_report_saying_yes = EMPTY_RULEBOOK;
Array B254_check_saying_no --> R_278 NULL; ! 1 rule(s)
Constant B255_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B256_report_saying_no = EMPTY_RULEBOOK;
Array B257_check_burning --> R_279 NULL; ! 1 rule(s)
Constant B258_carry_out_burning = EMPTY_RULEBOOK;
Constant B259_report_burning = EMPTY_RULEBOOK;
Array B260_check_waking_up --> R_280 NULL; ! 1 rule(s)
Constant B261_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B262_report_waking_up = EMPTY_RULEBOOK;
Array B263_check_thinking --> R_281 NULL; ! 1 rule(s)
Constant B264_carry_out_thinking = EMPTY_RULEBOOK;
Constant B265_report_thinking = EMPTY_RULEBOOK;
Array B266_check_smelling --> R_282 NULL; ! 1 rule(s)
Constant B267_carry_out_smelling = EMPTY_RULEBOOK;
Constant B268_report_smelling = EMPTY_RULEBOOK;
Array B269_check_listening_to --> R_283 NULL; ! 1 rule(s)
Constant B270_carry_out_listening_to = EMPTY_RULEBOOK;
Constant B271_report_listening_to = EMPTY_RULEBOOK;
Array B272_check_tasting --> R_284 NULL; ! 1 rule(s)
Constant B273_carry_out_tasting = EMPTY_RULEBOOK;
Constant B274_report_tasting = EMPTY_RULEBOOK;
Array B275_check_cutting --> R_285 NULL; ! 1 rule(s)
Constant B276_carry_out_cutting = EMPTY_RULEBOOK;
Constant B277_report_cutting = EMPTY_RULEBOOK;
Array B278_check_jumping --> R_286 NULL; ! 1 rule(s)
Constant B279_carry_out_jumping = EMPTY_RULEBOOK;
Constant B280_report_jumping = EMPTY_RULEBOOK;
Array B281_check_tying_it_to --> R_287 NULL; ! 1 rule(s)
Constant B282_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B283_report_tying_it_to = EMPTY_RULEBOOK;
Array B284_check_drinking --> R_288 NULL; ! 1 rule(s)
Constant B285_carry_out_drinking = EMPTY_RULEBOOK;
Constant B286_report_drinking = EMPTY_RULEBOOK;
Array B287_check_saying_sorry --> R_289 NULL; ! 1 rule(s)
Constant B288_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B289_report_saying_sorry = EMPTY_RULEBOOK;
Array B290_check_swearing_obscenel --> R_290 NULL; ! 1 rule(s)
Constant B291_carry_out_swearing_obsc = EMPTY_RULEBOOK;
Constant B292_report_swearing_obscene = EMPTY_RULEBOOK;
Array B293_check_swearing_mildly --> R_291 NULL; ! 1 rule(s)
Constant B294_carry_out_swearing_mild = EMPTY_RULEBOOK;
Constant B295_report_swearing_mildly = EMPTY_RULEBOOK;
Array B296_check_swinging --> R_292 NULL; ! 1 rule(s)
Constant B297_carry_out_swinging = EMPTY_RULEBOOK;
Constant B298_report_swinging = EMPTY_RULEBOOK;
Array B299_check_rubbing --> R_293 NULL; ! 1 rule(s)
Constant B300_carry_out_rubbing = EMPTY_RULEBOOK;
Constant B301_report_rubbing = EMPTY_RULEBOOK;
Array B302_check_setting_it_to --> R_294 NULL; ! 1 rule(s)
Constant B303_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B304_report_setting_it_to = EMPTY_RULEBOOK;
Array B305_check_waving_hands --> R_295 NULL; ! 1 rule(s)
Constant B306_carry_out_waving_hands = EMPTY_RULEBOOK;
Constant B307_report_waving_hands = EMPTY_RULEBOOK;
Array B308_check_buying --> R_296 NULL; ! 1 rule(s)
Constant B309_carry_out_buying = EMPTY_RULEBOOK;
Constant B310_report_buying = EMPTY_RULEBOOK;
Array B311_check_singing --> R_297 NULL; ! 1 rule(s)
Constant B312_carry_out_singing = EMPTY_RULEBOOK;
Constant B313_report_singing = EMPTY_RULEBOOK;
Array B314_check_climbing --> R_1247 R_298 NULL; ! 2 rule(s)
Constant B315_carry_out_climbing = EMPTY_RULEBOOK;
Constant B316_report_climbing = EMPTY_RULEBOOK;
Constant B317_check_sleeping = EMPTY_RULEBOOK;
Constant B318_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B319_report_sleeping = EMPTY_RULEBOOK;
Constant B320_check_quitting_the_game = EMPTY_RULEBOOK;
Array B321_carry_out_quitting_the_ --> QUIT_THE_GAME_R NULL; ! 1 rule(s)
Constant B322_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B323_check_saving_the_game = EMPTY_RULEBOOK;
Array B324_carry_out_saving_the_ga --> SAVE_THE_GAME_R NULL; ! 1 rule(s)
Constant B325_report_saving_the_game = EMPTY_RULEBOOK;
Constant B326_check_restoring_the_gam = EMPTY_RULEBOOK;
Array B327_carry_out_restoring_the --> RESTORE_THE_GAME_R NULL; ! 1 rule(s)
Constant B328_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B329_check_restarting_the_ga = EMPTY_RULEBOOK;
Array B330_carry_out_restarting_th --> RESTART_THE_GAME_R NULL; ! 1 rule(s)
Constant B331_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B332_check_verifying_the_sto = EMPTY_RULEBOOK;
Array B333_carry_out_verifying_the --> VERIFY_THE_STORY_FILE_R NULL; ! 1 rule(s)
Constant B334_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B335_check_switching_the_sto = EMPTY_RULEBOOK;
Array B336_carry_out_switching_the --> SWITCH_TRANSCRIPT_ON_R NULL; ! 1 rule(s)
Constant B337_report_switching_the_st = EMPTY_RULEBOOK;
Constant B338_check_switching_the_sto = EMPTY_RULEBOOK;
Array B339_carry_out_switching_the --> SWITCH_TRANSCRIPT_OFF_R NULL; ! 1 rule(s)
Constant B340_report_switching_the_st = EMPTY_RULEBOOK;
Constant B341_check_requesting_the_st = EMPTY_RULEBOOK;
Array B342_carry_out_requesting_th --> ANNOUNCE_STORY_FILE_VERSION_R NULL; ! 1 rule(s)
Constant B343_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B344_check_requesting_the_sc = EMPTY_RULEBOOK;
Array B345_carry_out_requesting_th --> R_1165 NULL; ! 1 rule(s)
Constant B346_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B347_check_preferring_abbrev = EMPTY_RULEBOOK;
Array B348_carry_out_preferring_ab --> PREFER_ABBREVIATED_R NULL; ! 1 rule(s)
Array B349_report_preferring_abbre --> REP_PREFER_ABBREVIATED_R NULL; ! 1 rule(s)
Constant B350_check_preferring_unabbr = EMPTY_RULEBOOK;
Array B351_carry_out_preferring_un --> PREFER_UNABBREVIATED_R NULL; ! 1 rule(s)
Array B352_report_preferring_unabb --> REP_PREFER_UNABBREVIATED_R NULL; ! 1 rule(s)
Constant B353_check_preferring_someti = EMPTY_RULEBOOK;
Array B354_carry_out_preferring_so --> PREFER_SOMETIMES_ABBREVIATED_R NULL; ! 1 rule(s)
Array B355_report_preferring_somet --> REP_PREFER_SOMETIMES_ABBR_R NULL; ! 1 rule(s)
Constant B356_check_switching_score_n = EMPTY_RULEBOOK;
Array B357_carry_out_switching_sco --> SWITCH_SCORE_NOTIFY_ON_R NULL; ! 1 rule(s)
Array B358_report_switching_score_ --> REP_SWITCH_NOTIFY_ON_R NULL; ! 1 rule(s)
Constant B359_check_switching_score_n = EMPTY_RULEBOOK;
Array B360_carry_out_switching_sco --> SWITCH_SCORE_NOTIFY_OFF_R NULL; ! 1 rule(s)
Array B361_report_switching_score_ --> REP_SWITCH_NOTIFY_OFF_R NULL; ! 1 rule(s)
Constant B362_check_requesting_the_pr = EMPTY_RULEBOOK;
Array B363_carry_out_requesting_th --> ANNOUNCE_PRONOUN_MEANINGS_R NULL; ! 1 rule(s)
Constant B364_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B365_check_retreating = EMPTY_RULEBOOK;
Array B366_carry_out_retreating --> R_747 NULL; ! 1 rule(s)
Constant B367_report_retreating = EMPTY_RULEBOOK;
Constant B368_check_overly_elaborate_ = EMPTY_RULEBOOK;
Array B369_carry_out_overly_elabor --> R_749 NULL; ! 1 rule(s)
Constant B370_report_overly_elaborate = EMPTY_RULEBOOK;
Constant B371_check_listing_exits = EMPTY_RULEBOOK;
Array B372_carry_out_listing_exits --> R_754 NULL; ! 1 rule(s)
Array B373_report_listing_exits --> R_755 R_756 R_757 NULL; ! 3 rule(s)
Constant B374_check_using = EMPTY_RULEBOOK;
Array B375_carry_out_using --> R_762 NULL; ! 1 rule(s)
Constant B376_report_using = EMPTY_RULEBOOK;
Array B377_holdall --> R_776 R_775 R_1205 R_777 R_778 R_779 NULL; ! 6 rule(s)
Array B378_stashing --> R_782 R_1208 R_1209 R_1210 R_783 R_784 R_785 R_1207 R_786 NULL; ! 9 rule(s)
Array B379_check_mounting --> R_798 R_799 R_800 R_801 R_802 NULL; ! 5 rule(s)
Array B380_carry_out_mounting --> R_803 NULL; ! 1 rule(s)
Array B381_report_mounting --> R_804 NULL; ! 1 rule(s)
Array B382_check_dismounting --> R_806 NULL; ! 1 rule(s)
Array B383_carry_out_dismounting --> R_807 NULL; ! 1 rule(s)
Array B384_report_dismounting --> R_808 NULL; ! 1 rule(s)
Constant B385_before_refusing_keys = EMPTY_RULEBOOK;
Array B386_for_refusing_keys --> R_821 NULL; ! 1 rule(s)
Constant B387_after_refusing_keys = EMPTY_RULEBOOK;
Array B388_check_unlocking_keyless --> R_827 R_825 NULL; ! 2 rule(s)
Array B389_carry_out_unlocking_key --> R_828 R_826 NULL; ! 2 rule(s)
Constant B390_report_unlocking_keyles = EMPTY_RULEBOOK;
Array B391_check_locking_keylessly --> R_832 R_830 NULL; ! 2 rule(s)
Array B392_carry_out_locking_keyle --> R_833 R_831 NULL; ! 2 rule(s)
Constant B393_report_locking_keylessl = EMPTY_RULEBOOK;
Constant B394_check_universal_unlocki = EMPTY_RULEBOOK;
Array B395_carry_out_universal_unl --> R_851 NULL; ! 1 rule(s)
Array B396_report_universal_unlock --> R_852 NULL; ! 1 rule(s)
Array B397_should_the_game_choose --> (-2) (-2) R_1107 ##Take R_1485 ##A130_taking_it_with R_1105 ##A100_filling_it_with R_1106 ##A130_taking_it_with R_1578 ##PutOn R_1660 (-2) R_1489 ##A101_pouring_it_into R_1104 ##Examine R_1227 ##Drink R_1232 ##A116_rowing_toward R_1312 ##Examine R_1332 ##SwitchOn R_1333 ##Take R_1484 ##Disrobe R_1488 ##Turn R_1639 (-2) 11 R_1329 R_1189 R_1260 R_1305 R_1354 R_1365 R_1366 R_1472 R_1537 R_1638 R_1651 ##A103_spilling R_1114 ##Disrobe 2 R_1420 R_1487 ##A127_skipping R_1493 NULL; ! 31 rule(s)
Array B398_should_the_game_suggest --> (-2) (-2) R_903 ##Remove R_901 ##PutOn R_898 ##Insert R_897 ##PutOn R_896 ##Insert R_895 ##Drop R_888 ##Give R_899 ##Show R_868 ##Give R_869 ##PutOn R_892 ##Insert R_893 ##PutOn R_894 ##Show R_870 ##Give R_871 ##Remove R_900 ##Insert 2 R_889 R_891 ##Remove R_902 ##Unlock R_874 ##Lock R_875 (-2) 2 R_912 R_1458 ##Take 2 R_880 R_881 ##Drop R_887 ##Take 4 R_886 R_882 R_883 R_885 ##Close R_872 ##Open R_873 ##Enter R_876 ##GetOff R_877 ##Wear R_878 ##Eat R_879 ##PutOn R_890 ##Take R_884 NULL; ! 38 rule(s)
Constant B399_bypass_disambiguation = EMPTY_RULEBOOK;
Constant B400_check_commenting = EMPTY_RULEBOOK;
Array B401_carry_out_commenting --> R_1034 NULL; ! 1 rule(s)
Constant B402_report_commenting = EMPTY_RULEBOOK;
Constant B403_check_greeting = EMPTY_RULEBOOK;
Array B404_carry_out_greeting --> R_1043 NULL; ! 1 rule(s)
Constant B405_report_greeting = EMPTY_RULEBOOK;
Constant B406_check_praying = EMPTY_RULEBOOK;
Constant B407_carry_out_praying = EMPTY_RULEBOOK;
Constant B408_report_praying = EMPTY_RULEBOOK;
Constant B409_check_blowing = EMPTY_RULEBOOK;
Constant B410_carry_out_blowing = EMPTY_RULEBOOK;
Constant B411_report_blowing = EMPTY_RULEBOOK;
Constant B412_check_shouting = EMPTY_RULEBOOK;
Constant B413_carry_out_shouting = EMPTY_RULEBOOK;
Constant B414_report_shouting = EMPTY_RULEBOOK;
Constant B415_check_facing = EMPTY_RULEBOOK;
Array B416_carry_out_facing --> R_1064 NULL; ! 1 rule(s)
Constant B417_report_facing = EMPTY_RULEBOOK;
Constant B418_check_looking_toward = EMPTY_RULEBOOK;
Array B419_carry_out_looking_towar --> R_1066 NULL; ! 1 rule(s)
Constant B420_report_looking_toward = EMPTY_RULEBOOK;
Array B421_check_following --> R_1067 NULL; ! 1 rule(s)
Array B422_carry_out_following --> R_1068 NULL; ! 1 rule(s)
Constant B423_report_following = EMPTY_RULEBOOK;
Constant B424_check_vehicle_exiting = EMPTY_RULEBOOK;
Array B425_carry_out_vehicle_exiti --> R_1072 NULL; ! 1 rule(s)
Constant B426_report_vehicle_exiting = EMPTY_RULEBOOK;
Constant B427_check_supporter_exiting = EMPTY_RULEBOOK;
Array B428_carry_out_supporter_exi --> R_1071 NULL; ! 1 rule(s)
Constant B429_report_supporter_exitin = EMPTY_RULEBOOK;
Array B430_when_first_pump_begins --> R_1082 NULL; ! 1 rule(s)
Constant B431_when_first_pump_ends = EMPTY_RULEBOOK;
Array B432_when_lever_action_begin --> R_1085 NULL; ! 1 rule(s)
Constant B433_when_lever_action_ends = EMPTY_RULEBOOK;
Array B434_when_gizmo_action_begin --> R_1086 NULL; ! 1 rule(s)
Constant B435_when_gizmo_action_ends = EMPTY_RULEBOOK;
Array B436_when_gadget_action_begi --> R_1087 NULL; ! 1 rule(s)
Constant B437_when_gadget_action_ends = EMPTY_RULEBOOK;
Array B438_when_hose_action_begins --> R_1088 NULL; ! 1 rule(s)
Constant B439_when_hose_action_ends = EMPTY_RULEBOOK;
Array B440_when_second_pump_begins --> R_1089 NULL; ! 1 rule(s)
Constant B441_when_second_pump_ends = EMPTY_RULEBOOK;
Array B442_when_third_pump_begins --> R_1090 NULL; ! 1 rule(s)
Constant B443_when_third_pump_ends = EMPTY_RULEBOOK;
Array B444_when_conductor_s_story_ --> R_1091 NULL; ! 1 rule(s)
Constant B445_when_conductor_s_story_ = EMPTY_RULEBOOK;
Array B446_when_fourth_pump_begins --> R_1098 NULL; ! 1 rule(s)
Constant B447_when_fourth_pump_ends = EMPTY_RULEBOOK;
Constant B448_check_liquid_drinking = EMPTY_RULEBOOK;
Array B449_carry_out_liquid_drinki --> R_1108 NULL; ! 1 rule(s)
Constant B450_report_liquid_drinking = EMPTY_RULEBOOK;
Constant B451_check_filling_it_with = EMPTY_RULEBOOK;
Array B452_carry_out_filling_it_wi --> R_1115 NULL; ! 1 rule(s)
Constant B453_report_filling_it_with = EMPTY_RULEBOOK;
Array B454_check_pouring_it_into --> R_1116 NULL; ! 1 rule(s)
Array B455_carry_out_pouring_it_in --> R_1119 R_1117 NULL; ! 2 rule(s)
Array B456_report_pouring_it_into --> R_1118 NULL; ! 1 rule(s)
Constant B457_check_swimming = EMPTY_RULEBOOK;
Constant B458_carry_out_swimming = EMPTY_RULEBOOK;
Constant B459_report_swimming = EMPTY_RULEBOOK;
Array B460_check_spilling --> R_1129 NULL; ! 1 rule(s)
Array B461_carry_out_spilling --> R_1130 NULL; ! 1 rule(s)
Constant B462_report_spilling = EMPTY_RULEBOOK;
Constant B463_check_boarding = EMPTY_RULEBOOK;
Array B464_carry_out_boarding --> R_1145 NULL; ! 1 rule(s)
Constant B465_report_boarding = EMPTY_RULEBOOK;
Array B466_check_train_waiting --> R_1155 NULL; ! 1 rule(s)
Array B467_carry_out_train_waiting --> R_1156 NULL; ! 1 rule(s)
Constant B468_report_train_waiting = EMPTY_RULEBOOK;
Array B469_check_waiting_more --> R_1159 NULL; ! 1 rule(s)
Array B470_carry_out_waiting_more --> R_1157 NULL; ! 1 rule(s)
Array B471_report_waiting_more --> R_1158 NULL; ! 1 rule(s)
Constant B472_check_asking_for_help = EMPTY_RULEBOOK;
Array B473_carry_out_asking_for_he --> R_1161 NULL; ! 1 rule(s)
Constant B474_report_asking_for_help = EMPTY_RULEBOOK;
Constant B475_check_crediting = EMPTY_RULEBOOK;
Array B476_carry_out_crediting --> R_1162 NULL; ! 1 rule(s)
Constant B477_report_crediting = EMPTY_RULEBOOK;
Constant B478_check_hinting = EMPTY_RULEBOOK;
Array B479_carry_out_hinting --> R_1163 NULL; ! 1 rule(s)
Constant B480_report_hinting = EMPTY_RULEBOOK;
Constant B481_check_requesting_the_fu = EMPTY_RULEBOOK;
Array B482_carry_out_requesting_th --> R_1167 NULL; ! 1 rule(s)
Constant B483_report_requesting_the_f = EMPTY_RULEBOOK;
Constant B484_check_xyzzy = EMPTY_RULEBOOK;
Array B485_carry_out_xyzzy --> R_1178 NULL; ! 1 rule(s)
Constant B486_report_xyzzy = EMPTY_RULEBOOK;
Constant B487_check_knocking_on = EMPTY_RULEBOOK;
Constant B488_carry_out_knocking_on = EMPTY_RULEBOOK;
Array B489_report_knocking_on --> R_1218 R_1219 NULL; ! 2 rule(s)
Constant B490_check_wading = EMPTY_RULEBOOK;
Constant B491_carry_out_wading = EMPTY_RULEBOOK;
Constant B492_report_wading = EMPTY_RULEBOOK;
Array B493_check_rowing --> R_1274 NULL; ! 1 rule(s)
Array B494_carry_out_rowing --> R_1275 NULL; ! 1 rule(s)
Constant B495_report_rowing = EMPTY_RULEBOOK;
Constant B496_check_dancing = EMPTY_RULEBOOK;
Array B497_carry_out_dancing --> R_1303 NULL; ! 1 rule(s)
Constant B498_report_dancing = EMPTY_RULEBOOK;
Constant B499_check_rowing_toward = EMPTY_RULEBOOK;
Constant B500_carry_out_rowing_toward = EMPTY_RULEBOOK;
Constant B501_report_rowing_toward = EMPTY_RULEBOOK;
Constant B502_check_looking_up = EMPTY_RULEBOOK;
Constant B503_carry_out_looking_up = EMPTY_RULEBOOK;
Constant B504_report_looking_up = EMPTY_RULEBOOK;
Array B505_check_plugging_it_with --> R_1336 NULL; ! 1 rule(s)
Array B506_carry_out_plugging_it_w --> R_1338 NULL; ! 1 rule(s)
Constant B507_report_plugging_it_with = EMPTY_RULEBOOK;
Constant B508_check_tightening = EMPTY_RULEBOOK;
Constant B509_carry_out_tightening = EMPTY_RULEBOOK;
Constant B510_report_tightening = EMPTY_RULEBOOK;
Array B511_check_lever_examining --> R_1359 NULL; ! 1 rule(s)
Array B512_carry_out_lever_examini --> R_1362 NULL; ! 1 rule(s)
Constant B513_report_lever_examining = EMPTY_RULEBOOK;
Array B514_check_switch_examining --> R_1361 NULL; ! 1 rule(s)
Array B515_carry_out_switch_examin --> R_1363 NULL; ! 1 rule(s)
Constant B516_report_switch_examining = EMPTY_RULEBOOK;
Array B517_check_gizmo_examining --> R_1360 NULL; ! 1 rule(s)
Array B518_carry_out_gizmo_examini --> R_1364 NULL; ! 1 rule(s)
Constant B519_report_gizmo_examining = EMPTY_RULEBOOK;
Array B520_check_flipping --> R_1369 NULL; ! 1 rule(s)
Array B521_carry_out_flipping --> R_1370 NULL; ! 1 rule(s)
Constant B522_report_flipping = EMPTY_RULEBOOK;
Constant B523_check_shaking = EMPTY_RULEBOOK;
Constant B524_carry_out_shaking = EMPTY_RULEBOOK;
Constant B525_report_shaking = EMPTY_RULEBOOK;
Constant B526_check_playing = EMPTY_RULEBOOK;
Constant B527_carry_out_playing = EMPTY_RULEBOOK;
Constant B528_report_playing = EMPTY_RULEBOOK;
Array B529_check_prying_it_with --> R_1478 NULL; ! 1 rule(s)
Array B530_carry_out_prying_it_wit --> R_1476 NULL; ! 1 rule(s)
Constant B531_report_prying_it_with = EMPTY_RULEBOOK;
Array B532_check_skipping --> R_1492 NULL; ! 1 rule(s)
Array B533_carry_out_skipping --> R_1495 NULL; ! 1 rule(s)
Constant B534_report_skipping = EMPTY_RULEBOOK;
Array B535_when_secretary_s_story_ --> R_1523 NULL; ! 1 rule(s)
Constant B536_when_secretary_s_story_ = EMPTY_RULEBOOK;
Constant B537_check_barking = EMPTY_RULEBOOK;
Array B538_carry_out_barking --> R_1551 NULL; ! 1 rule(s)
Constant B539_report_barking = EMPTY_RULEBOOK;
Constant B540_check_thing_barking = EMPTY_RULEBOOK;
Constant B541_carry_out_thing_barking = EMPTY_RULEBOOK;
Constant B542_report_thing_barking = EMPTY_RULEBOOK;
Constant B543_check_taking_it_with = EMPTY_RULEBOOK;
Constant B544_carry_out_taking_it_wit = EMPTY_RULEBOOK;
Constant B545_report_taking_it_with = EMPTY_RULEBOOK;
Constant B546_check_magnet_waving = EMPTY_RULEBOOK;
Constant B547_carry_out_magnet_waving = EMPTY_RULEBOOK;
Constant B548_report_magnet_waving = EMPTY_RULEBOOK;
Array B549_check_typing --> R_1602 NULL; ! 1 rule(s)
Array B550_carry_out_typing --> R_1603 NULL; ! 1 rule(s)
Constant B551_report_typing = EMPTY_RULEBOOK;
Constant B552_check_boat_examining = EMPTY_RULEBOOK;
Constant B553_carry_out_boat_examinin = EMPTY_RULEBOOK;
Constant B554_report_boat_examining = EMPTY_RULEBOOK;
Constant B555_when_vivian_s_story_beg = EMPTY_RULEBOOK;
Constant B556_when_vivian_s_story_end = EMPTY_RULEBOOK;
Constant B557_when_endgame_begins = EMPTY_RULEBOOK;
Constant B558_when_endgame_ends = EMPTY_RULEBOOK;
Array B559_when_switch_action_begi --> R_1713 NULL; ! 1 rule(s)
Array B560_when_switch_action_ends --> R_1714 NULL; ! 1 rule(s)
Array B561_check_train_moving --> R_1720 NULL; ! 1 rule(s)
Array B562_carry_out_train_moving --> R_1721 NULL; ! 1 rule(s)
Constant B563_report_train_moving = EMPTY_RULEBOOK;
Array B564_check_train_examining --> R_1722 NULL; ! 1 rule(s)
Array B565_carry_out_train_examini --> R_1723 NULL; ! 1 rule(s)
Constant B566_report_train_examining = EMPTY_RULEBOOK;
Constant B567_check_lock_picking = EMPTY_RULEBOOK;
Constant B568_carry_out_lock_picking = EMPTY_RULEBOOK;
Constant B569_report_lock_picking = EMPTY_RULEBOOK;
Constant B570_check_double_lock_picki = EMPTY_RULEBOOK;
Constant B571_carry_out_double_lock_p = EMPTY_RULEBOOK;
Constant B572_report_double_lock_pick = EMPTY_RULEBOOK;

Constant BR_0 = R_8;
Constant BR_1 = R_9;
Constant BR_2 = R_10;
Constant BR_3 = R_11;
Constant BR_4 = R_12;
Constant BR_5 = R_13;
Constant BR_6 = R_16;
Constant BR_7 = R_17;
Constant BR_8 = R_18;
Constant BR_9 = R_19;
Constant BR_10 = R_20;
Constant BR_11 = R_21;
Constant BR_12 = R_22;
Constant BR_13 = R_23;
Constant BR_14 = R_24;
Constant BR_15 = R_25;
Constant BR_16 = R_26;
Constant BR_17 = R_27;
Constant BR_18 = R_28;
Constant BR_19 = R_29;
Constant BR_20 = R_31;
Constant BR_21 = R_32;
Constant BR_22 = R_33;
Constant BR_23 = R_34;
Constant BR_24 = R_35;
Constant BR_25 = R_36;
Constant BR_26 = R_57;
Constant BR_27 = R_58;
Constant BR_28 = R_59;
Constant BR_29 = R_60;
Constant BR_30 = R_61;
Constant BR_31 = R_62;
Constant BR_32 = R_63;
Constant BR_33 = R_64;
Constant BR_34 = R_65;
Constant BR_35 = R_66;
Constant BR_36 = R_67;
Constant BR_37 = R_68;
Constant BR_38 = R_69;
Constant BR_39 = R_70;
Constant BR_40 = R_73;
Constant BR_41 = R_74;
Constant BR_42 = R_75;
Constant BR_43 = R_76;
Constant BR_44 = R_77;
Constant BR_45 = R_78;
Constant BR_46 = R_79;
Constant BR_47 = R_80;
Constant BR_48 = R_81;
Constant BR_49 = R_82;
Constant BR_50 = R_83;
Constant BR_51 = R_85;
Constant BR_52 = R_86;
Constant BR_53 = R_87;
Constant BR_54 = R_88;
Constant BR_55 = R_89;
Constant BR_56 = R_90;
Constant BR_57 = R_91;
Constant BR_58 = R_92;
Constant BR_59 = R_93;
Constant BR_60 = R_94;
Constant BR_61 = R_95;
Constant BR_62 = R_96;
Constant BR_63 = R_97;
Constant BR_64 = R_98;
Constant BR_65 = R_99;
Constant BR_66 = R_100;
Constant BR_67 = R_101;
Constant BR_68 = R_102;
Constant BR_69 = R_103;
Constant BR_70 = R_104;
Constant BR_71 = R_105;
Constant BR_72 = R_106;
Constant BR_73 = R_107;
Constant BR_74 = R_108;
Constant BR_75 = R_109;
Constant BR_76 = R_110;
Constant BR_77 = R_111;
Constant BR_78 = R_112;
Constant BR_79 = R_113;
Constant BR_80 = R_114;
Constant BR_81 = R_115;
Constant BR_82 = R_116;
Constant BR_83 = R_117;
Constant BR_84 = R_118;
Constant BR_85 = R_119;
Constant BR_86 = R_120;
Constant BR_87 = R_121;
Constant BR_88 = R_122;
Constant BR_89 = R_123;
Constant BR_90 = R_124;
Constant BR_91 = R_125;
Constant BR_92 = R_126;
Constant BR_93 = R_127;
Constant BR_94 = R_128;
Constant BR_95 = R_129;
Constant BR_96 = R_130;
Constant BR_97 = R_131;
Constant BR_98 = R_132;
Constant BR_99 = R_133;
Constant BR_100 = R_134;
Constant BR_101 = R_135;
Constant BR_102 = R_136;
Constant BR_103 = R_137;
Constant BR_104 = R_138;
Constant BR_105 = R_139;
Constant BR_106 = R_140;
Constant BR_107 = R_141;
Constant BR_108 = R_142;
Constant BR_109 = R_143;
Constant BR_110 = R_144;
Constant BR_111 = R_145;
Constant BR_112 = R_146;
Constant BR_113 = R_147;
Constant BR_114 = R_148;
Constant BR_115 = R_149;
Constant BR_116 = R_150;
Constant BR_117 = R_151;
Constant BR_118 = R_152;
Constant BR_119 = R_153;
Constant BR_120 = R_154;
Constant BR_121 = R_155;
Constant BR_122 = R_156;
Constant BR_123 = R_157;
Constant BR_124 = R_158;
Constant BR_125 = R_160;
Constant BR_126 = R_161;
Constant BR_127 = R_162;
Constant BR_128 = R_163;
Constant BR_129 = R_164;
Constant BR_130 = R_165;
Constant BR_131 = R_166;
Constant BR_132 = R_167;
Constant BR_133 = R_168;
Constant BR_134 = R_169;
Constant BR_135 = R_170;
Constant BR_136 = R_171;
Constant BR_137 = R_172;
Constant BR_138 = R_173;
Constant BR_139 = R_174;
Constant BR_140 = R_175;
Constant BR_141 = R_176;
Constant BR_142 = R_177;
Constant BR_143 = R_178;
Constant BR_144 = R_179;
Constant BR_145 = R_180;
Constant BR_146 = R_181;
Constant BR_147 = R_182;
Constant BR_148 = R_183;
Constant BR_149 = R_184;
Constant BR_150 = R_185;
Constant BR_151 = R_186;
Constant BR_152 = R_187;
Constant BR_153 = R_188;
Constant BR_154 = R_189;
Constant BR_155 = R_190;
Constant BR_156 = R_191;
Constant BR_157 = R_192;
Constant BR_158 = R_193;
Constant BR_159 = R_194;
Constant BR_160 = R_195;
Constant BR_161 = R_196;
Constant BR_162 = R_197;
Constant BR_163 = R_198;
Constant BR_164 = R_199;
Constant BR_165 = R_200;
Constant BR_166 = R_201;
Constant BR_167 = R_202;
Constant BR_168 = R_203;
Constant BR_169 = R_204;
Constant BR_170 = R_205;
Constant BR_171 = R_206;
Constant BR_172 = R_207;
Constant BR_173 = R_208;
Constant BR_174 = R_209;
Constant BR_175 = R_210;
Constant BR_176 = R_211;
Constant BR_177 = R_212;
Constant BR_178 = R_213;
Constant BR_179 = R_214;
Constant BR_180 = R_215;
Constant BR_181 = R_216;
Constant BR_182 = R_217;
Constant BR_183 = R_218;
Constant BR_184 = R_219;
Constant BR_185 = R_220;
Constant BR_186 = R_221;
Constant BR_187 = R_222;
Constant BR_188 = R_223;
Constant BR_189 = R_224;
Constant BR_190 = R_225;
Constant BR_191 = R_226;
Constant BR_192 = R_227;
Constant BR_193 = R_228;
Constant BR_194 = R_229;
Constant BR_195 = R_230;
Constant BR_196 = R_231;
Constant BR_197 = R_232;
Constant BR_198 = R_233;
Constant BR_199 = R_234;
Constant BR_200 = R_235;
Constant BR_201 = R_236;
Constant BR_202 = R_237;
Constant BR_203 = R_238;
Constant BR_204 = R_239;
Constant BR_205 = R_240;
Constant BR_206 = R_241;
Constant BR_207 = R_242;
Constant BR_208 = R_243;
Constant BR_209 = R_244;
Constant BR_210 = R_245;
Constant BR_211 = R_246;
Constant BR_212 = R_247;
Constant BR_213 = R_248;
Constant BR_214 = R_249;
Constant BR_215 = R_250;
Constant BR_216 = R_251;
Constant BR_217 = R_252;
Constant BR_218 = R_253;
Constant BR_219 = R_254;
Constant BR_220 = R_255;
Constant BR_221 = R_256;
Constant BR_222 = R_257;
Constant BR_223 = R_258;
Constant BR_224 = R_259;
Constant BR_225 = R_260;
Constant BR_226 = R_261;
Constant BR_227 = R_262;
Constant BR_228 = R_263;
Constant BR_229 = R_264;
Constant BR_230 = R_265;
Constant BR_231 = R_266;
Constant BR_232 = R_267;
Constant BR_233 = R_268;
Constant BR_234 = R_269;
Constant BR_235 = R_270;
Constant BR_236 = R_271;
Constant BR_237 = R_272;
Constant BR_238 = R_273;
Constant BR_239 = R_274;
Constant BR_240 = R_275;
Constant BR_241 = R_276;
Constant BR_242 = R_277;
Constant BR_243 = R_278;
Constant BR_244 = R_279;
Constant BR_245 = R_280;
Constant BR_246 = R_281;
Constant BR_247 = R_282;
Constant BR_248 = R_283;
Constant BR_249 = R_284;
Constant BR_250 = R_285;
Constant BR_251 = R_286;
Constant BR_252 = R_287;
Constant BR_253 = R_288;
Constant BR_254 = R_289;
Constant BR_255 = R_290;
Constant BR_256 = R_291;
Constant BR_257 = R_292;
Constant BR_258 = R_293;
Constant BR_259 = R_294;
Constant BR_260 = R_295;
Constant BR_261 = R_296;
Constant BR_262 = R_297;
Constant BR_263 = R_298;
Constant BR_264 = R_299;
Constant BR_265 = R_742;
Constant BR_266 = R_745;
Constant BR_267 = R_746;
Constant BR_268 = R_747;
Constant BR_269 = R_748;
Constant BR_270 = R_749;
Constant BR_271 = R_750;
Constant BR_272 = R_751;
Constant BR_273 = R_752;
Constant BR_274 = R_754;
Constant BR_275 = R_755;
Constant BR_276 = R_756;
Constant BR_277 = R_757;
Constant BR_278 = R_759;
Constant BR_279 = R_760;
Constant BR_280 = R_761;
Constant BR_281 = R_762;
Constant BR_282 = R_776;
Constant BR_283 = R_777;
Constant BR_284 = R_778;
Constant BR_285 = R_787;
Constant BR_286 = R_792;
Constant BR_287 = R_798;
Constant BR_288 = R_799;
Constant BR_289 = R_800;
Constant BR_290 = R_801;
Constant BR_291 = R_802;
Constant BR_292 = R_803;
Constant BR_293 = R_804;
Constant BR_294 = R_805;
Constant BR_295 = R_806;
Constant BR_296 = R_807;
Constant BR_297 = R_808;
Constant BR_298 = R_809;
Constant BR_299 = R_811;
Constant BR_300 = R_812;
Constant BR_301 = R_813;
Constant BR_302 = R_814;
Constant BR_303 = R_815;
Constant BR_304 = R_816;
Constant BR_305 = R_817;
Constant BR_306 = R_818;
Constant BR_307 = R_819;
Constant BR_308 = R_821;
Constant BR_309 = R_823;
Constant BR_310 = R_824;
Constant BR_311 = R_825;
Constant BR_312 = R_826;
Constant BR_313 = R_827;
Constant BR_314 = R_828;
Constant BR_315 = R_830;
Constant BR_316 = R_831;
Constant BR_317 = R_832;
Constant BR_318 = R_833;
Constant BR_319 = R_835;
Constant BR_320 = R_836;
Constant BR_321 = R_837;
Constant BR_322 = R_838;
Constant BR_323 = R_839;
Constant BR_324 = R_840;
Constant BR_325 = R_841;
Constant BR_326 = R_842;
Constant BR_327 = R_843;
Constant BR_328 = R_844;
Constant BR_329 = R_845;
Constant BR_330 = R_846;
Constant BR_331 = R_847;
Constant BR_332 = R_848;
Constant BR_333 = R_849;
Constant BR_334 = R_850;
Constant BR_335 = R_851;
Constant BR_336 = R_852;
Constant BR_337 = R_868;
Constant BR_338 = R_869;
Constant BR_339 = R_870;
Constant BR_340 = R_871;
Constant BR_341 = R_872;
Constant BR_342 = R_873;
Constant BR_343 = R_874;
Constant BR_344 = R_875;
Constant BR_345 = R_876;
Constant BR_346 = R_877;
Constant BR_347 = R_878;
Constant BR_348 = R_879;
Constant BR_349 = R_880;
Constant BR_350 = R_881;
Constant BR_351 = R_882;
Constant BR_352 = R_883;
Constant BR_353 = R_884;
Constant BR_354 = R_885;
Constant BR_355 = R_886;
Constant BR_356 = R_887;
Constant BR_357 = R_888;
Constant BR_358 = R_889;
Constant BR_359 = R_890;
Constant BR_360 = R_891;
Constant BR_361 = R_892;
Constant BR_362 = R_893;
Constant BR_363 = R_894;
Constant BR_364 = R_895;
Constant BR_365 = R_896;
Constant BR_366 = R_897;
Constant BR_367 = R_898;
Constant BR_368 = R_899;
Constant BR_369 = R_900;
Constant BR_370 = R_901;
Constant BR_371 = R_902;
Constant BR_372 = R_903;
Constant BR_373 = R_906;
Constant BR_374 = R_919;
Constant BR_375 = R_935;
Constant BR_376 = R_936;
Constant BR_377 = R_937;
Constant BR_378 = R_939;
Constant BR_379 = R_1004;
Constant BR_380 = R_1005;
Constant BR_381 = R_1161;
Constant BR_382 = R_1165;
Constant BR_1744 = R_8;
Constant BR_1750 = R_9;
Constant BR_1751 = R_10;
Constant BR_1752 = R_11;
Constant BR_1753 = R_12;
Constant BR_1761 = R_16;
Constant BR_1762 = R_17;
Constant BR_1764 = R_18;
Constant BR_1767 = R_21;
Constant BR_1768 = R_19;
Constant BR_1769 = R_20;
Constant BR_1773 = R_22;
Constant BR_1777 = R_23;
Constant BR_1783 = R_35;
Constant BR_1785 = R_59;
Constant BR_1786 = R_60;
Constant BR_1788 = R_61;
Constant BR_1793 = R_69;
Constant BR_1794 = R_68;
Constant BR_1796 = R_70;
Constant BR_1797 = R_91;
Constant BR_1798 = R_148;
Constant BR_1819 = R_742;
Constant BR_1820 = R_745;
Constant BR_1821 = R_787;
Constant BR_1822 = R_824;
Constant BR_1823 = R_824;
Constant BR_1824 = R_842;
Constant BR_1825 = R_843;
Constant BR_1826 = R_1004;
Constant BR_1827 = R_1165;



[ DetectSceneChange 
    chs sc ch ! Used for scene searches
    ;
if (scene_status-->0 == 1) {
        if ((( (deadflag~=0) ))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' ends]^";
            if (GProperty(39, 1, p59_recurring)) scene_status-->0 = 0; else scene_status-->0 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 1);
            ProcessRulebook(28);
            scene_ended-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|2;
            scene_latest_ending-->0 = 1;
            jump CScene;
        }
    }
    if (scene_status-->0 == 0) {
        if ((( (deadflag==0) ))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Entire Game' begins]^";
            scene_status-->0 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 1);
            ProcessRulebook(27);
            scene_started-->0 = the_time;
            scene_endings-->0 = (scene_endings-->0)|1;
            scene_latest_ending-->0 = 0;
            jump CScene;
        }
    }
    if (scene_status-->1 == 1) {
    }
    if (scene_status-->1 == 0) {
        if (((((Adj_80_t1_v9(I417_underground_pump)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'First Pump' begins]^";
            scene_status-->1 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 2);
            ProcessRulebook(430);
            scene_started-->1 = the_time;
            scene_endings-->1 = (scene_endings-->1)|1;
            scene_latest_ending-->1 = 0;
            jump CScene;
        }
    }
    if (scene_status-->2 == 1) {
        if ((((((Adj_125_t1_v9(I538_blue_lever))))) || (((((Adj_124_t1_v9(I539_green_lever))))) || (((((Adj_125_t1_v9(I541_yellow_lever))))) || ((((Adj_125_t1_v9(I540_purple_lever))))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Lever-action' ends]^";
            if (GProperty(39, 3, p59_recurring)) scene_status-->2 = 0; else scene_status-->2 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 3);
            ProcessRulebook(433);
            scene_ended-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|2;
            scene_latest_ending-->2 = 1;
            jump CScene;
        }
    }
    if (scene_status-->2 == 0) {
        if ((((((Adj_124_t1_v9(I538_blue_lever))))) && (((((Adj_125_t1_v9(I539_green_lever))))) && (((((Adj_124_t1_v9(I541_yellow_lever))))) && ((((Adj_124_t1_v9(I540_purple_lever))))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Lever-action' begins]^";
            scene_status-->2 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 3);
            ProcessRulebook(432);
            scene_started-->2 = the_time;
            scene_endings-->2 = (scene_endings-->2)|1;
            scene_latest_ending-->2 = 0;
            jump CScene;
        }
    }
    if (scene_status-->3 == 1) {
    }
    if (scene_status-->3 == 0) {
        if ((((((Adj_80_t1_v9(I531_triangular_gizmo))))) && ((((Adj_80_t1_v9(I532_square_gizmo))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Gizmo-action' begins]^";
            scene_status-->3 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 4);
            ProcessRulebook(434);
            scene_started-->3 = the_time;
            scene_endings-->3 = (scene_endings-->3)|1;
            scene_latest_ending-->3 = 0;
            jump CScene;
        }
    }
    if (scene_status-->4 == 1) {
    }
    if (scene_status-->4 == 0) {
        if (((((Adj_76_t1_v9(I536_keyhole_on_the_security)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Gadget-action' begins]^";
            scene_status-->4 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 5);
            ProcessRulebook(436);
            scene_started-->4 = the_time;
            scene_endings-->4 = (scene_endings-->4)|1;
            scene_latest_ending-->4 = 0;
            jump CScene;
        }
    }
    if (scene_status-->5 == 1) {
    }
    if (scene_status-->5 == 0) {
        if ((((((scene_status-->(I425_lever_action-1)==1)))) && (((((scene_status-->(I426_gizmo_action-1)==1)))) && ((((scene_status-->(I427_gadget_action-1)==1))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Hose-action' begins]^";
            scene_status-->5 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 6);
            ProcessRulebook(438);
            scene_started-->5 = the_time;
            scene_endings-->5 = (scene_endings-->5)|1;
            scene_latest_ending-->5 = 0;
            jump CScene;
        }
    }
    if (scene_status-->6 == 1) {
    }
    if (scene_status-->6 == 0) {
        if ((((((scene_status-->(I425_lever_action-1)==1)))) && (((((scene_status-->(I426_gizmo_action-1)==1)))) && (((((scene_status-->(I427_gadget_action-1)==1)))) && ((((Adj_118_t1_v9(I526_leaky_hose))))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Second Pump' begins]^";
            scene_status-->6 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 7);
            ProcessRulebook(440);
            scene_started-->6 = the_time;
            scene_endings-->6 = (scene_endings-->6)|1;
            scene_latest_ending-->6 = 0;
            if (scene_status-->1 == 1) {
                if (debug_scenes) print "[Scene 'First Pump' ends]^";
                if (GProperty(39, 2, p59_recurring)) scene_status-->1 = 0; else scene_status-->1 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 2);
                ProcessRulebook(431);
                scene_ended-->1 = the_time;
                scene_endings-->1 = (scene_endings-->1)|2;
                scene_latest_ending-->1 = 1;
            }
            if (scene_status-->5 == 1) {
                if (debug_scenes) print "[Scene 'Hose-action' ends]^";
                if (GProperty(39, 6, p59_recurring)) scene_status-->5 = 0; else scene_status-->5 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 6);
                ProcessRulebook(439);
                scene_ended-->5 = the_time;
                scene_endings-->5 = (scene_endings-->5)|2;
                scene_latest_ending-->5 = 1;
            }
            jump CScene;
        }
    }
    if (scene_status-->7 == 1) {
    }
    if (scene_status-->7 == 0) {
        if (((((Adj_80_t1_v9(I418_big_pump)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Third Pump' begins]^";
            scene_status-->7 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 8);
            ProcessRulebook(442);
            scene_started-->7 = the_time;
            scene_endings-->7 = (scene_endings-->7)|1;
            scene_latest_ending-->7 = 0;
            if (scene_status-->6 == 1) {
                if (debug_scenes) print "[Scene 'Second Pump' ends]^";
                if (GProperty(39, 7, p59_recurring)) scene_status-->6 = 0; else scene_status-->6 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 7);
                ProcessRulebook(441);
                scene_ended-->6 = the_time;
                scene_endings-->6 = (scene_endings-->6)|2;
                scene_latest_ending-->6 = 1;
            }
            jump CScene;
        }
    }
    if (scene_status-->8 == 1) {
        if (((((Adj_136_t1_v9(I439_steam_train)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'conductor's story' ends]^";
            if (GProperty(39, 9, p59_recurring)) scene_status-->8 = 0; else scene_status-->8 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 9);
            ProcessRulebook(445);
            scene_ended-->8 = the_time;
            scene_endings-->8 = (scene_endings-->8)|2;
            scene_latest_ending-->8 = 1;
            jump CScene;
        }
    }
    if (scene_status-->8 == 0) {
        if ((((((scene_status-->(I430_third_pump-1)==1)))) && (((I439_steam_train == ContainerOf(player)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'conductor's story' begins]^";
            scene_status-->8 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 9);
            ProcessRulebook(444);
            scene_started-->8 = the_time;
            scene_endings-->8 = (scene_endings-->8)|1;
            scene_latest_ending-->8 = 0;
            jump CScene;
        }
    }
    if (scene_status-->9 == 1) {
    }
    if (scene_status-->9 == 0) {
        if ((((((scene_status-->(I704_switch_action-1)==1)))) && (TestSinglePastState(0, 53, false, 6) >= 2 ))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Fourth Pump' begins]^";
            scene_status-->9 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 10);
            ProcessRulebook(446);
            scene_started-->9 = the_time;
            scene_endings-->9 = (scene_endings-->9)|1;
            scene_latest_ending-->9 = 0;
            jump CScene;
        }
    }
    if (scene_status-->10 == 1) {
        if (((((~~Adj_9_t1_v9(I545_secretary_of_water)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'secretary's story' ends]^";
            if (GProperty(39, 11, p59_recurring)) scene_status-->10 = 0; else scene_status-->10 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 11);
            ProcessRulebook(536);
            scene_ended-->10 = the_time;
            scene_endings-->10 = (scene_endings-->10)|2;
            scene_latest_ending-->10 = 1;
            jump CScene;
        }
    }
    if (scene_status-->10 == 0) {
        if (((((I509_grassy_area == ContainerOf(player)))) && (((I509_grassy_area == ContainerOf(I545_secretary_of_water)))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'secretary's story' begins]^";
            scene_status-->10 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 11);
            ProcessRulebook(535);
            scene_started-->10 = the_time;
            scene_endings-->10 = (scene_endings-->10)|1;
            scene_latest_ending-->10 = 0;
            jump CScene;
        }
    }
    if (scene_status-->11 == 1) {
    }
    if (scene_status-->11 == 0) {
        if ((((I669_underwater == ContainerOf(I671_vivian))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Vivian's Story' begins]^";
            scene_status-->11 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 12);
            ProcessRulebook(555);
            scene_started-->11 = the_time;
            scene_endings-->11 = (scene_endings-->11)|1;
            scene_latest_ending-->11 = 0;
            jump CScene;
        }
    }
    if (scene_status-->12 == 1) {
    }
    if (scene_status-->12 == 0) {
        if ((((I677_the_crystal_city == ContainerOf(player))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Endgame' begins]^";
            scene_status-->12 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 13);
            ProcessRulebook(557);
            scene_started-->12 = the_time;
            scene_endings-->12 = (scene_endings-->12)|1;
            scene_latest_ending-->12 = 0;
            jump CScene;
        }
    }
    if (scene_status-->13 == 1) {
        if ((((((Adj_124_t1_v9(I693_green_switch))))) || (((((Adj_125_t1_v9(I692_yellow_switch))))) || (((((Adj_125_t1_v9(I694_purple_switch))))) || ((((Adj_125_t1_v9(I691_blue_switch))))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Switch-action' ends]^";
            if (GProperty(39, 14, p59_recurring)) scene_status-->13 = 0; else scene_status-->13 = 2; ProcessRulebook(WHEN_SCENE_ENDS_RB, 14);
            ProcessRulebook(560);
            scene_ended-->13 = the_time;
            scene_endings-->13 = (scene_endings-->13)|2;
            scene_latest_ending-->13 = 1;
            jump CScene;
        }
    }
    if (scene_status-->13 == 0) {
        if ((((((Adj_124_t1_v9(I691_blue_switch))))) && (((((Adj_124_t1_v9(I692_yellow_switch))))) && (((((Adj_124_t1_v9(I694_purple_switch))))) && ((((Adj_125_t1_v9(I693_green_switch))))))))) {
            ch = true;
            if (debug_scenes) print "[Scene 'Switch-action' begins]^";
            scene_status-->13 = 1; ProcessRulebook(WHEN_SCENE_BEGINS_RB, 14);
            ProcessRulebook(559);
            scene_started-->13 = the_time;
            scene_endings-->13 = (scene_endings-->13)|1;
            scene_latest_ending-->13 = 0;
            jump CScene;
        }
    }
    .CScene;
    if (chs>20) ">--> The scene change machinery is stuck.";

    if (ch>0) DetectSceneChange(++chs);

    rfalse;
];

#IFDEF DEBUG;
[ ShowSceneStatus chs sc ch;
    if (scene_status-->0 == 1) {
        print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
    } else {
        if (scene_latest_ending-->0 > 0) {
            print "Scene 'Entire Game' ended";
            print "^";
        }
    }
    if (scene_status-->1 == 1) {
        print "Scene 'First Pump' playing (for ", the_time-(scene_started-->1), " mins now)^";
    } else {
        if (scene_latest_ending-->1 > 0) {
            print "Scene 'First Pump' ended";
            print "^";
        }
    }
    if (scene_status-->2 == 1) {
        print "Scene 'Lever-action' playing (for ", the_time-(scene_started-->2), " mins now)^";
    } else {
        if (scene_latest_ending-->2 > 0) {
            print "Scene 'Lever-action' ended";
            print "^";
        }
    }
    if (scene_status-->3 == 1) {
        print "Scene 'Gizmo-action' playing (for ", the_time-(scene_started-->3), " mins now)^";
    } else {
        if (scene_latest_ending-->3 > 0) {
            print "Scene 'Gizmo-action' ended";
            print "^";
        }
    }
    if (scene_status-->4 == 1) {
        print "Scene 'Gadget-action' playing (for ", the_time-(scene_started-->4), " mins now)^";
    } else {
        if (scene_latest_ending-->4 > 0) {
            print "Scene 'Gadget-action' ended";
            print "^";
        }
    }
    if (scene_status-->5 == 1) {
        print "Scene 'Hose-action' playing (for ", the_time-(scene_started-->5), " mins now)^";
    } else {
        if (scene_latest_ending-->5 > 0) {
            print "Scene 'Hose-action' ended";
            print "^";
        }
    }
    if (scene_status-->6 == 1) {
        print "Scene 'Second Pump' playing (for ", the_time-(scene_started-->6), " mins now)^";
    } else {
        if (scene_latest_ending-->6 > 0) {
            print "Scene 'Second Pump' ended";
            print "^";
        }
    }
    if (scene_status-->7 == 1) {
        print "Scene 'Third Pump' playing (for ", the_time-(scene_started-->7), " mins now)^";
    } else {
        if (scene_latest_ending-->7 > 0) {
            print "Scene 'Third Pump' ended";
            print "^";
        }
    }
    if (scene_status-->8 == 1) {
        print "Scene 'conductor's story' playing (for ", the_time-(scene_started-->8), " mins now)^";
    } else {
        if (scene_latest_ending-->8 > 0) {
            print "Scene 'conductor's story' ended";
            print "^";
        }
    }
    if (scene_status-->9 == 1) {
        print "Scene 'Fourth Pump' playing (for ", the_time-(scene_started-->9), " mins now)^";
    } else {
        if (scene_latest_ending-->9 > 0) {
            print "Scene 'Fourth Pump' ended";
            print "^";
        }
    }
    if (scene_status-->10 == 1) {
        print "Scene 'secretary's story' playing (for ", the_time-(scene_started-->10), " mins now)^";
    } else {
        if (scene_latest_ending-->10 > 0) {
            print "Scene 'secretary's story' ended";
            print "^";
        }
    }
    if (scene_status-->11 == 1) {
        print "Scene 'Vivian's Story' playing (for ", the_time-(scene_started-->11), " mins now)^";
    } else {
        if (scene_latest_ending-->11 > 0) {
            print "Scene 'Vivian's Story' ended";
            print "^";
        }
    }
    if (scene_status-->12 == 1) {
        print "Scene 'Endgame' playing (for ", the_time-(scene_started-->12), " mins now)^";
    } else {
        if (scene_latest_ending-->12 > 0) {
            print "Scene 'Endgame' ended";
            print "^";
        }
    }
    if (scene_status-->13 == 1) {
        print "Scene 'Switch-action' playing (for ", the_time-(scene_started-->13), " mins now)^";
    } else {
        if (scene_latest_ending-->13 > 0) {
            print "Scene 'Switch-action' ended";
            print "^";
        }
    }
];


#ENDIF;



Constant AD_ACTION = 0; ! The I6 action number (0 to 4095)
Constant AD_REQUIREMENTS = 1; ! Such as requiring light; a bitmap, see below
Constant AD_NOUN_KOV = 2; ! Kind of value of the first noun
Constant AD_SECOND_KOV = 3; ! Kind of value of the second noun
Constant AD_VARIABLES_CREATOR = 4; ! Routine to initialise variables owned
Constant AD_VARIABLES_ID = 5; ! Frame ID for variables owned by action

Constant AD_RECORD_SIZE = 6;

[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t + AD_RECORD_SIZE;
	}
	rfalse;
];

[ ActionNumberIndexed i;
	if ((i>=0) && (i < AD_RECORDS)) return ActionData-->(i*AD_RECORD_SIZE + AD_ACTION + 1);
	return 0;
];

Constant TOUCH_NOUN_ABIT   = $$00000001;
Constant TOUCH_SECOND_ABIT = $$00000010;
Constant LIGHT_ABIT        = $$00000100;
Constant NEED_NOUN_ABIT    = $$00001000;
Constant NEED_SECOND_ABIT  = $$00010000;
Constant OUT_OF_WORLD_ABIT = $$00100000;
Constant CARRY_NOUN_ABIT   = $$01000000;
Constant CARRY_SECOND_ABIT = $$10000000;

[ NeedToCarryNoun;       return TestActionMask(CARRY_NOUN_ABIT); ];
[ NeedToCarrySecondNoun; return TestActionMask(CARRY_SECOND_ABIT); ];
[ NeedToTouchNoun;       return TestActionMask(TOUCH_NOUN_ABIT); ];
[ NeedToTouchSecondNoun; return TestActionMask(TOUCH_SECOND_ABIT); ];
[ NeedLightForAction;    return TestActionMask(LIGHT_ABIT); ];

[ TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+AD_REQUIREMENTS); 
	if (mask & match) rtrue; 
	rfalse; 
];

[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
	if (stora) return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
	tbits = req & (16+32);
	req = req & 1;
	@push actor; @push act_requester; @push inp1; @push inp2;
	@push parsed_number; smeta = meta;
	actor = by; if (req) act_requester = player; else act_requester = 0;

	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+AD_NOUN_KOV) == OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+AD_SECOND_KOV) == OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
		if (((ActionData-->(by+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(by+AD_SECOND_KOV) == UNDERSTANDING_TY)) && (tbits)) {
			saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			if (tbits == 16) {
				n = players_command; inp1 = 1; parsed_number = players_command;
			} else {
				s = players_command; inp2 = 1; parsed_number = players_command;
			}
			BlkFree(text_of_command);
			@push consult_from; @push consult_words;
			consult_from = 1; consult_words = parsed_number - 100;
		}
	}

	BeginAction(ac, n, s, 0, true);

	if (saved_command) {
		@pull consult_words; @pull consult_from;
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}

	meta = smeta; @pull parsed_number;
	@pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(true, smeta);
];

[ R_Process a i j;
	@push inp1; @push inp2;
    inp1 = i; inp2 = j; BeginAction(a, i, j);
    @pull inp2; @pull inp1;
];

Global converted_action_outcome = -1;
[ GVS_Convert ac n s;
	converted_action_outcome = BeginAction(ac, n, s);
	rtrue;
];

[ ConvertToGoingWithPush i oldrm newrm infl;
	i=noun;
	if (IndirectlyContains(noun, actor) == false) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = LocationOf(noun);
	BeginAction(##Go, second);
	newrm = LocationOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectlyContains(i, player)) TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
];

[ ImplicitTake obj ks;
	if (actor == player) L__M(##Miscellany, 69, obj);
	else L__M(##Miscellany, 68, obj);
	ClearParagraphing();
	@push keep_silent; keep_silent = true;
	if (act_requester) TryAction(true, actor, ##Take, obj, nothing);
	else TryAction(false, actor, ##Take, obj, nothing);
	@pull keep_silent;
	if (obj in actor) rtrue;
	rfalse;
];

[ LookAfterGoing;
	GoingLookBreak();
	AbbreviatedRoomDescription();
];

[ AbbreviatedRoomDescription  prior_action pos frame_id;
	prior_action = action; 

	action = ##Look;
	pos = FindAction(##Look);
	if ((pos) && (ActionData-->(pos+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(pos+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);
		ProcessRulebook(SETTING_ACTION_VARIABLES_RB);
		(MStack-->MstVO(frame_id, 0)) = prior_action; ! "room-describing action"
		(MStack-->MstVO(frame_id, 1)) = true; ! "abbreviated form allowed"
	}
	LookSub(); ! The I6 verb routine for "looking"
	if (frame_id) Mstack_Destroy_Frame(ActionData-->(pos+AD_VARIABLES_CREATOR), frame_id);

	action = prior_action;
];

[ BeginAction a n s moi notrack  rv;
	ChronologyPoint();

	@push action; @push noun; @push second; @push self; @push multiple_object_item;

	action = a; noun = n; second = s; self = noun; multiple_object_item = moi;
	if (action < 4096) rv = ActionPrimitive();

	@pull multiple_object_item; @pull self; @pull second; @pull noun; @pull action;
	
	if (notrack == false) TrackActions(true, meta);
	return rv;
];

[ ActionPrimitive  rv p1 p2 p3 p4 p5 frame_id;
	MStack_CreateRBVars(ACTION_PROCESSING_RB);

	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	reason_the_action_failed = 0;

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+AD_VARIABLES_CREATOR))) {
		frame_id = ActionData-->(p1+AD_VARIABLES_ID);
		Mstack_Create_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	if (ActionVariablesNotTypeSafe()) {
		if (frame_id ~= -1)
			Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
		MStack_DestroyRBVars(ACTION_PROCESSING_RB);
		return;
	}

	ProcessRulebook(SETTING_ACTION_VARIABLES_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^"; ClearParagraphing();
	}
	++debug_rule_nesting;
	#ENDIF;
	TrackActions(false, meta);
	BeginFollowRulebook();
	if ((meta) && (actor ~= player)) { L__M(##Miscellany, 74, actor); rv = RS_FAILS; }
	else if (meta) { DESCEND_TO_SPECIFIC_ACTION_R(); rv = RulebookOutcome(); }
	else { ProcessRulebook(ACTION_PROCESSING_RB); rv = RulebookOutcome(); }
	#IFDEF DEBUG;
	--debug_rule_nesting;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF MEMORY_ECONOMY;
				if (reason_the_action_failed)
					print " the ",
						(RulePrintingRule) reason_the_action_failed;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^"; say__p = 1;
		SetRulebookOutcome(rv); ! In case disturbed by printing activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) UpdateActionBitmap();
	EndFollowRulebook();
	if (frame_id ~= -1) {
		p1 = FindAction(action);
		Mstack_Destroy_Frame(ActionData-->(p1+AD_VARIABLES_CREATOR), frame_id);
	}
	MStack_DestroyRBVars(ACTION_PROCESSING_RB);
	if ((keep_silent == false) && (multiflag == false)) DivideParagraphPoint();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
	at = FindAction(-1); if (at == 0) rfalse; ! For any I6-defined actions

	noun_kova = ActionData-->(at+AD_NOUN_KOV);
	second_kova = ActionData-->(at+AD_SECOND_KOV);

	!print "at = ", at, " nst = ", noun_kova, "^";
	!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
	!print "inp1 = ", inp1, " noun = ", noun, "^";
	!print "inp2 = ", inp2, " second = ", second, "^";
	!print "sst = ", second_kova, "^";

	if (noun_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = nothing; ! noun = parsed_number;
	}
	if (second_kova == SNIPPET_TY or UNDERSTANDING_TY) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = nothing; ! second = parsed_number;
	}

	mask = ActionData-->(at+AD_REQUIREMENTS);
	if (mask & OUT_OF_WORLD_ABIT) { meta = 1; rfalse; }

	if (inp1 == 1) {
	    if (noun_kova == OBJECT_TY) {
	        return L__M(##Miscellany, 61); }
	} else {
	    if (noun_kova ~= OBJECT_TY) {
	        return L__M(##Miscellany, 62); }
	    if ((mask & NEED_NOUN_ABIT) && (noun == nothing)) {
	    	@push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
	        @pull act_requester;
	        if (noun == nothing) {
	        	if (say__p) rtrue;
	        	return L__M(##Miscellany, 59);
	    	}
	    }
	    if (((mask & NEED_NOUN_ABIT) == 0) && (noun ~= nothing)) {
	        return L__M(##Miscellany, 60); }
	}

	if (inp2 == 1) {
	    if (second_kova == OBJECT_TY) {
	        return L__M(##Miscellany, 63); }
	} else {
	    if (second_kova ~= OBJECT_TY) {
	        return L__M(##Miscellany, 64); }
	    if ((mask & NEED_SECOND_ABIT) && (second == nothing)) {
	        @push act_requester; act_requester = nothing;
	        CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
	        @pull act_requester;
	        if (second == nothing) {
	        	if (say__p) rtrue;
	        	return L__M(##Miscellany, 65);
	        }
	    }
	    if (((mask & NEED_SECOND_ABIT) == 0) && (second ~= nothing)) {
	        return L__M(##Miscellany, 66); }
	}

	rfalse;
];

[ BASIC_VISIBILITY_R;
	if (act_requester) rfalse;
	if ((NeedLightForAction()) &&
		(actor == player) &&
		(ProcessRulebook(VISIBLE_RB)) &&
		(RulebookSucceeded())) {
		BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		if (ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT)==false) L__M(##Miscellany, 17);
		EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
		reason_the_action_failed = BASIC_VISIBILITY_R;
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ BASIC_ACCESSIBILITY_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if (noun ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R; 
			if (actor~=player) rtrue;
			return L__M(##Miscellany, 67);
		}
		if (ObjectIsUntouchable(noun, (actor~=player), FALSE, actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if (second ofclass K3_direction) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			if (actor~=player) rtrue;
			return L__M(##Miscellany, 67);
		}
		if (ObjectIsUntouchable(second, (actor~=player), FALSE, actor)) {
			RulebookFails();
			reason_the_action_failed = BASIC_ACCESSIBILITY_R;
			rtrue;
		}
	}
	rfalse;
];

[ CARRYING_REQUIREMENTS_R mask at;
	
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+AD_REQUIREMENTS);

	if ((mask & TOUCH_NOUN_ABIT) && noun && (inp1 ~= 1)) {
		if ((mask & CARRY_NOUN_ABIT) && (noun notin actor)) {
			BeginActivity(IMPLICITLY_TAKING_ACT, noun);
            if (ForActivity(IMPLICITLY_TAKING_ACT, noun)==false)
            	ImplicitTake(noun);
            EndActivity(IMPLICITLY_TAKING_ACT, noun);
            !if (act_requester) rfalse;
			if (noun notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}

	if ((mask & TOUCH_SECOND_ABIT) && second && (inp2 ~= 1)) {
		if ((mask & CARRY_SECOND_ABIT) && (second notin actor)) {
			BeginActivity(IMPLICITLY_TAKING_ACT, second);
            if (ForActivity(IMPLICITLY_TAKING_ACT, second)==false)
            	ImplicitTake(second);
            EndActivity(IMPLICITLY_TAKING_ACT, second);
            !if (act_requester) rfalse;
			if (second notin actor) {
				RulebookFails();
				reason_the_action_failed = CARRYING_REQUIREMENTS_R;
				rtrue;
			}
		}
	}
	rfalse;
];

[ REQUESTED_ACTIONS_REQUIRE_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push say__p;
		say__p = 0;
		rv = ProcessRulebook(PERSUADE_RB);
		if (RulebookSucceeded() == false) {
			if ((deadflag == false) && (say__p == FALSE)) L__M(##Miscellany, 72, actor);
			ActRulebookFails(rv); rtrue;
		}
		@pull say__p;
	}
	rfalse;
];

[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
	if ((actor ~= player) && (act_requester)) {
		@push act_requester; act_requester = nothing;
		rv = BeginAction(action, noun, second);
		if (((meta) || (rv == false)) && (deadflag == false)) {
			if (ProcessRulebook(UNSUCCESSFUL_ATTEMPT_RB) == false) L__M(##Miscellany, 58);
		}
		@pull act_requester;
		ActRulebookSucceeds();
		rtrue;
	}
	rfalse;
];

Array Details_of_Specific_Action-->5;

[ GenericVerbSub ch co re vis rv;
	@push converted_action_outcome;
	converted_action_outcome = -1;

	Details_of_Specific_Action-->0 = true;
	if (meta) Details_of_Specific_Action-->0 = false;
	Details_of_Specific_Action-->1 = keep_silent;
	Details_of_Specific_Action-->2 = ch; ! Check rules for the action
	Details_of_Specific_Action-->3 = co; ! Carry out rules for the action
	Details_of_Specific_Action-->4 = re; ! Report rules for the action

	ProcessRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, true);
	if ((RulebookFailed()) && (converted_action_outcome == 1)) ActRulebookSucceeds();

	@pull converted_action_outcome;
	rtrue;
];

[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0) = Details_of_Specific_Action-->0;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1) = Details_of_Specific_Action-->1;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2) = Details_of_Specific_Action-->2;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3) = Details_of_Specific_Action-->3;
	MStack-->MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4) = Details_of_Specific_Action-->4;
	rfalse;
];

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	if (act == -1) return (((bitmap->0) & 1) ~= 0); 
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];

[ UpdateActionBitmap;
	SetActionBitmap(noun, action);
	if (action == ##Go) SetActionBitmap(location, ##Enter);
];

[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=2; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];

[ SayActionName act; DB_Action(0, 0, act, 0, 0, 2); ];

[ DA_Name n; if (n ofclass K3_direction) print (name) n; else print (the) n; ];
[ DA_Topic x a b c d i cf cw;
	cw = x%100; cf = x/100;
	print "~";
	for (a=cf:d<cw:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<cw-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ DA_TruthState n; if (n==0) print "false"; else print "true"; ];
[ DB_Action ac acr act n s for_say t at l j v c clc;
	if ((for_say == 0) && (debug_rule_nesting > 0))
		print "(", debug_rule_nesting, ") ";
	if ((ac ~= player) && (for_say ~= 2)) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " ";
	}
	DB_Action_Details(act, n, s, for_say);
	if ((keep_silent) && (for_say == 0)) print " - silently";
];

Constant MAX_NESTED_ACTIVITIES = 20;
Global activities_sp = 0;
Array activities_stack --> MAX_NESTED_ACTIVITIES;
Array activity_parameters_stack --> MAX_NESTED_ACTIVITIES;

Global inhibit_flag = 0;
Global saved_debug_rules = 0;
[ FixInhibitFlag n act inhibit_rule_debugging;
	for (n=0:n<activities_sp:n++) {
		act = activities_stack-->n;
		if (act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or
			PRINTING_ROOM_DESC_DETAILS_ACT or LISTING_CONTENTS_ACT or
			GROUPING_TOGETHER_ACT) inhibit_rule_debugging = true;
	}
	if ((inhibit_flag == false) && (inhibit_rule_debugging)) {
		saved_debug_rules = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (inhibit_rule_debugging == false)) {
		debug_rules = saved_debug_rules;
	}
	inhibit_flag = inhibit_rule_debugging;
];

[ TestActivity A desc val i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (desc) {
				if ((desc)(activity_parameters_stack-->i)) rtrue;
			} else if (val) {
				if (val == activity_parameters_stack-->i) rtrue;
			} else rtrue;
		}
	rfalse;
];

[ ActivityEmpty A x;
	x = Activity_before_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	x = Activity_for_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	x = Activity_after_rulebooks-->A;
	if (((rulebooks_array-->x)-->0) ~= NULL) rfalse;
	rtrue;
];

[ RulebookEmpty rb;
	if (((rulebooks_array-->rb)-->0) ~= NULL) rfalse;
	rtrue;
];

[ ProcessActivityRulebook rulebook parameter  rv;
	@push self;
	if (parameter) self = parameter;
	rv = ProcessRulebook(rulebook, parameter, true);
	@pull self;
	if (rv) rtrue;
	rfalse;
];

[ CarryOutActivity A o rv;
	BeginActivity(A, o);
	rv = ForActivity(A, o);
	EndActivity(A, o);
	return rv;
];

[ BeginActivity A o x;
	if (activities_sp == MAX_NESTED_ACTIVITIES) return RunTimeProblem(RTP_TOOMANYACTS);
	activity_parameters_stack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];

[ ForActivity A o x;
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = ProcessActivityRulebook(Activity_for_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];

[ EndActivity A o rv x;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = ProcessActivityRulebook(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return rv;
	}
	return RunTimeProblem(RTP_CANTABANDON);
];

[ AbandonActivity A o;
	if ((activities_sp > 0) && (activities_stack-->(activities_sp-1) == A)) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	return RunTimeProblem(RTP_CANTEND);
];

Array ResourceUsageFlags ->
	(1+0+5);

[ DisplayFigure resource_ID one_time;
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	print "^"; VM_Picture(resource_ID); print "^";
];

[ PlaySound resource_ID one_time;
	if (resource_ID == 0) return; ! The "silence" non-sound effect
	if ((one_time) && (ResourceUsageFlags->resource_ID)) return;
	ResourceUsageFlags->resource_ID = true;
	VM_SoundEffect(resource_ID);
];

#IFDEF PLUGIN_FILES;

Constant AUXF_MAGIC = 0; ! First word holds a safety constant
Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure
Constant AUXF_STATUS = 1; ! One of the following:
	Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist
	Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
	Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
	Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary
Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)
Constant AUXF_FILENAME = 4; ! Packed address of constant string
Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or
	! string array of IFID of owner wrapped in //...//, or NULL to leave open

Constant NO_EXTERNAL_FILES 0;
Array TableOfExternalFiles --> 0 0;


[ FileIO_Error extf err_text  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) {
		print "^*** Error on unknown file: ", (string) err_text, " ***^";
	} else {
		struc = TableOfExternalFiles-->extf;
		print "^*** Error on file '",
			(string) struc-->AUXF_FILENAME, "': ",
			(string) err_text, " ***^";
	}
	RunTimeProblem(RTP_FILEIOERROR);
	return 0;
];

#IFDEF TARGET_GLULX;

[ FileIO_Exists extf  fref struc rv usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	rv = glk_fileref_does_file_exist(fref);
	glk_fileref_destroy(fref);
	return rv;
];

[ FileIO_Ready extf  struc fref usage str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) rfalse;
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		rfalse;
	}
	str = glk_stream_open_file(fref, filemode_Read, 0);
	ch = glk_get_char_stream(str);
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
	if (ch ~= '*') rfalse;
	rtrue;
];

[ FileIO_MarkReady extf readiness  struc fref str ch usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (glk_fileref_does_file_exist(fref) == false) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only existing files can be marked");
	}
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {
		glk_fileref_destroy(fref);
		return FileIO_Error(extf, "only closed files can be marked");
	}
	str = glk_stream_open_file(fref, filemode_ReadWrite, 0);
	glk_stream_set_position(str, 0, 0); ! seek start
	if (readiness) ch = '*'; else ch = '-';
	glk_put_char_stream(str, ch); ! mark as complete
	glk_stream_close(str, 0);
	glk_fileref_destroy(fref);
];

[ FileIO_Open extf write_flag append_flag
	struc fref str mode ix ch not_this_ifid owner force_header usage;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if ((struc == 0) || (struc-->AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)
		return FileIO_Error(extf, "tried to open a file already open");
	if (struc-->AUXF_BINARY) usage = fileusage_BinaryMode;
	else usage = fileusage_TextMode;
	fref = glk_fileref_create_by_name(fileusage_Data + usage,
		Glulx_ChangeAnyToCString(struc-->AUXF_FILENAME), 0);
	if (write_flag) {
		if (append_flag) {
			mode = filemode_WriteAppend;
			if (glk_fileref_does_file_exist(fref) == false)
				force_header = true;
		}
		else mode = filemode_Write;
	} else {
		mode = filemode_Read;
		if (glk_fileref_does_file_exist(fref) == false) {
			glk_fileref_destroy(fref);
			return FileIO_Error(extf, "tried to open a file which does not exist");
		}
	}
	str = glk_stream_open_file(fref, mode, 0);
	glk_fileref_destroy(fref);
	if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");
	struc-->AUXF_STREAM = str;
	if (write_flag) {
		if (append_flag)
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;
		else
			struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;
		glk_stream_set_current(str);
		if ((append_flag == FALSE) || (force_header)) {
			print "- ";
			for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
			print " ", (string) struc-->AUXF_FILENAME, "^";
		}
	} else {
		struc-->AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;
		ch = FileIO_GetC(extf);
		if (ch ~= '-' or '*') { jump BadFile; }
		if (ch == '-')
			return FileIO_Error(extf, "tried to open a file which was incomplete");
		ch = FileIO_GetC(extf);
		if (ch ~= ' ') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		ch = FileIO_GetC(extf);
		if (ch ~= '/') { jump BadFile; }
		owner = struc-->AUXF_IFID_OF_OWNER;
		ix = 3;
		if (owner == UUID_ARRAY) ix = 8;
		if (owner ~= NULL) {
			for (: ix <= owner->0: ix++) {
				ch = FileIO_GetC(extf);
				if (ch == -1) { jump BadFile; }
				if (ch ~= owner->ix) not_this_ifid = true;
				if (ch == ' ') break;
			}
			if (not_this_ifid == false) {
				ch = FileIO_GetC(extf);
				if (ch ~= ' ') { jump BadFile; }
			}
		}
		while (ch ~= -1) {
			ch = FileIO_GetC(extf);
			if (ch == 10 or 13) break;
		}
		if (not_this_ifid) {
			struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
			glk_stream_close(str, 0);
			return FileIO_Error(extf,
				"tried to open a file owned by another project");
		}
	}
	return struc-->AUXF_STREAM;
	.BadFile;
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
	glk_stream_close(str, 0);
	return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];

[ FileIO_Close extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to open a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_READ or
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf, "tried to close a file which is not open");
	if ((struc-->AUXF_BINARY == false) &&
		(struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
		glk_set_window(gg_mainwin);
	}
	if (struc-->AUXF_STATUS ==
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND) {
		glk_stream_set_position(struc-->AUXF_STREAM, 0, 0); ! seek start
		glk_put_char_stream(struc-->AUXF_STREAM, '*'); ! mark as complete
	}
	glk_stream_close(struc-->AUXF_STREAM, 0);
	struc-->AUXF_STATUS = AUXF_STATUS_IS_CLOSED;
];

[ FileIO_GetC extf  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;
	return glk_get_char_stream(struc-->AUXF_STREAM);
];

[ FileIO_PutC extf char  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES)) return -1;
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_STATUS ~=
		AUXF_STATUS_IS_OPEN_FOR_WRITE or
		AUXF_STATUS_IS_OPEN_FOR_APPEND)
		return FileIO_Error(extf,
			"tried to write to a file which is not open for writing");
	return glk_put_char_stream(struc-->AUXF_STREAM, char);
];

[ FileIO_PrintLine extf ch  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write to a non-file");
	struc = TableOfExternalFiles-->extf;
	for (::) {
		ch = FileIO_GetC(extf);
		if (ch == -1) rfalse;
		if (ch == 10 or 13) { print "^"; rtrue; }
		print (char) ch;
	}
];

[ FileIO_PrintContents extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "printing text will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	while (FileIO_PrintLine(extf)) ;
	FileIO_Close(extf);
	rtrue;
];

[ FileIO_PutContents extf text append_flag  struc str ch;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to access a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing text will not work with binary files");
	str = FileIO_Open(extf, true, append_flag);
	if (str == 0) rfalse;
	@push say__p; @push say__pc;
	ClearParagraphing();
	PrintText(text);
	FileIO_Close(extf);
	@pull say__pc; @pull say__p;
	rfalse;
];

[ FileIO_PutTable extf tab rv  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to write table to a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "writing a table will not work with binary files");
	if (FileIO_Open(extf, true) == 0) rfalse;
	rv = TablePrint(tab);
	FileIO_Close(extf);
	if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	rtrue;
];

[ FileIO_GetTable extf tab  struc;
	if ((extf < 1) || (extf > NO_EXTERNAL_FILES))
		return FileIO_Error(extf, "tried to read table from a non-file");
	struc = TableOfExternalFiles-->extf;
	if (struc-->AUXF_BINARY)
		return FileIO_Error(extf, "reading a table will not work with binary files");
	if (FileIO_Open(extf, false) == 0) rfalse;
	TableRead(tab, extf);
	FileIO_Close(extf);
	rtrue;
];

#IFNOT; ! TARGET_GLULX
[ FileIO_Exists extf; rfalse; ];
[ FileIO_Ready extf; rfalse; ];
[ FileIO_GetC extf; return -1; ];
[ FileIO_PutTable extf tab;
	return FileIO_Error(extf, "external files can only be used under Glulx");
];
[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];
[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];
[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];
[ FileIO_PutContents extf; FileIO_PutTable(extf); ];
#ENDIF; ! TARGET_GLULX

#IFNOT; ! PLUGIN_FILES
[ FileIO_GetC extf; return -1; ];
#ENDIF; ! PLUGIN_FILES

Constant MAX_MSTACK_FRAME = 2 + 6;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0; ! Topmost word currently used

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2, 1);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	rtrue;
];

[ Mstack_Destroy_Frame creator id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	if (creator) creator.call(pos, -1);
	rtrue;
];

Global MStack_Frame_Extent = 0;

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while ((pos > 0) && (MStack-->pos ~= 0)) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable for this action, activity or rulebook: ",
			"internal ID number ",
			id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! word position 0 on the M-stack
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

#IFNDEF MEMORY_ECONOMY;
Array rulebook_var_creators --> 0 0 0 0 0 0 0 0 0 0 RBSTVC_10 0 RBSTVC_12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
#ENDIF;
[  RBSTVC_10 pos state;
    if (state == 1) {
        MStack-->pos = selfobj; pos++;
    } else {
        pos++;
    }
    return 1;
];
[  RBSTVC_12 pos state;
    if (state == 1) {
        MStack-->pos = false; pos++;
        MStack-->pos = false; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = 0; pos++;
        MStack-->pos = false; pos++;
    } else {
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
        pos++;
    }
    return 6;
];


[ MStack_CreateRBVars rb cr;
#IFDEF MEMORY_ECONOMY;
switch (rb) {
10: cr = RBSTVC_10;
12: cr = RBSTVC_12;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#ENDIF;

	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
#IFDEF MEMORY_ECONOMY;
switch (rb) {
10: cr = RBSTVC_10;
12: cr = RBSTVC_12;
}
#IFNOT;
cr = rulebook_var_creators-->rb;
#ENDIF;

	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, rb);
];

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(cr, av + 10000);
];

[ Perform_Undo;
	#ifdef PREVENT_UNDO; L__M(##Miscellany, 70); return; #endif;
	if (turns == 1) { L__M(##Miscellany, 11); return; }
	if (undo_flag == 0) { L__M(##Miscellany, 6); return; }
	if (undo_flag == 1) { L__M(##Miscellany, 7); return; }
	if (VM_Undo() == 0) L__M(##Miscellany, 7);
];

[ ANNOUNCE_SCORE_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; L__M(##Score, 2);
	#ifnot; GL__M(##Score); PrintRank();
	#endif;
];

[ SWITCH_SCORE_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=1; #endif;
];

[ REP_SWITCH_NOTIFY_ON_R;
	if (actor ~= player) rfalse;
	#ifndef NO_SCORING; GL__M(##NotifyOn); #endif;
];

[ SWITCH_SCORE_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#ifdef NO_SCORING; ANNOUNCE_SCORE_R();
	#ifnot; notify_mode=0; #endif;
];

[ REP_SWITCH_NOTIFY_OFF_R;
	if (actor ~= player) rfalse;
	#ifndef NO_SCORING; GL__M(##NotifyOff); #endif;
];

[ PREFER_SOMETIMES_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=1;
]; ! Brief

[ REP_PREFER_SOMETIMES_ABBR_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode1);
]; ! Brief

[ PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=2;
]; ! Verbose

[ REP_PREFER_UNABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode2);
]; ! Verbose

[ PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	lookmode=3;
]; ! Superbrief

[ REP_PREFER_ABBREVIATED_R;
	if (actor ~= player) rfalse;
	print (string) Story; GL__M(##LMode3);
]; ! Superbrief

[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
	if (actor ~= player) rfalse;
	GL__M(##Pronouns, 1);

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) return GL__M(##Pronouns, 4);

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3) {
		print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) GL__M(##Pronouns, 3);
		else { GL__M(##Pronouns, 2); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) print (string) LISTAND__TX;
	}
	if (player ~= selfobj) {
		print "~", (address) ME1__WD, "~ "; GL__M(##Pronouns, 2);
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];

!Constant TRACE_I7_SPACING;

[ ClearParagraphing;
	say__p = 0; say__pc = 0;
];

[ DivideParagraphPoint;
	#ifdef TRACE_I7_SPACING; print "[DPP", say__p, say__pc, "]"; #endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		if (say__pc & PARA_PROMPTSKIP) say__pc = say__pc - PARA_PROMPTSKIP;
		if (say__pc & PARA_SUPPRESSPROMPTSKIP) say__pc = say__pc - PARA_SUPPRESSPROMPTSKIP;
	}
	#ifdef TRACE_I7_SPACING; print "[-->", say__p, say__pc, "]"; #endif;
	say__pc = say__pc | PARA_CONTENTEXPECTED;
];

[ ParaContent;
	if (say__pc & PARA_CONTENTEXPECTED) {
		say__pc = say__pc - PARA_CONTENTEXPECTED;
		say__p = 1;
	}
];

[ GoingLookBreak;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	ClearParagraphing();
];

[ CommandClarificationBreak;
	new_line;
	ClearParagraphing();
];

[ RunParagraphOn;
	#ifdef TRACE_I7_SPACING; print "[RPO", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
	say__pc = say__pc | PARA_SUPPRESSPROMPTSKIP;
];

[ SpecialLookSpacingBreak;
	#ifdef TRACE_I7_SPACING; print "[SLS", say__p, say__pc, "]"; #endif;
	say__p = 0;
	say__pc = say__pc | PARA_PROMPTSKIP;
];

[ EnsureBreakBeforePrompt;
	if ((say__p) ||
		((say__pc & PARA_PROMPTSKIP) && ((say__pc & PARA_SUPPRESSPROMPTSKIP)==0)))
		new_line;
	ClearParagraphing();
];

[ PrintSingleParagraph matter;
	say__p = 1;
	say__pc = say__pc | PARA_NORULEBOOKBREAKS;
	PrintText(matter);
	DivideParagraphPoint();
	say__pc = 0;
];

[ STextSubstitution;
	if (say__n ~= 1) print "s";
];

[ PrintPrompt i;
	style roman;
	EnsureBreakBeforePrompt();
	PrintText( (Global_Vars-->1) );
	ClearBoxedText();
	ClearParagraphing();
	enable_rte = true;
];

Global pending_boxed_quotation; ! a routine to overlay the quotation on screen

[ DisplayBoxedQuotation Q;
	pending_boxed_quotation = Q;
];

[ ClearBoxedText i;
	if (pending_boxed_quotation) {
		for (i=0: Runtime_Quotations_Displayed-->i: i++)
			if (Runtime_Quotations_Displayed-->i == pending_boxed_quotation) {
				pending_boxed_quotation = 0;
				return;
			}
		Runtime_Quotations_Displayed-->i = pending_boxed_quotation;

		ClearParagraphing();
		pending_boxed_quotation();
		ClearParagraphing();

		pending_boxed_quotation = 0;
	}
];

[ NotifyTheScore;
#Ifndef NO_SCORING;
	if (notify_mode == 1) {
		DivideParagraphPoint();
		VM_Style(NOTE_VMSTY);
		print "["; L__M(##Miscellany, 50, score-last_score); print ".]^";
		VM_Style(NORMAL_VMSTY);
	}
#Endif;
];

#Ifdef TARGET_ZCODE;
#Iftrue (#version_number == 6);
[ DrawStatusLine; Z6_DrawStatusLine(); ];
#Endif;
#Endif;

#Ifndef DrawStatusLine;
[ DrawStatusLine width posb;
	@push say__p; @push say__pc;
	BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
	VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1); 
	if (statuswin_current) {
		width = VM_ScreenWidth(); posb = width-15;
		spaces width;
		ClearParagraphing();
		if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {
			VM_MoveCursorInStatusLine(1, 2);
			switch(metaclass(left_hand_status_line)) {
				String: print (string) left_hand_status_line;
				Routine: left_hand_status_line();
			}
			VM_MoveCursorInStatusLine(1, posb);
			switch(metaclass(right_hand_status_line)) {
				String: print (string) right_hand_status_line;
				Routine: right_hand_status_line();
			}
		}
		VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();
	}
	ClearParagraphing();
	EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
	@pull say__pc; @pull say__p;
];
#Endif;

[ SL_Score_Moves;
	if (not_yet_in_play) return;
	#ifdef NO_SCORING; print sline2; #ifnot; print sline1, "/", sline2; #endif;
];

[ SL_Location;
	if (not_yet_in_play) return;
	if (location == thedark) {
		BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
		if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)
 			L__M(##Miscellany, 71);
		EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
	} else {
		FindVisibilityLevels();
		if (visibility_ceiling == location) print (name) location;
		else print (The) visibility_ceiling;
	}
];

[ Banner;
   BeginActivity(PRINTING_BANNER_TEXT_ACT);
   if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {
	   	VM_Style(HEADER_VMSTY);
		print (string) Story;
		VM_Style(NORMAL_VMSTY);
		new_line;
		print (string) Headline;
		#ifdef Story_Author;
		print " by ", (string) Story_Author;
		#endif; ! Story_Author
		new_line;
		VM_Describe_Release();
		print " / Inform 7 build ", (string) NI_BUILD_COUNT, " ";
		print "(I6/v"; inversion;
		print " lib ", (string) LibRelease, ") ";
		#Ifdef STRICT_MODE;
		print "S";
		#Endif; ! STRICT_MODE
		#Ifdef DEBUG;
		print "D";
		#Endif; ! DEBUG
		new_line;
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];

[ DecimalNumber num; print num; ];

[ EnglishNumber n; LanguageNumber(n); ];

[ PrintText x;
	if (x ofclass String) print (string) x;
	if (x ofclass Routine) (x)();
];
[ I7_String x; PrintText(x); ]; ! An alternative name now used only by extensions

[ PrintOrRun obj prop no_break  routine_return_value;
	!print "(", obj, ".", prop, ";", say__p, say__pc, ")";
	if (prop == 0) {
		print (name) prop; routine_return_value = true;
	} else {
		switch (metaclass(obj.prop)) {
			nothing:
				routine_return_value = false;
			String:
				if (obj.prop == EMPTY_TEXT_VALUE) break;
				print (string) obj.prop; !if (no_break == false) new_line;
				routine_return_value = true;
			Routine:
				routine_return_value = RunRoutines(obj, prop);
				!print "[", routine_return_value, "]";
		}
	}
	
	if (routine_return_value) {
		say__p = 1;
		if (no_break == false) {
			new_line;
			!print "(DP->", say__p, say__pc, ")";
			DivideParagraphPoint();
			!print "(to", say__p, say__pc, ")";
		}
	}

	!print "(-->", say__p, say__pc, ")";
	return routine_return_value;
];

Array StorageForShortName buffer 250;

[ CPrintOrRun obj prop  v length i;
    if ((obj ofclass String or Routine) || (prop == 0))
        VM_PrintToBuffer (StorageForShortName, 160, obj);
    else {
    	if (obj.prop == NULL) rfalse;
        if (metaclass(obj.prop) == Routine or String)
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        else return RunTimeError(2, obj, prop);
	}

    length = StorageForShortName-->0;

    StorageForShortName->WORDSIZE = VM_LowerToUpperCase(StorageForShortName->WORDSIZE);
    for (i=WORDSIZE: i<length+WORDSIZE: i++) print (char) StorageForShortName->i;
    if (i>WORDSIZE) say__p = 1;

    return;
];

[ Cap str nocaps;
    if (nocaps) print (string) str;
    else CPrintOrRun(str, 0);
];

[ PSN__ o;
    if (o == 0) { print (string) NOTHING__TX; rtrue; }
    switch (metaclass(o)) {
		Routine:  print "<routine ", o, ">"; rtrue;
		String:   print "<string ~", (string) o, "~>"; rtrue;
		nothing:  print "<illegal object number ", o, ">"; rtrue;
    }
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];

Global caps_mode = false;

[ STANDARD_NAME_PRINTING_R obj;
	obj = parameter_object;
    if (obj == 0) {
    	print (string) NOTHING__TX; return;
    }
    switch (metaclass(obj)) {
		Routine:  print "<routine ", obj, ">"; return;
		String:   print "<string ~", (string) obj, "~>"; return;
		nothing:  print "<illegal object number ", obj, ">"; return;
    }
    if (obj == player) { 
   	    if (indef_mode == NULL && caps_mode) print (string) YOU__TX;
   	    else print (string) YOURSELF__TX;
   	    return;
   	}
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) return;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0 &&
    	PrintOrRun(obj, short_name_indef, true) ~= 0) return;
    if (caps_mode &&
    	obj.&cap_short_name ~= 0 && PrintOrRun(obj, cap_short_name, true) ~= 0) {
    	caps_mode = false;
    	return;
    }
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, true) ~= 0) return;
    print (object) obj;
];

Global short_name_case;

[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;
    if (obj provides articles) {
        artval=(obj.&articles)-->(acode+short_name_case*LanguageCases);
        if (capitalise)
            print (Cap) artval, " ";
        else
            print (string) artval, " ";
        if (pluralise) return;
        print (PSN__) obj; return;
    }

    i = GetGNAOfObject(obj);
    if (pluralise) {
        if (i < 3 || (i >= 6 && i < 9)) i = i + 3;
    }
    i = LanguageGNAsToArticles-->i;

    artform = LanguageArticles
        + 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);

    #Iftrue (LanguageContractionForms == 2);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 3);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms == 4);
    if (artform-->acode ~= artform-->(acode+3)) findout = true;
    if (artform-->(acode+3) ~= artform-->(acode+6)) findout = true;
    if (artform-->(acode+6) ~= artform-->(acode+9)) findout = true;
    #Endif; ! LanguageContractionForms
    #Iftrue (LanguageContractionForms > 4);
    findout = true;
    #Endif; ! LanguageContractionForms

    #Ifdef TARGET_ZCODE;
    if (standard_interpreter ~= 0 && findout) {
        StorageForShortName-->0 = 160;
        @output_stream 3 StorageForShortName;
        if (pluralise) print (number) pluralise; else print (PSN__) obj;
        @output_stream -3;
        acode = acode + 3*LanguageContraction(StorageForShortName + 2);
    }
    #Ifnot; ! TARGET_GLULX
    if (findout) {
        if (pluralise)
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        else
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        acode = acode + 3*LanguageContraction(StorageForShortName);
    }
    #Endif; ! TARGET_

    Cap (artform-->acode, ~~capitalise); ! print article
    if (pluralise) return;
    print (PSN__) obj;
];

[ IndefArt obj i;
	if (obj == 0) { print (string) NOTHING__TX; rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }
    if ((obj provides article) && (obj.article ~= EMPTY_TEXT_VALUE)) {
        PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2); indef_mode = i;
];

[ CIndefArt obj i;
	if (obj == 0) { CPrintOrRun(NOTHING__TX, 0); rtrue; }
    i = indef_mode; indef_mode = true;
    if (obj has proper) {
    	indef_mode = NULL;
		caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((obj provides article) && (obj.article ~= EMPTY_TEXT_VALUE)) {
        CPrintOrRun(obj, article); print " ", (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;
];

[ DefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 1); indef_mode = i;
];

[ CDefArt obj i;
    i = indef_mode; indef_mode = false;
    if ((obj ofclass Object) && (obj has proper || obj == player)) {
    	indef_mode = NULL;
    	caps_mode = true;
    	print (PSN__) obj;
    	indef_mode = i;
    	caps_mode = false;
    	return;
    }
    if ((~~obj ofclass Object) || obj has proper) {
        indef_mode = NULL; print (PSN__) obj; indef_mode = i;
        return;
    }
    PrefaceByArticle(obj, 0); indef_mode = i;
];

[ PrintShortName obj i;
    i = indef_mode; indef_mode = NULL;
    PSN__(obj); indef_mode = i;
];

[ I7_SOO_PAR oldval count; if (count <= 1) return count; return random(count); ];
[ I7_SOO_RAN oldval count v; if (count <= 1) return count;
	v = oldval; while (v == oldval) v = random(count); return v; ];
[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];
[ I7_SOO_CYC oldval count; oldval++; if (oldval > count) oldval = 1; return oldval; ];
[ I7_SOO_STOP oldval count; oldval++; if (oldval > count) oldval = count; return oldval; ];
[ I7_SOO_TAP oldval count tn rn c; if (count <= 1) return count; tn = count*(count+1)/2;
	rn = random(tn); for (c=1:c<=count:c++) { rn = rn - c; if (rn<=0) return (count-c+1); } ];
[ I7_SOO_TRAN oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];
[ I7_SOO_TPAR oldval count; if (oldval<count) return oldval+1; 
	return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];

Array I7_SOO_SHUF->32;

[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
	base = count+1;
	v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;
	if (count > 32) return I7_SOO_PAR(oldval, count);
	if (count <= 1) v = count;
	else {
		!print "^In v=", v, " ct=", ct, " sd=", sd, "^";
		cc = base*base;
		scope = (MAX_POSITIVE_NUMBER-1)/cc;
		!print "Scope = ", scope, "^";
		if (sd == 0) { sd = random(scope); ct=0; }
		for (i=0:i<count:i++) I7_SOO_SHUF->i = i;
		ssd = sd;
		for (i=0:i<count-1:i++) {
			j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd<0) sd=-sd;
			s = I7_SOO_SHUF->j; I7_SOO_SHUF->j = I7_SOO_SHUF->i; I7_SOO_SHUF->i = s;
		}
		!for (i=0:i<count:i++) print I7_SOO_SHUF->i, " "; print "^";
		v = (I7_SOO_SHUF->ct)+1;
		ct++; if (ct >= count) { ct = 0; ssd = 0; }
	}
	!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";
	!print "Return ", v + ct*base + ssd*base*base, "^";
	return v + ct*base + ssd*base*base;
];

Constant RR_NAME     		4;
Constant RR_PERMISSIONS		5;
Constant RR_STORAGE			6;
Constant RR_KIND			7;
Constant RR_HANDLER			8;
Constant RR_DESCRIPTION		9;

Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;
[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & RELS_EQUIVALENCE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		perms = perms + RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;
	}
	if ((set == false) && (state)) {
		perms = perms - RELS_EQUIVALENCE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to an equivalence relation ***";		
];

[ RELATION_TY_SymmetricAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & RELS_SYMMETRIC) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) perms = perms + RELS_SYMMETRIC;
	if ((set == false) && (state)) perms = perms - RELS_SYMMETRIC;
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a symmetric relation ***";		
];

[ RELATION_TY_OToOAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-one relation ***";		
];

[ RELATION_TY_OToVAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a one-to-various relation ***";		
];

[ RELATION_TY_VToOAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
		if (perms & RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;
		if (perms & RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-one relation ***";		
];

[ RELATION_TY_VToVAdjective rel set  perms state handler;
	perms = rel-->RR_PERMISSIONS;
	if (perms & (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;
	if (set < 0) return state;
	if ((set) && (state == false)) {
		if (perms & RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;
	}
	if ((set == false) && (state)) {
		if (perms & RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;
		if (perms & RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;
	}
	rel-->RR_PERMISSIONS = perms;
	handler = rel-->RR_HANDLER;
	if (handler(rel, RELS_SET_VALENCY, perms & VALENCY_MASK) == 0)
		"*** Can't change this to a various-to-various relation ***";		
];

[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true
	if (obj2) objectloop (ol provides relation_property)
		if (ol.relation_property == obj2) ol.relation_property = nothing;
	if (obj1) obj1.relation_property = obj2;
];

[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false
	if ((obj1) && (obj1.relation_property == obj2)) obj1.relation_property = nothing;
];

[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true
	if (obj2) {
		N = KOVDomainSize(KOV);
		for (ol=1: ol<=N: ol++)
			if (GProperty(KOV, ol, relation_property) == obj2)
				WriteGProperty(KOV, ol, relation_property, 0);
	}
	if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);
];

[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false
	if ((obj1) && (GProperty(KOV, obj1, relation_property) == obj2))
		WriteGProperty(KOV, obj1, relation_property, 0);
];

[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property)) {
		if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }
		if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }
		obj1.relation_property = obj2; obj2.relation_property = obj1;
	}
];

[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false
	if ((obj1 ofclass Object) && (obj1 provides relation_property) &&
		(obj2 ofclass Object) && (obj2 provides relation_property) &&
		(obj1.relation_property == obj2)) {
		obj1.relation_property = 0; obj2.relation_property = 0;
	}
];

[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true
	if (GProperty(KOV, obj1, relation_property))
		WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
	if (GProperty(KOV, obj2, relation_property)) 
		WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
	WriteGProperty(KOV, obj1, relation_property, obj2);
	WriteGProperty(KOV, obj2, relation_property, obj1);
];

[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false
	if (GProperty(KOV, obj1, relation_property) == obj2) {
		WriteGProperty(KOV, obj1, relation_property, 0);
		WriteGProperty(KOV, obj2, relation_property, 0);
	}
];

Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;

[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	vtov_structure-->pr = (vtov_structure-->pr) | i1;
];

[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	if (sym && (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	vtov_structure-->VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, relation);
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, relation);
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) vtov_structure-->pr = vtov_structure-->pr - i1;
];

[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
		if ((obj2 ofclass Object) && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE) + i2;
	i1 = IncreasingPowersOfTwo_TB-->(pr%16);
	pr = pr/16 + 8;
	if ((vtov_structure-->pr) & i1) rtrue; rfalse;
];

[ Relation_NowEquiv obj1 relation_property obj2 big little;
	big = obj1.relation_property; little = obj2.relation_property;
	if (big == little) return;
	if (big < little) { little = obj1.relation_property; big = obj2.relation_property; }
	objectloop (obj1 provides relation_property)
		if (obj1.relation_property == big) obj1.relation_property = little;
];

[ Relation_NowNEquiv obj1 relation_property obj2 old new;
	old = obj1.relation_property; new = obj2.relation_property;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides relation_property)
		if (obj2.relation_property > new) new = obj2.relation_property;
	new++;
	obj1.relation_property = new;
];

[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
	big = GProperty(KOV, obj1, relation_property);
	little = GProperty(KOV, obj2, relation_property);
	if (big == little) return;
	if (big < little) {
		little = GProperty(KOV, obj1, relation_property);
		big = GProperty(KOV, obj2, relation_property);
	}
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) == big)
			WriteGProperty(KOV, i, relation_property, little);
];

[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
	old = GProperty(KOV, obj1, relation_property); 
	new = GProperty(KOV, obj2, relation_property);
	if (old ~= new) return;
	new = 0;
	n = KOVDomainSize(KOV);
	for (i=1: i<=n: i++)
		if (GProperty(KOV, i, relation_property) > new)
			new = GProperty(KOV, i, relation_property);
	new++;
	WriteGProperty(KOV, obj1, relation_property, new);
];

[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	pr = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	proutine1 = vtov_structure-->VTOVS_LEFT_PRINTING_ROUTINE;
	proutine2 = vtov_structure-->VTOVS_RIGHT_PRINTING_ROUTINE;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (Relation_TestVtoV(obj1, relation, obj2)) {
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=vtov_structure-->2:obj1++)
		  for (obj2=1:obj2<=vtov_structure-->VTOVS_RIGHT_DOMAIN_SIZE:obj2++)
			if (Relation_TestVtoV(obj1, relation, obj2)) {
				if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];

[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;
	relation_property = relation-->RR_STORAGE;
	t = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property) {
			obj2 = obj1.relation_property;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
			print "  ", (The) obj1;
			if (sym) print "  ==  "; else print "  >=>  ";
			print (the) obj2, "^";
		}
	} else {
		for (obj1=1: obj1<=N: obj1++) {
			obj2 = GProperty(t, obj1, relation_property);
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
			if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
			print "  ";
			PrintKindValuePair(t, obj1);
			if (sym) print "  ==  "; else print "  >=>  ";
			PrintKindValuePair(t, obj2);
			print "^";
		}
	}
];

[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
	relation_property = relation-->RR_STORAGE;
	t1 = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	t2 = KindBaseTerm(relation-->RR_KIND, 1); ! Kind of right term
	if (t2 == OBJECT_TY) {
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  "; PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					print (the) obj2, "^";
				}
			}
		}
	} else {
		N2 = KOVDomainSize(t2);
		if (t1 == OBJECT_TY) {
			objectloop (obj1) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ", (The) obj1;
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		} else {
			N1 = KOVDomainSize(t1);
			for (obj1=1: obj1<=N1: obj1++) {
				for (obj2=1: obj2<=N2: obj2++) {
					if (GProperty(t2, obj2, relation_property) ~= obj1) continue;
					if (x == 0) { print (string) relation-->RR_DESCRIPTION, ":^"; x=1; }
					print "  ";
					PrintKindValuePair(t1, obj1);
					print "  >=>  ";
					PrintKindValuePair(t2, obj2);
					print "^";
				}
			}
		}
	}
];

[ RSE_Flip KOV v relation_property x;
	x = GProperty(KOV, v, relation_property); x = -x;
	WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
	if (GProperty(KOV, v, relation_property) < 0) rtrue; rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
	print (string) relation-->RR_DESCRIPTION, ":^";
	relation_property = relation-->RR_STORAGE;
	t = KindBaseTerm(relation-->RR_KIND, 0); ! Kind of left term
	N = KOVDomainSize(t);
	if (t == OBJECT_TY) {
		objectloop (obj1 provides relation_property)
			obj1.relation_property = -(obj1.relation_property);
		objectloop (obj1 provides relation_property) {
			if (obj1.relation_property < 0) {
				v = obj1.relation_property; c = 0;
				objectloop (obj2 has workflag2) give obj2 ~workflag2;
				objectloop (obj2 provides relation_property) {
					if (obj2.relation_property == v) {
						give obj2 workflag2;
						obj2.relation_property = -v;
						c++;
					}
				}
				if (c>1) {
					somegroups = true;
					print "  { ";
					WriteListOfMarkedObjects(ENGLISH_BIT);
					print " }^";
				} else obj1.relation_property = v;
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0; objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0) { c++; give obj1 workflag2; }
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c < 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }
		else print c;
		if (c == 1) print " a";
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		objectloop (obj1 provides relation_property)
			if (obj1.relation_property < 0)
				obj1.relation_property = -(obj1.relation_property);
	} else {
		! A slower method, since we have less efficient storage:
		for (obj1 = 1: obj1 <= N: obj1++)
			RSE_Flip(t, obj1, relation_property);
		for (obj1 = 1: obj1 <= N: obj1++) {
			if (RSE_Set(t, obj1, relation_property)) {
				v = GProperty(t, obj1, relation_property);
				c = 0;
				for (obj2 = 1: obj2 <= N: obj2++)
					if (GProperty(t, obj2, relation_property) == v)
						c++;
				if (c>1) {
					somegroups = true;
					print "  {";
					d = 0;
					for (obj2 = 1: obj2 <= N: obj2++) {
						if (GProperty(t, obj2, relation_property) == v) {
							print " "; PrintKindValuePair(t, obj2);
							if (d < c-1) print ","; print " ";
							RSE_Flip(t, obj2, relation_property);
							d++;
						}
					}
					print "}^";
				} else WriteGProperty(t, obj1, relation_property, v);
			}
		}
		objectloop (obj2 has workflag2) give obj2 ~workflag2;
		c = 0;
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property)) c++;
		if (c == 0) return;
		if (somegroups) print "  and "; else print "  ";
		if (c == 1) print "a"; else print c;
		print " single-member group";
		if (c > 1) print "s";
		print "^";
		for (obj1 = 1: obj1 <= N: obj1++)
			if (RSE_Set(t, obj1, relation_property))
				RSE_Flip(t, obj1, relation_property);
	}
];

#ifndef FAST_ROUTE_FINDING;
#ifndef SLOW_ROUTE_FINDING;
#ifdef TARGET_GLULX;
Constant FAST_ROUTE_FINDING;
#ifnot;
Constant SLOW_ROUTE_FINDING;
#endif;
#endif;
#endif;

Constant NUM_DOORS = 4;
Constant NUM_ROOMS = 27;

Array DoorRoutingViable -> NUM_DOORS+1;

Global map_has_changed = true;
Global last_filter; Global last_use_doors;

[ SignalMapChange; map_has_changed = true; ];

[ MapRouteTo from to filter use_doors count  oy oyi ds;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if ((filter) && (filter(from) == 0)) return nothing;
	if ((filter) && (filter(to) == 0)) return nothing;
	if ((last_filter ~= filter) || (last_use_doors ~= use_doors)) map_has_changed = true;
	oyi = 0;
	objectloop (oy has mark_as_room) {
		if ((filter == 0) || (filter(oy))) {
			if (oy.room_index == -1) map_has_changed = true;
			oy.room_index = oyi++;
		} else {
			if (oy.room_index >= 0) map_has_changed = true;
			oy.room_index = -1;
		}
	}
	oyi = 0;
	objectloop (oy ofclass K4_door) {
		ds = false;
		if ((use_doors & 2) ||
			(oy has open) || ((oy has openable) && (oy hasnt locked))) ds = true;
		if (DoorRoutingViable->oyi ~= ds) map_has_changed = true;
		DoorRoutingViable->oyi = ds;
		oyi++;
	}
	if (map_has_changed) {
		#ifdef FAST_ROUTE_FINDING; ComputeFWMatrix(filter, use_doors); #endif;
		map_has_changed = false; last_filter = filter; last_use_doors = use_doors;
	}
	#ifdef FAST_ROUTE_FINDING;
	if (count) return FastCountRouteTo(from, to, filter, use_doors);
	return FastRouteTo(from, to, filter, use_doors);
	#ifnot;
	if (count) return SlowCountRouteTo(from, to, filter, use_doors);
	return SlowRouteTo(from, to, filter, use_doors);
	#endif;
];

#ifdef FAST_ROUTE_FINDING;
Array FWMatrix --> NUM_ROOMS*NUM_ROOMS;

[ FastRouteTo from to filter use_doors diri i dir oy;
	if (from == to) return nothing;
	i = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (i == 0) return nothing;
	diri = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))%No_Directions;
	i=0; objectloop (dir ofclass K3_direction) {
		if (i == diri) return dir;
		i++;
	}
	return nothing;
];

[ FastCountRouteTo from to filter use_doors  k;
	if (from == to) return 0;
	k = (FWMatrix-->(from.room_index*NUM_ROOMS + to.room_index))/No_Directions;
	if (k == 0) return -1;
	return k;
];

[ ComputeFWMatrix filter use_doors  oy ox oj axy ayj axj dir diri nd row;
	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0)
			FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = 0;

	objectloop (oy has mark_as_room) if (oy.room_index >= 0) {
		row = (oy.IK1_Count)*No_Directions;
		for (diri=0: diri<No_Directions: diri++) {
			ox = Map_Storage-->(row+diri);
			if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
				FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
				continue;
			}
			if (use_doors && (ox ofclass K4_door) &&
				((use_doors & 2) || (DoorRoutingViable->(ox.IK4_Count)))) {
				@push location; location = oy;
				ox = ox.door_to();
				@pull location;
				if ((ox) && (ox has mark_as_room) && (ox.room_index >= 0)) {
					FWMatrix-->(oy.room_index*NUM_ROOMS + ox.room_index) = No_Directions + diri;
					continue;
				}
			}
		}	
	}

	objectloop (oy has mark_as_room) if (oy.room_index >= 0)
		objectloop (ox has mark_as_room) if (ox.room_index >= 0) {
			axy = (FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))/No_Directions;
			if (axy > 0)
				objectloop (oj has mark_as_room) if (oj.room_index >= 0) {
					ayj = (FWMatrix-->(oy.room_index*NUM_ROOMS + oj.room_index))/No_Directions;
					if (ayj > 0) {
						!print "Is it faster to go from ", (name) ox, " to ",
						!   (name) oj, " via ", (name) oy, "?^";
						axj = (FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index))/
							No_Directions;
						if ((axj == 0) || (axy + ayj < axj)) {
							!print "Yes^";
							FWMatrix-->(ox.room_index*NUM_ROOMS + oj.room_index) =
								(axy + ayj)*No_Directions +
								(FWMatrix-->(ox.room_index*NUM_ROOMS + oy.room_index))%
									No_Directions;
						}
					}
				}
		}
];
#ENDIF;

#ifndef FAST_ROUTE_FINDING;
[ SlowRouteTo from to filter use_doors  obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj has mark_as_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj has mark_as_room)
			if ((filter == 0) || (filter(obj)))
				if (obj.vector == 0)
					objectloop (dir ofclass K3_direction) {
						in_direction = Map_Storage-->((obj.IK1_Count)*No_Directions + dir.IK3_Count);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction)
							&& (in_direction has mark_as_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | WORD_HIGHBIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door)
								&& (through_door has mark_as_room)
								&& (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | WORD_HIGHBIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj has mark_as_room) obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) return from.vector;
		if (progressed == false) return from.vector;
	}
];

[ SlowCountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from has mark_as_room && to has mark_as_room) {
		obj = MapRouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<NUM_ROOMS)) { i++; obj = MapConnection(obj,obj.vector); }
		return i;
	}
	return -1;
];
#ENDIF;

Constant MAX_ROUTE_LENGTH = 286 + 32;

[ RelationRouteTo relation from to count  handler;
	if (count) {
		if (from == nothing) return -1;
		if (to == nothing) return -1;
		if (relation == 0) return -1;
	} else {
		if (from == nothing) return nothing;
		if (to == nothing) return nothing;
		if (relation == 0) return nothing;
	}
	if (from == to) return nothing;
	if (((relation-->RR_PERMISSIONS) & RELS_ROUTE_FIND) == 0) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	if (relation-->RR_STORAGE == 0) return nothing;
	handler = relation-->RR_HANDLER;
	if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);
	return handler(relation, RELS_ROUTE_FIND, from, to);
];

[ RelFollowVector rv from to  obj i;
	if (rv == nothing) return -1;
	i = 0; obj = from;
	while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
	return i;
];

[ OtoVRelRouteTo relation_property from to previous;
	while ((to) && (to provides relation_property) && (to.relation_property)) {
		previous = to.relation_property;
		previous.vector = to;
		if (previous == from) return to;
		to = previous;
	}
	return nothing;
];

[ VtoORelRouteTo relation_property from to next  start;
	start = from;
	while ((from) && (from provides relation_property) && (from.relation_property)) {
		next = from.relation_property;
		from.vector = next;
		if (from == to) return start.vector;
		from = next;
	}
	return nothing;
];

[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
	vtov_structure = relation-->RR_STORAGE;
	if (vtov_structure-->VTOVS_CACHE)
		return FastVtoVRelRouteTo(relation, from, to, count);
	left_ix = vtov_structure-->VTOVS_LEFT_INDEX_PROP;
	pr2 = vtov_structure-->VTOVS_RIGHT_INDEX_PROP;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides left_ix)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (Relation_TestVtoV(obj, relation, obj2)) {
						obj.vector = obj2 | WORD_HIGHBIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides left_ix)
			obj.vector = obj.vector &~ WORD_HIGHBIT;
		if (from.vector) break;
		if (progressed == false) break;
	}
	if (count) {
		if (from.vector == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }
		return i;
	}
	return from.vector;
];

[ FastVtoVRelRouteTo relation from to count
	domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
	domainsize = relation-->RR_STORAGE-->2; ! Number of left instances
	left_ix = relation-->RR_STORAGE-->VTOVS_LEFT_INDEX_PROP;
	if ((from provides left_ix) && (to provides left_ix)) {
		if (domainsize < 256) {
			cache = relation-->RR_STORAGE-->VTOVS_CACHE;
			cache2 = cache + domainsize*domainsize;
			if (relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN == true) {
				relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 1;
							cache2->offset = ox.left_ix;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache->offset = 0;
							cache2->offset = 255;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache->offset = (axy + ayj);
										cache2->offset = cache2->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			oy = cache2->((from.left_ix)*domainsize + (to.left_ix));
			if (oy < 255)
				objectloop (ox provides left_ix)
					if (ox.left_ix == oy) return oy;
			return nothing;
		} else {
			cache = relation-->RR_STORAGE-->VTOVS_CACHE;
			cache2 = cache + WORDSIZE*domainsize*domainsize;
			if (relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN == true) {
				relation-->RR_STORAGE-->VTOVS_CACHE_BROKEN = false;
				objectloop (oy provides left_ix)
					objectloop (ox provides left_ix)
						if (Relation_TestVtoV(oy, relation, ox)) {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 1;
							cache2-->offset = ox;
						} else {
							offset = ((oy.left_ix)*domainsize + (ox.left_ix));
							cache-->offset = 0;
							cache2-->offset = nothing;
						}
				for (oy=0: oy<domainsize: oy++)
					for (ox=0: ox<domainsize: ox++) {
						axy = cache-->(ox*domainsize + oy);
						if (axy > 0)
							for (oj=0: oj<domainsize: oj++) {
								ayj = cache-->(oy*domainsize + oj);
								if (ayj > 0) {
									offset = ox*domainsize + oj;
									axj = cache-->offset;
									if ((axj == 0) || (axy + ayj < axj)) {
										cache-->offset = (axy + ayj);
										cache2-->offset = cache2-->(ox*domainsize + oy);
									}
								}
							}
					}
			}
			if (count) {
				count = cache-->((from.left_ix)*domainsize + (to.left_ix));
				if (count == 0) return -1;
				return count;
			}
			return cache2-->((from.left_ix)*domainsize + (to.left_ix));
		}
	}
	if (count) return -1;
	return nothing;
];

[ IterateRelations callback;
	callback(Rel_Record_63);
    callback(Rel_Record_65);
    callback(Rel_Record_67);
    callback(Rel_Record_69);

];

[ RunTimeProblem n par1 par2 par3 ln   i c;
	if (enable_rte == false) return;
	enable_rte = false;
	print "^*** Run-time problem P", n;
	if (ln) print " (at paragraph ", ln, " in the source text)";
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) par1, " (a backdrop) to ", (the) par2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) par1, ", which is not a person.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) par2, " exit of ", (the) par1,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) par1,
				", violating '", (string) par2-->RR_DESCRIPTION, "'.^";
		RTP_RULESTACK:
			print "Too many procedural rules acting all at once.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) par1, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) par1, " is not allowed the property ~",
					(string) par2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) par1, " is allowed to have the property ~",
				(string) par2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", par1, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a backdrop) to ", (the) par2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", par2,
				", row ", par3, " of the table '", (PrintTableName) par1, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				par1, ").^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTRUNTHROUGH:
			print "Attempt to repeat through a table in a tricky column order: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_CANTSAVE:
			print "Attempt to save a table to a file whose data is unstable: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_WONTFIT:
			print "File being read has too many rows or columns to fit into table: table '",
				(PrintTableName) par1, "'.^";
		RTP_TABLE_BADFILE:
			print "File being read is not a previously saved table: table '",
				(PrintTableName) par1, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) par1, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object: property ",
				(PrintPropertyName) par2, "^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		RTP_LOWLEVELERROR:
			print "Low level error.^";
		RTP_DONTIGNORETURNSEQUENCE:
			print "Attempt to ignore the turn sequence rules.^";
		RTP_SAYINVALIDSNIPPET:
			print "Attempt to say a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_SPLICEINVALIDSNIPPET:
			print "Attempt to splice a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_INCLUDEINVALIDSNIPPET:
			print "Attempt to match a snippet value which is currently invalid: words ",
				par1, " to ", par2, ".^";
		RTP_LISTWRITERMEMORY:
			print "The list-writer has run out of memory.^";
		RTP_CANTREMOVEPLAYER:
			print "Attempt to remove the player from play.^";
		RTP_CANTREMOVEDOORS:
			print "Attempt to remove a door from play.^";
		RTP_CANTCHANGEOFFSTAGE:
			print "Attempt to change the player to a person off-stage.^";
		RTP_MSTACKMEMORY:
			print "The memory stack is exhausted.^";
		RTP_TYPECHECK:
			print "Phrase applied to an incompatible kind of value.^";
		RTP_FILEIOERROR:
			print "Error handling external file.^";
		RTP_HEAPERROR:
			print "Memory allocation proved impossible.^";
		RTP_LISTRANGEERROR:
			print "Attempt to use list item which does not exist.^";
		RTP_REGEXPSYNTAXERROR:
			print "Syntax error in regular expression.^";
		RTP_NOGLULXUNICODE:
			print "This interpreter does not support Unicode.^";
		RTP_BACKDROPONLY:
			print "Only backdrops can be moved to multiple places.^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) par1, " (not a thing) to ", (the) par2,
				", but only things can move around.^";
		RTP_SCENEHASNTSTARTED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't started, so you can't ask when it did.^";
		RTP_SCENEHASNTENDED:
			print "The scene ", (PrintSceneName) par1,
				" hasn't ended, so you can't ask when it did.^";
		RTP_NEGATIVEROOT:
			print "You can't take the square root of a negative number.^";
		RTP_CANTITERATE:
			print "You can't implicitly repeat through the values of this kind: ",
				"a problem arising from a description which started out here - ~",
				(string) par1, "~.^";
		RTP_WRONGASSIGNEDKIND:
			print "Attempt to set a variable to the wrong kind of object: ",
				"you wrote '", (string) par2, "', which sets the value to ", (the) par1,
				" - but that doesn't have the kind '", (string) par3, "'.^";			
		}
	print "^";
];

Constant MAX_TIMERS = 0;
[ RunTimeError n p1 p2;
    #Ifdef DEBUG;
    print "** Library error ", n, " (", p1, ",", p2, ") **^** ";
    switch (n) {
      1:    print "preposition not found (this should not occur)";
      2:    print "Property value not routine or string: ~", (property) p2, "~ of ~", (name) p1,
                  "~ (", p1, ")";
      3:    print "Entry in property list not routine or string: ~", (property) p2, "~ list of ~",
                  (name) p1, "~ (", p1, ")";
      4:    print "Too many timers/daemons are active simultaneously.
                  The limit is the library constant MAX_TIMERS (currently ",
                  MAX_TIMERS, ") and should be increased";
      5:    print "Object ~", (name) p1, "~ has no ~time_left~ property";
      7:    print "The object ~", (name) p1, "~ can only be used as a player object if it has
                  the ~number~ property";
      8:    print "Attempt to take random entry from an empty table array";
      9:    print p1, " is not a valid direction property number";
      10:   print "The player-object is outside the object tree";
      11:   print "The room ~", (name) p1, "~ has no ~description~ property";
      12:   print "Tried to set a non-existent pronoun using SetPronoun";
      13:   print "A 'topic' token can only be followed by a preposition";
      default: print "(unexplained)";
    }
    print " **^";
    #Ifnot;
    print "** Library error ", n, " (", p1, ",", p2, ") **^";
    #Endif; ! DEBUG
    RunTimeProblem(RTP_LOWLEVELERROR);
];

[ ArgumentTypeFailed file line arg;
	RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line);
];

[ CheckKindReturned V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];

[ WhetherProvides obj either_or p issue_rtp  off i textual a l;
	if (metaclass(obj) ~= Object) rfalse;
	if (p<0) p = ~p;
	if (either_or) {
		if (p < FBNA_PROP_NUMBER) off = attributed_property_offsets-->p;
		else off = valued_property_offsets-->p;
	} else off = valued_property_offsets-->p;
	if (off<0) {
		if (issue_rtp) RunTimeProblem(RTP_BADPROPERTY, obj);
		rfalse;
	}
	textual = property_metadata-->off; off++;
	
	if (ScanPropertyMetadata(obj, off)) jump PermissionFound;
	if (obj provides KD_Count) {
		l = obj.KD_Count;
		while (l > 0) {
			a = l*2;
			if (ScanPropertyMetadata(KindHierarchy-->a, off)) jump PermissionFound;
			l = KindHierarchy-->(a+1);
		}
	}
	if (issue_rtp) RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;

	.PermissionFound;
		if (either_or) rtrue;
		if (obj provides p) rtrue;
		if (issue_rtp) RunTimeProblem(RTP_UNSET, obj, textual);
		rfalse;
];

[ PrintPropertyName  p  off textual;
	if (p<0) p = ~p;
	off = valued_property_offsets-->p;
	textual = property_metadata-->off;
	print (string) textual;
];

[ ScanPropertyMetadata obj off i;
	for (i=off: property_metadata-->i >= 0: i++)
		if (obj == property_metadata-->i) rtrue;
	rfalse;
];

[ GetEitherOrProperty o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (WhetherProvides(o, true, p, false)) {
		if (p<FBNA_PROP_NUMBER) { if (o has p) rtrue; rfalse; }
		if ((o provides p) && (o.p)) rtrue;
	}
	rfalse;
];

[ SetEitherOrProperty o p negate adj;
	if (p<0) { p = ~p; negate = ~negate; }
	if (adj) {
		(adj)(o);
	} else if (WhetherProvides(o, true, p, true)) {
		if (negate) {
			if (p<FBNA_PROP_NUMBER) give o ~p; else o.p = false;
		} else {
			if (p<FBNA_PROP_NUMBER) give o p; else o.p = true;
		}
	}
];

[ GProperty K V pr obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (obj provides pr) {
		if (K == OBJECT_TY) {
			if (pr == door_to) return obj.pr();
			if (WhetherProvides(V, false, pr, true)) return obj.pr;
			rfalse;
		}
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
		if ((V < 1) || (V > obj.value_range)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY); return 0; }
		return (obj.pr)-->(V+COL_HSIZE);
	} else {
		if (obj ofclass K0_kind)
			WhetherProvides(V, false, pr, true); ! to force a run-time problem
	}
    rfalse;
];

[ WriteGProperty K V pr val obj;
	if (K == OBJECT_TY) obj = V; else obj = KOV_representatives-->K;
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (K == OBJECT_TY) {
		if (WhetherProvides(V, false, pr, true)) obj.pr = val;
	} else {
		if ((V < 1) || (V > obj.value_range))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		if (obj provides pr) { (obj.pr)-->(V+COL_HSIZE) = val; }
	}
];

[ PROPERTY_TY_Say v;
	print "property ", v;
];

Constant RULECHANGE_STACK_SIZE = 501;
Global rulechange_sp = 0;
Array rulechange_stack --> RULECHANGE_STACK_SIZE;

[ PushRuleChange usage rule1 rule2;
	if (rulechange_sp >= RULECHANGE_STACK_SIZE) return RunTimeProblem(RTP_RULESTACK);
	if ((rulechange_stack-->rulechange_sp == RS_SUCCEEDS or RS_FAILS) &&
		(KOVIsBlockValue(rulechange_stack-->(rulechange_sp+1))))
		BlkValueDestroy(rulechange_stack-->(rulechange_sp+2));
	if ((usage == RS_SUCCEEDS or RS_FAILS) && (KOVIsBlockValue(rule1)))
		rule2 = BlkValueCopy(BlkValueCreate(rule1), rule2);
	rulechange_stack-->rulechange_sp++ = usage;
	rulechange_stack-->rulechange_sp++ = rule1;
	rulechange_stack-->rulechange_sp++ = rule2;
];

Constant RS_FRAME       = -1;

Constant RS_DONOTRUN	= 1;
Constant RS_RUN			= 2;
Constant RS_MOVEBEFORE	= 3;
Constant RS_MOVEAFTER	= 4;
Constant RS_DONOTUSE	= 5;
Constant RS_USE			= 6;
Constant RS_SUBSTITUTE	= 7;

Constant RS_SUCCEEDS	= 8;
Constant RS_FAILS		= 9;
Constant RS_NEITHER		= 10;

Global rule_frames = 0; ! Number of frames currently in force
Constant MAX_SIMULTANEOUS_FRAMES = 20;

[ FollowRulebook rulebook parameter no_paragraph_skips  rv;
	@push self;
	if ((Protect_I7_Arrays-->0 ~= 16339) || (Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (parameter) self = parameter;
	if (rulebook ~= PROCEDURAL_RB) BeginFollowRulebook();
	rv = ProcessRulebook(rulebook, parameter, no_paragraph_skips);
	if (rulebook ~= PROCEDURAL_RB) EndFollowRulebook();
	@pull self;
	if (rv) rtrue;
	rfalse;
];

[ BeginFollowRulebook;
	PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
	rule_frames++;
	if (rule_frames == MAX_SIMULTANEOUS_FRAMES) {
		RunTimeProblem(RTP_TOOMANYRULEBOOKS);
		rule_frames = -1; ! For recovery: this terminates rulebook processing
		return;
	}
	ProcessRulebook(PROCEDURAL_RB, 0, true);
];

[ EndFollowRulebook r x y;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) r = 1;
	else if (rulechange_stack-->rulechange_sp == RS_FAILS) r = 0;
	else r = -1;
	if (r ~= -1) {
		x = rulechange_stack-->(rulechange_sp+1);
		y = rulechange_stack-->(rulechange_sp+2);
	}
	rule_frames--;
	while (rulechange_sp > 0) {
		rulechange_sp = rulechange_sp - 3;
		if (rulechange_stack-->rulechange_sp == RS_FRAME) break;
	}
	if (rulechange_sp == 0) rule_frames = 0;
	if (r == 1) rulechange_stack-->rulechange_sp = RS_SUCCEEDS;
	else if (r == 0) rulechange_stack-->rulechange_sp = RS_FAILS;
	if (r ~= -1) {
		rulechange_stack-->(rulechange_sp+1) = x;
		rulechange_stack-->(rulechange_sp+2) = y;
	}
];

Constant RS_ACTIVE_BIT		= 1;
Constant RS_MOVED_BIT		= 2;
Constant RS_USERESULT_BIT	= 4;
Constant RS_ACTIVITY		= 8;
Constant RS_NOSKIPS			= 16;
Constant RS_AFFECTED_BIT	= 32;

Global process_rulebook_count; ! Depth of processing recursion
Global debugging_rules = false; ! Are we tracing rule invocations?

[ ProcessRulebook rulebook parameter bits rv
	x frame_base substituted_rule usage original_deadflag rbaddress ra acf gc ga;
	if (bits) bits = RS_ACTIVITY + RS_NOSKIPS;
	if (say__pc & PARA_NORULEBOOKBREAKS) bits = bits | RS_NOSKIPS;
	if (rule_frames<0) rfalse;
	if (parameter) parameter_object = parameter;
	for (x = rulechange_sp-3: x>=0: x = x - 3) {
		usage = rulechange_stack-->x;
		if (usage == RS_FRAME) { x=x+3; break; }
		if (rulechange_stack-->(x+1) == rulebook) {
			bits = bits | (RS_AFFECTED_BIT);
			if (usage == RS_MOVEBEFORE or RS_MOVEAFTER)
				bits = bits | (RS_MOVED_BIT);
		}
		if (rulechange_stack-->(x+2) == rulebook) {
			bits = bits | (RS_AFFECTED_BIT);
		}
	} if (x<0) x=0; frame_base = x;
	if ((bits & RS_MOVED_BIT) && (rv == false)) { rfalse; }
	! rv was a call parameter: it's no longer needed and is now reused
	bits = bits | (RS_ACTIVE_BIT + RS_USERESULT_BIT);
	substituted_rule = rulebook; rv = 0;
	if (bits & RS_AFFECTED_BIT)
		for (: x<rulechange_sp: x = x + 3) {
			usage = rulechange_stack-->x;
			if (rulechange_stack-->(x+1) == rulebook) {
				if (usage == RS_DONOTRUN) bits = bits & (~RS_ACTIVE_BIT);
				if (usage == RS_RUN) bits = bits | (RS_ACTIVE_BIT);
				if (usage == RS_DONOTUSE) bits = bits & (~RS_USERESULT_BIT);
				if (usage == RS_USE) bits = bits | (RS_USERESULT_BIT);
				if (usage == RS_SUBSTITUTE)
					substituted_rule = rulechange_stack-->(x+2);
			}
			if ((usage == RS_MOVEBEFORE) && (rulechange_stack-->(x+2) == rulebook)) {
				rv = ProcessRulebook(rulechange_stack-->(x+1),
					parameter, (bits & RS_ACTIVITY ~= 0), true);
				if (rv) return rv;
			}
		}
	if ((bits & RS_ACTIVE_BIT) == 0) rfalse;
	! We now reuse usage to keep the stack frame slimmer
	usage = debugging_rules;
	#ifndef MEMORY_ECONOMY;
	if (debugging_rules) DebugRulebooks(substituted_rule, parameter);
	#endif;
	! (A routine defined in the I7 code generator)
	process_rulebook_count = process_rulebook_count + debugging_rules;
	if ((substituted_rule >= 0) && (substituted_rule < NUMBER_RULEBOOKS_CREATED)) {
		rbaddress = rulebooks_array-->substituted_rule;
		ra = rbaddress-->0; x = 0; original_deadflag = deadflag;
		if (ra ~= NULL) {
			acf = (bits & RS_ACTIVITY ~= 0);
			if (substituted_rule ~= ACTION_PROCESSING_RB) MStack_CreateRBVars(substituted_rule);
			if (ra == (-2)) {
				for (x=1: original_deadflag == deadflag: x++) {
					ra = rbaddress-->x;
					if (ra == NULL) break;
					if (gc == 0) {
						ga = ra; x++; gc = rbaddress-->x;
						if ((gc<1) || (gc>31)) { gc = 1; x--; }
						x++; ra = rbaddress-->x;
					}
					gc--;
					if (ga ~= (-2) or action) continue;
					if ((rv = (ProcessRulebook(ra, parameter, acf)))
						&& (bits & RS_USERESULT_BIT)) jump NonNullResult;
				}
			} else {
				for (: original_deadflag == deadflag: x++) {
					ra = rbaddress-->x;
					if (ra == NULL) break;
					if ((rv = (ProcessRulebook(ra, parameter, acf)))
						&& (bits & RS_USERESULT_BIT)) jump NonNullResult;
				}
			}
			rv = 0;
			.NonNullResult;
			if (substituted_rule ~= ACTION_PROCESSING_RB) MStack_DestroyRBVars(substituted_rule);
		}
	} else {
		if ((say__p) && (bits & RS_NOSKIPS == 0)) DivideParagraphPoint();
		rv = indirect(substituted_rule);
		if (rv == 2) rv = reason_the_action_failed;
		else if (rv) rv = substituted_rule;
	}
	if (rv && (bits & RS_USERESULT_BIT)) {
		process_rulebook_count = process_rulebook_count - debugging_rules;
		if (process_rulebook_count < 0) process_rulebook_count = 0;
		#ifndef MEMORY_ECONOMY;
		if (debugging_rules) {
			spaces(2*process_rulebook_count);
	  	    if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
	  			print "[stopped: success]^";
	  	    if (rulechange_stack-->rulechange_sp == RS_FAILS)
	  			print "[stopped: fail]^";
		}
		#endif;
		debugging_rules = usage;
		return rv;
	}
	if (bits & RS_AFFECTED_BIT)
		for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
			if ((rulechange_stack-->x == RS_MOVEAFTER) &&
				(rulechange_stack-->(x+2) == rulebook)) {
				rv = ProcessRulebook(rulechange_stack-->(x+1),
					parameter, (bits & RS_ACTIVITY ~= 0), true);
				if (rv) {
					process_rulebook_count--;
					debugging_rules = usage;
					return rv;
				}
			}
		}
	process_rulebook_count = process_rulebook_count - debugging_rules;
	rulechange_stack-->rulechange_sp = 0;
	debugging_rules = usage;
	rfalse;
];

[ ActRulebookSucceeds rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookSucceeds();
];

[ ActRulebookFails rule_id;
	if (rule_id) reason_the_action_failed = rule_id;
	RulebookFails();
];

[ RulebookSucceeds weak_kind value;
	PushRuleChange(RS_SUCCEEDS, weak_kind, value);
	rulechange_sp = rulechange_sp - 3;
];

[ RulebookFails weak_kind value;
	PushRuleChange(RS_FAILS, weak_kind, value);
	rulechange_sp = rulechange_sp - 3;
];

[ RuleHasNoOutcome;
	PushRuleChange(RS_NEITHER, 0, 0);
	rulechange_sp = rulechange_sp - 3;
];

[ SetRulebookOutcome a;
	rulechange_stack-->rulechange_sp = a;
];

[ RulebookOutcome a;
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) return a;
	return RS_NEITHER;
];

[ RulebookFailed;
	if (rulechange_stack-->rulechange_sp == RS_FAILS) rtrue; rfalse;
];

[ RulebookSucceeded;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) rtrue; rfalse;
];

[ ResultOfRule RB V F K a;
	if (RB) ProcessRulebook(RB, V, F);
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = rulechange_stack-->(rulechange_sp + 1);
		if (a) return rulechange_stack-->(rulechange_sp + 2);
	}
	if (K) return DefaultValueOfKOV(K);
	return 0;
];

Global DITS_said = false;
[ SuppressRule rule;
	if (rule == TURN_SEQUENCE_RB) {
		if (DITS_said == false) RunTimeProblem(RTP_DONTIGNORETURNSEQUENCE);
		DITS_said = true;
	} else PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule; PushRuleChange(RS_RUN, rule, 0); ];
[ DonotuseRule rule; PushRuleChange(RS_DONOTUSE, rule, 0); ];
[ UseRule rule; PushRuleChange(RS_USE, rule, 0); ];
[ SubstituteRule rule1 rule2; PushRuleChange(RS_SUBSTITUTE, rule2, rule1); ];
[ MoveRuleBefore rule1 rule2; PushRuleChange(RS_MOVEBEFORE, rule1, rule2); ];
[ MoveRuleAfter rule1 rule2; PushRuleChange(RS_MOVEAFTER, rule1, rule2); ];

#IFNDEF MEMORY_ECONOMY;
Array RulebookNames -->
    "Procedural rulebook" ! 0
    "Startup rulebook" ! 1
    "Turn sequence rulebook" ! 2
    "Shutdown rulebook" ! 3
    "Scene changing rulebook" ! 4
    "When play begins rulebook" ! 5
    "When play ends rulebook" ! 6
    "When scene begins rulebook" ! 7
    "When scene ends rulebook" ! 8
    "Every turn rulebook" ! 9
    "Action-processing rulebook" ! 10
    "Setting action variables rulebook" ! 11
    "specific action-processing rulebook" ! 12
    "player's action awareness rulebook" ! 13
    "Accessibility rulebook" ! 14
    "Reaching inside rulebook" ! 15
    "Reaching outside rulebook" ! 16
    "Visibility rulebook" ! 17
    "Persuasion rulebook" ! 18
    "Unsuccessful attempt by rulebook" ! 19
    "Before rulebook" ! 20
    "Instead rulebook" ! 21
    "Check rulebook" ! 22
    "Carry out rulebook" ! 23
    "After rulebook" ! 24
    "Report rulebook" ! 25
    "does the player mean rulebook" ! 26
    "when Entire Game begins rulebook" ! 27
    "when Entire Game ends rulebook" ! 28
    "before Printing the name rulebook" ! 29
    "for Printing the name rulebook" ! 30
    "after Printing the name rulebook" ! 31
    "before Printing the plural name rulebook" ! 32
    "for Printing the plural name rulebook" ! 33
    "after Printing the plural name rulebook" ! 34
    "before Printing a number rulebook" ! 35
    "for Printing a number rulebook" ! 36
    "after Printing a number rulebook" ! 37
    "before Printing room description details rulebook" ! 38
    "for Printing room description details rulebook" ! 39
    "after Printing room description details rulebook" ! 40
    "before Listing contents rulebook" ! 41
    "for Listing contents rulebook" ! 42
    "after Listing contents rulebook" ! 43
    "before Grouping together rulebook" ! 44
    "for Grouping together rulebook" ! 45
    "after Grouping together rulebook" ! 46
    "before Writing a paragraph about rulebook" ! 47
    "for Writing a paragraph about rulebook" ! 48
    "after Writing a paragraph about rulebook" ! 49
    "before Listing nondescript items rulebook" ! 50
    "for Listing nondescript items rulebook" ! 51
    "after Listing nondescript items rulebook" ! 52
    "before Printing the name of a dark room rulebook" ! 53
    "for Printing the name of a dark room rulebook" ! 54
    "after Printing the name of a dark room rulebook" ! 55
    "before Printing the description of a dark room rulebook" ! 56
    "for Printing the description of a dark room rulebook" ! 57
    "after Printing the description of a dark room rulebook" ! 58
    "before Printing the announcement of darkness rulebook" ! 59
    "for Printing the announcement of darkness rulebook" ! 60
    "after Printing the announcement of darkness rulebook" ! 61
    "before Printing the announcement of light rulebook" ! 62
    "for Printing the announcement of light rulebook" ! 63
    "after Printing the announcement of light rulebook" ! 64
    "before Printing a refusal to act in the dark rulebook" ! 65
    "for Printing a refusal to act in the dark rulebook" ! 66
    "after Printing a refusal to act in the dark rulebook" ! 67
    "before Constructing the status line rulebook" ! 68
    "for Constructing the status line rulebook" ! 69
    "after Constructing the status line rulebook" ! 70
    "before Printing the banner text rulebook" ! 71
    "for Printing the banner text rulebook" ! 72
    "after Printing the banner text rulebook" ! 73
    "before Reading a command rulebook" ! 74
    "for Reading a command rulebook" ! 75
    "after Reading a command rulebook" ! 76
    "before Deciding the scope rulebook" ! 77
    "for Deciding the scope rulebook" ! 78
    "after Deciding the scope rulebook" ! 79
    "before Deciding the concealed possessions rulebook" ! 80
    "for Deciding the concealed possessions rulebook" ! 81
    "after Deciding the concealed possessions rulebook" ! 82
    "before Deciding whether all includes rulebook" ! 83
    "for Deciding whether all includes rulebook" ! 84
    "after Deciding whether all includes rulebook" ! 85
    "before Clarifying the parser's choice rulebook" ! 86
    "for Clarifying the parser's choice rulebook" ! 87
    "after Clarifying the parser's choice rulebook" ! 88
    "before Asking which do you mean rulebook" ! 89
    "for Asking which do you mean rulebook" ! 90
    "after Asking which do you mean rulebook" ! 91
    "before Printing a parser error rulebook" ! 92
    "for Printing a parser error rulebook" ! 93
    "after Printing a parser error rulebook" ! 94
    "before Supplying a missing noun rulebook" ! 95
    "for Supplying a missing noun rulebook" ! 96
    "after Supplying a missing noun rulebook" ! 97
    "before Supplying a missing second noun rulebook" ! 98
    "for Supplying a missing second noun rulebook" ! 99
    "after Supplying a missing second noun rulebook" ! 100
    "before Implicitly taking rulebook" ! 101
    "for Implicitly taking rulebook" ! 102
    "after Implicitly taking rulebook" ! 103
    "before Starting the virtual machine rulebook" ! 104
    "for Starting the virtual machine rulebook" ! 105
    "after Starting the virtual machine rulebook" ! 106
    "before Amusing a victorious player rulebook" ! 107
    "for Amusing a victorious player rulebook" ! 108
    "after Amusing a victorious player rulebook" ! 109
    "before Printing the player's obituary rulebook" ! 110
    "for Printing the player's obituary rulebook" ! 111
    "after Printing the player's obituary rulebook" ! 112
    "before Handling the final question rulebook" ! 113
    "for Handling the final question rulebook" ! 114
    "after Handling the final question rulebook" ! 115
    "before Printing the locale description rulebook" ! 116
    "for Printing the locale description rulebook" ! 117
    "after Printing the locale description rulebook" ! 118
    "before Choosing notable locale objects rulebook" ! 119
    "for Choosing notable locale objects rulebook" ! 120
    "after Choosing notable locale objects rulebook" ! 121
    "before Printing a locale paragraph about rulebook" ! 122
    "for Printing a locale paragraph about rulebook" ! 123
    "after Printing a locale paragraph about rulebook" ! 124
    "check Taking inventory rulebook" ! 125
    "carry out Taking inventory rulebook" ! 126
    "report Taking inventory rulebook" ! 127
    "check Taking rulebook" ! 128
    "carry out Taking rulebook" ! 129
    "report Taking rulebook" ! 130
    "check Removing it from rulebook" ! 131
    "carry out Removing it from rulebook" ! 132
    "report Removing it from rulebook" ! 133
    "check Dropping rulebook" ! 134
    "carry out Dropping rulebook" ! 135
    "report Dropping rulebook" ! 136
    "check Putting it on rulebook" ! 137
    "carry out Putting it on rulebook" ! 138
    "report Putting it on rulebook" ! 139
    "check Inserting it into rulebook" ! 140
    "carry out Inserting it into rulebook" ! 141
    "report Inserting it into rulebook" ! 142
    "check Eating rulebook" ! 143
    "carry out Eating rulebook" ! 144
    "report Eating rulebook" ! 145
    "check Going rulebook" ! 146
    "carry out Going rulebook" ! 147
    "report Going rulebook" ! 148
    "check Entering rulebook" ! 149
    "carry out Entering rulebook" ! 150
    "report Entering rulebook" ! 151
    "check Exiting rulebook" ! 152
    "carry out Exiting rulebook" ! 153
    "report Exiting rulebook" ! 154
    "check Getting off rulebook" ! 155
    "carry out Getting off rulebook" ! 156
    "report Getting off rulebook" ! 157
    "check Looking rulebook" ! 158
    "carry out Looking rulebook" ! 159
    "report Looking rulebook" ! 160
    "check Examining rulebook" ! 161
    "carry out Examining rulebook" ! 162
    "report Examining rulebook" ! 163
    "check Looking under rulebook" ! 164
    "carry out Looking under rulebook" ! 165
    "report Looking under rulebook" ! 166
    "check Searching rulebook" ! 167
    "carry out Searching rulebook" ! 168
    "report Searching rulebook" ! 169
    "check Consulting it about rulebook" ! 170
    "carry out Consulting it about rulebook" ! 171
    "report Consulting it about rulebook" ! 172
    "check Locking it with rulebook" ! 173
    "carry out Locking it with rulebook" ! 174
    "report Locking it with rulebook" ! 175
    "check Unlocking it with rulebook" ! 176
    "carry out Unlocking it with rulebook" ! 177
    "report Unlocking it with rulebook" ! 178
    "check Switching on rulebook" ! 179
    "carry out Switching on rulebook" ! 180
    "report Switching on rulebook" ! 181
    "check Switching off rulebook" ! 182
    "carry out Switching off rulebook" ! 183
    "report Switching off rulebook" ! 184
    "check Opening rulebook" ! 185
    "carry out Opening rulebook" ! 186
    "report Opening rulebook" ! 187
    "check Closing rulebook" ! 188
    "carry out Closing rulebook" ! 189
    "report Closing rulebook" ! 190
    "check Wearing rulebook" ! 191
    "carry out Wearing rulebook" ! 192
    "report Wearing rulebook" ! 193
    "check Taking off rulebook" ! 194
    "carry out Taking off rulebook" ! 195
    "report Taking off rulebook" ! 196
    "check Giving it to rulebook" ! 197
    "carry out Giving it to rulebook" ! 198
    "report Giving it to rulebook" ! 199
    "check Showing it to rulebook" ! 200
    "carry out Showing it to rulebook" ! 201
    "report Showing it to rulebook" ! 202
    "check Waking rulebook" ! 203
    "carry out Waking rulebook" ! 204
    "report Waking rulebook" ! 205
    "check Throwing it at rulebook" ! 206
    "carry out Throwing it at rulebook" ! 207
    "report Throwing it at rulebook" ! 208
    "check Attacking rulebook" ! 209
    "carry out Attacking rulebook" ! 210
    "report Attacking rulebook" ! 211
    "check Kissing rulebook" ! 212
    "carry out Kissing rulebook" ! 213
    "report Kissing rulebook" ! 214
    "check Answering it that rulebook" ! 215
    "carry out Answering it that rulebook" ! 216
    "report Answering it that rulebook" ! 217
    "check Telling it about rulebook" ! 218
    "carry out Telling it about rulebook" ! 219
    "report Telling it about rulebook" ! 220
    "check Asking it about rulebook" ! 221
    "carry out Asking it about rulebook" ! 222
    "report Asking it about rulebook" ! 223
    "check Asking it for rulebook" ! 224
    "carry out Asking it for rulebook" ! 225
    "report Asking it for rulebook" ! 226
    "check Waiting rulebook" ! 227
    "carry out Waiting rulebook" ! 228
    "report Waiting rulebook" ! 229
    "check Touching rulebook" ! 230
    "carry out Touching rulebook" ! 231
    "report Touching rulebook" ! 232
    "check Waving rulebook" ! 233
    "carry out Waving rulebook" ! 234
    "report Waving rulebook" ! 235
    "check Pulling rulebook" ! 236
    "carry out Pulling rulebook" ! 237
    "report Pulling rulebook" ! 238
    "check Pushing rulebook" ! 239
    "carry out Pushing rulebook" ! 240
    "report Pushing rulebook" ! 241
    "check Turning rulebook" ! 242
    "carry out Turning rulebook" ! 243
    "report Turning rulebook" ! 244
    "check Pushing it to rulebook" ! 245
    "carry out Pushing it to rulebook" ! 246
    "report Pushing it to rulebook" ! 247
    "check Squeezing rulebook" ! 248
    "carry out Squeezing rulebook" ! 249
    "report Squeezing rulebook" ! 250
    "check Saying yes rulebook" ! 251
    "carry out Saying yes rulebook" ! 252
    "report Saying yes rulebook" ! 253
    "check Saying no rulebook" ! 254
    "carry out Saying no rulebook" ! 255
    "report Saying no rulebook" ! 256
    "check Burning rulebook" ! 257
    "carry out Burning rulebook" ! 258
    "report Burning rulebook" ! 259
    "check Waking up rulebook" ! 260
    "carry out Waking up rulebook" ! 261
    "report Waking up rulebook" ! 262
    "check Thinking rulebook" ! 263
    "carry out Thinking rulebook" ! 264
    "report Thinking rulebook" ! 265
    "check Smelling rulebook" ! 266
    "carry out Smelling rulebook" ! 267
    "report Smelling rulebook" ! 268
    "check Listening to rulebook" ! 269
    "carry out Listening to rulebook" ! 270
    "report Listening to rulebook" ! 271
    "check Tasting rulebook" ! 272
    "carry out Tasting rulebook" ! 273
    "report Tasting rulebook" ! 274
    "check Cutting rulebook" ! 275
    "carry out Cutting rulebook" ! 276
    "report Cutting rulebook" ! 277
    "check Jumping rulebook" ! 278
    "carry out Jumping rulebook" ! 279
    "report Jumping rulebook" ! 280
    "check Tying it to rulebook" ! 281
    "carry out Tying it to rulebook" ! 282
    "report Tying it to rulebook" ! 283
    "check Drinking rulebook" ! 284
    "carry out Drinking rulebook" ! 285
    "report Drinking rulebook" ! 286
    "check Saying sorry rulebook" ! 287
    "carry out Saying sorry rulebook" ! 288
    "report Saying sorry rulebook" ! 289
    "check Swearing obscenely rulebook" ! 290
    "carry out Swearing obscenely rulebook" ! 291
    "report Swearing obscenely rulebook" ! 292
    "check Swearing mildly rulebook" ! 293
    "carry out Swearing mildly rulebook" ! 294
    "report Swearing mildly rulebook" ! 295
    "check Swinging rulebook" ! 296
    "carry out Swinging rulebook" ! 297
    "report Swinging rulebook" ! 298
    "check Rubbing rulebook" ! 299
    "carry out Rubbing rulebook" ! 300
    "report Rubbing rulebook" ! 301
    "check Setting it to rulebook" ! 302
    "carry out Setting it to rulebook" ! 303
    "report Setting it to rulebook" ! 304
    "check Waving hands rulebook" ! 305
    "carry out Waving hands rulebook" ! 306
    "report Waving hands rulebook" ! 307
    "check Buying rulebook" ! 308
    "carry out Buying rulebook" ! 309
    "report Buying rulebook" ! 310
    "check Singing rulebook" ! 311
    "carry out Singing rulebook" ! 312
    "report Singing rulebook" ! 313
    "check Climbing rulebook" ! 314
    "carry out Climbing rulebook" ! 315
    "report Climbing rulebook" ! 316
    "check Sleeping rulebook" ! 317
    "carry out Sleeping rulebook" ! 318
    "report Sleeping rulebook" ! 319
    "check Quitting the game rulebook" ! 320
    "carry out Quitting the game rulebook" ! 321
    "report Quitting the game rulebook" ! 322
    "check Saving the game rulebook" ! 323
    "carry out Saving the game rulebook" ! 324
    "report Saving the game rulebook" ! 325
    "check Restoring the game rulebook" ! 326
    "carry out Restoring the game rulebook" ! 327
    "report Restoring the game rulebook" ! 328
    "check Restarting the game rulebook" ! 329
    "carry out Restarting the game rulebook" ! 330
    "report Restarting the game rulebook" ! 331
    "check Verifying the story file rulebook" ! 332
    "carry out Verifying the story file rulebook" ! 333
    "report Verifying the story file rulebook" ! 334
    "check Switching the story transcript on rulebook" ! 335
    "carry out Switching the story transcript on rulebook" ! 336
    "report Switching the story transcript on rulebook" ! 337
    "check Switching the story transcript off rulebook" ! 338
    "carry out Switching the story transcript off rulebook" ! 339
    "report Switching the story transcript off rulebook" ! 340
    "check Requesting the story file version rulebook" ! 341
    "carry out Requesting the story file version rulebook" ! 342
    "report Requesting the story file version rulebook" ! 343
    "check Requesting the score rulebook" ! 344
    "carry out Requesting the score rulebook" ! 345
    "report Requesting the score rulebook" ! 346
    "check Preferring abbreviated room descriptions rulebook" ! 347
    "carry out Preferring abbreviated room descriptions rulebook" ! 348
    "report Preferring abbreviated room descriptions rulebook" ! 349
    "check Preferring unabbreviated room descriptions rulebook" ! 350
    "carry out Preferring unabbreviated room descriptions rulebook" ! 351
    "report Preferring unabbreviated room descriptions rulebook" ! 352
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 353
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 354
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 355
    "check Switching score notification on rulebook" ! 356
    "carry out Switching score notification on rulebook" ! 357
    "report Switching score notification on rulebook" ! 358
    "check Switching score notification off rulebook" ! 359
    "carry out Switching score notification off rulebook" ! 360
    "report Switching score notification off rulebook" ! 361
    "check Requesting the pronoun meanings rulebook" ! 362
    "carry out Requesting the pronoun meanings rulebook" ! 363
    "report Requesting the pronoun meanings rulebook" ! 364
    "check Retreating rulebook" ! 365
    "carry out Retreating rulebook" ! 366
    "report Retreating rulebook" ! 367
    "check Overly elaborate looking rulebook" ! 368
    "carry out Overly elaborate looking rulebook" ! 369
    "report Overly elaborate looking rulebook" ! 370
    "check Listing exits rulebook" ! 371
    "carry out Listing exits rulebook" ! 372
    "report Listing exits rulebook" ! 373
    "check Using rulebook" ! 374
    "carry out Using rulebook" ! 375
    "report Using rulebook" ! 376
    "holdall rulebook" ! 377
    "stashing rulebook" ! 378
    "check Mounting rulebook" ! 379
    "carry out Mounting rulebook" ! 380
    "report Mounting rulebook" ! 381
    "check Dismounting rulebook" ! 382
    "carry out Dismounting rulebook" ! 383
    "report Dismounting rulebook" ! 384
    "before Refusing keys rulebook" ! 385
    "for Refusing keys rulebook" ! 386
    "after Refusing keys rulebook" ! 387
    "check Unlocking keylessly rulebook" ! 388
    "carry out Unlocking keylessly rulebook" ! 389
    "report Unlocking keylessly rulebook" ! 390
    "check Locking keylessly rulebook" ! 391
    "carry out Locking keylessly rulebook" ! 392
    "report Locking keylessly rulebook" ! 393
    "check Universal unlocking rulebook" ! 394
    "carry out Universal unlocking rulebook" ! 395
    "report Universal unlocking rulebook" ! 396
    "should the game choose rulebook" ! 397
    "Should the game suggest rulebook" ! 398
    "bypass disambiguation rulebook" ! 399
    "check Commenting rulebook" ! 400
    "carry out Commenting rulebook" ! 401
    "report Commenting rulebook" ! 402
    "check Greeting rulebook" ! 403
    "carry out Greeting rulebook" ! 404
    "report Greeting rulebook" ! 405
    "check Praying rulebook" ! 406
    "carry out Praying rulebook" ! 407
    "report Praying rulebook" ! 408
    "check Blowing rulebook" ! 409
    "carry out Blowing rulebook" ! 410
    "report Blowing rulebook" ! 411
    "check Shouting rulebook" ! 412
    "carry out Shouting rulebook" ! 413
    "report Shouting rulebook" ! 414
    "check Facing rulebook" ! 415
    "carry out Facing rulebook" ! 416
    "report Facing rulebook" ! 417
    "check Looking toward rulebook" ! 418
    "carry out Looking toward rulebook" ! 419
    "report Looking toward rulebook" ! 420
    "check Following rulebook" ! 421
    "carry out Following rulebook" ! 422
    "report Following rulebook" ! 423
    "check Vehicle-exiting rulebook" ! 424
    "carry out Vehicle-exiting rulebook" ! 425
    "report Vehicle-exiting rulebook" ! 426
    "check Supporter-exiting rulebook" ! 427
    "carry out Supporter-exiting rulebook" ! 428
    "report Supporter-exiting rulebook" ! 429
    "when First Pump begins rulebook" ! 430
    "when First Pump ends rulebook" ! 431
    "when Lever-action begins rulebook" ! 432
    "when Lever-action ends rulebook" ! 433
    "when Gizmo-action begins rulebook" ! 434
    "when Gizmo-action ends rulebook" ! 435
    "when Gadget-action begins rulebook" ! 436
    "when Gadget-action ends rulebook" ! 437
    "when Hose-action begins rulebook" ! 438
    "when Hose-action ends rulebook" ! 439
    "when Second Pump begins rulebook" ! 440
    "when Second Pump ends rulebook" ! 441
    "when Third Pump begins rulebook" ! 442
    "when Third Pump ends rulebook" ! 443
    "when conductor's story begins rulebook" ! 444
    "when conductor's story ends rulebook" ! 445
    "when Fourth Pump begins rulebook" ! 446
    "when Fourth Pump ends rulebook" ! 447
    "check Liquid-drinking rulebook" ! 448
    "carry out Liquid-drinking rulebook" ! 449
    "report Liquid-drinking rulebook" ! 450
    "check Filling it with rulebook" ! 451
    "carry out Filling it with rulebook" ! 452
    "report Filling it with rulebook" ! 453
    "check Pouring it into rulebook" ! 454
    "carry out Pouring it into rulebook" ! 455
    "report Pouring it into rulebook" ! 456
    "check Swimming rulebook" ! 457
    "carry out Swimming rulebook" ! 458
    "report Swimming rulebook" ! 459
    "check Spilling rulebook" ! 460
    "carry out Spilling rulebook" ! 461
    "report Spilling rulebook" ! 462
    "check Boarding rulebook" ! 463
    "carry out Boarding rulebook" ! 464
    "report Boarding rulebook" ! 465
    "check Train-waiting rulebook" ! 466
    "carry out Train-waiting rulebook" ! 467
    "report Train-waiting rulebook" ! 468
    "check Waiting more rulebook" ! 469
    "carry out Waiting more rulebook" ! 470
    "report Waiting more rulebook" ! 471
    "check Asking for help rulebook" ! 472
    "carry out Asking for help rulebook" ! 473
    "report Asking for help rulebook" ! 474
    "check Crediting rulebook" ! 475
    "carry out Crediting rulebook" ! 476
    "report Crediting rulebook" ! 477
    "check Hinting rulebook" ! 478
    "carry out Hinting rulebook" ! 479
    "report Hinting rulebook" ! 480
    "check Requesting the full score rulebook" ! 481
    "carry out Requesting the full score rulebook" ! 482
    "report Requesting the full score rulebook" ! 483
    "check Xyzzy rulebook" ! 484
    "carry out Xyzzy rulebook" ! 485
    "report Xyzzy rulebook" ! 486
    "check Knocking on rulebook" ! 487
    "carry out Knocking on rulebook" ! 488
    "report Knocking on rulebook" ! 489
    "check Wading rulebook" ! 490
    "carry out Wading rulebook" ! 491
    "report Wading rulebook" ! 492
    "check Rowing rulebook" ! 493
    "carry out Rowing rulebook" ! 494
    "report Rowing rulebook" ! 495
    "check Dancing rulebook" ! 496
    "carry out Dancing rulebook" ! 497
    "report Dancing rulebook" ! 498
    "check Rowing toward rulebook" ! 499
    "carry out Rowing toward rulebook" ! 500
    "report Rowing toward rulebook" ! 501
    "check Looking up rulebook" ! 502
    "carry out Looking up rulebook" ! 503
    "report Looking up rulebook" ! 504
    "check Plugging it with rulebook" ! 505
    "carry out Plugging it with rulebook" ! 506
    "report Plugging it with rulebook" ! 507
    "check Tightening rulebook" ! 508
    "carry out Tightening rulebook" ! 509
    "report Tightening rulebook" ! 510
    "check Lever-examining rulebook" ! 511
    "carry out Lever-examining rulebook" ! 512
    "report Lever-examining rulebook" ! 513
    "check Switch-examining rulebook" ! 514
    "carry out Switch-examining rulebook" ! 515
    "report Switch-examining rulebook" ! 516
    "check Gizmo-examining rulebook" ! 517
    "carry out Gizmo-examining rulebook" ! 518
    "report Gizmo-examining rulebook" ! 519
    "check Flipping rulebook" ! 520
    "carry out Flipping rulebook" ! 521
    "report Flipping rulebook" ! 522
    "check Shaking rulebook" ! 523
    "carry out Shaking rulebook" ! 524
    "report Shaking rulebook" ! 525
    "check Playing rulebook" ! 526
    "carry out Playing rulebook" ! 527
    "report Playing rulebook" ! 528
    "check Prying it with rulebook" ! 529
    "carry out Prying it with rulebook" ! 530
    "report Prying it with rulebook" ! 531
    "check Skipping rulebook" ! 532
    "carry out Skipping rulebook" ! 533
    "report Skipping rulebook" ! 534
    "when secretary's story begins rulebook" ! 535
    "when secretary's story ends rulebook" ! 536
    "check Barking rulebook" ! 537
    "carry out Barking rulebook" ! 538
    "report Barking rulebook" ! 539
    "check Thing-barking rulebook" ! 540
    "carry out Thing-barking rulebook" ! 541
    "report Thing-barking rulebook" ! 542
    "check Taking it with rulebook" ! 543
    "carry out Taking it with rulebook" ! 544
    "report Taking it with rulebook" ! 545
    "check Magnet-waving rulebook" ! 546
    "carry out Magnet-waving rulebook" ! 547
    "report Magnet-waving rulebook" ! 548
    "check Typing rulebook" ! 549
    "carry out Typing rulebook" ! 550
    "report Typing rulebook" ! 551
    "check Boat-examining rulebook" ! 552
    "carry out Boat-examining rulebook" ! 553
    "report Boat-examining rulebook" ! 554
    "when Vivian's Story begins rulebook" ! 555
    "when Vivian's Story ends rulebook" ! 556
    "when Endgame begins rulebook" ! 557
    "when Endgame ends rulebook" ! 558
    "when Switch-action begins rulebook" ! 559
    "when Switch-action ends rulebook" ! 560
    "check Train-moving rulebook" ! 561
    "carry out Train-moving rulebook" ! 562
    "report Train-moving rulebook" ! 563
    "check Train-examining rulebook" ! 564
    "carry out Train-examining rulebook" ! 565
    "report Train-examining rulebook" ! 566
    "check Lock-picking rulebook" ! 567
    "carry out Lock-picking rulebook" ! 568
    "report Lock-picking rulebook" ! 569
    "check Double-lock-picking rulebook" ! 570
    "carry out Double-lock-picking rulebook" ! 571
    "report Double-lock-picking rulebook" ! 572
;


#ENDIF; ! MEMORY_ECONOMY

[ RulePrintingRule R p1;
#ifndef MEMORY_ECONOMY;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print (string) (RulebookNames-->R);
	} else {
		if (R == R_8) { print "start in the correct scenes rule"; return; } ! 0, case 1
		if (R == R_9) { print "when play begins stage rule"; return; } ! 1, case 1
		if (R == R_10) { print "fix baseline scoring rule"; return; } ! 2, case 1
		if (R == R_11) { print "display banner rule"; return; } ! 3, case 1
		if (R == R_12) { print "initial room description rule"; return; } ! 4, case 1
		if (R == R_13) { print "every turn stage rule"; return; } ! 5, case 1
		if (R == R_16) { print "notify score changes rule"; return; } ! 6, case 1
		if (R == R_17) { print "when play ends stage rule"; return; } ! 7, case 1
		if (R == R_18) { print "print player's obituary rule"; return; } ! 8, case 1
		if (R == R_19) { print "set pronouns from items from multiple object lists rule"; return; } ! 9, case 1
		if (R == R_20) { print "announce items from multiple object lists rule"; return; } ! 10, case 1
		if (R == R_21) { print "before stage rule"; return; } ! 11, case 1
		if (R == R_22) { print "instead stage rule"; return; } ! 12, case 1
		if (R == R_23) { print "end action-processing in success rule"; return; } ! 13, case 1
		if (R == R_24) { print "investigate player's awareness before action rule"; return; } ! 14, case 1
		if (R == R_25) { print "check stage rule"; return; } ! 15, case 1
		if (R == R_26) { print "carry out stage rule"; return; } ! 16, case 1
		if (R == R_27) { print "after stage rule"; return; } ! 17, case 1
		if (R == R_28) { print "investigate player's awareness after action rule"; return; } ! 18, case 1
		if (R == R_29) { print "report stage rule"; return; } ! 19, case 1
		if (R == R_31) { print "player aware of his own actions rule"; return; } ! 20, case 1
		if (R == R_32) { print "player aware of actions by visible actors rule"; return; } ! 21, case 1
		if (R == R_33) { print "player aware of actions on visible nouns rule"; return; } ! 22, case 1
		if (R == R_34) { print "player aware of actions on visible second nouns rule"; return; } ! 23, case 1
		if (R == R_35) { print "can't act in the dark rule"; return; } ! 24, case 1
		if (R == R_36) { print "very unlikely to mean taking what's already carried rule"; return; } ! 25, case 1
		if (R == R_57) { print "scene description text rule"; return; } ! 26, case 1
		if (R == R_58) { print "make named things mentioned rule"; return; } ! 27, case 1
		if (R == R_59) { print "standard printing the plural name rule"; return; } ! 28, case 1
		if (R == R_60) { print "standard printing a number of something rule"; return; } ! 29, case 1
		if (R == R_61) { print "look around once light available rule"; return; } ! 30, case 1
		if (R == R_62) { print "exclude scenery from take all rule"; return; } ! 31, case 1
		if (R == R_63) { print "exclude people from take all rule"; return; } ! 32, case 1
		if (R == R_64) { print "exclude fixed in place things from take all rule"; return; } ! 33, case 1
		if (R == R_65) { print "ambient odour rule"; return; } ! 34, case 1
		if (R == R_66) { print "ambient sound rule"; return; } ! 35, case 1
		if (R == R_67) { print "block vaguely going rule"; return; } ! 36, case 1
		if (R == R_68) { print "print the final prompt rule"; return; } ! 37, case 1
		if (R == R_69) { print "print the final question rule"; return; } ! 38, case 1
		if (R == R_70) { print "standard respond to final question rule"; return; } ! 39, case 1
		if (R == R_73) { print "initialise locale description rule"; return; } ! 40, case 1
		if (R == R_74) { print "find notable locale objects rule"; return; } ! 41, case 1
		if (R == R_75) { print "interesting locale paragraphs rule"; return; } ! 42, case 1
		if (R == R_76) { print "you-can-also-see rule"; return; } ! 43, case 1
		if (R == R_77) { print "standard notable locale objects rule"; return; } ! 44, case 1
		if (R == R_78) { print "don't mention player's supporter in room descriptions rule"; return; } ! 45, case 1
		if (R == R_79) { print "don't mention scenery in room descriptions rule"; return; } ! 46, case 1
		if (R == R_80) { print "don't mention undescribed items in room descriptions rule"; return; } ! 47, case 1
		if (R == R_81) { print "set pronouns from items in room descriptions rule"; return; } ! 48, case 1
		if (R == R_82) { print "offer items to writing a paragraph about rule"; return; } ! 49, case 1
		if (R == R_83) { print "use initial appearance in room descriptions rule"; return; } ! 50, case 1
		if (R == R_85) { print "describe what's on scenery supporters in room descriptions rule"; return; } ! 51, case 1
		if (R == R_86) { print "print empty inventory rule"; return; } ! 52, case 1
		if (R == R_87) { print "print standard inventory rule"; return; } ! 53, case 1
		if (R == R_88) { print "report other people taking inventory rule"; return; } ! 54, case 1
		if (R == R_89) { print "can't take yourself rule"; return; } ! 55, case 1
		if (R == R_90) { print "can't take other people rule"; return; } ! 56, case 1
		if (R == R_91) { print "can't take component parts rule"; return; } ! 57, case 1
		if (R == R_92) { print "can't take people's possessions rule"; return; } ! 58, case 1
		if (R == R_93) { print "can't take items out of play rule"; return; } ! 59, case 1
		if (R == R_94) { print "can't take what you're inside rule"; return; } ! 60, case 1
		if (R == R_95) { print "can't take what's already taken rule"; return; } ! 61, case 1
		if (R == R_96) { print "can't take scenery rule"; return; } ! 62, case 1
		if (R == R_97) { print "can only take things rule"; return; } ! 63, case 1
		if (R == R_98) { print "can't take what's fixed in place rule"; return; } ! 64, case 1
		if (R == R_99) { print "use player's holdall to avoid exceeding carrying capacity rule"; return; } ! 65, case 1
		if (R == R_100) { print "can't exceed carrying capacity rule"; return; } ! 66, case 1
		if (R == R_101) { print "standard taking rule"; return; } ! 67, case 1
		if (R == R_102) { print "standard report taking rule"; return; } ! 68, case 1
		if (R == R_103) { print "can't remove what's not inside rule"; return; } ! 69, case 1
		if (R == R_104) { print "can't remove from people rule"; return; } ! 70, case 1
		if (R == R_105) { print "convert remove to take rule"; return; } ! 71, case 1
		if (R == R_106) { print "can't drop yourself rule"; return; } ! 72, case 1
		if (R == R_107) { print "can't drop what's already dropped rule"; return; } ! 73, case 1
		if (R == R_108) { print "can't drop what's not held rule"; return; } ! 74, case 1
		if (R == R_109) { print "can't drop clothes being worn rule"; return; } ! 75, case 1
		if (R == R_110) { print "can't drop if this exceeds carrying capacity rule"; return; } ! 76, case 1
		if (R == R_111) { print "standard dropping rule"; return; } ! 77, case 1
		if (R == R_112) { print "standard report dropping rule"; return; } ! 78, case 1
		if (R == R_113) { print "convert put to drop where possible rule"; return; } ! 79, case 1
		if (R == R_114) { print "can't put what's not held rule"; return; } ! 80, case 1
		if (R == R_115) { print "can't put something on itself rule"; return; } ! 81, case 1
		if (R == R_116) { print "can't put onto what's not a supporter rule"; return; } ! 82, case 1
		if (R == R_117) { print "can't put onto something being carried rule"; return; } ! 83, case 1
		if (R == R_118) { print "can't put clothes being worn rule"; return; } ! 84, case 1
		if (R == R_119) { print "can't put if this exceeds carrying capacity rule"; return; } ! 85, case 1
		if (R == R_120) { print "standard putting rule"; return; } ! 86, case 1
		if (R == R_121) { print "concise report putting rule"; return; } ! 87, case 1
		if (R == R_122) { print "standard report putting rule"; return; } ! 88, case 1
		if (R == R_123) { print "convert insert to drop where possible rule"; return; } ! 89, case 1
		if (R == R_124) { print "can't insert what's not held rule"; return; } ! 90, case 1
		if (R == R_125) { print "can't insert something into itself rule"; return; } ! 91, case 1
		if (R == R_126) { print "can't insert into closed containers rule"; return; } ! 92, case 1
		if (R == R_127) { print "can't insert into what's not a container rule"; return; } ! 93, case 1
		if (R == R_128) { print "can't insert clothes being worn rule"; return; } ! 94, case 1
		if (R == R_129) { print "can't insert if this exceeds carrying capacity rule"; return; } ! 95, case 1
		if (R == R_130) { print "standard inserting rule"; return; } ! 96, case 1
		if (R == R_131) { print "concise report inserting rule"; return; } ! 97, case 1
		if (R == R_132) { print "standard report inserting rule"; return; } ! 98, case 1
		if (R == R_133) { print "can't eat unless edible rule"; return; } ! 99, case 1
		if (R == R_134) { print "can't eat clothing without removing it first rule"; return; } ! 100, case 1
		if (R == R_135) { print "standard eating rule"; return; } ! 101, case 1
		if (R == R_136) { print "standard report eating rule"; return; } ! 102, case 1
		if (R == R_137) { print "standard set going variables rule"; return; } ! 103, case 1
		if (R == R_138) { print "stand up before going rule"; return; } ! 104, case 1
		if (R == R_139) { print "can't travel in what's not a vehicle rule"; return; } ! 105, case 1
		if (R == R_140) { print "can't go through undescribed doors rule"; return; } ! 106, case 1
		if (R == R_141) { print "can't go through closed doors rule"; return; } ! 107, case 1
		if (R == R_142) { print "determine map connection rule"; return; } ! 108, case 1
		if (R == R_143) { print "can't go that way rule"; return; } ! 109, case 1
		if (R == R_144) { print "move player and vehicle rule"; return; } ! 110, case 1
		if (R == R_145) { print "move floating objects rule"; return; } ! 111, case 1
		if (R == R_146) { print "check light in new location rule"; return; } ! 112, case 1
		if (R == R_147) { print "describe room gone into rule"; return; } ! 113, case 1
		if (R == R_148) { print "find what to enter rule"; return; } ! 114, case 1
		if (R == R_149) { print "convert enter door into go rule"; return; } ! 115, case 1
		if (R == R_150) { print "convert enter compass direction into go rule"; return; } ! 116, case 1
		if (R == R_151) { print "can't enter what's already entered rule"; return; } ! 117, case 1
		if (R == R_152) { print "can't enter what's not enterable rule"; return; } ! 118, case 1
		if (R == R_153) { print "can't enter closed containers rule"; return; } ! 119, case 1
		if (R == R_154) { print "can't enter something carried rule"; return; } ! 120, case 1
		if (R == R_155) { print "implicitly pass through other barriers rule"; return; } ! 121, case 1
		if (R == R_156) { print "standard entering rule"; return; } ! 122, case 1
		if (R == R_157) { print "standard report entering rule"; return; } ! 123, case 1
		if (R == R_158) { print "describe contents entered into rule"; return; } ! 124, case 1
		if (R == R_160) { print "convert exit into go out rule"; return; } ! 125, case 1
		if (R == R_161) { print "can't exit when not inside anything rule"; return; } ! 126, case 1
		if (R == R_162) { print "can't exit closed containers rule"; return; } ! 127, case 1
		if (R == R_163) { print "convert exit into get off rule"; return; } ! 128, case 1
		if (R == R_164) { print "standard exiting rule"; return; } ! 129, case 1
		if (R == R_165) { print "standard report exiting rule"; return; } ! 130, case 1
		if (R == R_166) { print "describe room emerged into rule"; return; } ! 131, case 1
		if (R == R_167) { print "can't get off things rule"; return; } ! 132, case 1
		if (R == R_168) { print "standard getting off rule"; return; } ! 133, case 1
		if (R == R_169) { print "standard report getting off rule"; return; } ! 134, case 1
		if (R == R_170) { print "describe room stood up into rule"; return; } ! 135, case 1
		if (R == R_171) { print "determine visibility ceiling rule"; return; } ! 136, case 1
		if (R == R_172) { print "room description heading rule"; return; } ! 137, case 1
		if (R == R_173) { print "room description body text rule"; return; } ! 138, case 1
		if (R == R_174) { print "room description paragraphs about objects rule"; return; } ! 139, case 1
		if (R == R_175) { print "check new arrival rule"; return; } ! 140, case 1
		if (R == R_176) { print "other people looking rule"; return; } ! 141, case 1
		if (R == R_177) { print "standard examining rule"; return; } ! 142, case 1
		if (R == R_178) { print "examine directions rule"; return; } ! 143, case 1
		if (R == R_179) { print "examine containers rule"; return; } ! 144, case 1
		if (R == R_180) { print "examine supporters rule"; return; } ! 145, case 1
		if (R == R_181) { print "examine devices rule"; return; } ! 146, case 1
		if (R == R_182) { print "examine undescribed things rule"; return; } ! 147, case 1
		if (R == R_183) { print "report other people examining rule"; return; } ! 148, case 1
		if (R == R_184) { print "standard looking under rule"; return; } ! 149, case 1
		if (R == R_185) { print "report other people looking under rule"; return; } ! 150, case 1
		if (R == R_186) { print "can't search unless container or supporter rule"; return; } ! 151, case 1
		if (R == R_187) { print "can't search closed opaque containers rule"; return; } ! 152, case 1
		if (R == R_188) { print "standard search containers rule"; return; } ! 153, case 1
		if (R == R_189) { print "standard search supporters rule"; return; } ! 154, case 1
		if (R == R_190) { print "report other people searching rule"; return; } ! 155, case 1
		if (R == R_191) { print "block consulting rule"; return; } ! 156, case 1
		if (R == R_192) { print "can't lock without a lock rule"; return; } ! 157, case 1
		if (R == R_193) { print "can't lock what's already locked rule"; return; } ! 158, case 1
		if (R == R_194) { print "can't lock what's open rule"; return; } ! 159, case 1
		if (R == R_195) { print "can't lock without the correct key rule"; return; } ! 160, case 1
		if (R == R_196) { print "standard locking rule"; return; } ! 161, case 1
		if (R == R_197) { print "standard report locking rule"; return; } ! 162, case 1
		if (R == R_198) { print "can't unlock without a lock rule"; return; } ! 163, case 1
		if (R == R_199) { print "can't unlock what's already unlocked rule"; return; } ! 164, case 1
		if (R == R_200) { print "can't unlock without the correct key rule"; return; } ! 165, case 1
		if (R == R_201) { print "standard unlocking rule"; return; } ! 166, case 1
		if (R == R_202) { print "standard report unlocking rule"; return; } ! 167, case 1
		if (R == R_203) { print "can't switch on unless switchable rule"; return; } ! 168, case 1
		if (R == R_204) { print "can't switch on what's already on rule"; return; } ! 169, case 1
		if (R == R_205) { print "standard switching on rule"; return; } ! 170, case 1
		if (R == R_206) { print "standard report switching on rule"; return; } ! 171, case 1
		if (R == R_207) { print "can't switch off unless switchable rule"; return; } ! 172, case 1
		if (R == R_208) { print "can't switch off what's already off rule"; return; } ! 173, case 1
		if (R == R_209) { print "standard switching off rule"; return; } ! 174, case 1
		if (R == R_210) { print "standard report switching off rule"; return; } ! 175, case 1
		if (R == R_211) { print "can't open unless openable rule"; return; } ! 176, case 1
		if (R == R_212) { print "can't open what's locked rule"; return; } ! 177, case 1
		if (R == R_213) { print "can't open what's already open rule"; return; } ! 178, case 1
		if (R == R_214) { print "standard opening rule"; return; } ! 179, case 1
		if (R == R_215) { print "reveal any newly visible interior rule"; return; } ! 180, case 1
		if (R == R_216) { print "standard report opening rule"; return; } ! 181, case 1
		if (R == R_217) { print "can't close unless openable rule"; return; } ! 182, case 1
		if (R == R_218) { print "can't close what's already closed rule"; return; } ! 183, case 1
		if (R == R_219) { print "standard closing rule"; return; } ! 184, case 1
		if (R == R_220) { print "standard report closing rule"; return; } ! 185, case 1
		if (R == R_221) { print "can't wear what's not clothing rule"; return; } ! 186, case 1
		if (R == R_222) { print "can't wear what's not held rule"; return; } ! 187, case 1
		if (R == R_223) { print "can't wear what's already worn rule"; return; } ! 188, case 1
		if (R == R_224) { print "standard wearing rule"; return; } ! 189, case 1
		if (R == R_225) { print "standard report wearing rule"; return; } ! 190, case 1
		if (R == R_226) { print "can't take off what's not worn rule"; return; } ! 191, case 1
		if (R == R_227) { print "standard taking off rule"; return; } ! 192, case 1
		if (R == R_228) { print "standard report taking off rule"; return; } ! 193, case 1
		if (R == R_229) { print "can't give what you haven't got rule"; return; } ! 194, case 1
		if (R == R_230) { print "can't give to yourself rule"; return; } ! 195, case 1
		if (R == R_231) { print "can't give to a non-person rule"; return; } ! 196, case 1
		if (R == R_232) { print "can't give clothes being worn rule"; return; } ! 197, case 1
		if (R == R_233) { print "block giving rule"; return; } ! 198, case 1
		if (R == R_234) { print "standard giving rule"; return; } ! 199, case 1
		if (R == R_235) { print "standard report giving rule"; return; } ! 200, case 1
		if (R == R_236) { print "can't show what you haven't got rule"; return; } ! 201, case 1
		if (R == R_237) { print "convert show to yourself to examine rule"; return; } ! 202, case 1
		if (R == R_238) { print "block showing rule"; return; } ! 203, case 1
		if (R == R_239) { print "block waking rule"; return; } ! 204, case 1
		if (R == R_240) { print "implicitly remove thrown clothing rule"; return; } ! 205, case 1
		if (R == R_241) { print "futile to throw things at inanimate objects rule"; return; } ! 206, case 1
		if (R == R_242) { print "block throwing at rule"; return; } ! 207, case 1
		if (R == R_243) { print "block attacking rule"; return; } ! 208, case 1
		if (R == R_244) { print "kissing yourself rule"; return; } ! 209, case 1
		if (R == R_245) { print "block kissing rule"; return; } ! 210, case 1
		if (R == R_246) { print "block answering rule"; return; } ! 211, case 1
		if (R == R_247) { print "telling yourself rule"; return; } ! 212, case 1
		if (R == R_248) { print "block telling rule"; return; } ! 213, case 1
		if (R == R_249) { print "block asking rule"; return; } ! 214, case 1
		if (R == R_250) { print "asking yourself for something rule"; return; } ! 215, case 1
		if (R == R_251) { print "translate asking for to giving rule"; return; } ! 216, case 1
		if (R == R_252) { print "standard report waiting rule"; return; } ! 217, case 1
		if (R == R_253) { print "report touching yourself rule"; return; } ! 218, case 1
		if (R == R_254) { print "report touching other people rule"; return; } ! 219, case 1
		if (R == R_255) { print "report touching things rule"; return; } ! 220, case 1
		if (R == R_256) { print "can't wave what's not held rule"; return; } ! 221, case 1
		if (R == R_257) { print "report waving things rule"; return; } ! 222, case 1
		if (R == R_258) { print "can't pull what's fixed in place rule"; return; } ! 223, case 1
		if (R == R_259) { print "can't pull scenery rule"; return; } ! 224, case 1
		if (R == R_260) { print "can't pull people rule"; return; } ! 225, case 1
		if (R == R_261) { print "report pulling rule"; return; } ! 226, case 1
		if (R == R_262) { print "can't push what's fixed in place rule"; return; } ! 227, case 1
		if (R == R_263) { print "can't push scenery rule"; return; } ! 228, case 1
		if (R == R_264) { print "can't push people rule"; return; } ! 229, case 1
		if (R == R_265) { print "report pushing rule"; return; } ! 230, case 1
		if (R == R_266) { print "can't turn what's fixed in place rule"; return; } ! 231, case 1
		if (R == R_267) { print "can't turn scenery rule"; return; } ! 232, case 1
		if (R == R_268) { print "can't turn people rule"; return; } ! 233, case 1
		if (R == R_269) { print "report turning rule"; return; } ! 234, case 1
		if (R == R_270) { print "can't push unpushable things rule"; return; } ! 235, case 1
		if (R == R_271) { print "can't push to non-directions rule"; return; } ! 236, case 1
		if (R == R_272) { print "can't push vertically rule"; return; } ! 237, case 1
		if (R == R_273) { print "standard pushing in directions rule"; return; } ! 238, case 1
		if (R == R_274) { print "block pushing in directions rule"; return; } ! 239, case 1
		if (R == R_275) { print "innuendo about squeezing people rule"; return; } ! 240, case 1
		if (R == R_276) { print "report squeezing rule"; return; } ! 241, case 1
		if (R == R_277) { print "block saying yes rule"; return; } ! 242, case 1
		if (R == R_278) { print "block saying no rule"; return; } ! 243, case 1
		if (R == R_279) { print "block burning rule"; return; } ! 244, case 1
		if (R == R_280) { print "block waking up rule"; return; } ! 245, case 1
		if (R == R_281) { print "block thinking rule"; return; } ! 246, case 1
		if (R == R_282) { print "block smelling rule"; return; } ! 247, case 1
		if (R == R_283) { print "block listening rule"; return; } ! 248, case 1
		if (R == R_284) { print "block tasting rule"; return; } ! 249, case 1
		if (R == R_285) { print "block cutting rule"; return; } ! 250, case 1
		if (R == R_286) { print "block jumping rule"; return; } ! 251, case 1
		if (R == R_287) { print "block tying rule"; return; } ! 252, case 1
		if (R == R_288) { print "block drinking rule"; return; } ! 253, case 1
		if (R == R_289) { print "block saying sorry rule"; return; } ! 254, case 1
		if (R == R_290) { print "block swearing obscenely rule"; return; } ! 255, case 1
		if (R == R_291) { print "block swearing mildly rule"; return; } ! 256, case 1
		if (R == R_292) { print "block swinging rule"; return; } ! 257, case 1
		if (R == R_293) { print "block rubbing rule"; return; } ! 258, case 1
		if (R == R_294) { print "block setting it to rule"; return; } ! 259, case 1
		if (R == R_295) { print "block waving hands rule"; return; } ! 260, case 1
		if (R == R_296) { print "block buying rule"; return; } ! 261, case 1
		if (R == R_297) { print "block singing rule"; return; } ! 262, case 1
		if (R == R_298) { print "block climbing rule"; return; } ! 263, case 1
		if (R == R_299) { print "block sleeping rule"; return; } ! 264, case 1
		if (R == R_742) { print "Small Kindnesses exit leaves when there's only one way to go rule"; return; } ! 265, case 1
		if (R == R_745) { print "new can't get off things rule"; return; } ! 266, case 1
		if (R == R_746) { print "Small Kindnesses store former location rule"; return; } ! 267, case 1
		if (R == R_747) { print "Small Kindnesses carry out retreating rule"; return; } ! 268, case 1
		if (R == R_748) { print "Small Kindnesses place the room in scope while looking rule"; return; } ! 269, case 1
		if (R == R_749) { print "Small Kindnesses overly elaborate looking rule"; return; } ! 270, case 1
		if (R == R_750) { print "Small Kindnesses place the room in scope while getting off rule"; return; } ! 271, case 1
		if (R == R_751) { print "Small Kindnesses overly elaborate exiting rule"; return; } ! 272, case 1
		if (R == R_752) { print "Small Kindnesses reporting on exits rule"; return; } ! 273, case 1
		if (R == R_754) { print "Small Kindnesses count exits rule"; return; } ! 274, case 1
		if (R == R_755) { print "Small Kindnesses report on no exits rule"; return; } ! 275, case 1
		if (R == R_756) { print "Small Kindnesses report on one exit rule"; return; } ! 276, case 1
		if (R == R_757) { print "Small Kindnesses report on exits rule"; return; } ! 277, case 1
		if (R == R_759) { print "Small Kindnesses allow for switching things in darkness rule"; return; } ! 278, case 1
		if (R == R_760) { print "Small Kindnesses don't implicitly take inedibles rule"; return; } ! 279, case 1
		if (R == R_761) { print "Small Kindnesses don't implicitly take unwearables rule"; return; } ! 280, case 1
		if (R == R_762) { print "Small Kindnesses carry out using rule"; return; } ! 281, case 1
		if (R == R_776) { print "remove all from a holdall rule"; return; } ! 282, case 1
		if (R == R_777) { print "require an open holdall rule"; return; } ! 283, case 1
		if (R == R_778) { print "check the size of a holdall rule"; return; } ! 284, case 1
		if (R == R_787) { print "considerate player's holdall rule"; return; } ! 285, case 1
		if (R == R_792) { print "allow rideables to be going vehicles rule"; return; } ! 286, case 1
		if (R == R_798) { print "can't mount when mounted on an animal rule"; return; } ! 287, case 1
		if (R == R_799) { print "can't mount when mounted on a vehicle rule"; return; } ! 288, case 1
		if (R == R_800) { print "can't mount something unrideable rule"; return; } ! 289, case 1
		if (R == R_801) { print "can't mount something carried rule"; return; } ! 290, case 1
		if (R == R_802) { print "can't mount something unreachable rule"; return; } ! 291, case 1
		if (R == R_803) { print "standard mounting rule"; return; } ! 292, case 1
		if (R == R_804) { print "standard report mounting rule"; return; } ! 293, case 1
		if (R == R_805) { print "mounting excuses rule"; return; } ! 294, case 1
		if (R == R_806) { print "can't dismount when not mounted rule"; return; } ! 295, case 1
		if (R == R_807) { print "standard dismounting rule"; return; } ! 296, case 1
		if (R == R_808) { print "standard report dismounting rule"; return; } ! 297, case 1
		if (R == R_809) { print "dismounting excuses rule"; return; } ! 298, case 1
		if (R == R_811) { print "opening doors before entering rule"; return; } ! 299, case 1
		if (R == R_812) { print "closing doors before locking rule"; return; } ! 300, case 1
		if (R == R_813) { print "closing doors before locking keylessly rule"; return; } ! 301, case 1
		if (R == R_814) { print "unlocking before opening rule"; return; } ! 302, case 1
		if (R == R_815) { print "intelligently opening doors rule"; return; } ! 303, case 1
		if (R == R_816) { print "intelligently closing doors rule"; return; } ! 304, case 1
		if (R == R_817) { print "intelligently closing keyless doors rule"; return; } ! 305, case 1
		if (R == R_818) { print "intelligently opening containers rule"; return; } ! 306, case 1
		if (R == R_819) { print "need a matching key rule"; return; } ! 307, case 1
		if (R == R_821) { print "standard printing key lack rule"; return; } ! 308, case 1
		if (R == R_823) { print "must be able to reach the key rule"; return; } ! 309, case 1
		if (R == R_824) { print "right second rule"; return; } ! 310, case 1
		if (R == R_825) { print "check keylessly unlocking rule"; return; } ! 311, case 1
		if (R == R_826) { print "standard keylessly unlocking rule"; return; } ! 312, case 1
		if (R == R_827) { print "check someone else keylessly unlocking rule"; return; } ! 313, case 1
		if (R == R_828) { print "standard someone else keylessly unlocking rule"; return; } ! 314, case 1
		if (R == R_830) { print "check keylessly locking rule"; return; } ! 315, case 1
		if (R == R_831) { print "standard keylessly locking rule"; return; } ! 316, case 1
		if (R == R_832) { print "check someone keylessly locking rule"; return; } ! 317, case 1
		if (R == R_833) { print "standard someone keylessly locking rule"; return; } ! 318, case 1
		if (R == R_835) { print "identify passkeys in inventory rule"; return; } ! 319, case 1
		if (R == R_836) { print "passkey description rule"; return; } ! 320, case 1
		if (R == R_837) { print "standard passkey unlocking rule"; return; } ! 321, case 1
		if (R == R_838) { print "observe someone unlocking rule"; return; } ! 322, case 1
		if (R == R_839) { print "standard passkey locking rule"; return; } ! 323, case 1
		if (R == R_840) { print "observe someone locking rule"; return; } ! 324, case 1
		if (R == R_841) { print "limiting keychains rule"; return; } ! 325, case 1
		if (R == R_842) { print "can't put onto something being carried except keychains rule"; return; } ! 326, case 1
		if (R == R_843) { print "keychain-aware carrying requirements rule"; return; } ! 327, case 1
		if (R == R_844) { print "don't strip keys rule"; return; } ! 328, case 1
		if (R == R_845) { print "noun autotaking rule"; return; } ! 329, case 1
		if (R == R_846) { print "second noun autotaking rule"; return; } ! 330, case 1
		if (R == R_847) { print "must hold the noun rule"; return; } ! 331, case 1
		if (R == R_848) { print "must hold the second noun rule"; return; } ! 332, case 1
		if (R == R_849) { print "must have accessible the noun rule"; return; } ! 333, case 1
		if (R == R_850) { print "must have accessible the second noun rule"; return; } ! 334, case 1
		if (R == R_851) { print "lock debugging rule"; return; } ! 335, case 1
		if (R == R_852) { print "report universal unlocking rule"; return; } ! 336, case 1
		if (R == R_868) { print "expect animate nouns for giving rule"; return; } ! 337, case 1
		if (R == R_869) { print "expect animate nouns for showing rule"; return; } ! 338, case 1
		if (R == R_870) { print "reject inanimate nouns for giving rule"; return; } ! 339, case 1
		if (R == R_871) { print "reject inanimate nouns for showing rule"; return; } ! 340, case 1
		if (R == R_872) { print "standard suggest closing rule"; return; } ! 341, case 1
		if (R == R_873) { print "standard suggestion opening rule"; return; } ! 342, case 1
		if (R == R_874) { print "standard suggest unlocking rule"; return; } ! 343, case 1
		if (R == R_875) { print "standard suggest locking rule"; return; } ! 344, case 1
		if (R == R_876) { print "standard suggest entering rule"; return; } ! 345, case 1
		if (R == R_877) { print "standard suggest getting off rule"; return; } ! 346, case 1
		if (R == R_878) { print "standard suggest wearing rule"; return; } ! 347, case 1
		if (R == R_879) { print "standard suggest eating rule"; return; } ! 348, case 1
		if (R == R_880) { print "don't suggest taking yourself rule"; return; } ! 349, case 1
		if (R == R_881) { print "don't suggest taking something someone's got rule"; return; } ! 350, case 1
		if (R == R_882) { print "don't suggest taking the scenery rule"; return; } ! 351, case 1
		if (R == R_883) { print "don't suggest taking something fixed rule"; return; } ! 352, case 1
		if (R == R_884) { print "suggest to take portable things rule"; return; } ! 353, case 1
		if (R == R_885) { print "don't suggest taking a person rule"; return; } ! 354, case 1
		if (R == R_886) { print "don't suggest to take what's carried rule"; return; } ! 355, case 1
		if (R == R_887) { print "don't suggest dropping something you've not got rule"; return; } ! 356, case 1
		if (R == R_888) { print "drop what's you've got rule"; return; } ! 357, case 1
		if (R == R_889) { print "don't suggest inserting into a non-container rule"; return; } ! 358, case 1
		if (R == R_890) { print "don't suggest putting into a non-supporter rule"; return; } ! 359, case 1
		if (R == R_891) { print "suggest inserting into a container rule"; return; } ! 360, case 1
		if (R == R_892) { print "suggest putting on a supporter rule"; return; } ! 361, case 1
		if (R == R_893) { print "expect to put held things into rule"; return; } ! 362, case 1
		if (R == R_894) { print "suggest to put held things on rule"; return; } ! 363, case 1
		if (R == R_895) { print "don't suggest inserting somewhere it already is rule"; return; } ! 364, case 1
		if (R == R_896) { print "don't suggest putting somewhere it already is rule"; return; } ! 365, case 1
		if (R == R_897) { print "don't expecting inserting something into itself rule"; return; } ! 366, case 1
		if (R == R_898) { print "don't suggest putting something into itself rule"; return; } ! 367, case 1
		if (R == R_899) { print "suggest giving held things rule"; return; } ! 368, case 1
		if (R == R_900) { print "don't expect to remove from items not including other items rule"; return; } ! 369, case 1
		if (R == R_901) { print "don't expect to remove items from things they're not in rule"; return; } ! 370, case 1
		if (R == R_902) { print "expect to remove items from things they are in rule"; return; } ! 371, case 1
		if (R == R_903) { print "never suggest yourself rule"; return; } ! 372, case 1
		if (R == R_906) { print "disambiguation printing rule"; return; } ! 373, case 1
		if (R == R_919) { print "print library message rule"; return; } ! 374, case 1
		if (R == R_935) { print "custom_internal_i6 reveal any newly visible exterior rule"; return; } ! 375, case 1
		if (R == R_936) { print "fake_newly_visible_exterior rule"; return; } ! 376, case 1
		if (R == R_937) { print "fake_newly_visible_exterior_nothing rule"; return; } ! 377, case 1
		if (R == R_939) { print "notice plurality of printed object rule"; return; } ! 378, case 1
		if (R == R_1004) { print "update ambiguous pronouns for actions rule"; return; } ! 379, case 1
		if (R == R_1005) { print "notice plurality of printed ambiguous object rule"; return; } ! 380, case 1
		if (R == R_1161) { print "help request rule"; return; } ! 381, case 1
		if (R == R_1165) { print "complete scoring rule"; return; } ! 382, case 1
		if (R == LITTLE_USED_DO_NOTHING_R) { print "little-used do nothing rule"; return; } ! 410, case 1
		if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! 411, case 1
		if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! 412, case 1
		if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! 413, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 414, case 1
		if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! 415, case 1
		if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! 416, case 1
		if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! 417, case 1
		if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! 418, case 1
		if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! 419, case 1
		if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! 420, case 1
		if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! 421, case 1
		if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! 422, case 1
		if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! 423, case 1
		if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! 424, case 1
		if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! 427, case 1
		if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! 428, case 1
		if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! 429, case 1
		if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! 430, case 1
		if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! 431, case 1
		if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! 432, case 1
		if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! 433, case 1
		if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! 434, case 1
		if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! 435, case 1
		if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! 436, case 1
		if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! 437, case 1
		if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! 441, case 1
		if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! 454, case 1
		if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! 518, case 1
		if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! 525, case 1
		if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! 526, case 1
		if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! 527, case 1
		if (R == IMMEDIATELY_RESTART_VM_R) { print "immediately restart the VM rule"; return; } ! 531, case 1
		if (R == IMMEDIATELY_RESTORE_SAVED_R) { print "immediately restore saved game rule"; return; } ! 532, case 1
		if (R == IMMEDIATELY_QUIT_R) { print "immediately quit rule"; return; } ! 533, case 1
		if (R == IMMEDIATELY_UNDO_R) { print "immediately undo rule"; return; } ! 534, case 1
		if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! 535, case 1
		if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! 743, case 1
		if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! 747, case 1
		if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! 751, case 1
		if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! 755, case 1
		if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! 759, case 1
		if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! 763, case 1
		if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! 767, case 1
		if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! 771, case 1
		if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! 775, case 1
		if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! 779, case 1
		if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! 780, case 1
		if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! 784, case 1
		if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! 785, case 1
		if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 789, case 1
		if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! 790, case 1
		if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! 794, case 1
		if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! 795, case 1
		if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! 799, case 1
		if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! 800, case 1
		if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! 804, case 1
		if (R == R_14) { print "A first turn sequence rule"; return; } ! 1013, case 2
		if (R == R_15) { print "A last turn sequence rule"; return; } ! 1014, case 2
		if (R == R_30) { print "last specific action-processing rule"; return; } ! 1015, case 2
		if (R == R_159) { print "Setting action variables for exiting"; return; } ! 1016, case 2
		if (R == R_772) { print "Before when the noun is a thing"; return; } ! 1017, case 2
		if (R == R_773) { print "Before when the second noun is a thing"; return; } ! 1018, case 2
		if (R == R_775) { print "Holdall rule for a thing not enclosed by the player"; return; } ! 1019, case 2
		if (R == R_779) { print "last holdall rule"; return; } ! 1020, case 2
		if (R == R_782) { print "First stashing rule for thing ( called the item )"; return; } ! 1021, case 2
		if (R == R_783) { print "Stashing rule for the considered holdall"; return; } ! 1022, case 2
		if (R == R_784) { print "Stashing rule for something enclosing the considered holdall"; return; } ! 1023, case 2
		if (R == R_785) { print "Stashing rule for a body-part thing"; return; } ! 1024, case 2
		if (R == R_786) { print "last stashing rule"; return; } ! 1025, case 2
		if (R == R_793) { print "Before an actor entering a rideable animal ( called the steed )"; return; } ! 1026, case 2
		if (R == R_794) { print "Before an actor entering a rideable vehicle ( called the conveyance )"; return; } ! 1027, case 2
		if (R == R_795) { print "Before an actor getting off a rideable animal ( called the steed )"; return; } ! 1028, case 2
		if (R == R_796) { print "Before an actor getting off a rideable vehicle ( called the conveyance )"; return; } ! 1029, case 2
		if (R == R_797) { print "Before an actor exiting"; return; } ! 1030, case 2
		if (R == R_810) { print "Before asking a rideable animal ( called the mount ) to try going a direction ( called the way )"; return; } ! 1031, case 2
		if (R == R_829) { print "Check locking it with"; return; } ! 1032, case 2
		if (R == R_911) { print "After deciding the scope of the player"; return; } ! 1033, case 2
		if (R == R_912) { print "Should the game suggest doing something with no-object"; return; } ! 1034, case 2
		if (R == R_913) { print "Rule for deciding whether all includes no-object"; return; } ! 1035, case 2
		if (R == R_915) { print "When play begins"; return; } ! 1036, case 2
		if (R == R_1033) { print "Instead of giving the wooden drawer to the secretary"; return; } ! 1037, case 2
		if (R == R_1034) { print "Carry out commenting"; return; } ! 1038, case 2
		if (R == R_1035) { print "Instead of swearing obscenely"; return; } ! 1039, case 2
		if (R == R_1036) { print "Instead of swearing mildly"; return; } ! 1040, case 2
		if (R == R_1037) { print "Instead of cutting something"; return; } ! 1041, case 2
		if (R == R_1038) { print "Instead of burning something"; return; } ! 1042, case 2
		if (R == R_1039) { print "After examining something"; return; } ! 1043, case 2
		if (R == R_1040) { print "Rule for supplying a missing noun while entering"; return; } ! 1044, case 2
		if (R == R_1041) { print "Instead of searching something"; return; } ! 1045, case 2
		if (R == R_1042) { print "Instead of showing something to someone"; return; } ! 1046, case 2
		if (R == R_1043) { print "Carry out greeting"; return; } ! 1047, case 2
		if (R == R_1044) { print "Instead of giving the torn page to the secretary"; return; } ! 1048, case 2
		if (R == R_1045) { print "Instead of giving the torn page to the conductor"; return; } ! 1049, case 2
		if (R == R_1046) { print "Report unlocking it with when the second noun is the screwdriver"; return; } ! 1050, case 2
		if (R == R_1047) { print "Report locking it with when the second noun is the screwdriver"; return; } ! 1051, case 2
		if (R == R_1048) { print "Instead of thinking"; return; } ! 1052, case 2
		if (R == R_1049) { print "Instead of praying"; return; } ! 1053, case 2
		if (R == R_1050) { print "Instead of blowing"; return; } ! 1054, case 2
		if (R == R_1051) { print "Instead of kissing someone"; return; } ! 1055, case 2
		if (R == R_1052) { print "Instead of kissing yourself"; return; } ! 1056, case 2
		if (R == R_1053) { print "Instead of kissing the dog"; return; } ! 1057, case 2
		if (R == R_1054) { print "Instead of attacking the dog"; return; } ! 1058, case 2
		if (R == R_1055) { print "Instead of singing"; return; } ! 1059, case 2
		if (R == R_1056) { print "Instead of shouting"; return; } ! 1060, case 2
		if (R == R_1057) { print "Instead of doing anything other than examining to the gull"; return; } ! 1061, case 2
		if (R == R_1058) { print "Instead of throwing something at the gull"; return; } ! 1062, case 2
		if (R == R_1061) { print "Instead of going nowhere when the noun is outside"; return; } ! 1063, case 2
		if (R == R_1062) { print "Instead of exiting when the player is in a room and the player is not on a supporter"; return; } ! 1064, case 2
		if (R == R_1063) { print "Instead of going inside when the room inside from the location is not a room and at least one room is inward"; return; } ! 1065, case 2
		if (R == R_1064) { print "Carry out facing"; return; } ! 1066, case 2
		if (R == R_1065) { print "Instead of facing up"; return; } ! 1067, case 2
		if (R == R_1066) { print "Carry out looking toward"; return; } ! 1068, case 2
		if (R == R_1067) { print "Check following"; return; } ! 1069, case 2
		if (R == R_1068) { print "Carry out following"; return; } ! 1070, case 2
		if (R == R_1069) { print "Before a person ( called the pawn ) going"; return; } ! 1071, case 2
		if (R == R_1070) { print "Instead of exiting when the player is in a room and the player is on a supporter"; return; } ! 1072, case 2
		if (R == R_1071) { print "Carry out supporter-exiting"; return; } ! 1073, case 2
		if (R == R_1072) { print "Carry out vehicle-exiting"; return; } ! 1074, case 2
		if (R == R_1073) { print "After inserting something into a pocket"; return; } ! 1075, case 2
		if (R == R_1074) { print "After removing something from a pocket"; return; } ! 1076, case 2
		if (R == R_1075) { print "After switching off a light source ( called source )"; return; } ! 1077, case 2
		if (R == R_1076) { print "After switching on a light source ( called source )"; return; } ! 1078, case 2
		if (R == R_1077) { print "Every turn when the small metal detector is switched on and the small metal detector is visible and at least one metal thing is visible"; return; } ! 1079, case 2
		if (R == R_1078) { print "Every turn when the small metal detector has been switched on for three turns"; return; } ! 1080, case 2
		if (R == R_1079) { print "Every turn when the magnet has not been visible and the metal detector is visible and the location is Sandy Beach and the metal detector is switched on"; return; } ! 1081, case 2
		if (R == R_1080) { print "Instead of pushing the small button"; return; } ! 1082, case 2
		if (R == R_1081) { print "After switching on the metal detector"; return; } ! 1083, case 2
		if (R == R_1082) { print "When First Pump begins"; return; } ! 1084, case 2
		if (R == R_1083) { print "Every turn when the player is in Other Side of the Pond and the wetness level is ~just beachy~"; return; } ! 1085, case 2
		if (R == R_1084) { print "After flipping a lever when lever-action is happening"; return; } ! 1086, case 2
		if (R == R_1085) { print "When Lever-action begins"; return; } ! 1087, case 2
		if (R == R_1086) { print "When Gizmo-action begins"; return; } ! 1088, case 2
		if (R == R_1087) { print "When Gadget-action begins"; return; } ! 1089, case 2
		if (R == R_1088) { print "When Hose-action begins"; return; } ! 1090, case 2
		if (R == R_1089) { print "When Second Pump begins"; return; } ! 1091, case 2
		if (R == R_1090) { print "When Third Pump begins"; return; } ! 1092, case 2
		if (R == R_1091) { print "When the conductor's story begins"; return; } ! 1093, case 2
		if (R == R_1093) { print "Instead of sleeping while the conductor's story is happening"; return; } ! 1094, case 2
		if (R == R_1094) { print "Every turn when the conductor's story is happening"; return; } ! 1095, case 2
		if (R == R_1095) { print "Every turn when the conductor's story has been happening for exactly eight turns"; return; } ! 1096, case 2
		if (R == R_1096) { print "Every turn when the conductor's story has been happening for exactly one turn"; return; } ! 1097, case 2
		if (R == R_1098) { print "When Fourth Pump begins"; return; } ! 1098, case 2
		if (R == R_1099) { print "After examining a fluid container"; return; } ! 1099, case 2
		if (R == R_1101) { print "Instead of inserting something into a fluid container"; return; } ! 1100, case 2
		if (R == R_1104) { print "Should the game choose pouring running water into something"; return; } ! 1101, case 2
		if (R == R_1105) { print "Should the game choose taking running water with the beer bottle"; return; } ! 1102, case 2
		if (R == R_1106) { print "Should the game choose filling the beer bottle with running water"; return; } ! 1103, case 2
		if (R == R_1107) { print "Should the game choose doing something with running water when also only considering the pond"; return; } ! 1104, case 2
		if (R == R_1108) { print "Carry out liquid-drinking"; return; } ! 1105, case 2
		if (R == R_1109) { print "Instead of drinking something"; return; } ! 1106, case 2
		if (R == R_1110) { print "Instead of drinking a fluid container"; return; } ! 1107, case 2
		if (R == R_1111) { print "Instead of drinking a liquid source"; return; } ! 1108, case 2
		if (R == R_1112) { print "Instead of tasting a liquid source"; return; } ! 1109, case 2
		if (R == R_1113) { print "Instead of tasting a fluid container"; return; } ! 1110, case 2
		if (R == R_1114) { print "Should the game choose spilling a fluid container"; return; } ! 1111, case 2
		if (R == R_1115) { print "Carry out filling it with"; return; } ! 1112, case 2
		if (R == R_1116) { print "Check pouring it into"; return; } ! 1113, case 2
		if (R == R_1117) { print "Carry out pouring it into"; return; } ! 1114, case 2
		if (R == R_1118) { print "Report pouring it into"; return; } ! 1115, case 2
		if (R == R_1119) { print "Carry out pouring a liquid source into something"; return; } ! 1116, case 2
		if (R == R_1120) { print "After pouring a liquid source into a fluid container"; return; } ! 1117, case 2
		if (R == R_1121) { print "Instead of pouring the fountain into something"; return; } ! 1118, case 2
		if (R == R_1122) { print "Instead of pouring something into the fountain"; return; } ! 1119, case 2
		if (R == R_1123) { print "Instead of pouring a fluid container into a liquid source"; return; } ! 1120, case 2
		if (R == R_1124) { print "Instead of inserting a fluid container into the player's holdall"; return; } ! 1121, case 2
		if (R == R_1125) { print "Rule for printing the name of a fluid container ( called bottle ) while taking inventory"; return; } ! 1122, case 2
		if (R == R_1126) { print "Instead of swimming in the presence of a liquid source ( called source )"; return; } ! 1123, case 2
		if (R == R_1127) { print "Instead of swimming"; return; } ! 1124, case 2
		if (R == R_1128) { print "Before inserting something into a liquid source"; return; } ! 1125, case 2
		if (R == R_1129) { print "Check spilling something"; return; } ! 1126, case 2
		if (R == R_1130) { print "Carry out spilling something"; return; } ! 1127, case 2
		if (R == R_1131) { print "Rule for supplying a missing noun while spilling"; return; } ! 1128, case 2
		if (R == R_1132) { print "Rule for supplying a missing noun while drinking"; return; } ! 1129, case 2
		if (R == R_1133) { print "Instead of searching a liquid source"; return; } ! 1130, case 2
		if (R == R_1134) { print "After deciding the scope of the player when the player is in the station of the steam train"; return; } ! 1131, case 2
		if (R == R_1135) { print "After deciding the scope of the player when the player is in Pump Room and the secretary is in Inside Waterworks"; return; } ! 1132, case 2
		if (R == R_1136) { print "Rule for reaching inside the Steam Train when we are speech"; return; } ! 1133, case 2
		if (R == R_1137) { print "Rule for reaching inside the Steam Train when we are giving something to someone"; return; } ! 1134, case 2
		if (R == R_1138) { print "Rule for reaching inside the Steam Train when we are showing something to someone"; return; } ! 1135, case 2
		if (R == R_1139) { print "Instead of exiting when the player is in the steam train"; return; } ! 1136, case 2
		if (R == R_1140) { print "Before going outside when the player is in the steam train"; return; } ! 1137, case 2
		if (R == R_1141) { print "Before going inside when the player is in the station of the steam train"; return; } ! 1138, case 2
		if (R == R_1142) { print "Before going east when the player is in the steam train"; return; } ! 1139, case 2
		if (R == R_1143) { print "Rule for supplying a missing noun while entering"; return; } ! 1140, case 2
		if (R == R_1144) { print "Instead of entering the steam train"; return; } ! 1141, case 2
		if (R == R_1145) { print "Carry out boarding"; return; } ! 1142, case 2
		if (R == R_1146) { print "Before boarding"; return; } ! 1143, case 2
		if (R == R_1147) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1144, case 2
		if (R == R_1148) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1145, case 2
		if (R == R_1149) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1146, case 2
		if (R == R_1150) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1147, case 2
		if (R == R_1151) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1148, case 2
		if (R == R_1152) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1149, case 2
		if (R == R_1153) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1150, case 2
		if (R == R_1154) { print "Every turn when Other Side of the Pond is not flooded"; return; } ! 1151, case 2
		if (R == R_1155) { print "Check train-waiting"; return; } ! 1152, case 2
		if (R == R_1156) { print "Carry out train-waiting"; return; } ! 1153, case 2
		if (R == R_1157) { print "Carry out waiting more"; return; } ! 1154, case 2
		if (R == R_1158) { print "Report waiting more"; return; } ! 1155, case 2
		if (R == R_1159) { print "Check waiting more"; return; } ! 1156, case 2
		if (R == R_1160) { print "After printing the banner text"; return; } ! 1157, case 2
		if (R == R_1162) { print "Carry out crediting"; return; } ! 1158, case 2
		if (R == R_1163) { print "Carry out hinting"; return; } ! 1159, case 2
		if (R == R_1167) { print "Carry out requesting the full score"; return; } ! 1160, case 2
		if (R == R_1168) { print "After taking the ticket"; return; } ! 1161, case 2
		if (R == R_1169) { print "After taking the old key"; return; } ! 1162, case 2
		if (R == R_1170) { print "After taking the flashlight"; return; } ! 1163, case 2
		if (R == R_1171) { print "After taking the screwdriver"; return; } ! 1164, case 2
		if (R == R_1172) { print "After taking the wrench"; return; } ! 1165, case 2
		if (R == R_1173) { print "Every turn when the player is in Other Side of the Pond"; return; } ! 1166, case 2
		if (R == R_1174) { print "Every turn when the player is in Atop the Tank"; return; } ! 1167, case 2
		if (R == R_1175) { print "After going to Floating on the Pond"; return; } ! 1168, case 2
		if (R == R_1176) { print "After going to the Boat House"; return; } ! 1169, case 2
		if (R == R_1177) { print "Instead of jumping"; return; } ! 1170, case 2
		if (R == R_1178) { print "Carry out xyzzy"; return; } ! 1171, case 2
		if (R == R_1179) { print "Instead of smelling"; return; } ! 1172, case 2
		if (R == R_1180) { print "Instead of listening when the location is the Hill"; return; } ! 1173, case 2
		if (R == R_1181) { print "Instead of listening when at least one pump is switched on"; return; } ! 1174, case 2
		if (R == R_1182) { print "Instead of listening"; return; } ! 1175, case 2
		if (R == R_1183) { print "Instead of waving hands"; return; } ! 1176, case 2
		if (R == R_1184) { print "Instead of waving the flag"; return; } ! 1177, case 2
		if (R == R_1185) { print "Instead of waving the flagpole"; return; } ! 1178, case 2
		if (R == R_1186) { print "Instead of taking the wind chimes when the player is in the Hill"; return; } ! 1179, case 2
		if (R == R_1187) { print "Every turn when the player is in the Hill or the player is in In The Sweetgum Tree"; return; } ! 1180, case 2
		if (R == R_1188) { print "Instead of listening to the sound of the wind chimes"; return; } ! 1181, case 2
		if (R == R_1189) { print "Should the game choose doing something to the wind chimes"; return; } ! 1182, case 2
		if (R == R_1190) { print "Instead of taking the sound of the wind chimes"; return; } ! 1183, case 2
		if (R == R_1191) { print "After taking the wind chimes"; return; } ! 1184, case 2
		if (R == R_1192) { print "Instead of rubbing the dog"; return; } ! 1185, case 2
		if (R == R_1193) { print "Instead of touching the dog"; return; } ! 1186, case 2
		if (R == R_1194) { print "Carry out throwing something at the dog"; return; } ! 1187, case 2
		if (R == R_1195) { print "Instead of dropping the stick when the dog is in the location of the player"; return; } ! 1188, case 2
		if (R == R_1196) { print "Instead of dropping a pinecone when the dog is in the location of the player"; return; } ! 1189, case 2
		if (R == R_1197) { print "Rule for supplying a missing second noun when throwing something at something"; return; } ! 1190, case 2
		if (R == R_1198) { print "Rule for constructing the status line"; return; } ! 1191, case 2
		if (R == R_1199) { print "When play begins"; return; } ! 1192, case 2
		if (R == R_1200) { print "When play begins"; return; } ! 1193, case 2
		if (R == R_1201) { print "Every turn when a random chance of 1 in 10 succeeds"; return; } ! 1194, case 2
		if (R == R_1202) { print "Every turn when a random chance of 1 in 12 succeeds"; return; } ! 1195, case 2
		if (R == R_1203) { print "Instead of going nowhere from a room that is indoors"; return; } ! 1196, case 2
		if (R == R_1204) { print "Instead of taking inventory"; return; } ! 1197, case 2
		if (R == R_1205) { print "Holdall rule for a thing not enclosed by the player"; return; } ! 1198, case 2
		if (R == R_1206) { print "After examining the coat"; return; } ! 1199, case 2
		if (R == R_1207) { print "A stashing rule for a fluid container"; return; } ! 1200, case 2
		if (R == R_1208) { print "A stashing rule for the wide stick"; return; } ! 1201, case 2
		if (R == R_1209) { print "A stashing rule for the wooden drawer"; return; } ! 1202, case 2
		if (R == R_1210) { print "A stashing rule for the flagpole"; return; } ! 1203, case 2
		if (R == R_1211) { print "Rule for deciding whether all includes something in the right pocket"; return; } ! 1204, case 2
		if (R == R_1212) { print "Rule for deciding whether all includes something in the left pocket"; return; } ! 1205, case 2
		if (R == R_1213) { print "Instead of taking off the boots"; return; } ! 1206, case 2
		if (R == R_1214) { print "Instead of knocking on an open door"; return; } ! 1207, case 2
		if (R == R_1215) { print "Instead of knocking on a closed door"; return; } ! 1208, case 2
		if (R == R_1216) { print "Instead of knocking on the Waterworks door when the Waterworks door is closed and the secretary of water is in Inside Waterworks and the player is in Outside Waterworks"; return; } ! 1209, case 2
		if (R == R_1217) { print "Instead of attacking a door"; return; } ! 1210, case 2
		if (R == R_1218) { print "Report knocking on something soft"; return; } ! 1211, case 2
		if (R == R_1219) { print "Report knocking on something"; return; } ! 1212, case 2
		if (R == R_1220) { print "Instead of going northwest from Outside Waterworks"; return; } ! 1213, case 2
		if (R == R_1221) { print "Instead of entering the Waterworks when the location is Outside Waterworks"; return; } ! 1214, case 2
		if (R == R_1222) { print "Instead of facing northwest when the location is Outside Waterworks"; return; } ! 1215, case 2
		if (R == R_1223) { print "Instead of facing west when the location is Outside Waterworks"; return; } ! 1216, case 2
		if (R == R_1224) { print "Instead of going north in Outside Waterworks"; return; } ! 1217, case 2
		if (R == R_1225) { print "Instead of going north in Outside Waterworks for the second turn"; return; } ! 1218, case 2
		if (R == R_1226) { print "After switching on the fountain"; return; } ! 1219, case 2
		if (R == R_1227) { print "Should the game choose examining the fountain"; return; } ! 1220, case 2
		if (R == R_1228) { print "After switching off the fountain"; return; } ! 1221, case 2
		if (R == R_1229) { print "Before switching on the fountain"; return; } ! 1222, case 2
		if (R == R_1230) { print "Before switching off the fountain"; return; } ! 1223, case 2
		if (R == R_1231) { print "Instead of drinking the fountain"; return; } ! 1224, case 2
		if (R == R_1232) { print "Should the game choose drinking running water"; return; } ! 1225, case 2
		if (R == R_1233) { print "Instead of going west in Outside Waterworks when Muddy Beach is unvisited"; return; } ! 1226, case 2
		if (R == R_1234) { print "Instead of going northwest in Outside Waterworks when Muddy Beach is unvisited"; return; } ! 1227, case 2
		if (R == R_1235) { print "Instead of going west in Outside Waterworks when Muddy Beach is visited"; return; } ! 1228, case 2
		if (R == R_1236) { print "Instead of going northwest in Outside Waterworks when Muddy Beach is visited"; return; } ! 1229, case 2
		if (R == R_1237) { print "Instead of shaking the fence"; return; } ! 1230, case 2
		if (R == R_1238) { print "Instead of pushing the fence"; return; } ! 1231, case 2
		if (R == R_1239) { print "Instead of attacking the fence"; return; } ! 1232, case 2
		if (R == R_1240) { print "After examining the pond when the underground pump is switched off for the first time"; return; } ! 1233, case 2
		if (R == R_1241) { print "Instead of examining the pond when the player is in the steam train and the station of the steam train is Freshwater Crossing"; return; } ! 1234, case 2
		if (R == R_1242) { print "Instead of searching or entering the large rusty pipe"; return; } ! 1235, case 2
		if (R == R_1243) { print "After examining the pond"; return; } ! 1236, case 2
		if (R == R_1244) { print "Instead of drinking or touching the pond"; return; } ! 1237, case 2
		if (R == R_1245) { print "Instead of pouring the pond into something"; return; } ! 1238, case 2
		if (R == R_1246) { print "Instead of swimming in the presence of a liquid source when the location is Outside Waterworks or the location is the Hill or the location is In The Sweetgum Tree or the location is Atop the Tank"; return; } ! 1239, case 2
		if (R == R_1247) { print "Check climbing the chain-link fence"; return; } ! 1240, case 2
		if (R == R_1248) { print "Instead of inserting the wide stick into something"; return; } ! 1241, case 2
		if (R == R_1249) { print "Instead of inserting the wooden drawer into something"; return; } ! 1242, case 2
		if (R == R_1250) { print "Instead of inserting the flagpole into something that is not the pipe holes"; return; } ! 1243, case 2
		if (R == R_1251) { print "Check going west in Outside Waterworks"; return; } ! 1244, case 2
		if (R == R_1252) { print "Instead of going east in Muddy Beach"; return; } ! 1245, case 2
		if (R == R_1253) { print "Instead of going west in Muddy Beach"; return; } ! 1246, case 2
		if (R == R_1254) { print "Instead of going northwest in Muddy Beach"; return; } ! 1247, case 2
		if (R == R_1255) { print "Instead of going south in Muddy Beach"; return; } ! 1248, case 2
		if (R == R_1256) { print "Instead of going southeast in Muddy Beach"; return; } ! 1249, case 2
		if (R == R_1257) { print "Instead of going southwest in Muddy Beach"; return; } ! 1250, case 2
		if (R == R_1258) { print "Instead of going north in Muddy Beach"; return; } ! 1251, case 2
		if (R == R_1259) { print "Instead of exiting in Boat House when the player is not in the rowboat"; return; } ! 1252, case 2
		if (R == R_1260) { print "Should the game choose doing something to the structure"; return; } ! 1253, case 2
		if (R == R_1261) { print "Instead of wading"; return; } ! 1254, case 2
		if (R == R_1262) { print "Instead of unlocking the structure with something"; return; } ! 1255, case 2
		if (R == R_1263) { print "Instead of opening the structure when the player is not in Rocky Beach"; return; } ! 1256, case 2
		if (R == R_1264) { print "Before going west in Rocky Beach"; return; } ! 1257, case 2
		if (R == R_1265) { print "Instead of entering the structure"; return; } ! 1258, case 2
		if (R == R_1266) { print "Instead of unlocking the structure with something"; return; } ! 1259, case 2
		if (R == R_1267) { print "After unlocking the door to the structure with something"; return; } ! 1260, case 2
		if (R == R_1268) { print "Instead of unlocking keylessly the door to the structure for the first time"; return; } ! 1261, case 2
		if (R == R_1269) { print "Instead of unlocking keylessly the door to the structure when the player does not enclose the old key"; return; } ! 1262, case 2
		if (R == R_1270) { print "Instead of taking the rowboat"; return; } ! 1263, case 2
		if (R == R_1271) { print "Rule for supplying a missing noun while rowing"; return; } ! 1264, case 2
		if (R == R_1272) { print "Check going"; return; } ! 1265, case 2
		if (R == R_1273) { print "Before rowing"; return; } ! 1266, case 2
		if (R == R_1274) { print "Check rowing"; return; } ! 1267, case 2
		if (R == R_1275) { print "Carry out rowing"; return; } ! 1268, case 2
		if (R == R_1276) { print "Carry out going to the Boat House"; return; } ! 1269, case 2
		if (R == R_1277) { print "After going to Boat House when the rowboat is moved"; return; } ! 1270, case 2
		if (R == R_1278) { print "After opening the waterstained door when the rowboat is moved and the rowboat is in Floating on the Pond"; return; } ! 1271, case 2
		if (R == R_1279) { print "Instead of going east in Boat House"; return; } ! 1272, case 2
		if (R == R_1280) { print "Instead of going west in Boat House when the player is not in the rowboat"; return; } ! 1273, case 2
		if (R == R_1281) { print "Instead of exiting from the rowboat"; return; } ! 1274, case 2
		if (R == R_1282) { print "Instead of going up from Grassy Shore"; return; } ! 1275, case 2
		if (R == R_1283) { print "Instead of unlocking keylessly the community center door for the first time"; return; } ! 1276, case 2
		if (R == R_1284) { print "Instead of unlocking keylessly the community center door when the player does not enclose the brass key"; return; } ! 1277, case 2
		if (R == R_1285) { print "Instead of touching the red foam keychain"; return; } ! 1278, case 2
		if (R == R_1286) { print "Instead of entering the community center building"; return; } ! 1279, case 2
		if (R == R_1287) { print "Instead of going inside in Grassy Shore"; return; } ! 1280, case 2
		if (R == R_1288) { print "Instead of exiting in Pondside Community Center"; return; } ! 1281, case 2
		if (R == R_1289) { print "Instead of going south from Grassy Shore"; return; } ! 1282, case 2
		if (R == R_1290) { print "Instead of going southwest from Grassy Shore"; return; } ! 1283, case 2
		if (R == R_1291) { print "Instead of going east from Grassy Shore"; return; } ! 1284, case 2
		if (R == R_1292) { print "Instead of going nowhere from Grassy Shore"; return; } ! 1285, case 2
		if (R == R_1293) { print "Instead of going southeast from Grassy Shore when the player is not in the rowboat"; return; } ! 1286, case 2
		if (R == R_1294) { print "Instead of going south from Grassy Shore when the player is in the rowboat"; return; } ! 1287, case 2
		if (R == R_1295) { print "Instead of going southwest from Grassy Shore when the player is in the rowboat"; return; } ! 1288, case 2
		if (R == R_1296) { print "Instead of going east from Grassy Shore when the player is in the rowboat"; return; } ! 1289, case 2
		if (R == R_1297) { print "After going to Grassy Shore"; return; } ! 1290, case 2
		if (R == R_1298) { print "Before going north from Grassy Shore when the player is in the rowboat"; return; } ! 1291, case 2
		if (R == R_1299) { print "Check inserting something into the mural"; return; } ! 1292, case 2
		if (R == R_1300) { print "Instead of taking the mural"; return; } ! 1293, case 2
		if (R == R_1301) { print "Rule for deciding whether all includes the flagpole"; return; } ! 1294, case 2
		if (R == R_1302) { print "Instead of taking the peeling paint"; return; } ! 1295, case 2
		if (R == R_1303) { print "Carry out dancing"; return; } ! 1296, case 2
		if (R == R_1304) { print "Instead of taking the flag when the flagpole is in the mural"; return; } ! 1297, case 2
		if (R == R_1305) { print "Should the game choose doing something to the real crystal spire"; return; } ! 1298, case 2
		if (R == R_1306) { print "Instead of touching the real crystal spire"; return; } ! 1299, case 2
		if (R == R_1307) { print "Instead of touching the oval indentations"; return; } ! 1300, case 2
		if (R == R_1308) { print "Instead of going nowhere from Waterland when the player is in the rowboat"; return; } ! 1301, case 2
		if (R == R_1309) { print "Instead of jumping when the player is enclosed by the rowboat"; return; } ! 1302, case 2
		if (R == R_1310) { print "Before rowing toward"; return; } ! 1303, case 2
		if (R == R_1311) { print "Instead of going nowhere from Spireland"; return; } ! 1304, case 2
		if (R == R_1312) { print "Should the game choose rowing toward the real crystal spire"; return; } ! 1305, case 2
		if (R == R_1313) { print "Instead of looking up"; return; } ! 1306, case 2
		if (R == R_1314) { print "Instead of going inside in Outside Waterworks"; return; } ! 1307, case 2
		if (R == R_1315) { print "After going to Inside Waterworks when the secretary is in Inside Waterworks"; return; } ! 1308, case 2
		if (R == R_1316) { print "Instead of opening the desk"; return; } ! 1309, case 2
		if (R == R_1317) { print "Instead of opening the drawer when the secretary is visible"; return; } ! 1310, case 2
		if (R == R_1318) { print "Instead of closing the desk"; return; } ! 1311, case 2
		if (R == R_1319) { print "Instead of taking something that is enclosed by the tall cylinder"; return; } ! 1312, case 2
		if (R == R_1320) { print "Instead of taking something that is in the tall cylinder when the player is on something"; return; } ! 1313, case 2
		if (R == R_1321) { print "Instead of attacking the tall cylinder"; return; } ! 1314, case 2
		if (R == R_1322) { print "Instead of pulling or pushing the tall cylinder"; return; } ! 1315, case 2
		if (R == R_1323) { print "Instead of inserting something into the tall cylinder"; return; } ! 1316, case 2
		if (R == R_1324) { print "Instead of climbing the tall cylinder"; return; } ! 1317, case 2
		if (R == R_1325) { print "Instead of pouring something into the tall cylinder"; return; } ! 1318, case 2
		if (R == R_1326) { print "Instead of touching the tall cylinder"; return; } ! 1319, case 2
		if (R == R_1327) { print "Instead of throwing something at the tall cylinder"; return; } ! 1320, case 2
		if (R == R_1328) { print "Instead of doing anything with bubbling water"; return; } ! 1321, case 2
		if (R == R_1329) { print "Should the game choose doing something other than opening to the wooden drawer"; return; } ! 1322, case 2
		if (R == R_1330) { print "Instead of jumping when the tall cylinder is visible"; return; } ! 1323, case 2
		if (R == R_1331) { print "Every turn when the player is in Inside Waterworks"; return; } ! 1324, case 2
		if (R == R_1332) { print "Should the game choose examining the complicated pump"; return; } ! 1325, case 2
		if (R == R_1333) { print "Should the game choose switching on the complicated pump"; return; } ! 1326, case 2
		if (R == R_1334) { print "Instead of switching on a lever"; return; } ! 1327, case 2
		if (R == R_1335) { print "Instead of switching off a lever"; return; } ! 1328, case 2
		if (R == R_1336) { print "Check plugging it with"; return; } ! 1329, case 2
		if (R == R_1337) { print "Instead of taking the clump of sap when the leaky hose is plugged"; return; } ! 1330, case 2
		if (R == R_1338) { print "Carry out plugging it with"; return; } ! 1331, case 2
		if (R == R_1339) { print "Instead of putting something on the leaky hose"; return; } ! 1332, case 2
		if (R == R_1340) { print "Instead of putting the sap on the complicated pump"; return; } ! 1333, case 2
		if (R == R_1341) { print "After examining the nest of hoses"; return; } ! 1334, case 2
		if (R == R_1342) { print "Every turn when the player is in the Pump Room"; return; } ! 1335, case 2
		if (R == R_1343) { print "Every turn when the player is in the Pump Room and the Secretary is in Inside Waterworks and a random chance of 1 in 3 succeeds"; return; } ! 1336, case 2
		if (R == R_1344) { print "Every turn"; return; } ! 1337, case 2
		if (R == R_1345) { print "Instead of tightening"; return; } ! 1338, case 2
		if (R == R_1346) { print "Check switching on a gizmo"; return; } ! 1339, case 2
		if (R == R_1347) { print "After switching on a gizmo"; return; } ! 1340, case 2
		if (R == R_1348) { print "Instead of inserting something into the keyhole"; return; } ! 1341, case 2
		if (R == R_1349) { print "Instead of inserting something into the gadget"; return; } ! 1342, case 2
		if (R == R_1350) { print "Instead of unlocking the gadget with something"; return; } ! 1343, case 2
		if (R == R_1351) { print "Instead of unlocking keylessly the gadget"; return; } ! 1344, case 2
		if (R == R_1352) { print "Instead of locking the keyhole with something"; return; } ! 1345, case 2
		if (R == R_1353) { print "After unlocking the keyhole with something"; return; } ! 1346, case 2
		if (R == R_1354) { print "Should the game choose doing something to the green switch"; return; } ! 1347, case 2
		if (R == R_1355) { print "Instead of turning a lever"; return; } ! 1348, case 2
		if (R == R_1356) { print "Instead of turning a switch"; return; } ! 1349, case 2
		if (R == R_1357) { print "After printing the name of a lever ( called flippy ) when not examining"; return; } ! 1350, case 2
		if (R == R_1358) { print "After printing the name of a switch ( called flippy ) when not examining"; return; } ! 1351, case 2
		if (R == R_1359) { print "Check lever-examining"; return; } ! 1352, case 2
		if (R == R_1360) { print "Check gizmo-examining"; return; } ! 1353, case 2
		if (R == R_1361) { print "Check switch-examining"; return; } ! 1354, case 2
		if (R == R_1362) { print "Carry out lever-examining"; return; } ! 1355, case 2
		if (R == R_1363) { print "Carry out switch-examining"; return; } ! 1356, case 2
		if (R == R_1364) { print "Carry out gizmo-examining"; return; } ! 1357, case 2
		if (R == R_1365) { print "Should the game choose doing something to the blue lever"; return; } ! 1358, case 2
		if (R == R_1366) { print "Should the game choose doing something to the blue switch"; return; } ! 1359, case 2
		if (R == R_1367) { print "Instead of pulling a lever"; return; } ! 1360, case 2
		if (R == R_1368) { print "Instead of pushing a lever"; return; } ! 1361, case 2
		if (R == R_1369) { print "Check flipping"; return; } ! 1362, case 2
		if (R == R_1370) { print "Carry out flipping"; return; } ! 1363, case 2
		if (R == R_1371) { print "Instead of switching on or switching off the complicated pump"; return; } ! 1364, case 2
		if (R == R_1372) { print "Instead of examining the notes"; return; } ! 1365, case 2
		if (R == R_1373) { print "Instead of examining the notebook when the Secretary of Water is visible"; return; } ! 1366, case 2
		if (R == R_1374) { print "Rule for reaching inside Inside Waterworks when we are speech"; return; } ! 1367, case 2
		if (R == R_1375) { print "Instead of going up in Inside Waterworks"; return; } ! 1368, case 2
		if (R == R_1376) { print "Instead of exiting when the location is Inside Waterworks and the player is not on a supporter"; return; } ! 1369, case 2
		if (R == R_1377) { print "Instead of speech when the noun is the Secretary of Water"; return; } ! 1370, case 2
		if (R == R_1378) { print "Instead of jumping or dancing when the player is trapped"; return; } ! 1371, case 2
		if (R == R_1379) { print "Instead of attacking the secretary"; return; } ! 1372, case 2
		if (R == R_1380) { print "Instead of giving something to the Secretary"; return; } ! 1373, case 2
		if (R == R_1381) { print "Instead of giving something unimportant to the Secretary"; return; } ! 1374, case 2
		if (R == R_1382) { print "Before going down in Inside Waterworks when the Secretary is visible and the secretary is calm for the first turn"; return; } ! 1375, case 2
		if (R == R_1383) { print "Before going to the Pump Room when the Secretary is visible and the secretary is calm"; return; } ! 1376, case 2
		if (R == R_1384) { print "Before going to the Pump Room when the Secretary is not visible"; return; } ! 1377, case 2
		if (R == R_1385) { print "Before going up from the Pump Room"; return; } ! 1378, case 2
		if (R == R_1386) { print "Instead of going to the Pump Room when the Secretary is visible and the Secretary is irked"; return; } ! 1379, case 2
		if (R == R_1387) { print "Instead of going northeast in the hill"; return; } ! 1380, case 2
		if (R == R_1388) { print "Instead of going southeast in the hill"; return; } ! 1381, case 2
		if (R == R_1389) { print "Instead of smelling the pine trees"; return; } ! 1382, case 2
		if (R == R_1390) { print "Instead of smelling the grove"; return; } ! 1383, case 2
		if (R == R_1391) { print "Instead of taking the leaves"; return; } ! 1384, case 2
		if (R == R_1392) { print "Instead of entering the visitor center building"; return; } ! 1385, case 2
		if (R == R_1393) { print "Instead of going up in Outside Waterworks"; return; } ! 1386, case 2
		if (R == R_1394) { print "Instead of going down in Outside Waterworks"; return; } ! 1387, case 2
		if (R == R_1395) { print "Instead of going down in the Hill"; return; } ! 1388, case 2
		if (R == R_1397) { print "Before taking or touching something contained by the Hill when the location is In The Sweetgum Tree"; return; } ! 1389, case 2
		if (R == R_1398) { print "Instead of going nowhere from In The Sweetgum Tree"; return; } ! 1390, case 2
		if (R == R_1399) { print "Instead of jumping in In The Sweetgum Tree"; return; } ! 1391, case 2
		if (R == R_1400) { print "Instead of playing something"; return; } ! 1392, case 2
		if (R == R_1401) { print "Instead of playing the wind chimes"; return; } ! 1393, case 2
		if (R == R_1402) { print "Instead of listening to the wind chimes"; return; } ! 1394, case 2
		if (R == R_1403) { print "Instead of shaking something"; return; } ! 1395, case 2
		if (R == R_1404) { print "Instead of shaking the wind chimes"; return; } ! 1396, case 2
		if (R == R_1405) { print "After deciding the scope of the player when the player is in the Hill"; return; } ! 1397, case 2
		if (R == R_1406) { print "Before taking the chimes when the player is in the Hill"; return; } ! 1398, case 2
		if (R == R_1407) { print "Instead of taking twinkling lights"; return; } ! 1399, case 2
		if (R == R_1408) { print "Instead of dropping something when the location is In The Sweetgum Tree"; return; } ! 1400, case 2
		if (R == R_1409) { print "Before going down from In The Sweetgum Tree"; return; } ! 1401, case 2
		if (R == R_1410) { print "Instead of climbing the bench"; return; } ! 1402, case 2
		if (R == R_1411) { print "Instead of climbing the sweetgum tree"; return; } ! 1403, case 2
		if (R == R_1412) { print "Instead of going southeast in the Hill"; return; } ! 1404, case 2
		if (R == R_1413) { print "Check going up in the Hill"; return; } ! 1405, case 2
		if (R == R_1414) { print "Instead of jumping in the Hill"; return; } ! 1406, case 2
		if (R == R_1415) { print "Instead of going nowhere from the Hill"; return; } ! 1407, case 2
		if (R == R_1416) { print "Instead of smelling a pinecone"; return; } ! 1408, case 2
		if (R == R_1417) { print "Instead of taking the pine bark"; return; } ! 1409, case 2
		if (R == R_1418) { print "Instead of taking the needles"; return; } ! 1410, case 2
		if (R == R_1419) { print "Instead of climbing the tall pine trees"; return; } ! 1411, case 2
		if (R == R_1420) { print "Should the game choose taking off the pinecone"; return; } ! 1412, case 2
		if (R == R_1421) { print "Instead of going up in Pine Forest"; return; } ! 1413, case 2
		if (R == R_1422) { print "Instead of taking the sap"; return; } ! 1414, case 2
		if (R == R_1423) { print "Instead of removing the sap from something"; return; } ! 1415, case 2
		if (R == R_1424) { print "Instead of inserting the pine sap into the beer bottle"; return; } ! 1416, case 2
		if (R == R_1425) { print "Instead of going nowhere from Pine Forest"; return; } ! 1417, case 2
		if (R == R_1426) { print "Instead of going down in Pine Forest"; return; } ! 1418, case 2
		if (R == R_1427) { print "Instead of going inside in the Hill"; return; } ! 1419, case 2
		if (R == R_1428) { print "After deciding the scope of the player when the player is in Visitor Center"; return; } ! 1420, case 2
		if (R == R_1429) { print "Instead of opening the window"; return; } ! 1421, case 2
		if (R == R_1430) { print "Instead of closing the window"; return; } ! 1422, case 2
		if (R == R_1431) { print "Instead of examining the vending machine"; return; } ! 1423, case 2
		if (R == R_1432) { print "Instead of attacking the vending machine"; return; } ! 1424, case 2
		if (R == R_1433) { print "Instead of attacking the slot"; return; } ! 1425, case 2
		if (R == R_1434) { print "Instead of pushing the slot"; return; } ! 1426, case 2
		if (R == R_1435) { print "Instead of shaking the slot"; return; } ! 1427, case 2
		if (R == R_1436) { print "Instead of inserting something into the vending machine when the vending machine is closed"; return; } ! 1428, case 2
		if (R == R_1437) { print "Instead of shaking the vending machine"; return; } ! 1429, case 2
		if (R == R_1438) { print "Instead of pushing the vending machine"; return; } ! 1430, case 2
		if (R == R_1439) { print "Report opening the vending machine"; return; } ! 1431, case 2
		if (R == R_1440) { print "Instead of examining something when the noun is contained by the vending machine and the vending machine is closed"; return; } ! 1432, case 2
		if (R == R_1441) { print "Instead of rubbing the shelf"; return; } ! 1433, case 2
		if (R == R_1442) { print "Instead of rubbing the window"; return; } ! 1434, case 2
		if (R == R_1443) { print "Instead of inserting something into the slot"; return; } ! 1435, case 2
		if (R == R_1444) { print "Instead of unlocking the vending machine with something"; return; } ! 1436, case 2
		if (R == R_1445) { print "Instead of unlocking keylessly the vending machine"; return; } ! 1437, case 2
		if (R == R_1446) { print "Before inserting something into the vending machine when the vending machine is locked"; return; } ! 1438, case 2
		if (R == R_1447) { print "After inserting a small rock ( called rocky ) into the slot"; return; } ! 1439, case 2
		if (R == R_1448) { print "Instead of going east in Rocky Beach"; return; } ! 1440, case 2
		if (R == R_1449) { print "Instead of going southeast in Rocky Beach"; return; } ! 1441, case 2
		if (R == R_1450) { print "Instead of going south in Rocky Beach"; return; } ! 1442, case 2
		if (R == R_1451) { print "Instead of going north in Rocky Beach"; return; } ! 1443, case 2
		if (R == R_1452) { print "Instead of going northwest in Rocky Beach"; return; } ! 1444, case 2
		if (R == R_1453) { print "Every turn when the player is in Rocky Beach and a random chance of 1 in 2 succeeds and the gull is not in Rocky Beach"; return; } ! 1445, case 2
		if (R == R_1454) { print "Every turn when the player is in Rocky Beach and the gull is in Rocky Beach and a random chance of 1 in 5 succeeds"; return; } ! 1446, case 2
		if (R == R_1455) { print "Instead of entering the pond"; return; } ! 1447, case 2
		if (R == R_1456) { print "Instead of inserting the screwdriver into the panel when the panel is closed"; return; } ! 1448, case 2
		if (R == R_1457) { print "Before taking the drawer"; return; } ! 1449, case 2
		if (R == R_1458) { print "Should the game suggest doing something to the drawer bottom"; return; } ! 1450, case 2
		if (R == R_1459) { print "Check turning the wooden drawer"; return; } ! 1451, case 2
		if (R == R_1460) { print "Instead of turning the wooden drawer"; return; } ! 1452, case 2
		if (R == R_1461) { print "Instead of doing anything with the panel when the drawer is upside-down"; return; } ! 1453, case 2
		if (R == R_1462) { print "After printing the name of the wooden drawer when looking"; return; } ! 1454, case 2
		if (R == R_1463) { print "Instead of entering the wooden drawer"; return; } ! 1455, case 2
		if (R == R_1464) { print "Instead of getting off the wooden drawer"; return; } ! 1456, case 2
		if (R == R_1465) { print "Instead of going down when the player is on a supporter"; return; } ! 1457, case 2
		if (R == R_1466) { print "Instead of exiting when the player is on a supporter"; return; } ! 1458, case 2
		if (R == R_1467) { print "Check taking the wooden drawer"; return; } ! 1459, case 2
		if (R == R_1468) { print "Instead of climbing the wooden drawer"; return; } ! 1460, case 2
		if (R == R_1469) { print "Instead of doing anything with the drawer bottom when the drawer is right-side-up"; return; } ! 1461, case 2
		if (R == R_1470) { print "Every turn"; return; } ! 1462, case 2
		if (R == R_1471) { print "Every turn"; return; } ! 1463, case 2
		if (R == R_1472) { print "Should the game choose doing something to the engineer's blueprint"; return; } ! 1464, case 2
		if (R == R_1473) { print "After examining the engineer's blueprint for the first time"; return; } ! 1465, case 2
		if (R == R_1474) { print "Instead of dropping the secret panel"; return; } ! 1466, case 2
		if (R == R_1475) { print "Instead of inserting something that is not a flat paper into the secret panel"; return; } ! 1467, case 2
		if (R == R_1476) { print "Carry out prying it with"; return; } ! 1468, case 2
		if (R == R_1477) { print "Instead of unlocking the secret panel with something"; return; } ! 1469, case 2
		if (R == R_1478) { print "Check prying it with"; return; } ! 1470, case 2
		if (R == R_1479) { print "Instead of unlocking the secret panel with the screwdriver"; return; } ! 1471, case 2
		if (R == R_1480) { print "Instead of taking the secret panel"; return; } ! 1472, case 2
		if (R == R_1481) { print "Instead of touching the secret panel"; return; } ! 1473, case 2
		if (R == R_1482) { print "Instead of pushing the secret panel"; return; } ! 1474, case 2
		if (R == R_1483) { print "Check opening the secret panel"; return; } ! 1475, case 2
		if (R == R_1484) { print "Should the game choose taking the rock selection"; return; } ! 1476, case 2
		if (R == R_1485) { print "Should the game choose taking a small rock when a small rock is in Rocky Beach"; return; } ! 1477, case 2
		if (R == R_1486) { print "Instead of taking a small rock when the rock selection is visible and Rocky Beach does not contain a small rock"; return; } ! 1478, case 2
		if (R == R_1487) { print "Should the game choose taking off a small rock"; return; } ! 1479, case 2
		if (R == R_1488) { print "Should the game choose taking off the rock selection"; return; } ! 1480, case 2
		if (R == R_1489) { print "Should the game choose doing something other than taking with a small rock held by the player"; return; } ! 1481, case 2
		if (R == R_1490) { print "Before taking the rock selection when Rock Limbo is not empty"; return; } ! 1482, case 2
		if (R == R_1491) { print "Instead of taking the rock selection"; return; } ! 1483, case 2
		if (R == R_1492) { print "Check skipping"; return; } ! 1484, case 2
		if (R == R_1493) { print "Should the game choose skipping a small rock"; return; } ! 1485, case 2
		if (R == R_1494) { print "Before skipping something when the player is in Rocky Beach and the player does not enclose a small rock"; return; } ! 1486, case 2
		if (R == R_1495) { print "Carry out skipping"; return; } ! 1487, case 2
		if (R == R_1496) { print "Instead of going east in Sandy Beach"; return; } ! 1488, case 2
		if (R == R_1497) { print "Instead of going south in Sandy Beach"; return; } ! 1489, case 2
		if (R == R_1498) { print "Instead of going southeast in Sandy Beach"; return; } ! 1490, case 2
		if (R == R_1499) { print "Instead of going west in Sandy Beach"; return; } ! 1491, case 2
		if (R == R_1500) { print "Instead of going north in Sandy Beach"; return; } ! 1492, case 2
		if (R == R_1501) { print "Instead of going northeast in Sandy Beach"; return; } ! 1493, case 2
		if (R == R_1502) { print "Instead of searching the spot"; return; } ! 1494, case 2
		if (R == R_1503) { print "Instead of taking sand"; return; } ! 1495, case 2
		if (R == R_1504) { print "Instead of going west in Sandy Beach"; return; } ! 1496, case 2
		if (R == R_1505) { print "Instead of searching sand"; return; } ! 1497, case 2
		if (R == R_1506) { print "Instead of going up in Freshwater Crossing"; return; } ! 1498, case 2
		if (R == R_1507) { print "Instead of taking the leaves"; return; } ! 1499, case 2
		if (R == R_1508) { print "Instead of climbing the birch trees"; return; } ! 1500, case 2
		if (R == R_1509) { print "Instead of taking the birch bark"; return; } ! 1501, case 2
		if (R == R_1510) { print "Instead of going nowhere from Freshwater Crossing"; return; } ! 1502, case 2
		if (R == R_1511) { print "Instead of going down in Freshwater Crossing"; return; } ! 1503, case 2
		if (R == R_1512) { print "Instead of going up in Freshwater Crossing"; return; } ! 1504, case 2
		if (R == R_1513) { print "Every turn during Second Pump"; return; } ! 1505, case 2
		if (R == R_1514) { print "Every turn during Third Pump"; return; } ! 1506, case 2
		if (R == R_1515) { print "Every turn during First Pump"; return; } ! 1507, case 2
		if (R == R_1516) { print "Check going a direction ( called the way ) from Freshwater Crossing when the secretary is in Grassy Area"; return; } ! 1508, case 2
		if (R == R_1517) { print "Instead of going up in Grassy Area"; return; } ! 1509, case 2
		if (R == R_1518) { print "Instead of going down in Grassy Area"; return; } ! 1510, case 2
		if (R == R_1520) { print "Every turn when the secretary's story has been happening for at least one turn"; return; } ! 1511, case 2
		if (R == R_1521) { print "Every turn when the player has been trapped for exactly one turn"; return; } ! 1512, case 2
		if (R == R_1522) { print "Instead of doing anything other than touching , smelling , or examining to the rope"; return; } ! 1513, case 2
		if (R == R_1523) { print "When the secretary's story begins"; return; } ! 1514, case 2
		if (R == R_1525) { print "After printing the name of the location when the player is trapped"; return; } ! 1515, case 2
		if (R == R_1526) { print "Every turn when the secretary's story is happening and the player is free and a random chance of 1 in 3 succeeds"; return; } ! 1516, case 2
		if (R == R_1527) { print "Instead of going a direction ( called the way ) from Grassy Area when the secretary's story is happening"; return; } ! 1517, case 2
		if (R == R_1528) { print "Instead of going nowhere from Grassy Area when the secretary's story is happening and the player is not trapped"; return; } ! 1518, case 2
		if (R == R_1529) { print "Instead of going in Grassy Area when the player is trapped"; return; } ! 1519, case 2
		if (R == R_1530) { print "Instead of going nowhere from Grassy Area when the secretary is off-stage"; return; } ! 1520, case 2
		if (R == R_1531) { print "Instead of going to Grassy Area when the player has been trapped"; return; } ! 1521, case 2
		if (R == R_1533) { print "Instead of climbing or entering the ark"; return; } ! 1522, case 2
		if (R == R_1534) { print "Instead of pushing or taking the ark"; return; } ! 1523, case 2
		if (R == R_1535) { print "Instead of touching the ark"; return; } ! 1524, case 2
		if (R == R_1536) { print "Instead of touching the anchor"; return; } ! 1525, case 2
		if (R == R_1537) { print "Should the game choose doing something with the anchor"; return; } ! 1526, case 2
		if (R == R_1538) { print "Instead of pushing or taking the anchor"; return; } ! 1527, case 2
		if (R == R_1539) { print "Instead of going nowhere from Grassy Area"; return; } ! 1528, case 2
		if (R == R_1540) { print "After looking in Other Side of the Pond while First Pump is happening and we have not examined the pondy crystal spire"; return; } ! 1529, case 2
		if (R == R_1541) { print "Instead of entering the stone steps"; return; } ! 1530, case 2
		if (R == R_1542) { print "Check going east in Other Side of the Pond"; return; } ! 1531, case 2
		if (R == R_1543) { print "Instead of the dog going east in Other Side of the Pond"; return; } ! 1532, case 2
		if (R == R_1544) { print "Every turn when the player is in Other Side of the Pond"; return; } ! 1533, case 2
		if (R == R_1545) { print "Before going west in Other Side of the Pond by the rowboat"; return; } ! 1534, case 2
		if (R == R_1546) { print "Every turn when the dog is roaming and the player is not in the Woods and a random chance of 1 in 3 succeeds"; return; } ! 1535, case 2
		if (R == R_1547) { print "Instead of the dog going when the dog is in the rowboat"; return; } ! 1536, case 2
		if (R == R_1548) { print "Instead of speech when the noun is the dog"; return; } ! 1537, case 2
		if (R == R_1549) { print "Instead of thing-barking"; return; } ! 1538, case 2
		if (R == R_1550) { print "Instead of giving something to the dog"; return; } ! 1539, case 2
		if (R == R_1551) { print "Carry out barking"; return; } ! 1540, case 2
		if (R == R_1552) { print "Report the dog going a direction ( called the way )"; return; } ! 1541, case 2
		if (R == R_1553) { print "Every turn when the dog is visible and the dog is not in the rowboat and a random chance of 1 in 2 succeeds and we are not doing something to the dog"; return; } ! 1542, case 2
		if (R == R_1555) { print "Every turn when the dog is visible and the dog is in the rowboat and a random chance of 1 in 2 succeeds and we are not doing something to the dog"; return; } ! 1543, case 2
		if (R == R_1556) { print "Every turn"; return; } ! 1544, case 2
		if (R == R_1557) { print "Every turn when the player is in the Woods and a random chance of 2 in 3 succeeds"; return; } ! 1545, case 2
		if (R == R_1558) { print "Instead of taking the mat of leaves"; return; } ! 1546, case 2
		if (R == R_1559) { print "Instead of going up in the Woods"; return; } ! 1547, case 2
		if (R == R_1560) { print "Instead of going down in the Woods"; return; } ! 1548, case 2
		if (R == R_1561) { print "Instead of climbing the colorful trees"; return; } ! 1549, case 2
		if (R == R_1562) { print "Instead of going nowhere from Other Side Of the Pond"; return; } ! 1550, case 2
		if (R == R_1563) { print "Instead of going up in Other Side of the Pond"; return; } ! 1551, case 2
		if (R == R_1564) { print "Instead of going down in Other Side of the Pond"; return; } ! 1552, case 2
		if (R == R_1565) { print "Every turn when the player is in The Woods and the dog is roaming and the dog is not in the Woods"; return; } ! 1553, case 2
		if (R == R_1566) { print "Every turn"; return; } ! 1554, case 2
		if (R == R_1567) { print "Instead of the dog going to Atop the Tank"; return; } ! 1555, case 2
		if (R == R_1568) { print "Instead of going in from the Woods"; return; } ! 1556, case 2
		if (R == R_1569) { print "Instead of going up in the Woods"; return; } ! 1557, case 2
		if (R == R_1570) { print "Instead of going nowhere from the Woods"; return; } ! 1558, case 2
		if (R == R_1571) { print "Instead of doing anything other than examining to the metal door when Inside the Cinderblock Hut is keyed"; return; } ! 1559, case 2
		if (R == R_1572) { print "Instead of doing anything other than examining to the metal door when Inside the Cinderblock Hut is not keyed"; return; } ! 1560, case 2
		if (R == R_1573) { print "Instead of opening the hut"; return; } ! 1561, case 2
		if (R == R_1574) { print "Instead of touching the moss"; return; } ! 1562, case 2
		if (R == R_1575) { print "Instead of opening the plate when the plate is locked"; return; } ! 1563, case 2
		if (R == R_1576) { print "Instead of examining the deep crack"; return; } ! 1564, case 2
		if (R == R_1577) { print "Instead of taking the old key when the old key is in the deep crack"; return; } ! 1565, case 2
		if (R == R_1578) { print "Should the game choose taking the old key with the magnet"; return; } ! 1566, case 2
		if (R == R_1579) { print "Instead of inserting something into the deep crack"; return; } ! 1567, case 2
		if (R == R_1580) { print "Instead of taking a liquid source with a fluid container"; return; } ! 1568, case 2
		if (R == R_1581) { print "Instead of taking the water fountain with a fluid container"; return; } ! 1569, case 2
		if (R == R_1582) { print "Instead of putting the magnet on the deep crack when the old key is in the deep crack"; return; } ! 1570, case 2
		if (R == R_1583) { print "Instead of putting the magnet on the old key when the old key is in the deep crack"; return; } ! 1571, case 2
		if (R == R_1584) { print "Instead of magnet-waving"; return; } ! 1572, case 2
		if (R == R_1585) { print "Instead of taking something with something"; return; } ! 1573, case 2
		if (R == R_1586) { print "Instead of taking the sap with something"; return; } ! 1574, case 2
		if (R == R_1587) { print "Instead of taking the brass key with something when the keychain is contained by the tall cylinder"; return; } ! 1575, case 2
		if (R == R_1588) { print "Instead of taking something contained by the tall cylinder with something"; return; } ! 1576, case 2
		if (R == R_1589) { print "Instead of taking the sap with the beer bottle"; return; } ! 1577, case 2
		if (R == R_1590) { print "Instead of taking the sap with a pinecone"; return; } ! 1578, case 2
		if (R == R_1591) { print "Instead of taking the sap with a flat paper"; return; } ! 1579, case 2
		if (R == R_1592) { print "Instead of putting the sap on something"; return; } ! 1580, case 2
		if (R == R_1593) { print "Instead of inserting the sap into something"; return; } ! 1581, case 2
		if (R == R_1594) { print "Instead of taking the old key with something when the old key is in the deep crack"; return; } ! 1582, case 2
		if (R == R_1595) { print "Instead of taking the old key with the large magnet when the old key is in the deep crack"; return; } ! 1583, case 2
		if (R == R_1596) { print "Instead of inserting the magnet into the deep crack"; return; } ! 1584, case 2
		if (R == R_1597) { print "Instead of searching the floor when the location is Inside The Cinderblock Hut"; return; } ! 1585, case 2
		if (R == R_1598) { print "Instead of turning the large metal wheel"; return; } ! 1586, case 2
		if (R == R_1599) { print "Instead of going inside in Small Clearing when Inside the Cinderblock Hut is keyed"; return; } ! 1587, case 2
		if (R == R_1600) { print "Instead of the dog going inside from Small Clearing when Inside the Cinderblock Hut is keyed"; return; } ! 1588, case 2
		if (R == R_1601) { print "Instead of entering the hut"; return; } ! 1589, case 2
		if (R == R_1602) { print "Check typing"; return; } ! 1590, case 2
		if (R == R_1603) { print "Carry out typing"; return; } ! 1591, case 2
		if (R == R_1604) { print "Rule for supplying a missing second noun while typing"; return; } ! 1592, case 2
		if (R == R_1605) { print "Instead of going nowhere from Small Clearing"; return; } ! 1593, case 2
		if (R == R_1606) { print "After switching on the underground pump"; return; } ! 1594, case 2
		if (R == R_1607) { print "Every turn"; return; } ! 1595, case 2
		if (R == R_1608) { print "Every turn when Second Pump is happening and the player is in Outside Waterworks and the puddle is off-stage"; return; } ! 1596, case 2
		if (R == R_1609) { print "Every turn when Inside Waterworks has been flooded for exactly one turn"; return; } ! 1597, case 2
		if (R == R_1610) { print "Instead of going to Pump Room when Pump Room is flooded"; return; } ! 1598, case 2
		if (R == R_1611) { print "Instead of going to Inside Waterworks when Inside Waterworks is flooded"; return; } ! 1599, case 2
		if (R == R_1612) { print "Instead of going to Sandy Beach when Sandy Beach is flooded"; return; } ! 1600, case 2
		if (R == R_1613) { print "Every turn when the player is in Pump Room"; return; } ! 1601, case 2
		if (R == R_1614) { print "Every turn when the player is in Inside Waterworks"; return; } ! 1602, case 2
		if (R == R_1615) { print "Every turn"; return; } ! 1603, case 2
		if (R == R_1616) { print "Instead of switching off the underground pump"; return; } ! 1604, case 2
		if (R == R_1617) { print "Instead of speech when the noun is the family"; return; } ! 1605, case 2
		if (R == R_1618) { print "Instead of speech when the noun is the daughter"; return; } ! 1606, case 2
		if (R == R_1619) { print "Instead of speech when the noun is the father"; return; } ! 1607, case 2
		if (R == R_1620) { print "Instead of touching or smelling or tasting or attacking or taking the father"; return; } ! 1608, case 2
		if (R == R_1621) { print "Instead of touching or smelling or tasting or attacking or taking the daughter"; return; } ! 1609, case 2
		if (R == R_1622) { print "Instead of touching or smelling or tasting or attacking or taking the family"; return; } ! 1610, case 2
		if (R == R_1623) { print "Instead of touching or smelling or tasting or attacking or taking the game"; return; } ! 1611, case 2
		if (R == R_1624) { print "Instead of touching or smelling or tasting or attacking or taking the house"; return; } ! 1612, case 2
		if (R == R_1625) { print "Instead of entering the large tank"; return; } ! 1613, case 2
		if (R == R_1626) { print "Instead of climbing the large tank"; return; } ! 1614, case 2
		if (R == R_1627) { print "Instead of jumping when the player is in Large Clearing"; return; } ! 1615, case 2
		if (R == R_1628) { print "Instead of climbing the rungs"; return; } ! 1616, case 2
		if (R == R_1629) { print "Instead of going west in Large Clearing"; return; } ! 1617, case 2
		if (R == R_1630) { print "Instead of going nowhere from Large Clearing"; return; } ! 1618, case 2
		if (R == R_1631) { print "Instead of going down in Large Clearing"; return; } ! 1619, case 2
		if (R == R_1632) { print "Instead of going down in Small Clearing"; return; } ! 1620, case 2
		if (R == R_1633) { print "Instead of going up in Small Clearing"; return; } ! 1621, case 2
		if (R == R_1634) { print "Instead of jumping or dancing in Atop the Tank"; return; } ! 1622, case 2
		if (R == R_1635) { print "Instead of doing anything other than examining to the pond when the location is Atop the Tank"; return; } ! 1623, case 2
		if (R == R_1636) { print "Instead of doing anything other than examining to the weird lumpy island when the location is Atop the Tank"; return; } ! 1624, case 2
		if (R == R_1637) { print "Instead of doing anything other than examining to the distant house when the location is Atop the Tank"; return; } ! 1625, case 2
		if (R == R_1638) { print "Should the game choose doing something to the medium-sized wheel"; return; } ! 1626, case 2
		if (R == R_1639) { print "Should the game choose turning the medium-sized wheel"; return; } ! 1627, case 2
		if (R == R_1640) { print "Instead of turning the brass metal pipe"; return; } ! 1628, case 2
		if (R == R_1641) { print "Instead of turning the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and nothing is in the pipe holes"; return; } ! 1629, case 2
		if (R == R_1642) { print "Instead of turning the medium-sized wheel when Third Pump is happening"; return; } ! 1630, case 2
		if (R == R_1643) { print "Instead of turning the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and the flagpole is in the pipe holes"; return; } ! 1631, case 2
		if (R == R_1644) { print "Instead of pushing the flagpole"; return; } ! 1632, case 2
		if (R == R_1645) { print "Instead of pushing the medium-sized wheel"; return; } ! 1633, case 2
		if (R == R_1646) { print "Instead of turning the flagpole when the flagpole is in the pipe holes and the medium-sized wheel is on the brass metal pipe"; return; } ! 1634, case 2
		if (R == R_1647) { print "Instead of turning the flagpole when the flagpole is in the holes and the medium-sized wheel is not on the brass metal pipe"; return; } ! 1635, case 2
		if (R == R_1648) { print "Instead of putting the medium-sized wheel on the brass metal pipe when the flagpole is in the holes"; return; } ! 1636, case 2
		if (R == R_1649) { print "Instead of taking the medium-sized wheel when the medium-sized wheel is on the brass metal pipe and the flagpole is in the holes"; return; } ! 1637, case 2
		if (R == R_1650) { print "Instead of inserting something into the pipe holes when the pipe holes contain something"; return; } ! 1638, case 2
		if (R == R_1651) { print "Should the game choose doing something to the pipe holes"; return; } ! 1639, case 2
		if (R == R_1652) { print "Instead of inserting something into the brass metal pipe"; return; } ! 1640, case 2
		if (R == R_1653) { print "Instead of inserting something that is not the flagpole into the pipe holes"; return; } ! 1641, case 2
		if (R == R_1654) { print "Instead of inserting the flagpole into the medium-sized wheel when the medium-sized wheel is on the brass metal pipe"; return; } ! 1642, case 2
		if (R == R_1655) { print "Instead of inserting something into the wheel holes when the medium-sized wheel is on the brass metal pipe"; return; } ! 1643, case 2
		if (R == R_1656) { print "Instead of inserting the medium-sized wheel into something that is not the flagpole"; return; } ! 1644, case 2
		if (R == R_1657) { print "Report inserting the flagpole into the brass metal pipe"; return; } ! 1645, case 2
		if (R == R_1658) { print "Instead of putting anything that is not the medium-sized wheel on the brass metal pipe"; return; } ! 1646, case 2
		if (R == R_1659) { print "Instead of putting the medium-sized wheel on the pipe holes"; return; } ! 1647, case 2
		if (R == R_1660) { print "Should the game choose putting the medium-sized wheel on the wheel holes"; return; } ! 1648, case 2
		if (R == R_1661) { print "Instead of going up in Large Clearing"; return; } ! 1649, case 2
		if (R == R_1662) { print "Before going down from Atop the Tank"; return; } ! 1650, case 2
		if (R == R_1663) { print "Instead of boat-examining"; return; } ! 1651, case 2
		if (R == R_1664) { print "Instead of attacking the emergency supplies box"; return; } ! 1652, case 2
		if (R == R_1665) { print "Instead of taking the emergency supplies box"; return; } ! 1653, case 2
		if (R == R_1666) { print "After wearing the diving mask for the first time"; return; } ! 1654, case 2
		if (R == R_1667) { print "Instead of smelling when the player is wearing the diving mask"; return; } ! 1655, case 2
		if (R == R_1668) { print "Instead of drinking when the player is wearing the diving mask"; return; } ! 1656, case 2
		if (R == R_1669) { print "Instead of going nowhere from Weedy Island when the player is not in the rowboat"; return; } ! 1657, case 2
		if (R == R_1670) { print "Instead of going south in Weedy Island when the player is not in the rowboat"; return; } ! 1658, case 2
		if (R == R_1671) { print "Instead of going up in Weedy Island"; return; } ! 1659, case 2
		if (R == R_1672) { print "Instead of shouting or singing when the player is wearing the diving mask"; return; } ! 1660, case 2
		if (R == R_1673) { print "Instead of speech when the player is wearing the diving mask"; return; } ! 1661, case 2
		if (R == R_1674) { print "Instead of going down in Weedy Island"; return; } ! 1662, case 2
		if (R == R_1675) { print "Instead of going down in Underwater"; return; } ! 1663, case 2
		if (R == R_1676) { print "Instead of going nowhere in Underwater"; return; } ! 1664, case 2
		if (R == R_1677) { print "Instead of facing down when the player is in Underwater"; return; } ! 1665, case 2
		if (R == R_1678) { print "Instead of looking up when the player is in Underwaterland"; return; } ! 1666, case 2
		if (R == R_1679) { print "Every turn when the player is in Underwater and the player has been in Underwater less than eight turns and Vivian is off-stage and a random chance of one in two succeeds"; return; } ! 1667, case 2
		if (R == R_1680) { print "Every turn when the player is in Underwater and the player has been in Underwater at least eight turns and Vivian is off-stage and a random chance of one in two succeeds"; return; } ! 1668, case 2
		if (R == R_1681) { print "Instead of eating or drinking when the player is wearing the diving mask"; return; } ! 1669, case 2
		if (R == R_1682) { print "Instead of shaking the wind chimes when the player is in Underwater and Vivian is off-stage"; return; } ! 1670, case 2
		if (R == R_1683) { print "Instead of shaking the wind chimes when the player is in Underwaterland"; return; } ! 1671, case 2
		if (R == R_1684) { print "Instead of dropping anything when the player is in Underwater"; return; } ! 1672, case 2
		if (R == R_1685) { print "Instead of shaking the wind chimes when the player is in the Crystal City"; return; } ! 1673, case 2
		if (R == R_1686) { print "Every turn while the player is in Underwater and Vivian is in Underwater"; return; } ! 1674, case 2
		if (R == R_1687) { print "Instead of attacking Vivian"; return; } ! 1675, case 2
		if (R == R_1688) { print "Instead of attacking Cordelia"; return; } ! 1676, case 2
		if (R == R_1689) { print "Instead of attacking Douglas"; return; } ! 1677, case 2
		if (R == R_1690) { print "Instead of swimming when the player is in Underwaterland"; return; } ! 1678, case 2
		if (R == R_1691) { print "Before going up from Underwater when Vivian is in Underwater"; return; } ! 1679, case 2
		if (R == R_1692) { print "Instead of going up from Underwater"; return; } ! 1680, case 2
		if (R == R_1693) { print "Instead of waving the wind chimes"; return; } ! 1681, case 2
		if (R == R_1694) { print "Instead of taking off the diving mask when the player is in Underwaterland"; return; } ! 1682, case 2
		if (R == R_1695) { print "Instead of going up in the Crystal City"; return; } ! 1683, case 2
		if (R == R_1696) { print "Instead of going nowhere in the Crystal City"; return; } ! 1684, case 2
		if (R == R_1697) { print "Instead of doing anything other than examining to the giant metal wheel"; return; } ! 1685, case 2
		if (R == R_1698) { print "Instead of doing anything other than examining to the large crystal gear"; return; } ! 1686, case 2
		if (R == R_1699) { print "Instead of touching the underwater pump"; return; } ! 1687, case 2
		if (R == R_1700) { print "Instead of doing anything to something contained by the cavity when the cavity is inaccessible"; return; } ! 1688, case 2
		if (R == R_1701) { print "After inserting something into the cavity"; return; } ! 1689, case 2
		if (R == R_1702) { print "cavity hides"; return; } ! 1690, case 1
		if (R == R_1703) { print "cavity continues"; return; } ! 1691, case 1
		if (R == R_1704) { print "cavity continues yet again"; return; } ! 1692, case 1
		if (R == R_1705) { print "crystal gear approaches"; return; } ! 1693, case 1
		if (R == R_1706) { print "Instead of doing anything to the cavity while the cavity is inaccessible"; return; } ! 1694, case 2
		if (R == R_1707) { print "Instead of attacking something that is part of the underwater pump"; return; } ! 1695, case 2
		if (R == R_1708) { print "Every turn when Endgame is happening"; return; } ! 1696, case 2
		if (R == R_1709) { print "Instead of inserting something into the giant metal wheel"; return; } ! 1697, case 2
		if (R == R_1710) { print "gears catch"; return; } ! 1698, case 1
		if (R == R_1711) { print "Every turn while Endgame is happening and we are not speech"; return; } ! 1699, case 2
		if (R == R_1712) { print "Instead of attacking the underwater pump"; return; } ! 1700, case 2
		if (R == R_1713) { print "When switch-action begins"; return; } ! 1701, case 2
		if (R == R_1714) { print "When switch-action ends"; return; } ! 1702, case 2
		if (R == R_1715) { print "Every turn when the player is in the Crystal City and switch-action is happening"; return; } ! 1703, case 2
		if (R == R_1716) { print "Every turn when the crystal gear has been spinning for at least one turn and switch-action is happening"; return; } ! 1704, case 2
		if (R == R_1717) { print "Instead of switching on the underwater pump"; return; } ! 1705, case 2
		if (R == R_1718) { print "Instead of switching off the underwater pump"; return; } ! 1706, case 2
		if (R == R_1719) { print "Instead of speech when Endgame is happening and the player is wearing the diving mask"; return; } ! 1707, case 2
		if (R == R_1720) { print "Check train-moving"; return; } ! 1708, case 2
		if (R == R_1721) { print "Carry out train-moving"; return; } ! 1709, case 2
		if (R == R_1722) { print "Check train-examining"; return; } ! 1710, case 2
		if (R == R_1723) { print "Carry out train-examining"; return; } ! 1711, case 2
		if (R == R_1724) { print "After deciding the scope of the player when the location of the player is the station of the steam train"; return; } ! 1712, case 2
		if (R == R_1725) { print "Instead of doing anything with something contained by the steam train when the location of the player is freshwater crossing or the location of the player is other side of the pond"; return; } ! 1713, case 2
		if (R == R_1726) { print "Instead of examining the steam train"; return; } ! 1714, case 2
		if (R == R_1727) { print "Instead of entering the steam train"; return; } ! 1715, case 2
		if (R == R_1728) { print "Instead of unlocking keylessly the structure"; return; } ! 1716, case 2
		if (R == R_1729) { print "Instead of unlocking the structure with something"; return; } ! 1717, case 2
		if (R == R_1730) { print "Instead of opening the structure"; return; } ! 1718, case 2
		if (R == R_1731) { print "Instead of lock-picking"; return; } ! 1719, case 2
		if (R == R_1732) { print "Instead of double-lock-picking"; return; } ! 1720, case 2
		if (R == R_1733) { print "Instead of facing outside when the location is the steam train"; return; } ! 1721, case 2
		if (R == R_1734) { print "Report entering the seat for the first time"; return; } ! 1722, case 2
		if (R == R_1735) { print "Report entering the seat"; return; } ! 1723, case 2
		if (R == R_1736) { print "Before boarding when the ticket is contained by the right pocket or the ticket is contained by the left pocket"; return; } ! 1724, case 2
		if (R == R_1737) { print "Instead of boarding when the ticket is not held and the conductor is unsatisfied"; return; } ! 1725, case 2
		if (R == R_1738) { print "Instead of boarding when the secretary is in Grassy Area"; return; } ! 1726, case 2
		if (R == R_1739) { print "Instead of boarding when the steam train is flooded"; return; } ! 1727, case 2
		if (R == R_1740) { print "Instead of going to Freshwater Crossing when the Steam Train is flooded"; return; } ! 1728, case 2
		if (R == R_1741) { print "After boarding"; return; } ! 1729, case 2
		if (R == R_1742) { print "Instead of doing anything other than examining with the conductor when the conductor is distracted"; return; } ! 1730, case 2
		if (R == R_1743) { print "Instead of speech when the noun is the Conductor"; return; } ! 1731, case 2
		if (R == R_1744) { print "conductor says the second train monologue"; return; } ! 1732, case 1
		if (R == R_1745) { print "conductor says the third train monologue"; return; } ! 1733, case 1
		if (R == R_1746) { print "conductor shuts up"; return; } ! 1734, case 1
		if (R == R_1747) { print "Instead of giving something to the conductor"; return; } ! 1735, case 2
		if (R == R_1748) { print "Instead of giving the train schedule to the conductor"; return; } ! 1736, case 2
		if (R == R_1749) { print "Instead of giving the ticket to the conductor"; return; } ! 1737, case 2
		if (R == R_1750) { print "Instead of giving something unimportant to the conductor"; return; } ! 1738, case 2
		if (R == R_1751) { print "Instead of doing anything other than examining with the access panel when the conductor is undistracted and the conductor is visible and the conductor's story is not happening"; return; } ! 1739, case 2
		if (R == R_1752) { print "Report opening the access panel"; return; } ! 1740, case 2
		if (R == R_1753) { print "Instead of attacking the conductor"; return; } ! 1741, case 2
		if (R == R_1754) { print "Instead of doing anything other than examining with something contained by the access panel when the conductor is visible and the conductor's story is not happening and the conductor is undistracted"; return; } ! 1742, case 2
		if (R == R_1755) { print "Instead of sleeping"; return; } ! 1743, case 2
		if (R == R_8) { print "start in the correct scenes rule"; return; } ! 1744, case 1
		if (R == POSITION_PLAYER_IN_MODEL_R) { print "position player in model world rule"; return; } ! 1745, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 1746, case 1
		if (R == SEED_RANDOM_NUMBER_GENERATOR_R) { print "seed random number generator rule"; return; } ! 1747, case 1
		if (R == VIRTUAL_MACHINE_STARTUP_R) { print "virtual machine startup rule"; return; } ! 1748, case 1
		if (R == INITIALISE_MEMORY_R) { print "initialise memory rule"; return; } ! 1749, case 1
		if (R == R_9) { print "when play begins stage rule"; return; } ! 1750, case 1
		if (R == R_10) { print "fix baseline scoring rule"; return; } ! 1751, case 1
		if (R == R_11) { print "display banner rule"; return; } ! 1752, case 1
		if (R == R_12) { print "initial room description rule"; return; } ! 1753, case 1
		if (R == GENERATE_ACTION_R) { print "generate action rule"; return; } ! 1754, case 1
		if (R == PARSE_COMMAND_R) { print "parse command rule"; return; } ! 1755, case 1
		if (R == TIMED_EVENTS_R) { print "timed events rule"; return; } ! 1756, case 1
		if (R == ADVANCE_TIME_R) { print "advance time rule"; return; } ! 1757, case 1
		if (R == UPDATE_CHRONOLOGICAL_RECORDS_R) { print "update chronological records rule"; return; } ! 1758, case 1
		if (R == ADJUST_LIGHT_R) { print "adjust light rule"; return; } ! 1759, case 1
		if (R == NOTE_OBJECT_ACQUISITIONS_R) { print "note object acquisitions rule"; return; } ! 1760, case 1
		if (R == R_16) { print "notify score changes rule"; return; } ! 1761, case 1
		if (R == R_17) { print "when play ends stage rule"; return; } ! 1762, case 1
		if (R == RESURRECT_PLAYER_IF_ASKED_R) { print "resurrect player if asked rule"; return; } ! 1763, case 1
		if (R == R_18) { print "print player's obituary rule"; return; } ! 1764, case 1
		if (R == ASK_FINAL_QUESTION_R) { print "ask the final question rule"; return; } ! 1765, case 1
		if (R == DetectSceneChange) { print "scene change machinery rule"; return; } ! 1766, case 1
		if (R == R_21) { print "before stage rule"; return; } ! 1767, case 1
		if (R == R_19) { print "set pronouns from items from multiple object lists rule"; return; } ! 1768, case 1
		if (R == R_20) { print "announce items from multiple object lists rule"; return; } ! 1769, case 1
		if (R == BASIC_VISIBILITY_R) { print "basic visibility rule"; return; } ! 1770, case 1
		if (R == BASIC_ACCESSIBILITY_R) { print "basic accessibility rule"; return; } ! 1771, case 1
		if (R == CARRYING_REQUIREMENTS_R) { print "carrying requirements rule"; return; } ! 1772, case 1
		if (R == R_22) { print "instead stage rule"; return; } ! 1773, case 1
		if (R == REQUESTED_ACTIONS_REQUIRE_R) { print "requested actions require persuasion rule"; return; } ! 1774, case 1
		if (R == CARRY_OUT_REQUESTED_ACTIONS_R) { print "carry out requested actions rule"; return; } ! 1775, case 1
		if (R == DESCEND_TO_SPECIFIC_ACTION_R) { print "descend to specific action-processing rule"; return; } ! 1776, case 1
		if (R == R_23) { print "end action-processing in success rule"; return; } ! 1777, case 1
		if (R == WORK_OUT_DETAILS_OF_SPECIFIC_R) { print "work out details of specific action rule"; return; } ! 1778, case 1
		if (R == ACCESS_THROUGH_BARRIERS_R) { print "access through barriers rule"; return; } ! 1779, case 1
		if (R == CANT_REACH_INSIDE_ROOMS_R) { print "can't reach inside rooms rule"; return; } ! 1780, case 1
		if (R == CANT_REACH_INSIDE_CLOSED_R) { print "can't reach inside closed containers rule"; return; } ! 1781, case 1
		if (R == CANT_REACH_OUTSIDE_CLOSED_R) { print "can't reach outside closed containers rule"; return; } ! 1782, case 1
		if (R == R_35) { print "can't act in the dark rule"; return; } ! 1783, case 1
		if (R == STANDARD_NAME_PRINTING_R) { print "standard name printing rule"; return; } ! 1784, case 1
		if (R == R_59) { print "standard printing the plural name rule"; return; } ! 1785, case 1
		if (R == R_60) { print "standard printing a number of something rule"; return; } ! 1786, case 1
		if (R == STANDARD_CONTENTS_LISTING_R) { print "standard contents listing rule"; return; } ! 1787, case 1
		if (R == R_61) { print "look around once light available rule"; return; } ! 1788, case 1
		if (R == ENABLE_GLULX_ACCEL_R) { print "enable Glulx acceleration rule"; return; } ! 1789, case 1
		if (R == PRINT_OBITUARY_HEADLINE_R) { print "print obituary headline rule"; return; } ! 1790, case 1
		if (R == PRINT_FINAL_SCORE_R) { print "print final score rule"; return; } ! 1791, case 1
		if (R == DISPLAY_FINAL_STATUS_LINE_R) { print "display final status line rule"; return; } ! 1792, case 1
		if (R == R_69) { print "print the final question rule"; return; } ! 1793, case 1
		if (R == R_68) { print "print the final prompt rule"; return; } ! 1794, case 1
		if (R == READ_FINAL_ANSWER_R) { print "read the final answer rule"; return; } ! 1795, case 1
		if (R == R_70) { print "standard respond to final question rule"; return; } ! 1796, case 1
		if (R == R_91) { print "can't take component parts rule"; return; } ! 1797, case 1
		if (R == R_148) { print "find what to enter rule"; return; } ! 1798, case 1
		if (R == QUIT_THE_GAME_R) { print "quit the game rule"; return; } ! 1799, case 1
		if (R == SAVE_THE_GAME_R) { print "save the game rule"; return; } ! 1800, case 1
		if (R == RESTORE_THE_GAME_R) { print "restore the game rule"; return; } ! 1801, case 1
		if (R == RESTART_THE_GAME_R) { print "restart the game rule"; return; } ! 1802, case 1
		if (R == VERIFY_THE_STORY_FILE_R) { print "verify the story file rule"; return; } ! 1803, case 1
		if (R == SWITCH_TRANSCRIPT_ON_R) { print "switch the story transcript on rule"; return; } ! 1804, case 1
		if (R == SWITCH_TRANSCRIPT_OFF_R) { print "switch the story transcript off rule"; return; } ! 1805, case 1
		if (R == ANNOUNCE_STORY_FILE_VERSION_R) { print "announce the story file version rule"; return; } ! 1806, case 1
		if (R == ANNOUNCE_SCORE_R) { print "announce the score rule"; return; } ! 1807, case 1
		if (R == PREFER_ABBREVIATED_R) { print "prefer abbreviated room descriptions rule"; return; } ! 1808, case 1
		if (R == REP_PREFER_ABBREVIATED_R) { print "standard report preferring abbreviated room descriptions rule"; return; } ! 1809, case 1
		if (R == PREFER_UNABBREVIATED_R) { print "prefer unabbreviated room descriptions rule"; return; } ! 1810, case 1
		if (R == REP_PREFER_UNABBREVIATED_R) { print "standard report preferring unabbreviated room descriptions rule"; return; } ! 1811, case 1
		if (R == PREFER_SOMETIMES_ABBREVIATED_R) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 1812, case 1
		if (R == REP_PREFER_SOMETIMES_ABBR_R) { print "standard report preferring sometimes abbreviated room descriptions rule"; return; } ! 1813, case 1
		if (R == SWITCH_SCORE_NOTIFY_ON_R) { print "switch score notification on rule"; return; } ! 1814, case 1
		if (R == REP_SWITCH_NOTIFY_ON_R) { print "standard report switching score notification on rule"; return; } ! 1815, case 1
		if (R == SWITCH_SCORE_NOTIFY_OFF_R) { print "switch score notification off rule"; return; } ! 1816, case 1
		if (R == REP_SWITCH_NOTIFY_OFF_R) { print "standard report switching score notification off rule"; return; } ! 1817, case 1
		if (R == ANNOUNCE_PRONOUN_MEANINGS_R) { print "announce the pronoun meanings rule"; return; } ! 1818, case 1
		if (R == R_742) { print "Small Kindnesses exit leaves when there's only one way to go rule"; return; } ! 1819, case 1
		if (R == R_745) { print "new can't get off things rule"; return; } ! 1820, case 1
		if (R == R_787) { print "considerate player's holdall rule"; return; } ! 1821, case 1
		if (R == R_824) { print "right second rule"; return; } ! 1822, case 1
		if (R == R_824) { print "right second rule"; return; } ! 1823, case 1
		if (R == R_842) { print "can't put onto something being carried except keychains rule"; return; } ! 1824, case 1
		if (R == R_843) { print "keychain-aware carrying requirements rule"; return; } ! 1825, case 1
		if (R == R_1004) { print "update ambiguous pronouns for actions rule"; return; } ! 1826, case 1
		if (R == R_1165) { print "complete scoring rule"; return; } ! 1827, case 1

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<NUMBER_RULEBOOKS_CREATED)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];

[ DebugRulebooks subs parameter i;
	spaces(2*process_rulebook_count);
	print "[", (RulePrintingRule) subs;
	if (parameter) print " / on O", parameter;
	print "]^";
];

[ DB_Rule R N blocked;
	if (R==0) return;
	print "[Rule ~", (RulePrintingRule) R, "~ ";
	#ifdef NUMBERED_RULES; print "(", N, ") "; #endif;
	if (blocked == false) "applies.]";
	"does not apply.]";
];

Global I7S_Tab; ! The array to be sorted, which can have almost any format
Global I7S_Col; ! The "column number" in the array, if any
Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)
Global I7S_Swap; ! The current routine for swapping two fields
Global I7S_Comp; ! The current routine for comparing two fields

#ifdef MEASURE_SORT_PERFORMANCE;
Global I7S_CCOUNT; Global I7S_CCOUNT2; Global I7S_XCOUNT; ! For testing only
#endif;

[ SetSortDomain swapf compf;
	I7S_Swap = swapf;
	I7S_Comp = compf;
];

[ SortArray tab col dir size test_flag algorithm;
	I7S_Tab = tab;
	I7S_Col = col;
	I7S_Dir = dir;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT = 0;
	I7S_CCOUNT2 = 0;
	I7S_XCOUNT = 0;
	#endif;
	SortRange(0, size, algorithm);
	#ifdef MEASURE_SORT_PERFORMANCE;
	if (test_flag)
		print "Sorted array of size ", size, " with ", I7S_CCOUNT2, "*10000 + ", I7S_CCOUNT,
			" comparisons and ", I7S_XCOUNT, " exchanges^";
	#endif;
];

[ SortRange x y algorithm;
	if (y - x < 2) return;
	if (algorithm) {
		(algorithm)(x, y);
	} else {
		InPlaceMergeSortAlgorithm(x, y);
	}
];

[ CompareFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_CCOUNT++;
	if (I7S_CCOUNT == 10000) { I7S_CCOUNT = 0; I7S_CCOUNT2++; }
	#endif;
	return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);
];

[ ExchangeFields x y;
	#ifdef MEASURE_SORT_PERFORMANCE;
	I7S_XCOUNT++;
	if (I7S_XCOUNT < 0) { print "XO^"; I7S_XCOUNT = 0; }
	#endif;
	return I7S_Swap(I7S_Tab, x+1, y+1);
];

[ OldSortAlgorithm x y
	f i j;
	if (y - x < 2) return;
	f = true;
	while (f) {
		f = false;
		for (i=x:i<y:i++)
		    for (j=i+1:j<y:j++)
				if (CompareFields(i, j) > 0) {
					ExchangeFields(i, j); f = true; break;
				}
	}
];

[ InsertionSortAlgorithm from to
	i j;
	if (to > from+1) { 
		for (i = from+1: i < to: i++) { 
			for (j = i: j > from: j--) { 
				if (CompareFields(j, j-1) < 0) 
					ExchangeFields(j, j-1);
				else break;
			}
		}
	}
];

[ InPlaceMergeSortAlgorithm from to
	middle;
	if (to - from < 12) {
		if (to - from < 2) return;
		InsertionSortAlgorithm(from, to);
		return;
	}
	middle = (from + to)/2; 
	InPlaceMergeSortAlgorithm(from, middle); 
	InPlaceMergeSortAlgorithm(middle, to); 
	IPMS_Merge(from, middle, to, middle-from, to - middle); 
];

[ IPMS_Lower from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(mid, val) < 0) {
			from = mid + 1;
			len = len - half -1; 
		} else len = half;
	}
	return from;
];

[ IPMS_Upper from to val
	len half mid;
	len = to - from;
	while (len > 0) { 
		half = len/2; 
		mid = from + half;
		if (CompareFields(val, mid) < 0)
			len = half;
		else {
			from = mid + 1;
			len = len - half -1; 
		}
	}
	return from;
];

[ IPMS_Reverse from to;
	while (from < to) {
		ExchangeFields(from++, to--);
	}
];

[ IPMS_Rotate from mid to
	n val shift p1 p2;
	if ((from==mid) || (mid==to)) return; 
	IPMS_Reverse(from, mid-1); 
	IPMS_Reverse(mid, to-1); 
	IPMS_Reverse(from, to-1);
];

[ IPMS_Merge from pivot to len1 len2
	first_cut second_cut len11 len22 new_mid;
	if ((len1 == 0) || (len2 == 0)) return; 
	if (len1+len2 == 2) { 
		if (CompareFields(pivot, from) < 0) 
		ExchangeFields(pivot, from); 
		return; 
	}
	if (len1 > len2) { 
		len11 = len1/2; 
		first_cut = from + len11; 
		second_cut = IPMS_Lower(pivot, to, first_cut); 
		len22 = second_cut - pivot; 
	} else { 
		len22 = len2/2; 
		second_cut = pivot + len22; 
		first_cut = IPMS_Upper(from, pivot, second_cut); 
		len11 = first_cut - from; 
	} 
	IPMS_Rotate(first_cut, pivot, second_cut); 
	new_mid = first_cut + len22; 
	IPMS_Merge(from, first_cut, new_mid, len11, len22); 
	IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22); 
];

Constant TB_COLUMN_SIGNED      $4000;
Constant TB_COLUMN_TOPIC       $2000;
Constant TB_COLUMN_DONTSORTME  $1000;
Constant TB_COLUMN_NOBLANKBITS $0800;
Constant TB_COLUMN_CANEXCHANGE $0400;
Constant TB_COLUMN_ALLOCATED   $0200;
Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags

Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)

[ TableFindCol tab col f i no_cols n;
	no_cols = tab-->0;
	for (i=1: i<=no_cols: i++)
		if (col == ((tab-->i)-->1) & TB_COLUMN_NUMBER) return i;
	if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }
	return 0;
];

[ TableRows tab first_col;
	first_col = tab-->1; if (first_col == 0) return 0;
	return (first_col-->0) - COL_HSIZE;
];

Constant TABLE_NOVALUE = IMPROBABLE_VALUE;

Array CheckTableEntryIsBlank_LU
	->	$$00000001
		$$00000010
		$$00000100
		$$00001000
		$$00010000
		$$00100000
		$$01000000
		$$10000000;
Array CheckTableEntryIsNonBlank_LU
	->	$$11111110
		$$11111101
		$$11111011
		$$11110111
		$$11101111
		$$11011111
		$$10111111
		$$01111111;

[ CheckTableEntryIsBlank tab col row i at;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	if ((tab-->col)-->(row+COL_HSIZE) ~= TABLE_NOVALUE) {
		print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";
	}
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) rtrue;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	if ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row%8))) rtrue;
	rfalse;
];

[ ForceTableEntryBlank tab col row i at oldv flags;
	if (col >= 100) col = TableFindCol(tab, col);
	if (col == 0) rtrue;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) && (oldv ~= 0 or TABLE_NOVALUE))
		BlkFree(oldv);
	(tab-->col)-->(row+COL_HSIZE) = TABLE_NOVALUE;
	if (flags & TB_COLUMN_NOBLANKBITS) return;
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row%8));
];

[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	flags = (tab-->col)-->1;
	oldv = (tab-->col)-->(row+COL_HSIZE);
	if ((flags & TB_COLUMN_ALLOCATED) &&
		(oldv == 0 or TABLE_NOVALUE)) {
		kov = UNKNOWN_TY;
		tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
		kov = TC_KOV(tc);
		if (kov ~= UNKNOWN_TY) {
			i = kov;
			if (KindBaseArity(i) > 0) i = KindAtomic(i); else i = 0;
			(tab-->col)-->(row+COL_HSIZE) = BlkValueCreate(kov, 0, i);
		}
	}
	row--;
	at = ((tab-->col)-->2) + (row/8);
	(TB_Blanks->at) = (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row%8));
];

[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--;
	at1 = ((tab-->col)-->2) + (row1/8);
	row2--;
	at2 = ((tab-->col)-->2) + (row2/8);
	bit1 = ((TB_Blanks->at1) & (CheckTableEntryIsBlank_LU->(row1%8)));
	bit2 = ((TB_Blanks->at2) & (CheckTableEntryIsBlank_LU->(row2%8)));
	if (bit1) bit1 = true; 
	if (bit2) bit2 = true;
	if (bit1 == bit2) return;
	if (bit1) {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) & (CheckTableEntryIsNonBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at1)
			= (TB_Blanks->at1) | (CheckTableEntryIsBlank_LU->(row1%8));
		(TB_Blanks->at2)
			= (TB_Blanks->at2) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rtrue;
	if (((tab-->col)-->1) & TB_COLUMN_NOBLANKBITS) return;
	row1--; row2--;
	! Read blank bit for row1:
	at = ((tab-->col)-->2) + (row1/8);
	bit = ((TB_Blanks->at) & (CheckTableEntryIsBlank_LU->(row1%8)));
	if (bit) bit = true;
	! Loop through, setting each blank bit to the next:
	for (rx=row1:rx<row2:rx++) {
		atp1 = ((tab-->col)-->2) + ((rx+1)/8);
		at = ((tab-->col)-->2) + (rx/8);
		if ((TB_Blanks->atp1) & (CheckTableEntryIsBlank_LU->((rx+1)%8))) {
			(TB_Blanks->at)
				= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(rx%8));
		} else {
			(TB_Blanks->at)
				= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(rx%8));
		}
	}
	! Write bit to blank bit for row2:
	at = ((tab-->col)-->2) + (row2/8);
	if (bit) {
		(TB_Blanks->at)
			= (TB_Blanks->at) | (CheckTableEntryIsBlank_LU->(row2%8));
	} else {
		(TB_Blanks->at)
			= (TB_Blanks->at) & (CheckTableEntryIsNonBlank_LU->(row2%8));
	}
];

[ TableRowCorr tab col lookup_value lookup_col i j f;
	if (col >= 100) col=TableFindCol(tab, col, true);
	lookup_col = tab-->col;
	j = lookup_col-->0 - COL_HSIZE;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=1;
	for (i=1:i<=j:i++) {
		if ((lookup_value == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col,i))) continue;
		if (f) {
			if (BlkValueCompare(lookup_col-->(i+COL_HSIZE), lookup_value) == 0)
				return i;
		} else {
			if (lookup_col-->(i+COL_HSIZE) == lookup_value) return i;
		}
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableRowCorr tab col entry i k v f kov;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	f=0;
	if (((tab-->col)-->1) & TB_COLUMN_TOPIC) f=1;
	else if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED) f=2;
	k = TableRows(tab);
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i))) continue;
		switch (f) {
			1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;
			2: if (BlkValueCompare(v, entry) == 0) return i;
			default: if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];

[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, true);
	if (col2 >= 100) col2=TableFindCol(tab, col2, true);
	cola1 = tab-->col1;
	cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		v = cola2-->i;
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;
		if (f == 1) {
			if (BlkValueCompare(v, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (v ~= lookup_value) continue;
		}
		if (write_flag) {
			ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);
			switch (write_flag) {
				2: cola1-->i = cola1-->i + write_value;
				3: cola1-->i = cola1-->i - write_value;
				default: cola1-->i = write_value;
			}
			rfalse;
		}
		v = cola1-->i;
		if ((v == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		return v;
	}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
	if (col1 >= 100) col1=TableFindCol(tab, col1, false);
	if (col2 >= 100) col2=TableFindCol(tab, col2, false);
	if (col1*col2 == 0) rfalse;
	cola1 = tab-->col1; cola2 = tab-->col2;
	j = cola2-->0;
	f=0;
	if (((tab-->col2)-->1) & TB_COLUMN_ALLOCATED) f=1;
	if (((tab-->col2)-->1) & TB_COLUMN_TOPIC) f=2;
	for (i=1+COL_HSIZE:i<=j:i++) {
		if (f == 1) {
			if (BlkValueCompare(cola2-->i, lookup_value) ~= 0) continue;
		} else if (f == 2) {
			if ((cola2-->i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;
		} else {
			if (cola2-->i ~= lookup_value) continue;
		}
		if ((cola1-->i == TABLE_NOVALUE) &&
			(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;
		rtrue;
	}
	rfalse;
];

[ TableLookUpEntry tab col index write_flag write_value v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > TableRows(tab)))
		return RunTimeProblem(RTP_TABLE_NOROW, tab, index);
	if (write_flag) {
		switch(write_flag) {
			1:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) = write_value;
			2:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) + write_value;
			3:	ForceTableEntryNonBlank(tab,col,index);
				(tab-->col)-->(index+COL_HSIZE) =
					((tab-->col)-->(index+COL_HSIZE)) - write_value;
			4:	ForceTableEntryBlank(tab,col,index);
			5:	ForceTableEntryNonBlank(tab,col,index);
				return ((tab-->col)-->(index+COL_HSIZE));
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		return RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
	return v;
];

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > TableRows(tab))) rfalse;
	v = ((tab-->col)-->(index+COL_HSIZE));
	if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,index)))
		rfalse;
	rtrue;
];

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++) {
		if (((tab-->k)-->(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;
		if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;
	}
	rtrue;
];

[ TableBlankOutRow tab row k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	for (k=1:k<=tab-->0:k++)
		ForceTableEntryBlank(tab, k, row);
];

[ TableBlankOutColumn tab col n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		ForceTableEntryBlank(tab, col, k);
];

[ TableBlankOutAll tab n k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	n = TableRows(tab);
	for (k=1:k<=n:k++)
		TableBlankOutRow(tab, k);
];

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];

[ TableSwapRows tab i j k l v1 v2;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		v1 = (tab-->k)-->(i+COL_HSIZE);
		v2 = (tab-->k)-->(j+COL_HSIZE);
		(tab-->k)-->(i+COL_HSIZE) = v2;
		(tab-->k)-->(j+COL_HSIZE) = v1;
		if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))
			TableSwapBlankBits(tab, i, j, k);
	}
];

[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+COL_HSIZE);
	val2 = (tab-->col)-->(row2+COL_HSIZE);
	if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);
	if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);
	if ((val1 == val2) && (bl1 == bl2)) {
		if (val1 ~= TABLE_NOVALUE) return 0;
		if (bl1 == false) return 0;
		! The two entries are both blank:
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (bl1) return dir;
	if (bl2) return -1*dir;
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) {
		if (BlkValueCompare(val2, val1) < 0) return 1;
		return -1;
	} else if (f & TB_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];

[ TableMoveRowDown tab r1 r2 rx k l m v f;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		f = false;
		m = (tab-->k)-->(r1+COL_HSIZE);
		if (m == TABLE_NOVALUE) f = true;
		for (rx=r1:rx<r2:rx++) {
			v = (tab-->k)-->(rx+COL_HSIZE+1);
			(tab-->k)-->(rx+COL_HSIZE) = v;
			if (v == TABLE_NOVALUE) f = true;
		}
		(tab-->k)-->(r2+COL_HSIZE) = m;
		if (f) TableMoveBlankBitsDown(tab, r1, r2, k);
	}
];

[ TableShuffle tab i to;
	TableMoveBlanksToBack(tab, 1, TableRows(tab));
	to = TableFilledRows(tab);
	for (i=2:i<=to:i++) TableSwapRows(tab, i, random(i));
];

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	f = ((tab-->col)-->1);
	if (f & TB_COLUMN_ALLOCATED) RunTimeProblem(RTP_TABLE_CANTRUNTHROUGH, tab);
	signed_arithmetic = f & TB_COLUMN_SIGNED;
	#Iftrue (WORDSIZE == 2);
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! WORDSIZE == 4
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+COL_HSIZE);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif;
	k = TableRows(tab);
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i>row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+COL_HSIZE);
		    if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
		    	continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i<row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow < fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow: i<=torow: i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == 0) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];

[ TableSort tab col dir test_flag algorithm i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & TB_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	if (test_flag) {
		print "After moving blanks to back:^"; TableColumnDebug(tab, col);
	}

	SetSortDomain(TableSwapRows, TableCompareRows);
	SortArray(tab, col, dir, k, test_flag, algorithm);

	if (test_flag) {
		print "Final state:^"; TableColumnDebug(tab, col);
	}
];

[ PrintTableName T;
	switch(T) {
  TheEmptyTable: print "(the empty table)"; return;
  T0_final_question_options: print "Table of Final Question Options"; return;
  T1_locale_priorities: print "Table of Locale Priorities"; return;
  T2_small_kindnesses_response: print "Table of Small Kindnesses Responses"; return;
  T4_recent_items: print "Table of Recent Items"; return;
  T5_disambiguation_messages: print "Table of Disambiguation Messages"; return;
  T6_custom_library_messages: print "Table of custom library messages"; return;
  T7_library_messages: print "Table of library messages"; return;
  T8_ordinary_status: print "Table of Ordinary Status"; return;
  T10_further_conductor_s_comm: print "Table of Further Conductor's Commentary"; return;
  T11_tasks_achieved: print "Table of Tasks Achieved"; return;
  T12_pond_descriptions: print "Table of Pond Descriptions"; return;
  T13_further_secretary_s_comm: print "Table of Further Secretary's Commentary"; return;
  T14_secretary_s_commentary: print "Table of Secretary's Commentary"; return;
  T15_vivian: print "Table of Vivian"; return;
  T16_endgame_events: print "Table of Endgame Events"; return;
  T17_conductor_s_commentary: print "Table of Conductor's Commentary"; return;

		default: print "** No such table **";
	}
];

[ TablePrint tab i j k row col v tc kov;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    rtrue;
	}
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	print "! ", (PrintTableName) tab, " (", k, ")^";
	for (row=1:row<=k:row++) {
		for (col=1:col<=tab-->0:col++) {
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			v = (tab-->col)-->(row+COL_HSIZE);
			if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,row)))
				print "-- ";
			else {
				if (BlkValueWriteToFile(v, kov) == false) print v;
				print " ";
			}
		}
		print "^";
	}
	rfalse;
];

#ifdef TARGET_GLULX;
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
	for (col=1:col<=tab-->0:col++) {
		j = tab-->col; ! Address of column table
		if (((j-->1) & TB_COLUMN_CANEXCHANGE) == 0)
		    return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
	}
	maxrow = TableRows(tab);
	!print maxrow, " rows available.^";
	for (row=1: row<=maxrow: row++) {
		TableBlankOutRow(tab, row);
	}
	for (row=1: row<=maxrow: row++) {
		!print "Reading row ", row, "^";
		ch = FileIO_GetC(auxf);
		if (ch == '!') {
			while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);
			while (ch == 10 or 13) ch = FileIO_GetC(auxf);
		}
		for (col=1: col<=tab-->0: col++) {
			if (ch == -1) { row++; jump NoMore; }
			if (ch == 10 or 13) break;
			tc = ((tab-->col)-->1) & TB_COLUMN_NUMBER;
			kov = KindAtomic(TC_KOV(tc));
			if (kov == UNKNOWN_TY) kov = NUMBER_TY;
			!print "tc = ", tc, " kov = ", kov, "^";
			sgn = 1;
			if (ch == '-') {
				ch = FileIO_GetC(auxf);
				if (ch == -1) jump NotTable;
				if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }
				sgn = -1;
			}
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
				ForceTableEntryNonBlank(tab, col, row);
			!print "A";
			v = BlkValueReadFromFile(0, 0, -1, kov);
			if (v) {
				if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED)
					v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),
						auxf, ch, kov);
				else
					v = BlkValueReadFromFile(0, auxf, ch, kov);
				ch = 32;
			} else {
				dg = ch - '0';
				if ((dg < 0) || (dg > 9)) jump NotTable;
				v = dg;
				for (::) {
					ch = FileIO_GetC(auxf);
					dg = ch - '0';
					if ((dg < 0) || (dg > 9)) break;
					v = 10*v + dg;
				}
				v = v*sgn;
			}
			!print "v=", v, " ";
			if (((tab-->col)-->1) & TB_COLUMN_ALLOCATED == 0)
				TableLookUpEntry(tab, col, row, true, v);
			.EntryDone;
			!print "First nd is ", ch, "^";
			while (ch == 9 or 32) ch = FileIO_GetC(auxf);
		}
		while (ch ~= -1 or 10 or 13) {
			if ((ch ~= '-') && (((ch-'0')<0) || ((ch-'0')>9))) jump NotTable;
			if (ch ~= 9 or 32) jump WontFit;
			ch = FileIO_GetC(auxf);
		}
	}
	.NoMore;
	while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);
	if (ch == -1) return;
	.WontFit;
	return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
	.NotTable;
	return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
#ENDIF; ! TARGET_GLULX

[ PrintRank i j v;
#ifdef RANKING_TABLE;
	L__M(##Score, 3);
	j = TableRows(RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(RANKING_TABLE, 2, i);
		    if (v ofclass String) print (string) v;
		    else v();
		    ".";
		}
#endif;
	".";
];

[ TableColumnDebug tab col k i v;
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	print "Table col ", col, ": ";
	for (i=1:i<=k:i++) {
		v = (tab-->col)-->(i+COL_HSIZE);
		if ((v == TABLE_NOVALUE) && (CheckTableEntryIsBlank(tab,col,i)))
			print "BLANK ";
		else
			print v, " ";
	}
	print "*^";
];

[ HolderOf o;
	if (InitialSituation-->DONE_INIS == false) return thedark;
	if (o && (o.component_parent)) return o.component_parent;
	if (o && (parent(o))) return parent(o);
	return nothing;
];

[ ParentOf o;
	if (o) o = parent(o);
	return o;
];

[ CoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ CoreOfParentOfCoreOf o;
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	if (o) o = parent(o);
	while (o && (o provides component_parent) && (o.component_parent)) o = o.component_parent;
	return o;
];

[ LocationOf o;
	if (~~(O ofclass K1_room or K2_thing)) return nothing;
	if (O ofclass K4_door) return FrontSideOfDoor(O);
	if (O ofclass K7_backdrop) return nothing;
	while (o) {
		if (o ofclass K1_room) return o;
		o = CoreOfParentOfCoreOf(o);
	}
	return nothing;
];

[ CommonAncestor o1 o2 i j;
	o1 = CoreOf(o1);
	o2 = CoreOf(o2);
	
	for (i=o1: i: i = CoreOfParentOfCoreOf(i))
		for (j=o2: j: j = CoreOfParentOfCoreOf(j))
			if (j == i) return j;

	return nothing;
];

[ IndirectlyContains o1 o2;
	if ((o1 == nothing) || (o2 == nothing)) rfalse;
	if ((o1 ofclass K1_room) && (o2 ofclass K4_door)) {
		if (o1 == FrontSideOfDoor(o2)) rtrue;
		if (o1 == BackSideOfDoor(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	for (o2 = HolderOf(o2) : o2 && o2 ~= thedark : o2 = HolderOf(o2)) if (o2 == o1) rtrue;
	rfalse;
];

[ WhetherIn obj;
	if (obj has enterable) {
		if (IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return TestRegionalContainment(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];

[ ContainerOf A p;
	if (A ofclass K1_room) return A.map_region;
	p = parent(A);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];

[ TestContainmentRange obj e f;
	if (obj ofclass K9_region) {
		objectloop (f ofclass K1_room && f.map_region == obj)
			if (f > e) return f;
		return nothing;
	}
	if (obj ofclass K5_container or K1_room) {
		if (e == nothing) return child(obj);
		return sibling(e);
	}
	return nothing;
];

[ SupporterOf obj p;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];

[ CarrierOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];

[ WearerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];

[ OwnerOf obj p;
	p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];

[ MakePart P Of First;
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { DetachPart(P); return; }
	if (P.component_parent) DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];

[ DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
		P.component_sibling = nothing; return;
	}
	for (O = Daddy.component_child: O: O = O.component_sibling)
		if (O.component_sibling == P) {
			O.component_sibling = P.component_sibling;
			P.component_sibling = nothing; return;
		}
];

[ MoveObject F T opt going_mode was;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (TestRegionalContainment(LocationOf(player), T)) move F to LocationOf(player);
			else remove F;
			return; }
		return RunTimeProblem(RTP_BACKDROP, F, T);
	}
	if (~~(F ofclass K2_thing)) return RunTimeProblem(RTP_NOTTHING, F, T);
	if (T ofclass K9_region) return RunTimeProblem(RTP_NOTBACKDROP, F, T);
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	DetachPart(F);
	if (going_mode == false) {
		if (F == player) { PlayerTo(T, opt); return; }
		if ((IndirectlyContains(F, player)) && (LocationOf(player) ~= LocationOf(T))) {
			was = parent(player);
			move player to real_location;
			move F to T;
			PlayerTo(was, true);
			return;
		}
	}
	move F to T;
];

[ RemoveFromPlay F;
	if (F == nothing) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	if (F == player) return RunTimeProblem(RTP_CANTREMOVEPLAYER);
	if (F ofclass K4_door) return RunTimeProblem(RTP_CANTREMOVEDOORS);
	give F ~worn; DetachPart(F);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];

[ OnStage O set x;
	if (O ofclass K1_room) rfalse;
	if (set < 0) {
		while (metaclass(O) == Object) {
			if (O ofclass K1_room) rtrue;
			if (O ofclass K9_region) rfalse;
			if (O ofclass K4_door) rtrue;
			if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
			x = O.component_parent; if (x) { O = x; continue; }
			x = parent(O); if (x) { O = x; continue; }
			rfalse;
		}
	}
	x = OnStage(O, -1);
	if ((x) && (set == false)) RemoveFromPlay(O);
	if ((x == false) && (set)) MoveObject(O, real_location);
	rfalse;
];

[ PlayerTo newplace flag;
	@push actor; actor = player;
    move player to newplace;
    location = LocationOf(newplace);
    real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if (flag == 0) <Look>;
    if (flag == 1) give location visited;
    if (flag == 2) AbbreviatedRoomDescription();
    @pull actor;
];

[ MoveDuringGoing F T;
	MoveObject(F, T, 0, true);
	if (actor == player) {
		location = LocationOf(player);
		real_location = location;
	}
];

[ FoundEverywhere; rtrue; ];

[ ChangePlayer obj flag i;
	if (~~(obj ofclass K8_person)) return RunTimeProblem(RTP_CANTCHANGE, obj);
	if (~~(OnStage(obj, -1))) return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
	if (obj == player) return;

    give player ~concealed;
    if (player has remove_proper) give player ~proper;
    if (player == selfobj) {
    	player.saved_short_name = player.short_name; player.short_name = FORMER__TX;
    }
    player = obj;
    if (player == selfobj) {
    	player.short_name = player.saved_short_name;
    }
    if (player hasnt proper) give player remove_proper; ! when changing out again
    give player concealed proper;

    location = LocationOf(player); real_location = location;
    MoveFloatingObjects();
    SilentlyConsiderLight();
];

[ MoveFloatingObjects i k l m address flag;
    if (real_location == nothing) return;
    objectloop (i) {
        address = i.&found_in;
        if (address ~= 0 && i hasnt absent) {
            if (ZRegion(address-->0) == 2) {
                m = address-->0;
                .TestPropositionally;
                if (m.call(real_location) ~= 0) move i to real_location;
                else remove i;
            }
            else {
                k = i.#found_in;
                for (l=0 : l<k/WORDSIZE : l++) {
                    m = address-->l;
                    if (ZRegion(m) == 2) jump TestPropositionally;
                    if (m == real_location || m in real_location) {
                        if (i notin real_location) move i to real_location;
                        flag = true;
                    }
                }
                if (flag == false) { if (parent(i)) remove i; }
            }
        }
    }
];

[ MoveBackdrop bd D x address;
	if (~~(bd ofclass K7_backdrop)) return RunTimeProblem(RTP_BACKDROPONLY, bd);
	if (bd.#found_in > WORDSIZE) {
		address = bd.&found_in;
		address-->0 = D;
	} else bd.found_in = D;
	give bd ~absent;
	MoveFloatingObjects();
];

[ WearObject X P opt;
	if (X == false) rfalse;
	if (X notin P) MoveObject(X, P, opt);
	give X worn;
];

[ MapConnection from_room dir
	in_direction through_door;
	if ((from_room ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((from_room.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room) return in_direction;
		if (in_direction ofclass K4_door) {
			@push location;
			location = from_room;
			through_door = in_direction.door_to();
			@pull location;
			if (through_door ofclass K1_room) return through_door;
		}
	}
	return nothing;
];

[ DoorFrom obj dir rv;
	rv = RoomOrDoorFrom(obj, dir);
	if (rv ofclass K4_door) return rv;
	return nothing;
];

[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir ofclass K3_direction)) {
		in_direction = Map_Storage-->
			((obj.IK1_Count)*No_Directions + dir.IK3_Count);
		if (in_direction ofclass K1_room or K4_door) return in_direction;	
	}
	return nothing;
];

[ AssertMapConnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if ((in_direction == 0) || (in_direction ofclass K1_room)) {
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = r2;
		return;
	}
	if (in_direction ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];

[ AssertMapUnconnection r1 dir r2 in_direction;
	SignalMapChange();
	in_direction = Map_Storage-->
		((r1.IK1_Count)*No_Directions + dir.IK3_Count);
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if (in_direction == r2)
		Map_Storage-->((r1.IK1_Count)*No_Directions + dir.IK3_Count) = 0;
	return;
];

[ TestAdjacency R1 R2 i row;
	row = (R1.IK1_Count)*No_Directions;
	for (i=0: i<No_Directions: i++, row++)
		if (Map_Storage-->row == R2) rtrue;
	rfalse;
];

[ TestRegionalContainment obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (~~(obj ofclass K1_room)) obj = LocationOf(obj);
	if (obj == nothing) rfalse;
	o = obj.map_region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];

[ FrontSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0; ! Two-sided
	return parent(D); ! One-sided
];

[ BackSideOfDoor D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1; ! Two-sided
	return nothing; ! One-sided
];

[ OtherSideOfDoor D from_room rv;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_to();
		@pull location;
	}
	return rv;
];

[ DirectionDoorLeadsIn D from_room rv dir;
	if (D ofclass K4_door) {
		@push location;
		location = LocationOf(from_room);
		rv = D.door_dir();
		@pull location;
	}
	return rv;
];

[ TestVisibility A B;
	if (~~OffersLight(parent(CoreOf(A)))) rfalse;
	if (suppress_scope_loops) rtrue;
	return TestScope(B, A);
];

[ TestTouchability A B;
	if (TestScope(B,A) == false) rfalse;
	if (ObjectIsUntouchable(B, 1, 0, A)) rfalse;
	rtrue;
];

[ TestConcealment A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		particular_possession = B;
		if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) rtrue;
	}
	rfalse;
];





[ Cond_Token_400 ;
if ((((I464_grassy_shore == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_401 ;
if ((((I464_grassy_shore == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_463 ;
if (((((Adj_3_t1_v9(I623_stone_steps)))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_462 ;
if ((((((Adj_3_t1_v9(I553_twisty_stairs))))) || ((((Adj_3_t1_v9(I527_spiral_staircase))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_366 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_366;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 466;
    return GPR_PREPOSITION;
];
[ Cond_Token_367 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_367;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 467;
    return GPR_PREPOSITION;
];
[ Mistake_Token_355;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 455;
    return GPR_PREPOSITION;
];
[ Mistake_Token_356;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 456;
    return GPR_PREPOSITION;
];
[ Mistake_Token_358;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 458;
    return GPR_PREPOSITION;
];
[ Mistake_Token_359;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 459;
    return GPR_PREPOSITION;
];
[ Cond_Token_361 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_361;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 461;
    return GPR_PREPOSITION;
];
[ Cond_Token_362 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_362;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 462;
    return GPR_PREPOSITION;
];
[ Cond_Token_364 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_364;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 464;
    return GPR_PREPOSITION;
];
[ Cond_Token_365 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_365;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 465;
    return GPR_PREPOSITION;
];
[ Cond_Token_606 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_607 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_609 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_610 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_346;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 446;
    return GPR_PREPOSITION;
];
[ Mistake_Token_354;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 454;
    return GPR_PREPOSITION;
];
[ Mistake_Token_357;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 457;
    return GPR_PREPOSITION;
];
[ Cond_Token_360 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_360;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 460;
    return GPR_PREPOSITION;
];
[ Cond_Token_363 ;
if ((((~~(((Adj_3_t1_v9(I607_yellow_leaves)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_363;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 463;
    return GPR_PREPOSITION;
];
[ Mistake_Token_378;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 478;
    return GPR_PREPOSITION;
];
[ Cond_Token_490 ;
if ((((~~(((Adj_3_t1_v9(I588_gull)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_490;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 590;
    return GPR_PREPOSITION;
];
[ Cond_Token_536 ;
if ((((~~(((Adj_3_t1_v9(I491_peeling_paint)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_536;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 636;
    return GPR_PREPOSITION;
];
[ Cond_Token_604 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_605 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_608 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_611 ;
if ((((I469_atop_the_tank == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_615 ;
if ((((TestRegionalContainment(player,I676_underwaterland))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_615;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 715;
    return GPR_PREPOSITION;
];
[ Cond_Token_616 ;
if ((((TestRegionalContainment(player,I676_underwaterland))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_616;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 716;
    return GPR_PREPOSITION;
];
[ Cond_Token_445 ;
if ((((second == I536_keyhole_on_the_security)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_446 ;
if ((((second == I536_keyhole_on_the_security)))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_270;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 370;
    return GPR_PREPOSITION;
];
[ Mistake_Token_271;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 371;
    return GPR_PREPOSITION;
];
[ Mistake_Token_272;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 372;
    return GPR_PREPOSITION;
];
[ Cond_Token_491 ;
if ((((~~(((Adj_3_t1_v9(I588_gull)))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_491;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 591;
    return GPR_PREPOSITION;
];
[ Mistake_Token_336;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 436;
    return GPR_PREPOSITION;
];
[ Mistake_Token_334;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 434;
    return GPR_PREPOSITION;
];
[ Cond_Token_414 ;
if ((((IndirectlyContains(I481_rowboat,player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_235;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 335;
    return GPR_PREPOSITION;
];
[ Mistake_Token_236;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 336;
    return GPR_PREPOSITION;
];
[ Mistake_Token_237;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 337;
    return GPR_PREPOSITION;
];
[ Mistake_Token_238;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 338;
    return GPR_PREPOSITION;
];
[ Mistake_Token_239;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 339;
    return GPR_PREPOSITION;
];
[ Cond_Token_621 ;
if ((((TestRegionalContainment(player,I676_underwaterland))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_331;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 431;
    return GPR_PREPOSITION;
];
[ Mistake_Token_332;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 432;
    return GPR_PREPOSITION;
];
[ Mistake_Token_333;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 433;
    return GPR_PREPOSITION;
];
[ Mistake_Token_335;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 435;
    return GPR_PREPOSITION;
];
[ Cond_Token_552 ;
if ((((I494_other_side_of_the_pond == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_383 ;
if (((((real_location == I468_muddy_beach))) || (((real_location == I470_rocky_beach))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_393;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 493;
    return GPR_PREPOSITION;
];
[ Mistake_Token_394;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 494;
    return GPR_PREPOSITION;
];
[ Cond_Token_398 ;
if ((((((Adj_110_t1_v9(player))))) && ((((I481_rowboat == ContainerOf(player)))) && (((player == CarrierOf(I476_wide_stick))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_395;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 495;
    return GPR_PREPOSITION;
];
[ Cond_Token_399 ;
if ((((((Adj_110_t1_v9(player))))) && ((((I481_rowboat == ContainerOf(player)))) && (((player == CarrierOf(I476_wide_stick))))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_413;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 513;
    return GPR_PREPOSITION;
];
[ Cond_Token_415 ;
if ((((IndirectlyContains(I481_rowboat,player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_439;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 539;
    return GPR_PREPOSITION;
];
[ Mistake_Token_440;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 540;
    return GPR_PREPOSITION;
];
[ Mistake_Token_441;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 541;
    return GPR_PREPOSITION;
];
[ Cond_Token_465 ;
if ((((I441_hill == ContainerOf(player))))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Cond_Token_525 ;
if (((Prop_125()))) return GPR_PREPOSITION;
    return GPR_FAIL;
];
[ Mistake_Token_543;
    if (actor ~= player) return GPR_FAIL;
    understand_as_mistake_number = 643;
    return GPR_PREPOSITION;
];



[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
	wnc = wn; original_wn = wn; group_wn = wn;

	wn = wnc;
	r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10:
				#Iftrue (WORDSIZE == 2);
				if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Ifnot; ! i.e., if (WORDSIZE == 4)
				if (digit_count == 11) return GPR_FAIL;
				if (digit_count == 10) {
					if (n > 214748364) return GPR_FAIL;
					if (n == 214748364) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
				#Endif; 
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];

[ TRUTH_STATE_TOKEN original_wn wd;
	original_wn = wn;

	wn = original_wn;
	wd = NextWordStopped();
	if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }
	if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }
	wn = original_wn;
	return GPR_FAIL;
];

[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];

[ SquareRoot num
	op res one;
	op = num;
	if (num < 0) { RunTimeProblem(RTP_NEGATIVEROOT); return 1; }
	! "one" starts at the highest power of four <= the argument.
	for (one = WORD_NEXTTOHIGHBIT: one > op: one = one/4) ;

	while (one ~= 0) {
		!print "Round: op = ", op, " res = ", res, ", res**2 = ", res*res, " one = ", one, "^";
		if (op >= res + one) {
			op = op - res - one;
			res = res + one*2;
		}
		res = res/2;
		one = one/4;
	}
	!print "Res is ", res, "^";
	return res;
];

[ CubeRoot num x y n;
	if (num < 0) x = -SquareRoot(-num); else x = SquareRoot(num);
	for (n=0: (y ~= x) && (n++ < 100): y = x, x = (2*x + num/x/x)/3) ;
	return x;
];

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= TWELVE_HOURS) { aop = "pm"; t = t - TWELVE_HOURS; } else aop = "am";
	h = t/ONE_HOUR; if (h==0) h=12;
	print h, ":";
	if (t%ONE_HOUR < 10) print "0"; print t%ONE_HOUR, " ", (string) aop;
];

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/ONE_HOUR) % 12; m = t%ONE_HOUR; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > HALF_HOUR) { m = ONE_HOUR-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		QUARTER_HOUR: print "quarter"; HALF_HOUR: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
				if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];

[ TIME_TOKEN first_word second_word at length flag
	illegal_char offhour hr mn i original_wn;
	original_wn = wn;

	wn = original_wn;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = HALF_HOUR;
	if (first_word == 'quarter') offhour = QUARTER_HOUR;
	if (offhour < 0) offhour = TryNumber(wn-1);
	if (offhour < 0 || offhour >= ONE_HOUR) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = TryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = ONE_HOUR-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = TryNumber(--wn);
			if (mn < 0 || mn >= ONE_HOUR) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= ONE_HOUR) return -1;
	x = hour*ONE_HOUR + minute; if (hour >= 13) return x;
	x = x % TWELVE_HOURS; if (word == 'pm') x = x + TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + TWELVE_HOURS;
	return x;
];

[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
	original_wn = wn;
	wn = original_wn;
	
	first_word = NextWordStopped(); wn--;
	if (first_word == 'an' or 'a//') mn=1; else mn=TryNumber(wn);
	
    if (mn == -1000) {
		first_word = NextWordStopped();
		if (first_word == 'half') offhour = HALF_HOUR;
		if (first_word == 'quarter') offhour = QUARTER_HOUR;
		if (offhour > 0) {
			second_word = NextWordStopped();
			if (second_word == 'of') second_word = NextWordStopped();
			if (second_word == 'an') second_word = NextWordStopped();
			if (second_word == 'hour') {
				parsed_number = offhour;
				return GPR_NUMBER;
			}
		}
		return GPR_FAIL;
    }
	wn++;
	
	first_word = NextWordStopped();
	switch (first_word) {
		'minutes', 'minute': mult = 1;
		'hours', 'hour': mult = 60;
		default: return GPR_FAIL;
	}
	parsed_number = mn*mult;
	if (mult == 60) {
		mn=TryNumber(wn);
		if (mn ~= -1000) {
			wn++;
			first_word = NextWordStopped();
			if (first_word == 'minutes' or 'minute')
				parsed_number = parsed_number + mn;
			else wn = wn - 2;
		}
	}
	return GPR_NUMBER;
];

[ DuringSceneMatching prop sc;
	for (sc=0: sc<NUMBER_SCENES_CREATED: sc++)
		if ((scene_status-->sc == 1) && (prop(sc+1))) rtrue;
	rfalse;
];

[ SceneUtility sc task;
	if (sc <= 0) return 0;
	if (task == 1 or 2) {
		if (scene_endings-->(sc-1) == 0) return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
	} else {
		if (scene_endings-->(sc-1) <= 1) return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
	}
	switch (task) {
		1: return (the_time - scene_started-->(sc-1))%(TWENTY_FOUR_HOURS);
		2: return scene_started-->(sc-1);
		3: return (the_time - scene_ended-->(sc-1))%(TWENTY_FOUR_HOURS);
		4: return scene_ended-->(sc-1);
	}
];

[ Kind_GPR_10 original_wn group_wn v wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f w rv x;
    original_wn = wn;
    return GPR_FAIL;
];
[ Kind_GPR_46 original_wn group_wn v wpos mid_word matched_number cur_word cur_len cur_addr sgn tot f w rv x;
    original_wn = wn;
        if (NextWordStopped() ~= 'water') jump Fail_1;
        parsed_number = I437_pond_water;
        return GPR_NUMBER;
        .Fail_1; wn = original_wn;
        if (NextWordStopped() ~= 'water') jump Fail_2;
        parsed_number = I436_clean_water;
        return GPR_NUMBER;
        .Fail_2; wn = original_wn;
    wn = original_wn;
    wn = original_wn;if (NextWordStopped() ~= 'clean') jump Failed_1;
    if (NextWordStopped() ~= 'water') jump Failed_1;
    parsed_number = I436_clean_water; return GPR_NUMBER;
    .Failed_1;
    wn = original_wn;if (NextWordStopped() ~= 'pond') jump Failed_2;
    if (NextWordStopped() ~= 'water') jump Failed_2;
    parsed_number = I437_pond_water; return GPR_NUMBER;
    .Failed_2;
    return GPR_FAIL;
];



[ Noun_Filter_0 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_100_t1_v9(noun))));
];
[ Noun_Filter_1 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_100_t1_v9(noun))));
];
[ Noun_Filter_2 x;
    x=noun;
    return ((noun == I575_pine_sap));
];
[ Noun_Filter_3 x;
    x=noun;
    return ((noun == I472_beer_bottle));
];
[ Noun_Filter_4 x;
    x=noun;
    return ((noun ofclass K5_container));
];
[ Noun_Filter_5 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_6 x;
    x=noun;
    return ((noun ofclass K14_vehicle));
];
[ Noun_Filter_7 x;
    x=noun;
    return ((noun ofclass K6_supporter));
];
[ Noun_Filter_8 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_100_t1_v9(noun))));
];
[ Noun_Filter_9 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_100_t1_v9(noun))));
];
[ Noun_Filter_10 x;
    x=noun;
    return ((noun ofclass K5_container));
];
[ Noun_Filter_11 x;
    x=noun;
    return ((noun ofclass K18_passkey));
];
[ Noun_Filter_12 x;
    x=noun;
    return ((noun ofclass K19_keychain));
];
[ Noun_Filter_13 x;
    x=noun;
    return ((noun ofclass K26_liquid_source));
];
[ Noun_Filter_14 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_15 x;
    x=noun;
    return ((noun == I604_large_magnet));
];
[ Noun_Filter_16 x;
    x=noun;
    return ((noun == I639_deep_crack));
];
[ Noun_Filter_17 x;
    x=noun;
    return ((noun == I604_large_magnet));
];
[ Noun_Filter_18 x;
    x=noun;
    return ((noun == I640_old_key));
];
[ Noun_Filter_19 x;
    x=noun;
    return ((noun == I490_flagpole));
];
[ Noun_Filter_20 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_21 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Scope_Filter_22 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_23 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_24 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_25 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_26 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_27 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_28 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_29 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Scope_Filter_30 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room) && ((Adj_11_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_31 x;
    x=noun;
    return ((noun == I708_train_window));
];
[ Noun_Filter_32 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_33 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_34 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_35 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_36 x;
    x=noun;
    return ((noun ofclass K4_door));
];
[ Noun_Filter_37 x;
    x=noun;
    return ((noun ofclass K4_door));
];
[ Noun_Filter_38 x;
    x=noun;
    return ((noun ofclass K14_vehicle));
];
[ Noun_Filter_39 x;
    x=noun;
    return ((noun ofclass K14_vehicle));
];
[ Noun_Filter_40 x;
    x=noun;
    return ((noun ofclass K6_supporter));
];
[ Noun_Filter_41 x;
    x=noun;
    return ((noun ofclass K6_supporter));
];
[ Noun_Filter_42 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_43 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Scope_Filter_44 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room) && ((Adj_11_t1_v9(noun)))))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_45 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_46 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_47 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_48 x;
    x=noun;
    return ((noun == I591_secret_panel));
];
[ Noun_Filter_49 x;
    x=noun;
    return ((noun == I591_secret_panel));
];
[ Noun_Filter_50 x;
    x=noun;
    return ((noun == I533_janky_bolt));
];
[ Noun_Filter_51 x;
    x=noun;
    return ((noun == I533_janky_bolt));
];
[ Noun_Filter_52 x;
    x=noun;
    return ((noun == I589_wooden_drawer));
];
[ Noun_Filter_53 x;
    x=noun;
    return ((noun == I589_wooden_drawer));
];
[ Noun_Filter_54 x;
    x=noun;
    return ((noun == I589_wooden_drawer));
];
[ Noun_Filter_55 x;
    x=noun;
    return ((noun == I589_wooden_drawer));
];
[ Noun_Filter_56 x;
    x=noun;
    return ((noun == I589_wooden_drawer));
];
[ Noun_Filter_57 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_80_t1_v9(noun))));
];
[ Noun_Filter_58 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_76_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_59 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_60 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_76_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_61 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_62 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_63 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_64 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_65 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_66 x;
    x=noun;
    return ((noun == I563_metal_wind_chimes));
];
[ Noun_Filter_67 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_67_t1_v9(noun))));
];
[ Noun_Filter_68 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_69 x;
    x=noun;
    return ((noun ofclass K14_vehicle));
];
[ Noun_Filter_70 x;
    x=noun;
    return ((noun ofclass K6_supporter));
];
[ Noun_Filter_71 x;
    x=noun;
    return ((noun ofclass K6_supporter));
];
[ Noun_Filter_72 x;
    x=noun;
    return ((noun == I563_metal_wind_chimes));
];
[ Noun_Filter_73 x;
    x=noun;
    return ((noun == I414_flashlight));
];
[ Noun_Filter_74 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_75 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_76 x;
    x=noun;
    return ((noun ofclass K1_room));
];
[ Noun_Filter_77 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_53_t1_v9(noun))));
];
[ Noun_Filter_78 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_58_t1_v9(noun))));
];
[ Noun_Filter_79 x;
    x=noun;
    return ((noun ofclass K5_container) && ((Adj_71_t1_v9(noun))) && ((Adj_72_t1_v9(noun))));
];
[ Noun_Filter_80 x;
    x=noun;
    return ((noun ofclass K5_container) && ((Adj_70_t1_v9(noun))) && ((Adj_72_t1_v9(noun))));
];
[ Noun_Filter_81 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_82 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_76_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_83 x;
    x=noun;
    return ((noun ofclass K13_device) && ((Adj_81_t1_v9(noun))));
];
[ Noun_Filter_84 x;
    x=noun;
    return ((noun ofclass K4_door) && ((Adj_71_t1_v9(noun))));
];
[ Noun_Filter_85 x;
    x=noun;
    return ((noun ofclass K4_door) && ((Adj_70_t1_v9(noun))));
];
[ Noun_Filter_86 x;
    x=noun;
    return ((noun ofclass K6_supporter) && ((Adj_67_t1_v9(noun))) && (~~((Adj_33_t1_v9(noun)))));
];
[ Noun_Filter_87 x;
    x=noun;
    return ((noun ofclass K5_container) && ((Adj_67_t1_v9(noun))) && (~~((Adj_33_t1_v9(noun)))));
];
[ Noun_Filter_88 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_75_t1_v9(noun))) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_89 x;
    x=noun;
    return ((noun ofclass K2_thing) && ((Adj_74_t1_v9(noun))));
];
[ Noun_Filter_90 x;
    x=noun;
    return ((noun == I591_secret_panel));
];
[ Scope_Filter_91 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K8_person)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_92 x;
    x=noun;
    return ((noun == I440_sound_of_the_wind_chime));
];
[ Noun_Filter_93 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_94 x;
    x=noun;
    return ((noun ofclass K26_liquid_source));
];
[ Noun_Filter_95 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_96 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_97 x;
    x=noun;
    return ((noun == I526_leaky_hose));
];
[ Noun_Filter_98 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_99 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_100 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_101 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_102 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_103 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_104 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_105 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_106 x;
    x=noun;
    return ((noun ofclass K25_fluid_container));
];
[ Noun_Filter_107 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_108 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Scope_Filter_109 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_110 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_111 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Scope_Filter_112 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K1_room)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_113 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_114 x;
    x=noun;
    return ((noun ofclass K3_direction));
];
[ Noun_Filter_115 x;
    x=noun;
    return ((noun == I491_peeling_paint));
];
[ Noun_Filter_116 x;
    x=noun;
    return ((noun == I489_large_painted_mural));
];
[ Noun_Filter_117 x;
    x=noun;
    return ((noun == I481_rowboat));
];
[ Noun_Filter_118 x;
    x=noun;
    return ((noun == I563_metal_wind_chimes));
];
[ Noun_Filter_119 x;
    x=noun;
    return ((noun == I580_vending_machine));
];
[ Noun_Filter_120 x;
    x=noun;
    return ((noun == I580_vending_machine));
];
[ Scope_Filter_121 obj o2;
    switch (scope_stage) {
        1: rfalse;
        2: obj=noun;
        objectloop(noun ofclass Object && (((noun ofclass K2_thing)))) {
            o2 = noun; noun = obj;
            suppress_scope_loops = true; PlaceInScope(o2, true); suppress_scope_loops = false;
            noun = o2;
        }
        noun=obj;
        3: nextbest_etype = NOTINCONTEXT_PE; return -1;
    }
];
[ Noun_Filter_122 x;
    x=noun;
    return ((noun ofclass K2_thing));
];
[ Noun_Filter_123 x;
    x=noun;
    return ((noun == I490_flagpole));
];
[ Noun_Filter_124 x;
    x=noun;
    return ((noun == I563_metal_wind_chimes));
];


#IFDEF DEBUG;

[ XAbstractSub;
    if (XTestMove(noun, second)) return;
    move noun to second;
    "[Abstracted.]";
];

[ XTestMove obj dest;
    if ((obj <= InformLibrary) || (obj == LibraryMessages))
        "[Can't move ", (name) obj, ": it's a system object.]";
    if (obj.component_parent)
        "[Can't move ", (name) obj, ": it's part of ",
        (the) obj.component_parent, ".]";
    while (dest) {
        if (dest == obj) "[Can't move ", (name) obj, ": it would contain itself.]";
        dest = CoreOfParentOfCoreOf(dest);
    }
    rfalse;
];

[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];

[ GonearSub;
	PlayerTo(LocationOf(noun));
];

[ XPurloinSub;
    if (XTestMove(noun, player)) return;
    move noun to player; give noun moved ~concealed;
    say__p = 1;
    "[Purloined.]";
];

[ PredictableSub;
    VM_Seed_RNG(-100);
    say__p = 1;
    "[Random number generator now predictable.]";
];

[ ShowRelationsSub;
   IterateRelations(ShowOneRelation);
];

[ ShowOneRelation rel;
   if ((rel-->RR_PERMISSIONS) & (RELS_SHOW)) {
       (rel-->RR_HANDLER)(rel, RELS_SHOW);
   }
];

[ RulesOnSub;
	debug_rules = 1; say__p = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2; say__p = 1;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0; say__p = 1;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];

[ ScenesOnSub;
	debug_scenes = 1;
	ShowSceneStatus(); say__p = 1;
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0; say__p = 1;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];

Global x_scope_count;
[ ScopeSub;
    x_scope_count = 0;
    LoopOverScope(Print_ScL, noun);
    if (x_scope_count == 0) "Nothing is in scope.";
];
[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];

[ ShowHeapSub;
	DebugHeap();
];

[ ShowMeSub t_0 na;
	t_0 = noun;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (t_0 ofclass K2_thing) {
 		print "location:"; ShowRLocation(noun, true); print "^";
 	}
 	if (t_0) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(pluralname)) && (t_0  has pluralname)) { if (na++ > 0) print ", "; print "plural-named"; }
    if ((AllowInShowme(pluralname)) && (t_0  hasnt pluralname)) { if (na++ > 0) print ", "; print "singular-named"; }
    if ((AllowInShowme(proper)) && (t_0  has proper)) { if (na++ > 0) print ", "; print "proper-named"; }
    if ((AllowInShowme(proper)) && (t_0  hasnt proper)) { if (na++ > 0) print ", "; print "improper-named"; }
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lighted"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "dark"; }
    if ((AllowInShowme(visited)) && (t_0  has visited)) { if (na++ > 0) print ", "; print "visited"; }
    if ((AllowInShowme(visited)) && (t_0  hasnt visited)) { if (na++ > 0) print ", "; print "unvisited"; }
    if ((AllowInShowme(p77_indoors)) && (t_0  has p77_indoors)) { if (na++ > 0) print ", "; print "indoors"; }
    if ((AllowInShowme(p77_indoors)) && (t_0  hasnt p77_indoors)) { if (na++ > 0) print ", "; print "outdoors"; }
    if ((AllowInShowme(p112_keyed)) && (t_0 .p112_keyed == true)) { if (na++ > 0) print ", "; print "keyed"; }
    if ((AllowInShowme(p112_keyed)) && (t_0 .p112_keyed == false)) { if (na++ > 0) print ", "; print "unkeyed"; }
    if ((AllowInShowme(p114_flooded)) && (t_0 .p114_flooded == true)) { if (na++ > 0) print ", "; print "flooded"; }
    if ((AllowInShowme(p114_flooded)) && (t_0 .p114_flooded == false)) { if (na++ > 0) print ", "; print "safe"; }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(light)) && (t_0  has light)) { if (na++ > 0) print ", "; print "lit"; }
    if ((AllowInShowme(light)) && (t_0  hasnt light)) { if (na++ > 0) print ", "; print "unlit"; }
    if ((AllowInShowme(edible)) && (t_0  has edible)) { if (na++ > 0) print ", "; print "edible"; }
    if ((AllowInShowme(edible)) && (t_0  hasnt edible)) { if (na++ > 0) print ", "; print "inedible"; }
    if ((AllowInShowme(static)) && (t_0  has static)) { if (na++ > 0) print ", "; print "fixed in place"; }
    if ((AllowInShowme(static)) && (t_0  hasnt static)) { if (na++ > 0) print ", "; print "portable"; }
    if ((AllowInShowme(scenery)) && (t_0  has scenery)) { if (na++ > 0) print ", "; print "scenery"; }
    if ((AllowInShowme(clothing)) && (t_0  has clothing)) { if (na++ > 0) print ", "; print "wearable"; }
    if ((AllowInShowme(pushable)) && (t_0  has pushable)) { if (na++ > 0) print ", "; print "pushable between rooms"; }
    if ((AllowInShowme(moved)) && (t_0  has moved)) { if (na++ > 0) print ", "; print "handled"; }
    if ((AllowInShowme(concealed)) && (t_0  hasnt concealed)) { if (na++ > 0) print ", "; print "described"; }
    if ((AllowInShowme(concealed)) && (t_0  has concealed)) { if (na++ > 0) print ", "; print "undescribed"; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
    if ((AllowInShowme(mentioned)) && (t_0  has mentioned)) { if (na++ > 0) print ", "; print "mentioned"; }
    if ((AllowInShowme(mentioned)) && (t_0  hasnt mentioned)) { if (na++ > 0) print ", "; print "unmentioned"; }
    if ((AllowInShowme(neuter)) && (t_0  has neuter)) { if (na++ > 0) print ", "; print "neuter"; }
    if ((AllowInShowme(p61_stashable)) && (t_0  has p61_stashable)) { if (na++ > 0) print ", "; print "stashable"; }
    if ((AllowInShowme(p61_stashable)) && (t_0  hasnt p61_stashable)) { if (na++ > 0) print ", "; print "unstashable"; }
    if ((AllowInShowme(p65_chviable)) && (t_0  has p65_chviable)) { if (na++ > 0) print ", "; print "CHviable"; }
    if ((AllowInShowme(p65_chviable)) && (t_0  hasnt p65_chviable)) { if (na++ > 0) print ", "; print "CHunviable"; }
    if ((AllowInShowme(p71_ambiguously_plural)) && (t_0  has p71_ambiguously_plural)) { if (na++ > 0) print ", "; print "ambiguously plural"; }
    if ((AllowInShowme(p71_ambiguously_plural)) && (t_0  hasnt p71_ambiguously_plural)) { if (na++ > 0) print ", "; print "ordinarily enumerated"; }
    if ((AllowInShowme(p73_examined)) && (t_0  has p73_examined)) { if (na++ > 0) print ", "; print "examined"; }
    if ((AllowInShowme(p73_examined)) && (t_0  hasnt p73_examined)) { if (na++ > 0) print ", "; print "unexamined"; }
    if ((AllowInShowme(p79_pocketed)) && (t_0  has p79_pocketed)) { if (na++ > 0) print ", "; print "pocketed"; }
    if ((AllowInShowme(p79_pocketed)) && (t_0  hasnt p79_pocketed)) { if (na++ > 0) print ", "; print "unpocketed"; }
    if ((AllowInShowme(p81_metal)) && (t_0  has p81_metal)) { if (na++ > 0) print ", "; print "metal"; }
    if ((AllowInShowme(p81_metal)) && (t_0  hasnt p81_metal)) { if (na++ > 0) print ", "; print "nonmetal"; }
    if ((AllowInShowme(p86_soft)) && (t_0 .p86_soft == true)) { if (na++ > 0) print ", "; print "soft"; }
    if ((AllowInShowme(p86_soft)) && (t_0 .p86_soft == false)) { if (na++ > 0) print ", "; print "hard"; }
    if ((AllowInShowme(p104_important)) && (t_0 .p104_important == true)) { if (na++ > 0) print ", "; print "important"; }
    if ((AllowInShowme(p104_important)) && (t_0 .p104_important == false)) { if (na++ > 0) print ", "; print "unimportant"; }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(workflag)) && (t_0  has workflag)) { if (na++ > 0) print ", "; print "marked for listing"; }
    if ((AllowInShowme(workflag)) && (t_0  hasnt workflag)) { if (na++ > 0) print ", "; print "unmarked for listing"; }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
    if ((AllowInShowme(transparent)) && (t_0  hasnt transparent)) { if (na++ > 0) print ", "; print "opaque"; }
    if ((AllowInShowme(transparent)) && (t_0  has transparent)) { if (na++ > 0) print ", "; print "transparent"; }
    if ((AllowInShowme(open)) && (t_0  has open)) { if (na++ > 0) print ", "; print "open"; }
    if ((AllowInShowme(open)) && (t_0  hasnt open)) { if (na++ > 0) print ", "; print "closed"; }
    if ((AllowInShowme(openable)) && (t_0  has openable)) { if (na++ > 0) print ", "; print "openable"; }
    if ((AllowInShowme(openable)) && (t_0  hasnt openable)) { if (na++ > 0) print ", "; print "unopenable"; }
    if ((AllowInShowme(lockable)) && (t_0  has lockable)) { if (na++ > 0) print ", "; print "lockable"; }
    if ((AllowInShowme(locked)) && (t_0  has locked)) { if (na++ > 0) print ", "; print "locked"; }
    if ((AllowInShowme(locked)) && (t_0  hasnt locked)) { if (na++ > 0) print ", "; print "unlocked"; }
    if ((AllowInShowme(p75_accessed)) && (t_0  has p75_accessed)) { if (na++ > 0) print ", "; print "accessed"; }
    if ((AllowInShowme(p75_accessed)) && (t_0  hasnt p75_accessed)) { if (na++ > 0) print ", "; print "unaccessed"; }
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(enterable)) && (t_0  has enterable)) { if (na++ > 0) print ", "; print "enterable"; }
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(female)) && (t_0  has female)) { if (na++ > 0) print ", "; print "female"; }
    if ((AllowInShowme(female)) && (t_0  hasnt female)) { if (na++ > 0) print ", "; print "male"; }
    if ((AllowInShowme(p88_boaty)) && (t_0 .p88_boaty == true)) { if (na++ > 0) print ", "; print "boaty"; }
    if ((AllowInShowme(p88_boaty)) && (t_0 .p88_boaty == false)) { if (na++ > 0) print ", "; print "unboaty"; }
    if ((AllowInShowme(p92_irked)) && (t_0 .p92_irked == true)) { if (na++ > 0) print ", "; print "irked"; }
    if ((AllowInShowme(p92_irked)) && (t_0 .p92_irked == false)) { if (na++ > 0) print ", "; print "calm"; }
    if ((AllowInShowme(p94_curious)) && (t_0 .p94_curious == true)) { if (na++ > 0) print ", "; print "curious"; }
    if ((AllowInShowme(p94_curious)) && (t_0 .p94_curious == false)) { if (na++ > 0) print ", "; print "incurious"; }
    if ((AllowInShowme(p108_trapped)) && (t_0 .p108_trapped == true)) { if (na++ > 0) print ", "; print "trapped"; }
    if ((AllowInShowme(p108_trapped)) && (t_0 .p108_trapped == false)) { if (na++ > 0) print ", "; print "free"; }
    if ((AllowInShowme(p125_asleep)) && (t_0 .p125_asleep == true)) { if (na++ > 0) print ", "; print "asleep"; }
    if ((AllowInShowme(p125_asleep)) && (t_0 .p125_asleep == false)) { if (na++ > 0) print ", "; print "awake"; }
}
if (t_0 ofclass K12_animal) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p110_roaming)) && (t_0 .p110_roaming == true)) { if (na++ > 0) print ", "; print "roaming"; }
    if ((AllowInShowme(p110_roaming)) && (t_0 .p110_roaming == false)) { if (na++ > 0) print ", "; print "still"; }
}
if (t_0 ofclass K13_device) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(on)) && (t_0  has on)) { if (na++ > 0) print ", "; print "switched on"; }
    if ((AllowInShowme(on)) && (t_0  hasnt on)) { if (na++ > 0) print ", "; print "switched off"; }
}
if (t_0 ofclass K14_vehicle) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p83_moved)) && (t_0  has p83_moved)) { if (na++ > 0) print ", "; print "moved"; }
    if ((AllowInShowme(p83_moved)) && (t_0  hasnt p83_moved)) { if (na++ > 0) print ", "; print "unmoved"; }
}
if (t_0 ofclass K15_player_s_holdall) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p63_chavailable)) && (t_0  has p63_chavailable)) { if (na++ > 0) print ", "; print "CHavailable"; }
    if ((AllowInShowme(p63_chavailable)) && (t_0  hasnt p63_chavailable)) { if (na++ > 0) print ", "; print "CHunavailable"; }
}
if (t_0 ofclass K20_wheel) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p116_spinning)) && (t_0 .p116_spinning == true)) { if (na++ > 0) print ", "; print "spinning"; }
    if ((AllowInShowme(p116_spinning)) && (t_0 .p116_spinning == false)) { if (na++ > 0) print ", "; print "stopped"; }
}
if (t_0 ofclass K27_lever) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p102_flipped_up)) && (t_0 .p102_flipped_up == true)) { if (na++ > 0) print ", "; print "flipped up"; }
    if ((AllowInShowme(p102_flipped_up)) && (t_0 .p102_flipped_up == false)) { if (na++ > 0) print ", "; print "flipped down"; }
}
if (t_0 ofclass K28_gizmo) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p98_fixed)) && (t_0 .p98_fixed == true)) { if (na++ > 0) print ", "; print "fixed"; }
    if ((AllowInShowme(p98_fixed)) && (t_0 .p98_fixed == false)) { if (na++ > 0) print ", "; print "broken"; }
}
if (t_0 ofclass K29_switch) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p102_flipped_up)) && (t_0 .p102_flipped_up == true)) { if (na++ > 0) print ", "; print "flipped up"; }
    if ((AllowInShowme(p102_flipped_up)) && (t_0 .p102_flipped_up == false)) { if (na++ > 0) print ", "; print "flipped down"; }
}
if (t_0 == I409_library_message_debug) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p69_dbg_on)) && (t_0  has p69_dbg_on)) { if (na++ > 0) print ", "; print "dbg_on"; }
    if ((AllowInShowme(p69_dbg_on)) && (t_0  hasnt p69_dbg_on)) { if (na++ > 0) print ", "; print "dbg_off"; }
}
if (t_0 == I489_large_painted_mural) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p90_peeled)) && (t_0 .p90_peeled == true)) { if (na++ > 0) print ", "; print "peeled"; }
    if ((AllowInShowme(p90_peeled)) && (t_0 .p90_peeled == false)) { if (na++ > 0) print ", "; print "unpeeled"; }
}
if (t_0 == I526_leaky_hose) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p96_plugged)) && (t_0 .p96_plugged == true)) { if (na++ > 0) print ", "; print "plugged"; }
    if ((AllowInShowme(p96_plugged)) && (t_0 .p96_plugged == false)) { if (na++ > 0) print ", "; print "unplugged"; }
}
if (t_0 == I534_security_gadget) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p100_secure)) && (t_0 .p100_secure == true)) { if (na++ > 0) print ", "; print "secure"; }
    if ((AllowInShowme(p100_secure)) && (t_0 .p100_secure == false)) { if (na++ > 0) print ", "; print "insecure"; }
}
if (t_0 == I589_wooden_drawer) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p106_upside_down)) && (t_0 .p106_upside_down == true)) { if (na++ > 0) print ", "; print "upside-down"; }
    if ((AllowInShowme(p106_upside_down)) && (t_0 .p106_upside_down == false)) { if (na++ > 0) print ", "; print "right-side-up"; }
}
if (t_0 == I701_cavity) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p118_accessible)) && (t_0 .p118_accessible == true)) { if (na++ > 0) print ", "; print "accessible"; }
    if ((AllowInShowme(p118_accessible)) && (t_0 .p118_accessible == false)) { if (na++ > 0) print ", "; print "inaccessible"; }
}
if (t_0 == I711_conductor) {if (na > 0) { na = 0; print "; "; }
    if ((AllowInShowme(p121_satisfied)) && (t_0 .p121_satisfied == true)) { if (na++ > 0) print ", "; print "satisfied"; }
    if ((AllowInShowme(p121_satisfied)) && (t_0 .p121_satisfied == false)) { if (na++ > 0) print ", "; print "unsatisfied"; }
    if ((AllowInShowme(p123_distracted)) && (t_0 .p123_distracted == true)) { if (na++ > 0) print ", "; print "distracted"; }
    if ((AllowInShowme(p123_distracted)) && (t_0 .p123_distracted == false)) { if (na++ > 0) print ", "; print "undistracted"; }
}
if (t_0) {if (na > 0) { na = 0; print "^"; }
    print "printed name: "; if (GProperty(OBJECT_TY, t_0, short_name) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, short_name), "~", "^";
    print "printed plural name: "; if (GProperty(OBJECT_TY, t_0, plural) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, plural), "~", "^";
    print "indefinite article: "; if (GProperty(OBJECT_TY, t_0, article) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, article), "~", "^";
}
if (t_0 ofclass K1_room) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (GProperty(OBJECT_TY, t_0, description) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, description), "~", "^";
    if (GProperty(OBJECT_TY, t_0, map_region)) { print "map region: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, map_region), "^";
    }
}
if (t_0 ofclass K2_thing) {if (na > 0) { na = 0; print "^"; }
    print "description: "; if (GProperty(OBJECT_TY, t_0, description) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, description), "~", "^";
    print "initial appearance: "; if (GProperty(OBJECT_TY, t_0, initial) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, initial), "~", "^";
    if (GProperty(OBJECT_TY, t_0, with_key)) { print "matching key: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, with_key), "^";
    }
}
if (t_0 ofclass K3_direction) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p9_opposite)) { print "opposite: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p9_opposite), "^";
    }
}
if (t_0 ofclass K4_door) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, door_to)) { print "other side: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, door_to), "^";
    }
}
if (t_0 ofclass K5_container) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K6_supporter) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
}
if (t_0 ofclass K8_person) {if (na > 0) { na = 0; print "^"; }
    print "carrying capacity: "; print (DecimalNumber) GProperty(OBJECT_TY, t_0, capacity), "^";
    if (GProperty(OBJECT_TY, t_0, p13_last_location)) { print "last location: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p13_last_location), "^";
    }
    print "apology: "; if (GProperty(OBJECT_TY, t_0, p17_apology) == EMPTY_TEXT_VALUE) print "none^"; else print "~", (PrintText) GProperty(OBJECT_TY, t_0, p17_apology), "~", "^";
}
if (t_0 ofclass K25_fluid_container) {if (na > 0) { na = 0; print "^"; }
    print "fluid capacity: "; print (T68) GProperty(OBJECT_TY, t_0, p14_fluid_capacity), "^";
    print "current volume: "; print (T68) GProperty(OBJECT_TY, t_0, p15_current_volume), "^";
    print "liquid: "; print (T70) GProperty(OBJECT_TY, t_0, p85_liquid), "^";
}
if (t_0 ofclass K26_liquid_source) {if (na > 0) { na = 0; print "^"; }
    print "fluid capacity: "; print (T68) GProperty(OBJECT_TY, t_0, p14_fluid_capacity), "^";
    print "current volume: "; print (T68) GProperty(OBJECT_TY, t_0, p15_current_volume), "^";
    print "liquid: "; print (T70) GProperty(OBJECT_TY, t_0, p85_liquid), "^";
}
if (t_0 == I439_steam_train) {if (na > 0) { na = 0; print "^"; }
    if (GProperty(OBJECT_TY, t_0, p16_station)) { print "station: "; print (PrintShortName) GProperty(OBJECT_TY, t_0, p16_station), "^";
    }
}

];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];

[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides KD_Count) {
		k = KindHierarchy-->((obj.KD_Count)*2);
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

[ AllowInShowme pr;
	if (pr == workflag or concealed or mentioned) rfalse;
	rtrue;
];

[ ShowVerbSub address lines meta i x;
	wn = 2; x = NextWordStopped();
    if (x == 0 || ((x->#dict_par1) & 1) == 0)
        "Try typing ~showverb~ and then the name of a verb.";
    meta = ((x->#dict_par1) & 2)/2;
    i = DictionaryWordToVerbNum(x);
    address = VM_CommandTableAddress(i);
    lines = address->0;
    address++;
    print "Verb ";
    if (meta) print "meta ";
    VM_PrintCommandWords(i);
    new_line;
    if (lines == 0) "has no grammar lines.";
    for (: lines>0 : lines--) {
        address = UnpackGrammarLine(address);
        print "    "; DebugGrammarLine(); new_line;
    }
    ParaContent();
];

[ DebugGrammarLine pcount;
    print " * ";
    for (: line_token-->pcount ~= ENDIT_TOKEN : pcount++) {
        if ((line_token-->pcount)->0 & $10) print "/ ";
        print (DebugToken) line_token-->pcount, " ";
    }
    print "-> ", (DebugAction) action_to_be;
    if (action_reversed) print " reverse";
];

[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
      ILLEGAL_TT:
        print "<illegal token number ", token, ">";
      ELEMENTARY_TT:
        switch (found_tdata) {
          NOUN_TOKEN:           print "noun";
          HELD_TOKEN:           print "held";
          MULTI_TOKEN:          print "multi";
          MULTIHELD_TOKEN:      print "multiheld";
          MULTIEXCEPT_TOKEN:    print "multiexcept";
          MULTIINSIDE_TOKEN:    print "multiinside";
          CREATURE_TOKEN:       print "creature";
          SPECIAL_TOKEN:        print "special";
          NUMBER_TOKEN:         print "number";
          TOPIC_TOKEN:          print "topic";
          ENDIT_TOKEN:          print "END";
        }
      PREPOSITION_TT:
        print "'", (address) found_tdata, "'";
      ROUTINE_FILTER_TT:
        print "noun=Routine(", found_tdata, ")";
      ATTR_FILTER_TT:
        print (DebugAttribute) found_tdata;
      SCOPE_TT:
        print "scope=Routine(", found_tdata, ")";
      GPR_TT:
        print "Routine(", found_tdata, ")";
    }
];

#Iftrue (0 > 0);

[ TestScriptSub;
	switch(special_word) {

	default:
		print ">--> The following tests are available:^";

	}
];

#ifdef TARGET_GLULX;
Constant TEST_STACK_SIZE = 128;
#ifnot;
Constant TEST_STACK_SIZE = 48;
#endif;

Array test_stack --> TEST_STACK_SIZE;
Global test_sp = 0;
[ TestStart T R l k;
	if (test_sp >= TEST_STACK_SIZE) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 0;
	test_stack-->(test_sp+3) = l;
	test_sp = test_sp + 4;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^"; say__p = 1;
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return VM_ReadKeyboard(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-4);
	    i = test_stack-->(test_sp-3);
	    l = test_stack-->(test_sp-1);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = test_stack-->2 + 1;
	    style bold;
	    while ((i < l) && (p->i ~= '/')) {
	    	ch = p->i;
	        if (spaced || (ch ~= ' ')) {
	        	if ((p->i == '[') && (p->(i+1) == '/') && (p->(i+2) == ']')) {
	        		ch = '/'; i = i+2;
	        	}
	            a_buffer->(j+WORDSIZE) = ch;
	            print (char) ch;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    VM_Tokenise(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i >= l) {
	        test_sp = test_sp - 4;
	    } else test_stack-->(test_sp-3) = i;
	}
];

#IFNOT;

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF;

[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];

[ TraceLevelSub;
    parser_trace = parsed_number; say__p = 1;
    print "[Parser tracing set to level ", parser_trace, ".]^";
];

[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];

[ XTreeSub i;
    if (noun == 0) {
        objectloop (i)
            if (i ofclass Object && parent(i) == 0) XObj(i);
    }
    else XObj(noun,1);
];

[ XObj obj f;
    if (parent(obj) == 0) print (name) obj; else print (a) obj;
    print " (", obj, ") ";
    if (f == 1 && parent(obj) ~= 0)
        print "(in ", (name) parent(obj), " ", parent(obj), ")";
    new_line;
    if (child(obj) == 0) rtrue;
    if (obj == Class)
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);
    else
        WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);
];

[ testcommandnoun obj o2;
	switch (scope_stage) {
		1: rtrue; ! allow multiple objects
		2: objectloop (obj)
        	if ((obj ofclass Object) && (obj provides KD_Count))
            	PlaceInScope(obj, true);
        3: print "There seems to be no such object anywhere in the model world.^";
    }
];

Verb meta 'abstract'

    * scope=testcommandnoun 'to' scope=testcommandnoun -> XAbstract;
Verb meta 'actions'

    *                                           -> ActionsOn
    * 'on'                                      -> ActionsOn
    * 'off'                                     -> ActionsOff;
Verb meta 'gonear'

    * scope=testcommandnoun                     -> Gonear;
Verb meta 'purloin'

    * scope=testcommandnoun                     -> XPurloin;
Verb meta 'random'

    *                                           -> Predictable;
Verb meta 'relations'

	*                                           -> ShowRelations;
Verb meta 'rules'

	*                                           -> RulesOn
	* 'all'                                     -> RulesAll
	* 'on'                                      -> RulesOn
	* 'off'                                     -> RulesOff;
Verb meta 'scenes'

	*                                           -> ScenesOn
	* 'on'                                      -> ScenesOn
	* 'off'                                     -> ScenesOff;
Verb meta 'scope'

    *                                           -> Scope
    * scope=testcommandnoun                     -> Scope;
Verb meta 'showheap'

	*                                           -> ShowHeap;
Verb meta 'showme'

	*                                           -> ShowMe
	* scope=testcommandnoun                     -> ShowMe;
Verb meta 'showverb'

    * special                                   -> Showverb;
Verb meta 'test'

	*                                           -> TestScript
	* special                                   -> TestScript;
Verb meta 'trace'

    *                                           -> TraceOn
    * number                                    -> TraceLevel
    * 'on'                                      -> TraceOn
    * 'off'                                     -> TraceOff;
Verb meta 'tree'

    *                                           -> XTree
    * scope=testcommandnoun                     -> XTree;

[ InternalTestCases;
];

#ENDIF; ! DEBUG

! "Include (- ... -)" inclusions with no specified position appear here.


	[ CheckDPMR result sinp1 sinp2 rv;
		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 26 );
		inp1 = sinp1; inp2 = sinp2;
		if ((rv) && RulebookSucceeded()) {
			result = ResultOfRule();
			if (result == RBNO_6 ) return 4;
			if (result == RBNO_7 ) return 3;
			if (result == RBNO_8 ) return 2;
			if (result == RBNO_9 ) return 1;
			if (result == RBNO_10 ) return 0;
		}
		return 2;
	];

[ LITTLE_USED_DO_NOTHING_R; rfalse; ];


#ifndef printed_text;
Array printed_text buffer 256;
#endif;

[ Decapitalize item depth i j ch; 
!	@output_stream 3 printed_text;
!	print (the) item;
!	@output_stream -3;
	j = VM_PrintToBuffer(printed_text, 256, DefArt, item);
!	j = printed_text-->0;
	for (i=WORDSIZE:i<(j+WORDSIZE):i++)
	{
		ch = VM_UpperToLowerCase(printed_text->i);
!		if (ch < 97 && ch > 64) ch = ch + 32;
		print (char) ch;
	}
];

[ StringDecap item depth i j ch; 
!	@output_stream 3 printed_text;
!	print (string) item;
!	@output_stream -3;
	j = VM_PrintToBuffer(printed_text, 256, item);
!	j = printed_text-->0;
	for (i=WORDSIZE:i<(j+WORDSIZE):i++)
	{
		ch = VM_UpperToLowerCase(printed_text->i);
!		if (ch < 97 && ch > 64) ch = ch + 32;
		print (char) ch;
	}
];


[ Capitalize item depth i j ch; 
!	@output_stream 3 printed_text;
!	print (the) item;
!	@output_stream -3;
!	j = printed_text-->0;
	j = VM_PrintToBuffer(printed_text, 256, DefArt, item);
	for (i=WORDSIZE:i<(j+WORDSIZE):i++)
	{
		ch = VM_LowerToUpperCase(printed_text->i);
!		if (ch > 96) ch = ch - 32;
		print (char) ch;
	}
];

[ StringCap item depth i j ch; 
!	@output_stream 3 printed_text;
!	print (string) item;
!	@output_stream -3;
!	j = printed_text-->0;
	j = VM_PrintToBuffer(printed_text, 256, item);
	for (i=WORDSIZE:i<(j+WORDSIZE):i++)
	{
		ch = VM_LowerToUpperCase(printed_text->i);
!		if (ch > 96) ch = ch - 32;
		print (char) ch;
	}
];
 
 Constant CONSIDERATE_HOLDALL; 
[ TestingNoun;
	if (parameters > 0 || look_ahead) 
	{
!		print "[testing second]^";
		rfalse;
	}
!	print "[testing noun]^";
	rtrue;
];



[ ParserMessage n m;
!	print "--- ", n, " ----^";

! we swap messages if we're in indef mode

	if (indef_wanted > 0)
	{
		m = 0;
		switch(n)
		{	
			2:  	m = 6;
			3:  	m = 7;
			4: 	m = 8;
			5: 	m = 9;
		}
		if (m > 0)	! m had better never equal any of the values listed above!!
		{
			ParserMessage(1);
			ParserMessage(m);
			rtrue;
		}
		
	}


	(Global_Vars-->12) = n;
	R_906();

];

[ ActorOrPlayer i;
	 i = 1;
       if (actor~=player) print " ", (the) actor; 
	#ifdef FIRST_PERSON;
		if (actor == player) print " me";
	#endif;
];


[ PrintOrConstruct ;

 	if (~~look_ahead) PrintCommand();
	else if (action_to_be == ##Remove) ParserMessage(20);
	else if (action_to_be == ##Insert) ParserMessage(21);
	else if (action_to_be == ##PutOn) ParserMessage(22);

! to get here, the user must have created a new action with the Multi_held or multi_inside tokens.
! We'll have to let the parser do the best it can

! if we get strange messages for new actions, this might be the place to add something in!!

	else PrintCommand();

];



[ MatchListGuessing;
	return IncludedInMatchList(0);
];

[ IncludedInMatchList
obj excl_flag
 i 
;
if (obj == 0) obj = I92_no_object;

for (i = 0: i< number_matched : i++)
{ 	!print " ", (the) match_list-->i;
	if (match_list-->i == obj) 
		if (excl_flag == 0 || (excl_flag == 1 && number_matched == 2))  rtrue;
}	

rfalse;
];

[MatchListEntry N;
	if ( N > number_matched) return I92_no_object;
	return match_list-->(N-1);
];




[ SmartScoreDabCombo a b  result;

	if (guessing) rfalse;	

	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = SmartCheckDPMR();
	#ifdef COBJ_DEBUG;
	print "[smart: ", (the) noun, " / ", (the) second, " => ", result, "]^";
	#endif;
	@pull second; @pull noun; @pull act_requester; @pull action;

	return result;
];

	[ SmartCheckDPMR result sinp1 sinp2 rv;

		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 397 );
		inp1 = sinp1; inp2 = sinp2;
		if (RulebookSucceeded()) { ! was (rv) &&
			result = ResultOfRule();
			if (result == RBNO_16 ) return 9;
			if (result == RBNO_17 ) return 8;
			if (result == RBNO_18 ) return 7;
!			if (result == RBNO_8 ) return 6;
			if (result == RBNO_19 ) return -1;
		}
		rfalse;
	];



[ GuessScoreDabCombo a b context varying_item result;
	@push action; @push act_requester; @push noun; @push second;
	action = action_to_be;
	act_requester = player;
	if (action_reversed) { noun = b; second = a; }
	else { noun = a; second = b; }
	result = GuessCheckDPMR();

	if (context == CREATURE_TOKEN)
	{
	#ifdef COBJ_DEBUG;
		print "^(checking a creature context with v-i ", varying_item, ")^";
	#endif;
		if 	(	(varying_item == 1 && a has animate)
			||	(varying_item == 2 && b has animate)
			)	
			{
			
				#ifdef COBJ_DEBUG;
					print "(adjudicating creature context from ", result, " up to ", MaxOf(result, 3), ".)^";
				#endif;			
				result = MaxOf(result, 3);
			}
	}

	#ifdef COBJ_DEBUG;
	print "[guess: ", (the) noun, " / ", (the) second, " => ", result, "]^";
	#endif;
	@pull second; @pull noun; @pull act_requester; @pull action;

	return result;
];

[ MaxOf a b;
	if (a > b) return a; return b;
];

	[ GuessCheckDPMR result sinp1 sinp2 rv;

!	if (inp1 == 0 && inp2 ~= 0 && multiple_object-->0 > 0) print "(Made a multiple list!)^";

		sinp1 = inp1; sinp2 = inp2; inp1 = noun; inp2 = second;
		rv = FollowRulebook( 398 );
		inp1 = sinp1; inp2 = sinp2;
		if (RulebookSucceeded()) { ! was (rv) &&
			result = ResultOfRule();
			if (result == RBNO_20 ) return 4;
			if (result == RBNO_21 ) return 3;
			if (result == RBNO_22 ) return 2;
			

			if (result == RBNO_19 ) 
			{	
				if (~~guessing) return -2; 	! only ever return this when not guessing. 
										! Otherwise, same as impossible, which falls through
			}
		}

! so either we had no information or  the (result == RBNO_23 ) 

! if guessing, we want no list and no default

		 if (guessing)  return -1;

! if not guessing, we want list and default but not good ones.
! recall that this is the bottom of the scoring tree so we can afford to give it a score.

		 return 1;

	];


[ ChooseObjectsBypassDisambiguate rv;

		rv = FollowRulebook( 399 );
		if (RulebookSucceeded() && ResultOfRule() == RBNO_24) 
		{
!			print "(bypass disambig: Rulebook succeeded.)^";

			rfalse;
		}
!		print "(bypass disambig: Rulebook not succeeded.)^";
		rtrue;
];



[ ResolveChooseScores expectation_score preference_score;

! print "Resolving: ", noun_set_score, " / ", expectation_score , " / ", preference_score, "^";

! if guessing, this is easy
	if (guessing) 
	{
		if (expectation_score >= 3) (Global_Vars-->14) = true; 	! we've scored high enough to list what we found
		return expectation_score;
	}

! otherwise, we take individual score, then noun subset score, then guess score


       if (expectation_score == -2) return -1;
							! if the combination is declared "always impossible"
							! this takes absolute priority over everything else and we delete


	if (expectation_score > 0)		! 0 => it was a "bad" suggestion, which isn't good enough to print a list
		(Global_Vars-->14) = true; 	! this is automatically high enough to qualify now, because either we found a preference rule
								! (okay, so later these might include "unlikely" but they don't for now)
								! or we found bad-at-worst, which we still list


       if (preference_score ~= 0) 
		return preference_score;			! preference_score =-1 is a good return score for individual stuff

	if (expectation_score ~= -1) 	return expectation_score;
						! otherwise we use the guess score, but we never delete!

	rfalse;				! so we tell the score system nothing


];


[ LibraryMessagesBefore id isImplicitAction;
  id = -1;
  (Global_Vars-->17) = lm_o;
  (Global_Vars-->18) = lm_o2;

Miscellany:
    switch (lm_n) {
       1: id = I143_libmsg__first_n_objects;
       2: id = I142_libmsg__zero_multiple_o;
       3: id = I94_libmsg__you_have_died_;
       4: id = I95_libmsg__you_have_won_;
     ! 5 is "Would you like to restart ...", handled specially by Inform 7
       6: id = I108_libmsg__undo_not_provid;
       7: id = I107_libmsg__undo_failed_;
       8: id = I101_libmsg__restrict_answer;
       9: id = I187_libmsg__entering_darkne;
       10: id = I98_libmsg__empty_line_;
       11: id = I109_libmsg__cannot_undo_not;
       12: id = I110_libmsg__cannot_undo_twi;
       13: id = I106_libmsg__undo_succeeded_;
       14: id = I112_libmsg__oops_failed_;
       15: id = I114_libmsg__oops_no_argumen;
       16: id = I113_libmsg__oops_too_many_a;
       17: id = I188_libmsg__dark_descriptio;
       18: id = I96_libmsg__player_self_desc;
     ! 19 was LibMsg <player description>
	 ! - use "The description of the player is ..." instead
       20: id = I116_libmsg__again_usage_;
       21: id = I115_libmsg__cannot_do_again;
       22: id = I123_libmsg__cannot_begin_at;
       23: id = I161_libmsg__cannot_talk_to_;
       24: id = I162_libmsg__cannot_talk_to_;
       25: id = I124_libmsg__extra_words_bef;
       26: id = I145_libmsg__report_implicit;
       27: id = I117_libmsg__command_not_und;
       28: id = I118_libmsg__command_partly_;
       29: id = I122_libmsg__number_not_unde;
       30: id = I125_libmsg__unknown_object_;

       31: id = I120_libmsg__command_incompl;
       32: id = I126_libmsg__object_not_held;
       33: id = I138_libmsg__verb_cannot_hav;
       34: id = I139_libmsg__too_many_multip;
       35: id = I154_libmsg__pronoun_not_set;
       36: id = I144_libmsg__excepted_object;
       37: id = I128_libmsg__verb_cannot_hav;
       38: id = I127_libmsg__unknown_verb_;
       39: id = I97_libmsg__unimportant_obje;
       40: (Global_Vars-->17) = pronoun_obj;
	       id = I155_libmsg__pronoun_absent_;
       41: id = I119_libmsg__command_badly_e;
       42: id = I140_libmsg__not_that_many_a;
       43: id = I142_libmsg__zero_multiple_o; ! same as Miscellany #2 (?)
       44: id = I141_libmsg__no_objects_avai;
       45: id = I149_libmsg__who_disambiguat;
       46: id = I150_libmsg__which_disambigu;
       47: id = I153_libmsg__single_object_d;
       48: (Global_Vars-->17) = actor;
	       id = I151_libmsg__whom_disambigua;
       49: (Global_Vars-->17) = actor;
	       id = I152_libmsg__what_disambigua;
       50: id = I179_libmsg__score_changed_;
       51: id = I121_libmsg__command_cut_sho;
       52: id = I103_libmsg__menu_prompt_;
       53: id = I102_libmsg__page_prompt_;
       54: id = I104_libmsg__comment_recorde;
       55: id = I105_libmsg__comment_not_rec;
     ! 56 = ".^"
     ! 57 = "?^"
       58: id = I163_libmsg__npc_unable_to_d;
       59: id = I129_libmsg__noun_needed_;
       60: id = I130_libmsg__noun_not_needed;
       61: id = I131_libmsg__object_needed_;
       62: id = I132_libmsg__object_not_need;
       63: id = I133_libmsg__second_object_n;
       64: id = I134_libmsg__second_object_n;
       65: id = I135_libmsg__second_noun_nee;
       66: id = I136_libmsg__second_noun_not;
       67: id = I137_libmsg__something_more_;
       68: id = I146_libmsg__report_npc_impl;
       69: id = I145_libmsg__report_implicit;
       70: id = I111_libmsg__undo_forbidden_;
       71: id = I192_libmsg__dark_room_name_;
       72: id = I160_libmsg__person_ignores_;
    }
    jump end_part;

Quit:
    switch (lm_n) {
       1: id = I100_libmsg__yes_or_no_promp;
       2: id = I99_libmsg__confirm_quit_;
    }
    jump end_part;

Restart:
    switch (lm_n) {
       1: id = I164_libmsg__confirm_restart;
       2: id = I165_libmsg__restart_failed_;
    }
    jump end_part;


Restore:
    switch (lm_n) {
       1: id = I166_libmsg__restore_failed_;
       2: id = I167_libmsg__restore_succeed;
    }
    jump end_part;

Save:
    switch (lm_n) {
       1: id = I168_libmsg__save_failed_;
       2: id = I169_libmsg__save_succeeded_;
    }
    jump end_part;

Verify:
    switch (lm_n) {
       1: id = I170_libmsg__verify_succeede;
       2: id = I171_libmsg__verify_failed_;
    }
    jump end_part;

ScriptOn:
    switch (lm_n) {
       1: id = I172_libmsg__transcript_alre;
       2: id = I174_libmsg__start_of_transc;
       3: id = I176_libmsg__transcript_fail;
    }
    jump end_part;

ScriptOff:
    switch (lm_n) {
       1: id = I173_libmsg__transcript_alre;
       2: id = I175_libmsg__end_of_transcri;
       3: id = I177_libmsg__end_transcript_;
    }
    jump end_part;

NotifyOn:
     id = I180_libmsg__score_notificat;
    jump end_part;
 
NotifyOff:
     id = I181_libmsg__score_notificat;
    jump end_part;
 
Score:
    switch (lm_n) {
       1: id = I178_libmsg__score_command_;
       2: id = I182_libmsg__no_scoring_;
       3: id = I183_libmsg__score_rank_;
    }
    jump end_part;
 
Pronouns:
    switch (lm_n) {
       1: id = I156_libmsg__pronouns_initia;
       2: id = I157_libmsg__pronouns__means;
       3: id = I158_libmsg__pronouns__unset;
       4: id = I159_libmsg__no_pronouns_kno;
    }
    jump end_part;

Inv:
    switch (lm_n) {
       1: id = I186_libmsg__inventory_no_po;
       2: id = I185_libmsg__inventory_initi;
     ! 3 is ":^" (used for list style NEWLINE_BIT)
     ! 4 is ".^" (used for list style ENGLISH_BIT)
       5: id = I184_libmsg__report_npc_taki;
    }
    jump end_part;

Take:
    switch (lm_n) {
       1: id = I193_libmsg__report_player_t;
       2: id = I195_libmsg__cannot_take_you;
       3: id = I196_libmsg__cannot_take_oth;
       4: id = I197_libmsg__cannot_take_som;
       5: id = I198_libmsg__cannot_take_som;
       6: id = I199_libmsg__cannot_take_pos;
       7: id = I200_libmsg__cannot_take_com;
       8: id = I201_libmsg__cannot_take_hid;
       9: id = I202_libmsg__cannot_reach_wi;
       10: id = I203_libmsg__cannot_take_sce;
       11: id = I204_libmsg__cannot_take_som;
       12: id = I206_libmsg__cannot_exceed_c;
       13: id = I147_libmsg__use_holdall_to_;
           isImplicitAction = 1;
       14: id = I205_libmsg__cannot_reach_wi;
     ! 15 doesn't seem to be produced anywhere ("You cannot carry ...")
       16: id = I194_libmsg__report_npc_taki;
    }
    jump end_part;

Remove:
    switch (lm_n)
    {  1: id = I209_libmsg__cannot_remove_f;
       2: id = I210_libmsg__cannot_remove_s;
       3: id = I207_libmsg__report_player_r; ! TODO - not printed any more? ("Taken" instead)
    }
    jump end_part;

Drop:
    switch (lm_n) {
       1: id = I213_libmsg__cannot_drop_som;
       2: id = I214_libmsg__cannot_drop_not;
       3: id = I216_libmsg__cannot_drop_clo;
           isImplicitAction = 1;
       4: id = I211_libmsg__report_player_d;
       5,6: id = I215_libmsg__cannot_drop_if_;   ! 5 = supporter, 6 = container
       7: id = I212_libmsg__report_npc_drop;
    }
    jump end_part;

Insert:
    switch (lm_n) {
       1: id = I219_libmsg__cannot_insert_s;
       2: id = I220_libmsg__cannot_insert_i;
       3: id = I221_libmsg__cannot_insert_i;
       4: id = I222_libmsg__need_to_take_of;   ! (unused ?)
       5: id = I223_libmsg__cannot_insert_s;
       6: id = I225_libmsg__cannot_insert_c;
           isImplicitAction = 1;
       7: id = I224_libmsg__cannot_insert_i;
       8,9: id = I217_libmsg__report_player_i;  ! 8 is for multiple objects
       10: id = I218_libmsg__report_npc_inse;
    }
    jump end_part;

PutOn:
    switch (lm_n) {
       1: id = I228_libmsg__cannot_put_some;
       2: id = I229_libmsg__cannot_put_some;
       3: id = I230_libmsg__cannot_put_onto;
       4: id = I231_libmsg__cannot_put_onto;
       5: id = I232_libmsg__cannot_put_clot;
           isImplicitAction = 1;
       6: id = I148_libmsg__cannot_put_if_t;
      7,8: id = I226_libmsg__report_player_p;  ! 7 is for multiple objects
       9: id = I227_libmsg__report_npc_putt;
    }
    jump end_part;

Give:
    switch (lm_n) {
       1: id = I236_libmsg__cannot_give_wha;
       2: id = I237_libmsg__cannot_give_to_;
       3: id = I238_libmsg__block_giving_;
       4: id = I239_libmsg__unable_to_recei;
       5: id = I233_libmsg__report_player_g;
       6: id = I234_libmsg__report_npc_givi;  
       7: id = I235_libmsg__report_npc_givi;
   }
    jump end_part;

Show:
    switch (lm_n) {
       1: id = I240_libmsg__cannot_show_wha;
       2: id = I241_libmsg__block_showing_;
    }
    jump end_part;

Enter:
    switch (lm_n) {
       1: id = I244_libmsg__cannot_enter_so;
       2: id = I245_libmsg__cannot_enter_so;
       3: id = I246_libmsg__cannot_enter_cl;
       4: id = I247_libmsg__cannot_enter_so;
       5: id = I242_libmsg__report_player_e;
       6: id = I248_libmsg__implicitly_pass;
          isImplicitAction = 1;
       7: id = I249_libmsg__implicitly_pass;
           isImplicitAction = 1;
       8,9: id = I243_libmsg__report_npc_ente;  ! 8 = container, 9 = supporter
    }
    jump end_part;

Exit:
    switch (lm_n) {
       1: id = I252_libmsg__cannot_exit_whe;
       2: id = I253_libmsg__cannot_exit_clo;
       3: id = I250_libmsg__report_player_e;
       4: id = I255_libmsg__cannot_exit_thi;
       5,6: id = I251_libmsg__report_npc_exit;
    }
    jump end_part;

GetOff:
    id = I254_libmsg__cannot_get_off_;
    jump end_part;

Go:
    switch (lm_n) {
       1: id = I257_libmsg__cannot_travel_i;
       2: id = I256_libmsg__cannot_go_that_;
          (Global_Vars-->17) = noun;   ! the direction
       3: id = I259_libmsg__cannot_go_up_th;
       4: id = I260_libmsg__cannot_go_down_;
       5: id = I261_libmsg__cannot_go_throu;
       6: id = I262_libmsg__nothing_through;
       7: id = I263_libmsg__block_vaguely_g;
       8: id = I264_libmsg__say_npc_goes_;
         (Global_Vars-->17) = I54_up;
       9: id = I264_libmsg__say_npc_goes_;
         (Global_Vars-->17) = I55_down;
       10: id = I264_libmsg__say_npc_goes_;
       11: id = I265_libmsg__say_npc_arrives;
         (Global_Vars-->17) = I54_up;
       12:  id = I265_libmsg__say_npc_arrives;
         (Global_Vars-->17) = I55_down;
       13:  id = I265_libmsg__say_npc_arrives;
       14: id = I266_libmsg__say_npc_arrives;
       15: id = I267_libmsg__say_npc_arrives;
         (Global_Vars-->18) = I54_up;
       16: id = I267_libmsg__say_npc_arrives;
         (Global_Vars-->18) = I55_down;
       17: id = I267_libmsg__say_npc_arrives;
          ! secondary object already defined
       18: id = I268_libmsg__say_npc_goes_th;
       19: id = I269_libmsg__say_npc_arrives;
       20,21: id = I270_libmsg__say_npc_vehicle;
       22: id = I271_libmsg__say_npc_pushing;
       23: id = I272_libmsg__say_npc_pushing;
       24: id = I273_libmsg__say_npc_pushing;
       25: id = I274_libmsg__say_npc_pushing;
       26: id = I275_libmsg__say_npc_taking_;
    }
    jump end_part;

LMode1:
    id = I276_libmsg__brief_look_mode;
    jump end_part;

LMode2:
    id = I278_libmsg__verbose_look_mo;
    jump end_part;

LMode3:
    id = I277_libmsg__superbrief_look;
    jump end_part;

Look:
    switch (lm_n) {
       1: id = I280_libmsg__top_line_what_o;
       2: id = I281_libmsg__top_line_what_i;
       3: id = I282_libmsg__top_line_what_a;
       4: id = I285_libmsg__say_things_on_;
       5: id = I284_libmsg__say_things_also;
       6: id = I283_libmsg__say_things_with;
       8: if (lm_o has supporter) id = I280_libmsg__top_line_what_o;
          else id = I281_libmsg__top_line_what_i;
       9: id = I279_libmsg__report_npc_look;
    }
    jump end_part;

Examine:
    switch (lm_n) {
       1: id = I189_libmsg__examine_while_d;
       2: id = I287_libmsg__examine_undescr;
       3: id = I289_libmsg__examine_devices;
       4: id = I286_libmsg__report_npc_exam;
       5: id = I288_libmsg__examine_directi;
    }
    jump end_part;

Search:
    switch (lm_n) {
       1: id = I190_libmsg__search_while_da;
       2: id = I295_libmsg__nothing_found_o;
     ! 3 prints what is on a supporter; use I6 default behaviour
       4: id = I292_libmsg__cannot_search_u;
       5: id = I293_libmsg__cannot_search_c;
       6: id = I294_libmsg__nothing_found_w;
     ! 7 prints the contents of a container; use I6 default behaviour
       8: id = I291_libmsg__report_npc_sear;
    }
    jump end_part;

LookUnder:
   switch (lm_n) {
       1: id = I191_libmsg__look_under_whil;
       2: id = I298_libmsg__look_under_;
       3: id = I297_libmsg__report_npc_look;
    }
    jump end_part;

Open:
    switch (lm_n) {
       1: id = I303_libmsg__cannot_open_unl;
       2: id = I304_libmsg__cannot_open_som;
       3: id = I305_libmsg__cannot_open_som;
       4: id = -2; ! reveal any newly visible exterior
       5: id = I300_libmsg__report_player_o;
       6: id = I301_libmsg__report_npc_open;
       7: id = I302_libmsg__report_unseen_n;
    }
    jump end_part;

Close:
    switch (lm_n) {
       1: id = I311_libmsg__cannot_close_un;
       2: id = I312_libmsg__cannot_close_so;
       3: id = I308_libmsg__report_player_c;
       4: id = I309_libmsg__report_npc_clos;
       5: id = I310_libmsg__report_unseen_n;
    }
    jump end_part;

Lock:
    switch (lm_n) {
       1: id = I315_libmsg__cannot_lock_wit;
       2: id = I316_libmsg__cannot_lock_som;
       3: id = I317_libmsg__cannot_lock_som;
       4: id = I318_libmsg__cannot_lock_wit;
       5: id = I313_libmsg__report_player_l;
       6: id = I314_libmsg__report_npc_lock;
    }
    jump end_part;

Unlock:
    switch (lm_n) {
       1: id = I321_libmsg__cannot_unlock_w;
       2: id = I322_libmsg__cannot_unlock_s;
       3: id = I323_libmsg__cannot_unlock_w;
       4: id = I319_libmsg__report_player_u;
       5: id = I320_libmsg__report_npc_unlo;
    }
    jump end_part;

SwitchOn:
    switch (lm_n) {
       1: id = I326_libmsg__cannot_switch_o;
       2: id = I327_libmsg__cannot_switch_o;
       3: id = I324_libmsg__report_player_s;
       4: id = I325_libmsg__report_npc_swit;
    }
    jump end_part;

SwitchOff:
    switch (lm_n) {
       1: id = I330_libmsg__cannot_switch_o;
       2: id = I331_libmsg__cannot_switch_o;
       3: id = I328_libmsg__report_player_s;
       4: id = I329_libmsg__report_npc_swit;
    }
    jump end_part;

Wear:
    switch (lm_n) {
       1: id = I334_libmsg__cannot_wear_som;
       2: id = I335_libmsg__cannot_wear_not;
       3: id = I336_libmsg__cannot_wear_som;
       4: id = I332_libmsg__report_player_w;
       5: id = I333_libmsg__report_npc_wear;
    }
    jump end_part;

Disrobe:
    switch (lm_n) {
       1: id = I339_libmsg__cannot_take_off;
       2: id = I337_libmsg__report_player_t;
       3: id = I338_libmsg__report_npc_taki;
    }
    jump end_part;

Eat:
    switch (lm_n) {
       1: id = I342_libmsg__cannot_eat_unle;
       2: id = I340_libmsg__report_player_e;
       3: id = I341_libmsg__report_npc_eati;
    }
    jump end_part;
Drink:
    id = I343_libmsg__block_drinking_;
    jump end_part;
Taste:
    id = I344_libmsg__block_tasting_;
    jump end_part;
Smell:
    id = I345_libmsg__block_smelling_;
    jump end_part;
Listen:
    id = I346_libmsg__block_listening;
    jump end_part;
Touch:
    switch (lm_n) {
       1: id = I351_libmsg__report_player_t;
       2: id = I347_libmsg__report_player_t;
       3: id = I349_libmsg__report_player_t;
       4: id = I350_libmsg__report_npc_touc;
	 ! 5 is for touching the player, 6 is for another NPC
       5,6: id = I352_libmsg__report_npc_touc;
    }
    jump end_part;

Yes:
    id = I353_libmsg__block_saying_ye;
    jump end_part;
No:
    id = I354_libmsg__block_saying_no;
    jump end_part;
Sorry:
    id = I355_libmsg__block_saying_so;
    jump end_part;
Strong:
    id = I356_libmsg__block_swearing_;
    jump end_part;
Mild:
    id = I357_libmsg__block_swearing_;
    jump end_part;

Climb:
    id = I358_libmsg__block_climbing_;
    jump end_part;
Jump:
    id = I359_libmsg__block_jumping_;
    jump end_part;
Swing:
    id = I360_libmsg__block_swinging_;
    jump end_part;
WaveHands:
    id = I361_libmsg__block_waving_ha;
    jump end_part;

Attack:
    id = I362_libmsg__block_attacking;
    jump end_part;
Burn:
    id = I363_libmsg__block_burning_;
    jump end_part;
Cut:
    id = I364_libmsg__block_cutting_;
    jump end_part;
Rub:
    id = I365_libmsg__block_rubbing_;
    jump end_part;
SetTo:
    id = I366_libmsg__block_setting_t;
    jump end_part;
Tie:
    id = I367_libmsg__block_tying_;
    jump end_part;

Wave:
    switch (lm_n) {
       1: id = I370_libmsg__cannot_wave_som;
       2: id = I368_libmsg__report_player_w;
       3: id = I369_libmsg__report_npc_wavi;
    }
    jump end_part;

Squeeze:
    switch (lm_n) {
       1: id = I371_libmsg__squeezing_peopl;
       2: id = I372_libmsg__report_player_s;
       3: id = I373_libmsg__report_npc_sque;
    }
    jump end_part;

ThrowAt:
    switch (lm_n) {
       1: id = I375_libmsg__throw_at_inanim;
       2: id = I374_libmsg__block_throwing_;
    }
    jump end_part;

Push:
    switch (lm_n) {
       1: id = I385_libmsg__cannot_push_som;
       2: id = I388_libmsg__cannot_push_sce;
       3: id = I376_libmsg__report_player_p;
       4: id = I391_libmsg__cannot_push_peo;
     ! 5 does not apply to Push
       6:  id = I377_libmsg__report_npc_push;
    }
    jump end_part;

PushDir:
    switch (lm_n) {
       1: id = I382_libmsg__block_pushing_i;
       2: id = I383_libmsg__not_pushed_in_a;
       3: id = I384_libmsg__pushed_in_illeg;
    }
    jump end_part;

Pull:
    switch (lm_n) {
       1: id = I386_libmsg__cannot_pull_som;
       2: id = I389_libmsg__cannot_pull_sce;
       3: id = I378_libmsg__report_player_p;
       4: id = I392_libmsg__cannot_pull_peo;
       5: id = I379_libmsg__report_npc_pull;
    }
    jump end_part;

Turn:
    switch (lm_n) {
       1: id = I387_libmsg__cannot_turn_som;
       2: id = I390_libmsg__cannot_turn_sce;
       3: id = I380_libmsg__report_player_t;
       4: id = I393_libmsg__cannot_turn_peo;
     ! 5,6 do not apply to Turn
       7: id = I381_libmsg__report_npc_turn;
    }
    jump end_part;

Answer:
    id = I394_libmsg__block_answering;
    jump end_part;
Ask:
    id = I395_libmsg__block_asking_;
    jump end_part;
Buy:
    id = I396_libmsg__block_buying_;
    jump end_part;
Kiss:
    id = I397_libmsg__block_kissing_;
    jump end_part;
Sing:
    id = I398_libmsg__block_singing_;
    jump end_part;
Tell:
    switch (lm_n) {
       1: id = I400_libmsg__telling_yoursel;
       2: id = I399_libmsg__block_telling_;
    }
    jump end_part;

Think:
    id = I401_libmsg__block_thinking_;
    jump end_part;

Consult:
    switch (lm_n) {
       1: id = I402_libmsg__block_player_co;
       2: id = I403_libmsg__block_npc_consu;
    }
    jump end_part;

Sleep:
    id = I404_libmsg__block_sleeping_;
    jump end_part;

Wait:
    switch (lm_n) {
       1: id = I407_libmsg__report_player_w;
       2: id = I408_libmsg__report_npc_wait;
    }
    jump end_part;

Wake:
    id = I405_libmsg__block_waking_up;
    jump end_part;

WakeOther:
    id = I406_libmsg__block_waking_ot;
    jump end_part;

default:
.end_part;
    if (id == -1) { rfalse; }

    if (id == -2)  {
        R_935();
		rtrue;
    }
    else {
       (Global_Vars-->15) = id;
       R_919();

	   return (Global_Vars-->16);
    }
];


[ PlugPlural obj;
	SetPronoun('them', obj);
	SetPronoun('it', obj);
];

 

[ Detitler i j buffer_length flag; 

#ifdef TARGET_ZCODE;
	buffer_length = buffer->1+(WORDSIZE-1);
#endif;
#ifdef TARGET_GLULX;
	buffer_length = (buffer-->0)+(WORDSIZE-1);
#endif; 
	for (i = WORDSIZE : i <= buffer_length: i++)
	{ 
		if ((buffer->i) == '.' && (i > WORDSIZE + 1)) 
		{ 
			! flag if the period follows Mr, Mrs, Dr, prof, rev, or st
			!
			! This is hackish, but our hearts are pure
			
			if ((buffer->(i-1)=='r') && (buffer->(i-2)=='m') && ((buffer->(i-3)==' ') || ((i-3) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='r') && (buffer->(i-2)=='d') && ((buffer->(i-3)==' ') || ((i-3) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='t') && (buffer->(i-2)=='s') && ((buffer->(i-3)==' ') || ((i-3) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='s') && (buffer->(i-2)=='r') && (buffer->(i-3)=='m') && ((buffer->(i-4)==' ') || ((i-4) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='v') && (buffer->(i-2)=='e') && (buffer->(i-3)=='r') && ((buffer->(i-4)==' ') || ((i-4) < WORDSIZE))) flag = 1;
			if ((buffer->(i-1)=='f') && (buffer->(i-2)=='o') && (buffer->(i-3)=='r') && (buffer->(i-4)=='p') && ((buffer->(i-5)==' ') || ((i-5) < WORDSIZE))) flag = 1;
			if (flag) buffer->i = ' ';   
		}
	}
	VM_Tokenise(buffer, parse);
]; 



[ BufferOut i;   
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{  
		print (char) (buffer->i);
	} 
];

[ PunctuationStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '"' or '?' or '!') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ SingleQuoteStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)	{ 
		if ((buffer->i) == 39) 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];

[ QuoteStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)	{ 
		if ((buffer->i) == '"') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ Questionstripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '?') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ ExclamationStripping i;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '!') 
		{	buffer->i = ' ';  
		}
	}
	VM_Tokenise(buffer, parse);
];



[ PeriodStripping i j;
	for (i = WORDSIZE : i <= (buffer-->0)+(WORDSIZE-1) : i++)
	{ 
		if ((buffer->i) == '.') 
		{	buffer->i = ' ';  
			for (j=(buffer->1) + 1: j >= i: j-- )
			{
				buffer->j = buffer->(j-1);
			}
			buffer->1 = (buffer->1)+1;
		}
	}
	VM_Tokenise(buffer, parse);
];



[ KeyPause i; 
	i = VM_KeyChar(); 
	rfalse;
];

[ SPACEPause i;
	while (i ~= 13 or 31 or 32)
	{
		i = VM_KeyChar();	
	}
];

[ GetKey i;
	i = VM_KeyChar(); 
	return i;
];



#ifndef printed_text;
Array printed_text --> 64;
#endif;

[ CenterPrint str depth i j;
	font off;
	i = VM_ScreenWidth();
			VM_PrintToBuffer(printed_text, 63, str);
	j = (i-(printed_text-->0))/2; 
	j = j-1;
	VM_MoveCursorInStatusLine(depth, j);
	print (I7_string) str; 
	font on;
];

[ CenterPrintComplex str i j;
	font off;
	print "^"; 
	i = VM_ScreenWidth();
			VM_PrintToBuffer(printed_text, 63, str);
	j = (i-(printed_text-->0))/2; 
	spaces j-1;
	print (I7_string) str; 
	font on;
];



[ I7ScreenHeight i screen_height;
	i = 0->32;
		  if (screen_height == 0 or 255) screen_height = 18;
		  screen_height = screen_height - 7;
	return screen_height;
];

 

[ DeepStatus depth i screen_width;
    VM_StatusLineHeight(depth);
    screen_width = VM_ScreenWidth();
    #ifdef TARGET_GLULX;
        VM_ClearScreen(1);
    #ifnot;
        style reverse;
        for (i=1:i<depth+1:i++)
        {
             @set_cursor i 1;
             spaces(screen_width);
        } 
    #endif;
]; 

[ I7VM_MoveCursorInStatusLine depth;
	VM_MoveCursorInStatusLine(depth, 1);
];

[ RightAlign depth screen_width o n;
	screen_width = VM_ScreenWidth(); 
	n = (Global_Vars-->21);
	o = screen_width - n;
	VM_MoveCursorInStatusLine(depth, o);
];





! Request 0: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in miscellaneous message:
[ PHR_717_r0 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 1: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in miscellaneous list message:
[ PHR_718_r1 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 2: phrase nothing -> nothing
! From the Standard Rules
! To decide if intervened in action message:
[ PHR_719_r2 ;
      ! phrase 1
      ! [1: decide on false]
       return 0; 
   rfalse;
];
! Request 3: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To add the custom library messages:
[ PHR_916_r3 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through the table of custom library messages begin]
       @push ct_0; @push ct_1;
		for (t_0=T6_custom_library_messages,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 2
         ! [2: set message id entry to the message text entry]
         (PHR_917_r43 (TableLookUpEntry(ct_0,113,ct_1),TableLookUpEntry(ct_0,112,ct_1)));
         ! phrase 3
         ! [3: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! Request 4: phrase nothing -> nothing
! To say the dog-action:
[ PHR_1554_r4 ;
      ! phrase 1
      ! [1: say ~[one of]The dog sniffs at the ground[or]The dog wags its tail[or]The dog chases its own tail[purely at random].~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->51 =
	i7_soo_par(I7_ST_say_one_of-->51, 3);
	switch((I7_ST_say_one_of-->51)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1149; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_258; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1150; ParaContent();  } ParaContent();  print (PrintText) SC_250;  new_line; .L_Say798; .L_SayX760;
   rfalse;
];
! Request 5: phrase nothing -> nothing
! To continue the conductor's story:
[ PHR_1092_r5 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through table of further conductor's commentary begin]
       @push ct_0; @push ct_1;
		for (t_0=T10_further_conductor_s_comm,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
           if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
         ! phrase 2
         ! [2: if there is a commentary entry begin]
          if (( (ExistsTableLookUpEntry(ct_0,117,ct_1)) ))  {
            ! phrase 3
            ! [3: say ~[commentary entry][paragraph break]~]
            say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,117,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say799; .L_SayX761;
            ! phrase 4
            ! [4: blank out the commentary entry]
             TableLookUpEntry(ct_0,117,ct_1,4); 
            ! phrase 5
            ! [5: rule succeeds]
             RulebookSucceeds(); rtrue; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: end repeat]
         }
@pull ct_1; @pull ct_0;
        if (debug_rules>1) print "  [7: end repeat]^";
      ! phrase 8
      ! [8: end the conductor's story]
      (PHR_1097_r108 ());
   rfalse;
];
! Request 6: phrase text -> nothing
! To record ( T - text ) as achieved:
[ PHR_1164_r6 
    t_0 ! Call parameter 'T' = text
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: choose row with a citation of t in the table of tasks achieved]
       ct_0 = T11_tasks_achieved; ct_1 = TableRowCorr(ct_0, 119, t_0); 
      ! phrase 2
      ! [2: if there is no time entry begin]
       if (( (ExistsTableLookUpEntry(ct_0,110,ct_1) == false) ))  {
         ! phrase 3
         ! [3: now time entry is the time of day]
          TableLookUpEntry(ct_0,110,ct_1,1,the_time); 
         ! phrase 4
         ! [4: increase the score by the points entry]
          score = score + TableLookUpEntry(ct_0,118,ct_1); 
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 7: phrase nothing -> nothing
! To continue the attempt to free:
[ PHR_1524_r7 ;
      ! phrase 1
      ! [1: say ~[one of][The secretary] tugs firmly on the rope[or]Another pull of the rope[or]You feel the rope cut into your back as [the secretary] keeps pulling[at random].[paragraph break]~]
      say__p=1;ParaContent();  I7_ST_say_one_of-->52 =
	i7_soo_ran(I7_ST_say_one_of-->52, 3);
	switch((I7_ST_say_one_of-->52)%(3+1)-1) {
		0: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1151; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1152; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1153; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1154; ParaContent();  } ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say800; .L_SayX762;
   rfalse;
];
! Request 8: phrase nothing -> nothing
! To continue the secretary's story:
[ PHR_1519_r8 
    t_0 ! Local variable e.g. '?-1,-1?' = number
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: repeat through table of further secretary's commentary begin]
       @push ct_0; @push ct_1;
		for (t_0=T13_further_secretary_s_comm,t_1=1,ct_0=t_0,ct_1=t_1:
			t_1<=TableRows(t_0):t_1++,ct_0=t_0,ct_1=t_1)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
           if (debug_rules>1) print "  [repetition with ?-1,-1? set to ", (DecimalNumber) t_0, "]^";
         ! phrase 2
         ! [2: if there is a say-value entry begin]
          if (( (ExistsTableLookUpEntry(ct_0,122,ct_1)) ))  {
            ! phrase 3
            ! [3: if there is a commentary entry begin]
             if (( (ExistsTableLookUpEntry(ct_0,117,ct_1)) ))  {
               ! phrase 4
               ! [4: say ~[commentary entry][paragraph break]~]
               say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,117,ct_1); ParaContent();  DivideParagraphPoint(); new_line;  .L_Say801; .L_SayX763;
               ! phrase 5
               ! [5: blank out the commentary entry]
                TableLookUpEntry(ct_0,117,ct_1,4); 
               ! phrase 6
               ! [6: rule succeeds]
                RulebookSucceeds(); rtrue; 
               ! phrase 7
               ! [7: end if]
               }

            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end repeat]
         }
@pull ct_1; @pull ct_0;
        if (debug_rules>1) print "  [9: end repeat]^";
      ! phrase 10
      ! [10: end the secretary's story]
      (PHR_1532_r110 ());
   rfalse;
];
! Request 9: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say is-are:
[ PHR_944_r9 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_945_r13 ((Global_Vars-->19))); .L_Say802; .L_SayX764;
   rfalse;
];
! Request 10: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say it-them of ( item - a thing ):
[ PHR_987_r10 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~them~]
         say__p=1;ParaContent();  print (PrintText) SC_1155;  .L_Say803; .L_SayX765;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_529;  .L_Say804; .L_SayX766;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~him~]
         say__p=1;ParaContent();  print (PrintText) SC_1156;  .L_Say805; .L_SayX767;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~her~]
         say__p=1;ParaContent();  print (PrintText) SC_1157;  .L_Say806; .L_SayX768;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~it~]
         say__p=1;ParaContent();  print (PrintText) SC_1158;  .L_Say807; .L_SayX769;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 11: phrase thing -> nothing
! From "Considerate Holdall" by Jon Ingold
! To note ( n - a thing ):
[ PHR_774_r11 
    t_0 ! Call parameter 'n' = thing
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: if the n is a recent item listed in the table of recent items begin]
       if (((true) && ((ct_1=ExistsTableRowCorr(ct_0=T4_recent_items,109,t_0)))))  {
         ! phrase 2
         ! [2: change the time entry to the time of day]
          TableLookUpEntry(ct_0,110,ct_1,1,the_time); 
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: sort the table of recent items in time order]
          TableSort(T4_recent_items, 110, 1); 
         ! phrase 5
         ! [5: if the number of blank rows in the table of recent items is zero , choose row 1 in the table of recent items]
          if ((( TableBlankRows(T4_recent_items)  == 0))) {  ct_0 = T4_recent_items; ct_1 = 1;   }
         ! phrase 6
         ! [6: otherwise choose a blank row in the table of recent items]
          else {  ct_0 = T4_recent_items; ct_1 = TableBlankRow(ct_0);   }
         ! phrase 7
         ! [7: change the recent item entry to the n]
          TableLookUpEntry(ct_0,109,ct_1,1,t_0); 
         ! phrase 8
         ! [8: change the time entry to the time of day]
          TableLookUpEntry(ct_0,110,ct_1,1,the_time); 
         ! phrase 9
         ! [9: sort the table of recent items in time order]
          TableSort(T4_recent_items, 110, 1); 
         ! phrase 10
         ! [10: end if]
         }

   rfalse;
];
! Request 12: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say it-they of ( item - a thing ):
[ PHR_975_r12 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~they~]
         say__p=1;ParaContent();  print (PrintText) SC_1159;  .L_Say808; .L_SayX770;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_529;  .L_Say809; .L_SayX771;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_1160;  .L_Say810; .L_SayX772;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_1161;  .L_Say811; .L_SayX773;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~it~]
         say__p=1;ParaContent();  print (PrintText) SC_1158;  .L_Say812; .L_SayX774;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 13: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say is-are of ( item - a thing ):
[ PHR_945_r13 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~are~]
       if ((((PHR_943_r53 ((Global_Vars-->19))))) || ((((Global_Vars-->19) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_1162;  .L_Say813; .L_SayX775;  }
      ! phrase 3
      ! [3: otherwise say ~is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_1163;  .L_Say814; .L_SayX776;  }
   rfalse;
];
! Request 14: phrase volume -> nothing
! To say ( amount - a volume ) in rough terms:
[ PHR_1100_r14 
    t_0 ! Call parameter 'amount' = volume
    t_1 ! Local variable e.g. '?-1,-1?' = number
    ;
      ! phrase 1
      ! [1: if the amount is less than 0.5 fl oz begin]
       if (((t_0 < 5)))  {
         ! phrase 2
         ! [2: say ~a swallow or two~]
         say__p=1;ParaContent();  print (PrintText) SC_1164;  .L_Say815; .L_SayX777;
         ! phrase 3
         ! [3: otherwise if tenths part of amount is greater than 3 and tenths part of amount is less than 7]
          } else if (((( (t_0%10)  > 3))) && ((( (t_0%10)  < 7)))) { 
         ! phrase 4
         ! [4: let estimate be ounces part of amount]
          t_1 =  (t_0/10) ; 
         ! phrase 5
         ! [5: say ~[estimate in words] or [estimate plus 1 in words] fluid ounces~]
         say__p=1;ParaContent();  print (number) say__n=(t_1); ParaContent();  print (PrintText) SC_924; ParaContent();  print (number) say__n=( (t_1+1) ); ParaContent();  print (PrintText) SC_1165;  .L_Say816; .L_SayX778;
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: if tenths part of amount is greater than 6 , increase amount by 1.0 fl oz]
          if ((( (t_0%10)  > 6))) {  t_0 = t_0 + 10;   }
         ! phrase 8
         ! [8: say ~about [ounces part of amount in words] fluid ounce[s]~]
         say__p=1;ParaContent();  print (PrintText) SC_1166; ParaContent();  print (number) say__n=( (t_0/10) ); ParaContent();  print (PrintText) SC_1167; ParaContent();  STextSubstitution();  .L_Say817; .L_SayX779;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 15: phrase thing -> nothing
! From "Plurality" by Emily Short
! To mark ( target - a thing ) in output:
[ PHR_940_r15 
    t_0 ! Call parameter 'target' = thing
    ;
      ! phrase 1
      ! [1: if the target acts plural or target is the player , mark-future-plural]
       if ((((PHR_943_r53 (t_0)))) || (((t_0 == player)))) {  say__n = 1;   }
      ! phrase 2
      ! [2: otherwise mark-future-singular]
       else {  say__n = 29;   }
      ! phrase 3
      ! [3: now the prior named noun is the target]
       (Global_Vars-->19) = t_0; 
   rfalse;
];
! Request 16: phrase (object, number) -> nothing
! From the Standard Rules
! To set the/-- locale priority of ( O - an object ) to ( N - a number ):
[ PHR_72_r16 
    t_0 ! Call parameter 'O' = object
    t_1 ! Call parameter 'N' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: if o is a thing begin]
       if (((t_0 ofclass K2_thing)))  {
         ! phrase 2
         ! [2: if n <= 0 , now o is mentioned]
          if (((t_1 <= 0))) {  (Adj_65_t2_v9(t_0));   }
         ! phrase 3
         ! [3: if there is a notable-object of o in the table of locale priorities begin]
          if (( (ExistsTableLookUpCorr(T1_locale_priorities,105,105,t_0)) ))  {
            ! phrase 4
            ! [4: choose row with a notable-object of o in the table of locale priorities]
             ct_0 = T1_locale_priorities; ct_1 = TableRowCorr(ct_0, 105, t_0); 
            ! phrase 5
            ! [5: if n <= 0 , blank out the whole row]
             if (((t_1 <= 0))) {  TableBlankOutRow(ct_0, ct_1);   }
            ! phrase 6
            ! [6: otherwise now the locale description priority entry is n]
             else {  TableLookUpEntry(ct_0,106,ct_1,1,t_1);   }
            ! phrase 7
            ! [7: otherwise]
            } else {

            ! phrase 8
            ! [8: if n is greater than 0 begin]
             if (((t_1 > 0)))  {
               ! phrase 9
               ! [9: choose a blank row in the table of locale priorities]
                ct_0 = T1_locale_priorities; ct_1 = TableBlankRow(ct_0); 
               ! phrase 10
               ! [10: now the notable-object entry is o]
                TableLookUpEntry(ct_0,105,ct_1,1,t_0); 
               ! phrase 11
               ! [11: now the locale description priority entry is n]
                TableLookUpEntry(ct_0,106,ct_1,1,t_1); 
               ! phrase 12
               ! [12: end if]
               }

            ! phrase 13
            ! [13: end if]
            }

         ! phrase 14
         ! [14: end if]
         }

   rfalse;
];
! Request 17: phrase object -> nothing
! From the Standard Rules
! To describe locale for ( O - object ):
[ PHR_71_r17 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: carry out the printing the locale description activity with o]
       CarryOutActivity(V29_printing_the_locale_desc, t_0); 
   rfalse;
];
! Request 18: phrase nothing -> number
! From "Small Kindnesses" by Aaron Reed
! To decide what number is the count of indirectly-adjacent rooms:
[ PHR_743_r18 
    t_0 ! Local variable e.g. 'ctr' = number
    t_1 ! Local variable e.g. '?-1,-1?' = direction
    t_2 ! Local variable e.g. '?-1,-1?' = direction
    t_3 ! Local variable e.g. '?-1,-1?' = object
    ;
      ! phrase 1
      ! [1: let ctr be 0]
       t_0 = 0; 
      ! phrase 2
      ! [2: repeat with dir running through directions begin]
       for (t_1=Prop_126(0), t_2=Prop_126(t_1): t_1: t_1=t_2, t_2=Prop_126(t_2))  {
         ! phrase 3
         ! [3: let dest be the room-or-door dir from location]
          t_3 = (Resolver_9(t_1,real_location,"source", 50)); 
         ! phrase 4
         ! [4: if dest is a room begin]
          if (((t_3 ofclass K1_room)))  {
            ! phrase 5
            ! [5: increase ctr by 1]
             t_0 = t_0 + 1; 
            ! phrase 6
            ! [6: otherwise if dest is a door and the other side of dest from location is a room]
             } else if ((((t_3 ofclass K4_door))) && ((((Resolver_12(t_3,real_location,"source", 53)) ofclass K1_room)))) { 
            ! phrase 7
            ! [7: increase ctr by 1]
             t_0 = t_0 + 1; 
            ! phrase 8
            ! [8: end if]
            }

         ! phrase 9
         ! [9: end repeat]
         }

      ! phrase 10
      ! [10: decide on ctr]
       return t_0; 
   return 0;
];
! Request 19: phrase nothing -> room
! From "Small Kindnesses" by Aaron Reed
! To decide what room is the first indirectly-adjacent room:
[ PHR_744_r19 
    t_0 ! Local variable e.g. '?-1,-1?' = direction
    t_1 ! Local variable e.g. '?-1,-1?' = direction
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
      ! phrase 1
      ! [1: repeat with dir running through directions begin]
       for (t_0=Prop_127(0), t_1=Prop_127(t_0): t_0: t_0=t_1, t_1=Prop_127(t_1))  {
         ! phrase 2
         ! [2: let dest be the room-or-door dir from location]
          t_2 = (Resolver_9(t_0,real_location,"source", 59)); 
         ! phrase 3
         ! [3: if dest is a room begin]
          if (((t_2 ofclass K1_room)))  {
            ! phrase 4
            ! [4: decide on dest]
             return CheckKindReturned(t_2,K1_room); 
            ! phrase 5
            ! [5: otherwise if dest is a door and the other side of dest from location is a room]
             } else if ((((t_2 ofclass K4_door))) && ((((Resolver_12(t_2,real_location,"source", 62)) ofclass K1_room)))) { 
            ! phrase 6
            ! [6: decide on the other side of dest from location]
             return CheckKindReturned((Resolver_12(t_2,real_location,"source", 63)),K1_room); 
            ! phrase 7
            ! [7: end if]
            }

         ! phrase 8
         ! [8: end repeat]
         }

      ! phrase 9
      ! [9: decide on location]
       return CheckKindReturned(real_location,K1_room); 
   return I439_steam_train;
];
! Request 20: phrase nothing -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if testing the/a/-- second noun:
[ PHR_867_r20 ;
      ! phrase 1
      ! [1: if testing noun , no]
       if (( (TestingNoun()) )) {  rfalse;   }
      ! phrase 2
      ! [2: yes]
       rtrue; 
   rfalse;
];
! Request 21: phrase nothing -> nothing
! To say the scoring wetness level:
[ PHR_1166_r21 ;
      ! phrase 1
      ! [1: if the wetness level is ~dry land~ , say ~still on dry land~]
       if ((((Global_Vars-->22) == SC_238))) { say__p=1;ParaContent();  print (PrintText) SC_1168;  .L_Say818; .L_SayX780;  }
      ! phrase 2
      ! [2: otherwise say the wetness level]
       else { say__p=1;ParaContent();  print (PrintText) (Global_Vars-->22);  .L_Say819; .L_SayX781;  }
   rfalse;
];
! Request 22: phrase object -> nothing
! From "Locksmith" by Emily Short
! To say key-refusal for ( locked-thing - an object ):
[ PHR_820_r22 
    t_0 ! Call parameter 'locked-thing' = object
    ;
      ! phrase 1
      ! [1: carry out the refusing keys activity with the locked-thing]
       CarryOutActivity(V32_refusing_keys_of_somethi, t_0); 
   rfalse;
];
! Request 23: phrase (library message id, rule) -> nothing
! From "Default Messages" by David Fisher
! To display ( id_ - a library message id ) / ( original_rule - a rule ):
[ PHR_934_r23 
    t_0 ! Call parameter 'id_' = library message id
    t_1 ! Call parameter 'original_rule' = rule
    ;
      ! phrase 1
      ! [1: change library-message-id to id_]
       (Global_Vars-->15) = t_0; 
      ! phrase 2
      ! [2: follow the print library message rule]
       FollowRulebook(R_919); 
      ! phrase 3
      ! [3: if libmsg_printed is 0 , follow original_rule]
       if ((((Global_Vars-->16) == 0))) {  FollowRulebook(t_1);   }
   rfalse;
];
! Request 24: phrase thing -> nothing
! From "Considerate Holdall" by Jon Ingold
! To decide if ( item - a thing ) is not a recently handled item:
[ PHR_770_r24 
    t_0 ! Call parameter 'item' = thing
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: if the item is not a recent item listed in the table of recent items , decide yes]
       if (((~~((true) && ((ct_1=ExistsTableRowCorr(ct_0=T4_recent_items,109,t_0))))))) {  rtrue;   }
      ! phrase 2
      ! [2: decide no]
       rfalse; 
   rfalse;
];
! Request 25: phrase nothing -> nothing
! From the Standard Rules
! To say no line break -- running on ( documented at phs_nolinebreak ):
[ PHR_335_r25 ;
      ! phrase 1
      ! [1: do nothing]
       ; 
   rfalse;
];
! Request 26: phrase object -> nothing
! From the Standard Rules
! To say contents of ( O - an object ) ( deprecated ) ( documented at phs_contents_dep ):
[ PHR_357_r26 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence]
       WriteListFrom(child(t_0), 8); 
   rfalse;
];
! Request 27: phrase object -> nothing
! From the Standard Rules
! To say the contents of ( O - an object ) ( deprecated ) ( documented at phs_contents_dep ):
[ PHR_358_r27 
    t_0 ! Call parameter 'O' = object
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence , using the definite article]
       WriteListFrom(child(t_0), 264); 
   rfalse;
];
! Request 28: phrase nothing -> nothing
! From "Small Kindnesses" by Aaron Reed
! To say as the parser:
[ PHR_740_r28 ;
      ! phrase 1
      ! [1: do nothing]
       ; 
   rfalse;
];
! Request 29: phrase nothing -> nothing
! From "Small Kindnesses" by Aaron Reed
! To say as normal:
[ PHR_741_r29 ;
      ! phrase 1
      ! [1: do nothing]
       ; 
   rfalse;
];
! Request 30: phrase description of objects -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if considering some ( D - a description of objects ):
[ PHR_853_r30 
    t_0 ! Call parameter 'D' = description of objects
    ;blockv_stack-->(blockv_sp+5) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+4) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 6;
    blockv_stack-->(blockv_sp++) = R_SHELL_1(blockv_sp-6,
        t_0
        );
    blockv_sp = blockv_sp - 7;
    BlkFree(blockv_stack-->(blockv_sp+5));
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+6);
];
[ R_SHELL_1 I7BASPL 
    t_0 ! Call parameter 'D' = description of objects
    t_1 ! Local variable e.g. 'L' = list of objects
    t_2 ! Local variable e.g. 'Y' = list of objects
    ;
      ! phrase 1
      ! [1: let l be the match list]
       t_1 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_1, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 2
      ! [2: let y be a list of objects]
       t_2 = (blockv_stack-->(I7BASPL+2)); 
      ! phrase 3
      ! [3: let y be the list of d]
       BlkValueCopy(t_2,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+3)), t_0, OBJECT_TY) ); 
      ! phrase 4
      ! [4: if l intersect y is non-empty , yes]
       if (((PHR_905_r41 (BlkValueCopy((blockv_stack-->(I7BASPL+4)), t_1),BlkValueCopy((blockv_stack-->(I7BASPL+5)), t_2))))) {  rtrue;   }
      ! phrase 5
      ! [5: no]
       rfalse; 
   rfalse;
];
! Request 31: phrase (object, object) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x0 - an object ) against ( x1 - a object ):
[ PHR_857_r31 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_2(blockv_sp-2,
        t_0,
        t_1
        );
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_2 I7BASPL 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: if x0 is not under consideration , no]
       if (((PHR_865_r39 (t_0)))) {  rfalse;   }
      ! phrase 2
      ! [2: let l be the match list]
       t_2 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_2, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 3
      ! [3: remove the x0 from l , if present]
       LIST_OF_TY_RemoveValue(t_2, t_0, 1); 
      ! phrase 4
      ! [4: remove x1 from l , if present]
       LIST_OF_TY_RemoveValue(t_2, t_1, 1); 
      ! phrase 5
      ! [5: if the number of entries in l is 0 , yes]
       if ((( LIST_OF_TY_GetLength(t_2)  == 0))) {  rtrue;   }
      ! phrase 6
      ! [6: no]
       rfalse; 
   rfalse;
];
! Request 32: phrase (object, object) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x1 - a object ) +/plus ( x2 - a object ):
[ PHR_858_r32 
    t_0 ! Call parameter 'x1' = object
    t_1 ! Call parameter 'x2' = object
    ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_3(blockv_sp-2,
        t_0,
        t_1
        );
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_3 I7BASPL 
    t_0 ! Call parameter 'x1' = object
    t_1 ! Call parameter 'x2' = object
    t_2 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: let l be the match list]
       t_2 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_2, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 2
      ! [2: remove x1 from l , if present]
       LIST_OF_TY_RemoveValue(t_2, t_0, 1); 
      ! phrase 3
      ! [3: remove x2 from l , if present]
       LIST_OF_TY_RemoveValue(t_2, t_1, 1); 
      ! phrase 4
      ! [4: if the number of entries in l is 0 , yes]
       if ((( LIST_OF_TY_GetLength(t_2)  == 0))) {  rtrue;   }
      ! phrase 5
      ! [5: no]
       rfalse; 
   rfalse;
];
! Request 33: phrase (object, object, object) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x0 - an object ) against ( x1 - an object ) + ( x2 - an object ):
[ PHR_859_r33 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Call parameter 'x2' = object
    ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_4(blockv_sp-2,
        t_0,
        t_1,
        t_2
        );
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_4 I7BASPL 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Call parameter 'x2' = object
    t_3 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: if x0 is not under consideration , no]
       if (((PHR_865_r39 (t_0)))) {  rfalse;   }
      ! phrase 2
      ! [2: let l be the match list]
       t_3 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_3, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 3
      ! [3: remove the x0 from l , if present]
       LIST_OF_TY_RemoveValue(t_3, t_0, 1); 
      ! phrase 4
      ! [4: remove x1 from l , if present]
       LIST_OF_TY_RemoveValue(t_3, t_1, 1); 
      ! phrase 5
      ! [5: remove x2 from l , if present]
       LIST_OF_TY_RemoveValue(t_3, t_2, 1); 
      ! phrase 6
      ! [6: if the number of entries in l is 0 , yes]
       if ((( LIST_OF_TY_GetLength(t_3)  == 0))) {  rtrue;   }
      ! phrase 7
      ! [7: no]
       rfalse; 
   rfalse;
];
! Request 34: phrase (object, object, object) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x1 - an object ) + ( x2 - an object ) + ( x3 - an object ):
[ PHR_860_r34 
    t_0 ! Call parameter 'x1' = object
    t_1 ! Call parameter 'x2' = object
    t_2 ! Call parameter 'x3' = object
    ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_5(blockv_sp-2,
        t_0,
        t_1,
        t_2
        );
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_5 I7BASPL 
    t_0 ! Call parameter 'x1' = object
    t_1 ! Call parameter 'x2' = object
    t_2 ! Call parameter 'x3' = object
    t_3 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: let l be the match list]
       t_3 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_3, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 2
      ! [2: remove x1 from l , if present]
       LIST_OF_TY_RemoveValue(t_3, t_0, 1); 
      ! phrase 3
      ! [3: remove x2 from l , if present]
       LIST_OF_TY_RemoveValue(t_3, t_1, 1); 
      ! phrase 4
      ! [4: remove x3 from l , if present]
       LIST_OF_TY_RemoveValue(t_3, t_2, 1); 
      ! phrase 5
      ! [5: if the number of entries in l is 0 , yes]
       if ((( LIST_OF_TY_GetLength(t_3)  == 0))) {  rtrue;   }
      ! phrase 6
      ! [6: no]
       rfalse; 
   rfalse;
];
! Request 35: phrase (object, object, object, object) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x0 - an object ) against ( x1 - an object ) + ( x2 - an object ) + ( x3 - an object ):
[ PHR_861_r35 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Call parameter 'x2' = object
    t_3 ! Call parameter 'x3' = object
    ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_6(blockv_sp-2,
        t_0,
        t_1,
        t_2,
        t_3
        );
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_6 I7BASPL 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Call parameter 'x2' = object
    t_3 ! Call parameter 'x3' = object
    t_4 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: if x0 is not under consideration , no]
       if (((PHR_865_r39 (t_0)))) {  rfalse;   }
      ! phrase 2
      ! [2: let l be the match list]
       t_4 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_4, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 3
      ! [3: remove the x0 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_0, 1); 
      ! phrase 4
      ! [4: remove x1 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_1, 1); 
      ! phrase 5
      ! [5: remove x2 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_2, 1); 
      ! phrase 6
      ! [6: remove x3 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_3, 1); 
      ! phrase 7
      ! [7: if the number of entries in l is 0 , yes]
       if ((( LIST_OF_TY_GetLength(t_4)  == 0))) {  rtrue;   }
      ! phrase 8
      ! [8: no]
       rfalse; 
   rfalse;
];
! Request 36: phrase (object, object, object, object) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x0 - an object ) + ( x1 - an object ) + ( x2 - an object ) + ( x3 - an object ):
[ PHR_862_r36 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Call parameter 'x2' = object
    t_3 ! Call parameter 'x3' = object
    ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_7(blockv_sp-2,
        t_0,
        t_1,
        t_2,
        t_3
        );
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_7 I7BASPL 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'x1' = object
    t_2 ! Call parameter 'x2' = object
    t_3 ! Call parameter 'x3' = object
    t_4 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: let l be the match list]
       t_4 = (blockv_stack-->(I7BASPL+0)); BlkValueCopy(t_4, (PHR_909_r42 ((blockv_stack-->(I7BASPL+1))))); 
      ! phrase 2
      ! [2: remove x0 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_0, 1); 
      ! phrase 3
      ! [3: remove x1 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_1, 1); 
      ! phrase 4
      ! [4: remove x2 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_2, 1); 
      ! phrase 5
      ! [5: remove x3 from l , if present]
       LIST_OF_TY_RemoveValue(t_4, t_3, 1); 
      ! phrase 6
      ! [6: if the number of entries in l is 0 , yes]
       if ((( LIST_OF_TY_GetLength(t_4)  == 0))) {  rtrue;   }
      ! phrase 7
      ! [7: no]
       rfalse; 
   rfalse;
];
! Request 37: phrase description of objects -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( C - a description of objects ):
[ PHR_863_r37 
    t_0 ! Call parameter 'C' = description of objects
    ;blockv_stack-->(blockv_sp+4) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 5;
    blockv_stack-->(blockv_sp++) = R_SHELL_8(blockv_sp-5,
        t_0
        );
    blockv_sp = blockv_sp - 6;
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+5);
];
[ R_SHELL_8 I7BASPL 
    t_0 ! Call parameter 'C' = description of objects
    t_1 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: let l be a list of objects]
       t_1 = (blockv_stack-->(I7BASPL+0)); 
      ! phrase 2
      ! [2: let l be the list of c]
       BlkValueCopy(t_1,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), t_0, OBJECT_TY) ); 
      ! phrase 3
      ! [3: if the match list is a subset of l , yes]
       if (((PHR_904_r40 (BlkValueCopy((blockv_stack-->(I7BASPL+2)), (PHR_909_r42 ((blockv_stack-->(I7BASPL+3))))),BlkValueCopy((blockv_stack-->(I7BASPL+4)), t_1))))) {  rtrue;   }
      ! phrase 4
      ! [4: no]
       rfalse; 
   rfalse;
];
! Request 38: phrase (object, description of objects) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if comparing ( x0 - an object ) against ( C - a description of objects ):
[ PHR_864_r38 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'C' = description of objects
    ;blockv_stack-->(blockv_sp+4) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+3) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+2) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 5;
    blockv_stack-->(blockv_sp++) = R_SHELL_9(blockv_sp-5,
        t_0,
        t_1
        );
    blockv_sp = blockv_sp - 6;
    BlkFree(blockv_stack-->(blockv_sp+4));
    BlkFree(blockv_stack-->(blockv_sp+3));
    BlkFree(blockv_stack-->(blockv_sp+2));
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+5);
];
[ R_SHELL_9 I7BASPL 
    t_0 ! Call parameter 'x0' = object
    t_1 ! Call parameter 'C' = description of objects
    t_2 ! Local variable e.g. 'L' = list of objects
    ;
      ! phrase 1
      ! [1: if x0 is not under consideration , no]
       if (((PHR_865_r39 (t_0)))) {  rfalse;   }
      ! phrase 2
      ! [2: let l be a list of objects]
       t_2 = (blockv_stack-->(I7BASPL+0)); 
      ! phrase 3
      ! [3: remove the x0 from l , if present]
       LIST_OF_TY_RemoveValue(t_2, t_0, 1); 
      ! phrase 4
      ! [4: let l be the list of c]
       BlkValueCopy(t_2,  LIST_OF_TY_Desc((blockv_stack-->(I7BASPL+1)), t_1, OBJECT_TY) ); 
      ! phrase 5
      ! [5: if the match list is a subset of l , yes]
       if (((PHR_904_r40 (BlkValueCopy((blockv_stack-->(I7BASPL+2)), (PHR_909_r42 ((blockv_stack-->(I7BASPL+3))))),BlkValueCopy((blockv_stack-->(I7BASPL+4)), t_2))))) {  rtrue;   }
      ! phrase 6
      ! [6: no]
       rfalse; 
   rfalse;
];
! Request 39: phrase object -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if ( x - an object ) is not under consideration:
[ PHR_865_r39 
    t_0 ! Call parameter 'x' = object
    ;
      ! phrase 1
      ! [1: if testing noun and x is not the noun , yes]
       if ((( (TestingNoun()) )) && (((~~((t_0 == noun)))))) {  rtrue;   }
      ! phrase 2
      ! [2: if not testing noun and x is not the second noun , yes]
       if ((~~(( (TestingNoun()) ))) && (((~~((t_0 == second)))))) {  rtrue;   }
      ! phrase 3
      ! [3: no]
       rfalse; 
   rfalse;
];
! Request 40: phrase (list of objects, list of objects) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if ( X - a list of objects ) is a subset of ( Y - a list of objects ):
[ PHR_904_r40 
    t_0 ! Call parameter 'X' = list of objects
    t_1 ! Call parameter 'Y' = list of objects
    ;
      ! phrase 1
      ! [1: remove y from x , if present]
       LIST_OF_TY_Remove_List(t_0, t_1, 1); 
      ! phrase 2
      ! [2: if the number of entries in x is 0 , decide yes]
       if ((( LIST_OF_TY_GetLength(t_0)  == 0))) {  rtrue;   }
      ! phrase 3
      ! [3: decide no]
       rfalse; 
   rfalse;
];
! Request 41: phrase (list of objects, list of objects) -> nothing
! From "Disambiguation Control" by Jon Ingold
! To decide if ( X - a list of objects ) intersect ( Y - a list of objects ) is non-empty:
[ PHR_905_r41 
    t_0 ! Call parameter 'X' = list of objects
    t_1 ! Call parameter 'Y' = list of objects
    t_2 ! Local variable e.g. 'starting number' = number
    ;
      ! phrase 1
      ! [1: let starting number be the number of entries in x]
       t_2 =  LIST_OF_TY_GetLength(t_0) ; 
      ! phrase 2
      ! [2: remove y from x , if present]
       LIST_OF_TY_Remove_List(t_0, t_1, 1); 
      ! phrase 3
      ! [3: if the number of entries in x is not the starting number , decide yes]
       if (((~~(( LIST_OF_TY_GetLength(t_0)  == t_2))))) {  rtrue;   }
      ! phrase 4
      ! [4: decide no]
       rfalse; 
   rfalse;
];
! Request 42: phrase nothing -> list of objects
! From "Disambiguation Control" by Jon Ingold
! To decide which list of objects is the match list:
[ PHR_909_r42 I7RBLK ;blockv_stack-->(blockv_sp+1) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(LIST_OF_TY,0,KD3_list_of_objects);
    blockv_sp = blockv_sp + 2;
    I7RBLK = BlkValueCopy(I7RBLK, R_SHELL_10(blockv_sp-2));
    blockv_sp = blockv_sp - 2;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return I7RBLK;
];
[ R_SHELL_10 I7BASPL 
    t_0 ! Local variable e.g. 'L' = list of objects
    t_1 ! Local variable e.g. '?-1,-1?' = number
    t_2 ! Local variable e.g. '?-1,-1?' = object
    ;
      ! phrase 1
      ! [1: let l be a list of objects]
       t_0 = (blockv_stack-->(I7BASPL+0)); 
      ! phrase 2
      ! [2: repeat with n running from 1 to 100 begin]
       for (t_1=1: t_1<=100: t_1++)  {
         ! phrase 3
         ! [3: let i be item n from the match list]
          t_2 =  MatchListEntry(t_1) ; 
         ! phrase 4
         ! [4: if i is no-object begin]
          if (((t_2 == I92_no_object)))  {
            ! phrase 5
            ! [5: break]
             break; 
            ! phrase 6
            ! [6: end if]
            }

         ! phrase 7
         ! [7: add i to l]
          LIST_OF_TY_InsertItem(t_0, t_2, 0, 0, 0); 
         ! phrase 8
         ! [8: end repeat]
         }

      ! phrase 9
      ! [9: decide on l]
       return BlkValueCopy((blockv_stack-->(I7BASPL+1)), t_0); 
   return 0;
];
! Request 43: phrase (library message id, text) -> nothing
! From "Default Messages" by David Fisher
! To set ( id_ - library message id ) to ( msg_ - text ):
[ PHR_917_r43 
    t_0 ! Call parameter 'id_' = library message id
    t_1 ! Call parameter 'msg_' = text
    ;
      ! phrase 1
      ! [1: update the row with id of id_ to msg_]
      (PHR_918_r44 (t_0,t_1));
   rfalse;
];
! Request 44: phrase (library message id, text) -> nothing
! From "Default Messages" by David Fisher
! To update the row with id of ( id_ - library message id ) to ( msg_ - text ):
[ PHR_918_r44 
    t_0 ! Call parameter 'id_' = library message id
    t_1 ! Call parameter 'msg_' = text
    t_2 ! Local variable e.g. 'n1' = number
    t_3 ! Local variable e.g. 'n2' = number
    t_4 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let n1 be 1]
       t_2 = 1; 
      ! phrase 2
      ! [2: let n2 be the number of rows in the table of library messages]
       t_3 =  TableRows(T7_library_messages) ; 
      ! phrase 3
      ! [3: while n1 <= n2 begin]
       while (((t_2 <= t_3)))  {
         ! phrase 4
         ! [4: let mid_ be n1 plus n2]
          t_4 =  (t_2+t_3) ; 
         ! phrase 5
         ! [5: change mid_ to mid_ divided by 2]
          t_4 =  (IntegerDivide(t_4,2)) ; 
         ! phrase 6
         ! [6: choose row mid_ in the table of library messages]
          ct_0 = T7_library_messages; ct_1 = t_4; 
         ! phrase 7
         ! [7: if the message id entry is id_ begin]
          if (((TableLookUpEntry(ct_0,113,ct_1) == t_0)))  {
            ! phrase 8
            ! [8: change the message text entry to msg_]
             TableLookUpEntry(ct_0,112,ct_1,1,t_1); 
            ! phrase 9
            ! [9: change n1 to n2 + 1]
             t_2 =  (t_3+1) ; 
            ! phrase 10
            ! [10: end if]
            }

         ! phrase 11
         ! [11: if the message id entry < id_ , change n1 to mid_ plus 1]
          if (((TableLookUpEntry(ct_0,113,ct_1) < t_0))) {  t_2 =  (t_4+1) ;   }
         ! phrase 12
         ! [12: if the message id entry > id_ , change n2 to mid_ minus 1]
          if (((TableLookUpEntry(ct_0,113,ct_1) > t_0))) {  t_3 =  (t_4-1) ;   }
         ! phrase 13
         ! [13: end while]
         }

   rfalse;
];
! Request 45: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say dot:
[ PHR_925_r45 ;
      ! phrase 1
      ! [1: say ~/unicode 46/~]
      say__p=1;ParaContent();  print (PrintText) SC_1169;  .L_Say820; .L_SayX782;
   rfalse;
];
! Request 46: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say ExMark:
[ PHR_926_r46 ;
      ! phrase 1
      ! [1: say ~/unicode 33/~]
      say__p=1;ParaContent();  print (PrintText) SC_1170;  .L_Say821; .L_SayX783;
   rfalse;
];
! Request 47: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say QMark:
[ PHR_927_r47 ;
      ! phrase 1
      ! [1: say ~/unicode 63/~]
      say__p=1;ParaContent();  print (PrintText) SC_1171;  .L_Say822; .L_SayX784;
   rfalse;
];
! Request 48: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say LeftSqBr:
[ PHR_928_r48 ;
      ! phrase 1
      ! [1: say ~/unicode 91/~]
      say__p=1;ParaContent();  print (PrintText) SC_1172;  .L_Say823; .L_SayX785;
   rfalse;
];
! Request 49: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say RightSqBr:
[ PHR_929_r49 ;
      ! phrase 1
      ! [1: say ~/unicode 93/~]
      say__p=1;ParaContent();  print (PrintText) SC_1173;  .L_Say824; .L_SayX786;
   rfalse;
];
! Request 50: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say /n:
[ PHR_930_r50 ;
      ! phrase 1
      ! [1: say line break]
      say__p=1;ParaContent();  new_line;  .L_Say825; .L_SayX787;
   rfalse;
];
! Request 51: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say /p:
[ PHR_931_r51 ;
      ! phrase 1
      ! [1: say paragraph break]
      say__p=1;ParaContent();  DivideParagraphPoint(); new_line;  .L_Say826; .L_SayX788;
   rfalse;
];
! Request 52: phrase nothing -> nothing
! From "Default Messages" by David Fisher
! To say /r:
[ PHR_932_r52 ;
      ! phrase 1
      ! [1: say run paragraph on]
      say__p=1;ParaContent();  RunParagraphOn();  .L_Say827; .L_SayX789;
   rfalse;
];
! Request 53: phrase object -> nothing
! From "Plurality" by Emily Short
! To decide whether ( item - an object ) acts plural:
[ PHR_943_r53 
    t_0 ! Call parameter 'item' = object
    ;
      ! phrase 1
      ! [1: if the item is plural-named or the item is ambiguously plural begin]
       if (((((Adj_41_t1_v9(t_0))))) || ((((Adj_92_t1_v9(t_0))))))  {
         ! phrase 2
         ! [2: yes]
          rtrue; 
         ! phrase 3
         ! [3: end if]
         }

      ! phrase 4
      ! [4: no]
       rfalse; 
   rfalse;
];
! Request 54: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap is-are:
[ PHR_946_r54 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_949_r57 ((Global_Vars-->19))); .L_Say828; .L_SayX790;
   rfalse;
];
! Request 55: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap is-are of ( item - a thing ) ( deprecated ):
[ PHR_947_r55 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~Are~]
       if ((((PHR_943_r53 ((Global_Vars-->19))))) || ((((Global_Vars-->19) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_1174;  .L_Say829; .L_SayX791;  }
      ! phrase 3
      ! [3: otherwise say ~Is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_1175;  .L_Say830; .L_SayX792;  }
   rfalse;
];
! Request 56: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Is-are:
[ PHR_948_r56 ;
      ! phrase 1
      ! [1: say is-are of prior named noun]
      say__p=1;ParaContent(); (PHR_949_r57 ((Global_Vars-->19))); .L_Say831; .L_SayX793;
   rfalse;
];
! Request 57: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Is-are of ( item - a thing ):
[ PHR_949_r57 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: if prior named noun acts plural or the prior named noun is the player , say ~Are~]
       if ((((PHR_943_r53 ((Global_Vars-->19))))) || ((((Global_Vars-->19) == player)))) { say__p=1;ParaContent();  print (PrintText) SC_1174;  .L_Say832; .L_SayX794;  }
      ! phrase 3
      ! [3: otherwise say ~Is~]
       else { say__p=1;ParaContent();  print (PrintText) SC_1175;  .L_Say833; .L_SayX795;  }
   rfalse;
];
! Request 58: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say has-have:
[ PHR_950_r58 ;
      ! phrase 1
      ! [1: say has-have of prior named noun]
      say__p=1;ParaContent(); (PHR_951_r59 ((Global_Vars-->19))); .L_Say834; .L_SayX796;
   rfalse;
];
! Request 59: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say has-have of ( item - a thing ):
[ PHR_951_r59 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_943_r53 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~have~]
         say__p=1;ParaContent();  print (PrintText) SC_1176;  .L_Say835; .L_SayX797;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~has~]
         say__p=1;ParaContent();  print (PrintText) SC_1177;  .L_Say836; .L_SayX798;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 60: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Has-have of ( item - a thing ):
[ PHR_952_r60 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_943_r53 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~Have~]
         say__p=1;ParaContent();  print (PrintText) SC_1178;  .L_Say837; .L_SayX799;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~Has~]
         say__p=1;ParaContent();  print (PrintText) SC_1179;  .L_Say838; .L_SayX800;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 61: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Has-have:
[ PHR_953_r61 ;
      ! phrase 1
      ! [1: say has-have of prior named noun]
      say__p=1;ParaContent(); (PHR_952_r60 ((Global_Vars-->19))); .L_Say839; .L_SayX801;
   rfalse;
];
! Request 62: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say 's-'re of ( item - a thing ):
[ PHR_954_r62 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: if the item acts plural or the item is the player begin]
       if ((((PHR_943_r53 (t_0)))) || (((t_0 == player))))  {
         ! phrase 3
         ! [3: say ~[']re~]
         say__p=1;ParaContent();  print "'"; ParaContent();  print (PrintText) SC_1180;  .L_Say840; .L_SayX802;
         ! phrase 4
         ! [4: otherwise]
         } else {

         ! phrase 5
         ! [5: say ~[']s~]
         say__p=1;ParaContent();  print "'"; ParaContent();  print (PrintText) SC_597;  .L_Say841; .L_SayX803;
         ! phrase 6
         ! [6: end if]
         }

   rfalse;
];
! Request 63: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say 's-'re:
[ PHR_955_r63 ;
      ! phrase 1
      ! [1: say 's-'re of the prior named noun]
      say__p=1;ParaContent(); (PHR_954_r62 ((Global_Vars-->19))); .L_Say842; .L_SayX804;
   rfalse;
];
! Request 64: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say es:
[ PHR_961_r64 ;
      ! phrase 1
      ! [1: say es of prior named noun]
      say__p=1;ParaContent(); (PHR_962_r65 ((Global_Vars-->19))); .L_Say843; .L_SayX805;
   rfalse;
];
! Request 65: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say es of ( item - a thing ):
[ PHR_962_r65 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_943_r53 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~~]
         say__p=1;ParaContent();  print (PrintText) EMPTY_TEXT_VALUE;  .L_Say844; .L_SayX806;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~es~]
         say__p=1;ParaContent();  print (PrintText) SC_1181;  .L_Say845; .L_SayX807;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 66: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say ies:
[ PHR_963_r66 ;
      ! phrase 1
      ! [1: say ies of prior named noun]
      say__p=1;ParaContent(); (PHR_964_r67 ((Global_Vars-->19))); .L_Say846; .L_SayX808;
   rfalse;
];
! Request 67: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say ies of ( item - a thing ):
[ PHR_964_r67 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: if the item acts plural or the item is the player begin]
       if ((((PHR_943_r53 (t_0)))) || (((t_0 == player))))  {
         ! phrase 2
         ! [2: say ~y~]
         say__p=1;ParaContent();  print (PrintText) SC_1182;  .L_Say847; .L_SayX809;
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~ies~]
         say__p=1;ParaContent();  print (PrintText) SC_1183;  .L_Say848; .L_SayX810;
         ! phrase 5
         ! [5: end if]
         }

   rfalse;
];
! Request 68: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say that-those:
[ PHR_965_r68 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_969_r72 ((Global_Vars-->19))); .L_Say849; .L_SayX811;
   rfalse;
];
! Request 69: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those ( deprecated ):
[ PHR_966_r69 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_970_r73 ((Global_Vars-->19))); .L_Say850; .L_SayX812;
   rfalse;
];
! Request 70: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say That-those:
[ PHR_967_r70 ;
      ! phrase 1
      ! [1: say that-those prior named noun]
      say__p=1;ParaContent(); (PHR_970_r73 ((Global_Vars-->19))); .L_Say851; .L_SayX813;
   rfalse;
];
! Request 71: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those ( item - a thing ) ( deprecated ):
[ PHR_968_r71 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_1184;  .L_Say852; .L_SayX814;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say853; .L_SayX815;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_737;  .L_Say854; .L_SayX816;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_736;  .L_Say855; .L_SayX817;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_1186;  .L_Say856; .L_SayX818;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 72: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say that-those ( item - a thing ):
[ PHR_969_r72 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~those~]
         say__p=1;ParaContent();  print (PrintText) SC_1187;  .L_Say857; .L_SayX819;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_529;  .L_Say858; .L_SayX820;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_1160;  .L_Say859; .L_SayX821;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_1161;  .L_Say860; .L_SayX822;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~that~]
         say__p=1;ParaContent();  print (PrintText) SC_1188;  .L_Say861; .L_SayX823;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 73: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say That-those ( item - a thing ):
[ PHR_970_r73 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_1184;  .L_Say862; .L_SayX824;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say863; .L_SayX825;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_737;  .L_Say864; .L_SayX826;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_736;  .L_Say865; .L_SayX827;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_1186;  .L_Say866; .L_SayX828;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 74: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap that-those of ( item - a thing ) ( deprecated ):
[ PHR_971_r74 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_1184;  .L_Say867; .L_SayX829;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say868; .L_SayX830;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_737;  .L_Say869; .L_SayX831;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_736;  .L_Say870; .L_SayX832;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_1186;  .L_Say871; .L_SayX833;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 75: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say that-those of ( item - a thing ):
[ PHR_972_r75 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~those~]
         say__p=1;ParaContent();  print (PrintText) SC_1187;  .L_Say872; .L_SayX834;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~you~]
         say__p=1;ParaContent();  print (PrintText) SC_529;  .L_Say873; .L_SayX835;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~he~]
         say__p=1;ParaContent();  print (PrintText) SC_1160;  .L_Say874; .L_SayX836;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~she~]
         say__p=1;ParaContent();  print (PrintText) SC_1161;  .L_Say875; .L_SayX837;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~that~]
         say__p=1;ParaContent();  print (PrintText) SC_1188;  .L_Say876; .L_SayX838;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 76: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say That-those of ( item - a thing ):
[ PHR_973_r76 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Those~]
         say__p=1;ParaContent();  print (PrintText) SC_1184;  .L_Say877; .L_SayX839;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say878; .L_SayX840;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_737;  .L_Say879; .L_SayX841;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_736;  .L_Say880; .L_SayX842;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~That~]
         say__p=1;ParaContent();  print (PrintText) SC_1186;  .L_Say881; .L_SayX843;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 77: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say it-they:
[ PHR_974_r77 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_975_r12 ((Global_Vars-->19))); .L_Say882; .L_SayX844;
   rfalse;
];
! Request 78: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-they ( deprecated ):
[ PHR_976_r78 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_979_r81 ((Global_Vars-->19))); .L_Say883; .L_SayX845;
   rfalse;
];
! Request 79: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-they of ( item - a thing ) ( deprecated ):
[ PHR_977_r79 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~They~]
         say__p=1;ParaContent();  print (PrintText) SC_1189;  .L_Say884; .L_SayX846;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say885; .L_SayX847;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_737;  .L_Say886; .L_SayX848;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_736;  .L_Say887; .L_SayX849;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_1190;  .L_Say888; .L_SayX850;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 80: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say It-they:
[ PHR_978_r80 ;
      ! phrase 1
      ! [1: say it-they of prior named noun]
      say__p=1;ParaContent(); (PHR_979_r81 ((Global_Vars-->19))); .L_Say889; .L_SayX851;
   rfalse;
];
! Request 81: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say It-they of ( item - a thing ):
[ PHR_979_r81 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~They~]
         say__p=1;ParaContent();  print (PrintText) SC_1189;  .L_Say890; .L_SayX852;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say891; .L_SayX853;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~He~]
         say__p=1;ParaContent();  print (PrintText) SC_737;  .L_Say892; .L_SayX854;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~She~]
         say__p=1;ParaContent();  print (PrintText) SC_736;  .L_Say893; .L_SayX855;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_1190;  .L_Say894; .L_SayX856;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 82: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say its-their:
[ PHR_980_r82 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_981_r83 ((Global_Vars-->19))); .L_Say895; .L_SayX857;
   rfalse;
];
! Request 83: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say its-their of ( item - a thing ):
[ PHR_981_r83 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~their~]
         say__p=1;ParaContent();  print (PrintText) SC_1191;  .L_Say896; .L_SayX858;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~your~]
         say__p=1;ParaContent();  print (PrintText) SC_1192;  .L_Say897; .L_SayX859;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~his~]
         say__p=1;ParaContent();  print (PrintText) SC_1193;  .L_Say898; .L_SayX860;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~her~]
         say__p=1;ParaContent();  print (PrintText) SC_1157;  .L_Say899; .L_SayX861;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~its~]
         say__p=1;ParaContent();  print (PrintText) SC_1194;  .L_Say900; .L_SayX862;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 84: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-their ( deprecated ):
[ PHR_982_r84 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_985_r87 ((Global_Vars-->19))); .L_Say901; .L_SayX863;
   rfalse;
];
! Request 85: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-their of ( item - a thing ) ( deprecated ):
[ PHR_983_r85 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Their~]
         say__p=1;ParaContent();  print (PrintText) SC_1195;  .L_Say902; .L_SayX864;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_1196;  .L_Say903; .L_SayX865;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_1197;  .L_Say904; .L_SayX866;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_1198;  .L_Say905; .L_SayX867;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_1199;  .L_Say906; .L_SayX868;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 86: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Its-their:
[ PHR_984_r86 ;
      ! phrase 1
      ! [1: say its-their of prior named noun]
      say__p=1;ParaContent(); (PHR_985_r87 ((Global_Vars-->19))); .L_Say907; .L_SayX869;
   rfalse;
];
! Request 87: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Its-their of ( item - a thing ):
[ PHR_985_r87 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Their~]
         say__p=1;ParaContent();  print (PrintText) SC_1195;  .L_Say908; .L_SayX870;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_1196;  .L_Say909; .L_SayX871;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_1197;  .L_Say910; .L_SayX872;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_1198;  .L_Say911; .L_SayX873;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_1199;  .L_Say912; .L_SayX874;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 88: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say it-them:
[ PHR_986_r88 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_987_r10 ((Global_Vars-->19))); .L_Say913; .L_SayX875;
   rfalse;
];
! Request 89: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-them ( deprecated ):
[ PHR_988_r89 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_991_r92 ((Global_Vars-->19))); .L_Say914; .L_SayX876;
   rfalse;
];
! Request 90: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap it-them of ( item - a thing ) ( deprecated ):
[ PHR_989_r90 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Them~]
         say__p=1;ParaContent();  print (PrintText) SC_1200;  .L_Say915; .L_SayX877;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say916; .L_SayX878;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~Him~]
         say__p=1;ParaContent();  print (PrintText) SC_1201;  .L_Say917; .L_SayX879;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_1198;  .L_Say918; .L_SayX880;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_1190;  .L_Say919; .L_SayX881;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 91: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say It-them:
[ PHR_990_r91 ;
      ! phrase 1
      ! [1: say it-them of prior named noun]
      say__p=1;ParaContent(); (PHR_991_r92 ((Global_Vars-->19))); .L_Say920; .L_SayX882;
   rfalse;
];
! Request 92: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say It-them of ( item - a thing ):
[ PHR_991_r92 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Them~]
         say__p=1;ParaContent();  print (PrintText) SC_1200;  .L_Say921; .L_SayX883;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~You~]
         say__p=1;ParaContent();  print (PrintText) SC_1185;  .L_Say922; .L_SayX884;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~Him~]
         say__p=1;ParaContent();  print (PrintText) SC_1201;  .L_Say923; .L_SayX885;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Her~]
         say__p=1;ParaContent();  print (PrintText) SC_1198;  .L_Say924; .L_SayX886;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~It~]
         say__p=1;ParaContent();  print (PrintText) SC_1190;  .L_Say925; .L_SayX887;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 93: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say its-theirs:
[ PHR_992_r93 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_993_r94 ((Global_Vars-->19))); .L_Say926; .L_SayX888;
   rfalse;
];
! Request 94: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say its-theirs of ( item - a thing ):
[ PHR_993_r94 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_1202;  .L_Say927; .L_SayX889;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~yours~]
         say__p=1;ParaContent();  print (PrintText) SC_1203;  .L_Say928; .L_SayX890;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~his~]
         say__p=1;ParaContent();  print (PrintText) SC_1193;  .L_Say929; .L_SayX891;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~hers~]
         say__p=1;ParaContent();  print (PrintText) SC_1204;  .L_Say930; .L_SayX892;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~its~]
         say__p=1;ParaContent();  print (PrintText) SC_1194;  .L_Say931; .L_SayX893;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 95: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-theirs ( deprecated ):
[ PHR_994_r95 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_997_r98 ((Global_Vars-->19))); .L_Say932; .L_SayX894;
   rfalse;
];
! Request 96: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap its-theirs of ( item - a thing ) ( deprecated ):
[ PHR_995_r96 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_1205;  .L_Say933; .L_SayX895;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Yours~]
         say__p=1;ParaContent();  print (PrintText) SC_1206;  .L_Say934; .L_SayX896;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_1197;  .L_Say935; .L_SayX897;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Hers~]
         say__p=1;ParaContent();  print (PrintText) SC_1207;  .L_Say936; .L_SayX898;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_1199;  .L_Say937; .L_SayX899;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 97: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Its-theirs:
[ PHR_996_r97 ;
      ! phrase 1
      ! [1: say its-theirs of prior named noun]
      say__p=1;ParaContent(); (PHR_997_r98 ((Global_Vars-->19))); .L_Say938; .L_SayX900;
   rfalse;
];
! Request 98: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Its-theirs of ( item - a thing ):
[ PHR_997_r98 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item acts plural begin]
       if (((PHR_943_r53 (t_0))))  {
         ! phrase 4
         ! [4: say ~Theirs~]
         say__p=1;ParaContent();  print (PrintText) SC_1205;  .L_Say939; .L_SayX901;
         ! phrase 5
         ! [5: otherwise if the item is the player]
          } else if (((t_0 == player))) { 
         ! phrase 6
         ! [6: say ~Yours~]
         say__p=1;ParaContent();  print (PrintText) SC_1206;  .L_Say940; .L_SayX902;
         ! phrase 7
         ! [7: otherwise if the item is male and item is not neuter]
          } else if (((((Adj_78_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 8
         ! [8: say ~His~]
         say__p=1;ParaContent();  print (PrintText) SC_1197;  .L_Say941; .L_SayX903;
         ! phrase 9
         ! [9: otherwise if the item is female and item is not neuter]
          } else if (((((Adj_77_t1_v9(t_0))))) && (((~~(((Adj_79_t1_v9(t_0)))))))) { 
         ! phrase 10
         ! [10: say ~Hers~]
         say__p=1;ParaContent();  print (PrintText) SC_1207;  .L_Say942; .L_SayX904;
         ! phrase 11
         ! [11: otherwise]
         } else {

         ! phrase 12
         ! [12: say ~Its~]
         say__p=1;ParaContent();  print (PrintText) SC_1199;  .L_Say943; .L_SayX905;
         ! phrase 13
         ! [13: end if]
         }

   rfalse;
];
! Request 99: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say possessive:
[ PHR_998_r99 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_999_r100 ((Global_Vars-->19))); .L_Say944; .L_SayX906;
   rfalse;
];
! Request 100: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say possessive of ( item - a thing ):
[ PHR_999_r100 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~your~]
         say__p=1;ParaContent();  print (PrintText) SC_1192;  .L_Say945; .L_SayX907;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_943_r53 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[the item][apostrophe]~]
         say__p=1;ParaContent();  print (the) t_0; ParaContent();  print "'";  .L_Say946; .L_SayX908;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[the item][apostrophe]s~]
         say__p=1;ParaContent();  print (the) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_597;  .L_Say947; .L_SayX909;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 101: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Cap possessive ( deprecated ):
[ PHR_1000_r101 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_1003_r104 ((Global_Vars-->19))); .L_Say948; .L_SayX910;
   rfalse;
];
! Request 102: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Cap possessive of ( item - a thing ) ( deprecated ):
[ PHR_1001_r102 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_1196;  .L_Say949; .L_SayX911;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_943_r53 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[The item][apostrophe]~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'";  .L_Say950; .L_SayX912;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[The item][apostrophe]s~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_597;  .L_Say951; .L_SayX913;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 103: phrase nothing -> nothing
! From "Plurality" by Emily Short
! To say Possessive:
[ PHR_1002_r103 ;
      ! phrase 1
      ! [1: say possessive of prior named noun]
      say__p=1;ParaContent(); (PHR_1003_r104 ((Global_Vars-->19))); .L_Say952; .L_SayX914;
   rfalse;
];
! Request 104: phrase thing -> nothing
! From "Plurality" by Emily Short
! To say Possessive of ( item - a thing ):
[ PHR_1003_r104 
    t_0 ! Call parameter 'item' = thing
    ;
      ! phrase 1
      ! [1: now the prior named noun is the item]
       (Global_Vars-->19) = t_0; 
      ! phrase 2
      ! [2: mark prior named noun in output]
      (PHR_940_r15 ((Global_Vars-->19)));
      ! phrase 3
      ! [3: if the item is the player begin]
       if (((t_0 == player)))  {
         ! phrase 4
         ! [4: say ~Your~]
         say__p=1;ParaContent();  print (PrintText) SC_1196;  .L_Say953; .L_SayX915;
         ! phrase 5
         ! [5: otherwise if the item acts plural]
          } else if (((PHR_943_r53 (t_0)))) { 
         ! phrase 6
         ! [6: say ~[The item][apostrophe]~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'";  .L_Say954; .L_SayX916;
         ! phrase 7
         ! [7: otherwise]
         } else {

         ! phrase 8
         ! [8: say ~[The item][apostrophe]s~]
         say__p=1;ParaContent();  print (The) t_0; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_597;  .L_Say955; .L_SayX917;
         ! phrase 9
         ! [9: end if]
         }

   rfalse;
];
! Request 105: phrase object -> nothing
! From "Plurality" by Emily Short
! To have the parser notice ( o - an object ):
[ PHR_1007_r105 
    t_0 ! Call parameter 'o' = object
    ;
      ! phrase 1
      ! [1: if o is ambiguously plural , notice the plurality of o]
       if ((((Adj_92_t1_v9(t_0))))) {  PlugPlural(t_0);   }
      ! phrase 2
      ! [2: otherwise set pronouns from o]
       else {  PronounNotice(t_0);   }
   rfalse;
];
! Request 106: phrase nothing -> nothing
! From "Basic Screen Effects" by Emily Short
! To pause the/-- game:
[ PHR_1022_r106 ;
      ! phrase 1
      ! [1: say ~[paragraph break]Please press SPACE to continue.~]
      say__p=1;ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1208;  new_line; .L_Say956; .L_SayX918;
      ! phrase 2
      ! [2: wait for the space key]
       SPACEPause(); 
      ! phrase 3
      ! [3: clear the screen]
       VM_ClearScreen(0); 
   rfalse;
];
! Request 107: phrase table name -> nothing
! From "Basic Screen Effects" by Emily Short
! To fill the/-- status bar/line with ( selected table - a table-name ):
[ PHR_1032_r107 
    t_0 ! Call parameter 'selected table' = table name
    t_1 ! Local variable e.g. '__n' = number
    t_2 ! Local variable e.g. '__index' = number
    t_3 ! Local variable e.g. '?-1,-1?' = number
    t_4 ! Local variable e.g. '?-1,-1?' = number
    ct_0 ct_1 ! Used for table searches
    ;
      ! phrase 1
      ! [1: let __n be the number of rows in the selected table]
       t_1 =  TableRows(t_0) ; 
      ! phrase 2
      ! [2: deepen status line to __n rows]
       DeepStatus(t_1); 
      ! phrase 3
      ! [3: let __index be 1]
       t_2 = 1; 
      ! phrase 4
      ! [4: repeat through selected table begin]
       @push ct_0; @push ct_1;
		for (t_3=t_0,t_4=1,ct_0=t_3,ct_1=t_4:
			t_4<=TableRows(t_3):t_4++,ct_0=t_3,ct_1=t_4)
			if (TableRowIsBlank(ct_0,ct_1)==false)  {
         ! phrase 5
         ! [5: move cursor to __index]
          I7VM_MoveCursorInStatusLine(t_2); 
         ! phrase 6
         ! [6: say ~[left entry]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,114,ct_1);  .L_Say957; .L_SayX919;
         ! phrase 7
         ! [7: center central entry at row __index]
          CenterPrint(TableLookUpEntry(ct_0,115,ct_1), t_2); 
         ! phrase 8
         ! [8: right align cursor to __index]
          RightAlign(t_2); 
         ! phrase 9
         ! [9: say ~[right entry]~]
         say__p=1;ParaContent();  print (PrintText) TableLookUpEntry(ct_0,116,ct_1);  .L_Say958; .L_SayX920;
         ! phrase 10
         ! [10: increase __index by 1]
          t_2 = t_2 + 1; 
         ! phrase 11
         ! [11: end repeat]
         }
@pull ct_1; @pull ct_0;
   rfalse;
];
! Request 108: phrase nothing -> nothing
! To end the conductor's story:
[ PHR_1097_r108 ;
      ! phrase 1
      ! [1: say ~The train comes to a halt.[paragraph break]~]
      say__p=1;ParaContent();  print (PrintText) SC_270; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say959; .L_SayX921;
      ! phrase 2
      ! [2: now the station of the steam train is freshwater crossing]
       WriteGProperty(9, I439_steam_train,p16_station,I507_freshwater_crossing); 
      ! phrase 3
      ! [3: say ~'Well, we're here. I gotta -- gotta, er, prepare the train for storage, and go get on the boat.' He shakes your hand gravely. 'It was nice to meet you, however this turns out! I hope I'll be back to this train someday, but even if not, well, there's other trains in the sea! Or, well, in the pond!' He flashes you a final, wistful smile, and is gone.~]
      say__p=1;ParaContent();  print (PrintText) SC_1209;  new_line; .L_Say960; .L_SayX922;
      ! phrase 4
      ! [4: now the conductor is off-stage]
       (Adj_9_t3_v9(I711_conductor)); 
      ! phrase 5
      ! [5: now the steam train is flooded]
       (Adj_136_t2_v9(I439_steam_train)); 
   rfalse;
];
! Request 109: phrase nothing -> nothing
! To say two random autumnal colors:
[ PHR_1396_r109 
    t_0 ! Local variable e.g. 'hue' = autumnal color
    ;
      ! phrase 1
      ! [1: let hue be a random autumnal color]
       t_0 =  R_T75() ; 
      ! phrase 2
      ! [2: say ~[hue] and [a random autumnal color that is not hue]~]
      say__p=1;ParaContent();  print (T75) t_0; ParaContent();  print (PrintText) SC_1210; ParaContent();  print (T75)  (Prop_128(,t_0)) ;  .L_Say961; .L_SayX923;
   rfalse;
];
! Request 110: phrase nothing -> nothing
! To end the secretary's story:
[ PHR_1532_r110 ;
      ! phrase 1
      ! [1: say ~[The secretary] gives the rope another jerk, and you pull free from the mud, which fills the hole you left behind with a sickening squelch. She unties the rope and coils it back into her bag.[paragraph break][The secretary] walks up to the large boat, and presses it with her hand; a hitherto invisible door slides open. She turns back to you with a pained face, and then enters the boat. The door slides neatly shut behind her and is invisible again; there's no trace it was ever there.~]
      say__p=1;ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1211; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1212;  new_line; .L_Say962; .L_SayX924;
      ! phrase 2
      ! [2: now the player is free]
       (Adj_131_t2_v9(player)); 
      ! phrase 3
      ! [3: now the secretary is off-stage]
       (Adj_9_t3_v9(I545_secretary_of_water)); 
   rfalse;
];
[ LOS_0 
    t_0 ! Call parameter 'it' = object
    ;
if (((t_0 ofclass K26_liquid_source))) los_rv = t_0;
];
[ LOS_1 
    t_0 ! Call parameter 'it' = object
    ;
if (((t_0 ofclass K26_liquid_source))) los_rv = t_0;
];
[ text_routine_0;
say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_1213; 
	if (~~(((((Adj_124_t1_v9(noun))))))) jump L_Say963;
		ParaContent();  print (PrintText) SC_1214; 
	jump L_SayX925; .L_Say963;
		ParaContent();  print (PrintText) SC_1215; 
	.L_Say964; .L_SayX925;
		ParaContent();  print (PrintText) SC_250;  .L_Say965; .L_SayX926;
    rtrue;
];

[ text_routine_1;
say__p=1;ParaContent();  print (The) noun; ParaContent();  print (PrintText) SC_1213; 
	if (~~(((((Adj_124_t1_v9(noun))))))) jump L_Say966;
		ParaContent();  print (PrintText) SC_1214; 
	jump L_SayX927; .L_Say966;
		ParaContent();  print (PrintText) SC_1215; 
	.L_Say967; .L_SayX927;
		ParaContent();  print (PrintText) SC_250;  .L_Say968; .L_SayX928;
    rtrue;
];

[ text_routine_2;
say__p=1;ParaContent();  print (PrintText) SC_1216; 
	if (~~(((((Adj_80_t1_v9(I421_small_metal_detector))))))) jump L_Say969;
		ParaContent();  print (PrintText) SC_1217; 
	jump L_SayX929; .L_Say969;
		ParaContent();  print (PrintText) SC_1218; 
	.L_Say970; .L_SayX929;
		 .L_Say971; .L_SayX930;
    rtrue;
];

[ text_routine_3;
say__p=1;ParaContent();  print (PrintText) SC_1219; ParaContent();  DivideParagraphPoint(); new_line; 
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I439_steam_train))))) jump L_Say972;
		ParaContent();  I7_ST_say_one_of-->53 =
	i7_soo_par(I7_ST_say_one_of-->53, 3);
	switch((I7_ST_say_one_of-->53)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1220; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1221; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1222; ParaContent();  } 
	.L_Say972; .L_SayX931;
		
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing))))) jump L_Say973;
		ParaContent();  print (PrintText) SC_1223; 
	.L_Say973; .L_SayX932;
		
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I494_other_side_of_the_pond))))) jump L_Say974;
		ParaContent();  print (PrintText) SC_1224; 
	.L_Say974; .L_SayX933;
		 .L_Say975; .L_SayX934;
    rtrue;
];

[ text_routine_4;
say__p=1;ParaContent();  print (PrintText) SC_1225; 
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I439_steam_train))))) jump L_Say976;
		ParaContent();  I7_ST_say_one_of-->54 =
	i7_soo_par(I7_ST_say_one_of-->54, 2);
	switch((I7_ST_say_one_of-->54)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1226; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1227; ParaContent();  } ParaContent(); 
	jump L_SayX935; .L_Say976; if (~~((((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing))))) jump L_Say977;
		ParaContent();  print (PrintText) SC_1228; 
	jump L_SayX935; .L_Say977;
		ParaContent();  print (PrintText) SC_1229; 
	.L_Say978; .L_SayX935;
		ParaContent();  print (PrintText) SC_250;  .L_Say979; .L_SayX936;
    rtrue;
];

[ text_routine_5;
say__p=1;ParaContent();  print (PrintText) SC_1230; 
	if (~~(((((Adj_71_t1_v9(I709_access_panel))))))) jump L_Say980;
		ParaContent();  print (PrintText) SC_1231; 
	.L_Say980; .L_SayX937;
		ParaContent();  print (PrintText) SC_250;  .L_Say981; .L_SayX938;
    rtrue;
];

[ text_routine_6;
say__p=1;ParaContent();  print (PrintText) SC_1232; 
	if (~~(((Prop_129())))) jump L_Say982;
		ParaContent();  print (PrintText) SC_1233; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I711_conductor == CarrierOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; 
	.L_Say982; .L_SayX939;
		ParaContent();  print (PrintText) SC_250; 
	if (~~(((((Adj_144_t1_v9(I711_conductor))))))) jump L_Say983;
		ParaContent();  print (PrintText) SC_1234; 
	.L_Say983; .L_SayX940;
		 .L_Say984; .L_SayX941;
    rtrue;
];

[ text_routine_7;
say__p=1;
	if (~~((((I441_hill == ContainerOf(player)))))) jump L_Say985;
		ParaContent();  print (PrintText) SC_1235; 
	jump L_SayX942; .L_Say985;
		ParaContent();  print (PrintText) SC_1236; 
	.L_Say986; .L_SayX942;
		ParaContent();  print (PrintText) SC_250;  .L_Say987; .L_SayX943;
    rtrue;
];

[ text_routine_8;
say__p=1;
	if (~~((((I552_bench == SupporterOf(player)))))) jump L_Say988;
		ParaContent();  print (PrintText) SC_1237; 
	.L_Say988; .L_SayX944;
		
	if (~~((((Prop_130())) && (((I552_bench == SupporterOf(player))))))) jump L_Say989;
		ParaContent();  print (PrintText) SC_1238; 
	.L_Say989; .L_SayX945;
		
	if (~~((((~~((I552_bench == SupporterOf(player)))))))) jump L_Say990;
		ParaContent();  print (PrintText) SC_1239; ParaContent();  print (PrintShortName) I463_pond; ParaContent();  print (PrintText) SC_1240; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1241; 
	.L_Say990; .L_SayX946;
		 .L_Say991; .L_SayX947;
    rtrue;
];

[ text_routine_9;
say__p=1;ParaContent();  print (PrintText) SC_1242; ParaContent();  print (T75)  R_T75() ; ParaContent();  print (PrintText) SC_250;  .L_Say992; .L_SayX948;
    rtrue;
];

[ text_routine_10;
say__p=1;ParaContent();  print (PrintText) SC_1243; ParaContent();  I7_ST_say_one_of-->55 =
	i7_soo_ran(I7_ST_say_one_of-->55, 3);
	switch((I7_ST_say_one_of-->55)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1244; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1245; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1246; ParaContent();  } ParaContent();  print (PrintText) SC_1247; ParaContent();  I7_ST_say_one_of-->56 =
	i7_soo_ran(I7_ST_say_one_of-->56, 3);
	switch((I7_ST_say_one_of-->56)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1248; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1249; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1250; ParaContent();  } ParaContent();  print (PrintText) SC_517;  .L_Say993; .L_SayX949;
    rtrue;
];

[ text_routine_11;
say__p=1;ParaContent();  print (PrintText) SC_1251; ParaContent();  I7_ST_say_one_of-->57 =
	i7_soo_ran(I7_ST_say_one_of-->57, 4);
	switch((I7_ST_say_one_of-->57)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_1252; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1253; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1254; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_1255; ParaContent();  } ParaContent();  print (PrintText) SC_1256;  .L_Say994; .L_SayX950;
    rtrue;
];

[ text_routine_12;
say__p=1;ParaContent();  print (PrintText) SC_1257; 
	if (~~(((((I442_in_the_sweetgum_tree == ContainerOf(I563_metal_wind_chimes)))) && (((~~((I442_in_the_sweetgum_tree == ContainerOf(player))))))))) jump L_Say995;
		ParaContent();  print (PrintText) SC_1258; ParaContent(); 
	jump L_SayX951; .L_Say995; if (~~((((I442_in_the_sweetgum_tree == ContainerOf(I563_metal_wind_chimes)))))) jump L_Say996;
		ParaContent();  print (PrintText) SC_1259; 
	.L_Say996; .L_SayX951;
		ParaContent();  print (PrintText) SC_250;  .L_Say997; .L_SayX952;
    rtrue;
];

[ text_routine_13;
say__p=1;ParaContent();  print (PrintText) SC_1260; ParaContent();  I7_ST_say_one_of-->58 =
	i7_soo_par(I7_ST_say_one_of-->58, 5);
	switch((I7_ST_say_one_of-->58)%(5+1)-1) {
		0: ParaContent();  print (PrintText) SC_1261; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1262; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1263; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_1264; ParaContent();  @nop; 4: ParaContent();  print (PrintText) SC_1265; ParaContent();  } ParaContent();  print (PrintText) SC_1266; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1267;  .L_Say998; .L_SayX953;
    rtrue;
];

[ text_routine_14;
say__p=1;ParaContent();  print (PrintText) SC_1268; ParaContent();  print (PrintShortName) I460_path; ParaContent();  print (PrintText) SC_1269; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1270; 
	if (~~(((((Adj_71_t1_v9(I516_door_to_the_waterworks))))))) jump L_Say999;
		ParaContent();  print (PrintText) SC_1271; 
	jump L_SayX954; .L_Say999;
		ParaContent();  print (PrintText) SC_1272; 
	.L_Say1000; .L_SayX954;
		ParaContent();  print (PrintText) SC_1273; 
	if (~~(((((Adj_80_t1_v9(I461_water_fountain))))))) jump L_Say1001;
		ParaContent();  print (PrintText) SC_1274; 
	.L_Say1001; .L_SayX955;
		ParaContent();  print (PrintText) SC_1275; 
	if (~~(((((scene_status-->(I424_first_pump-1)==1)))))) jump L_Say1002;
		ParaContent();  I7_ST_say_one_of-->59 =
	i7_soo_stop(I7_ST_say_one_of-->59, 2);
	switch((I7_ST_say_one_of-->59)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1276; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1277; ParaContent();  } ParaContent();  print (PrintText) SC_250; 
	.L_Say1002; .L_SayX956;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1278; ParaContent();  print (PrintShortName) I463_pond; ParaContent();  print (PrintText) SC_1279; ParaContent();  print (a) I473_chain_link_fence; ParaContent();  print (PrintText) SC_1280; 
	if (~~(((Prop_131())))) jump L_Say1003;
		ParaContent();  print (PrintText) SC_1281; 
	.L_Say1003; .L_SayX957;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1282;  .L_Say1004; .L_SayX958;
    rtrue;
];

[ text_routine_15;
say__p=1;ParaContent();  print (PrintText) SC_1283; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_830; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (player == WearerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250;  .L_Say1005; .L_SayX959;
    rtrue;
];

[ text_routine_16;
say__p=1;ParaContent();  print (PrintText) SC_1284; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1285; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1286; ParaContent();  I7_ST_say_one_of-->60 =
	i7_soo_cyc(I7_ST_say_one_of-->60, 4);
	switch((I7_ST_say_one_of-->60)%(4+1)-1) {
		0: ParaContent();  print (PrintText) SC_1287; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1288; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1289; ParaContent();  @nop; 3: ParaContent();  print (PrintText) SC_1290; ParaContent();  } ParaContent();  print (PrintText) SC_250;  .L_Say1006; .L_SayX960;
    rtrue;
];

[ text_routine_17;
say__p=1;ParaContent();  print (PrintText) SC_1291; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1292;  .L_Say1007; .L_SayX961;
    rtrue;
];

[ text_routine_18;
say__p=1;ParaContent();  print (PrintText) SC_1293; ParaContent();  print (number) say__n=( (the_time%ONE_HOUR) ); ParaContent();  print (PrintText) SC_1294;  .L_Say1008; .L_SayX962;
    rtrue;
];

[ text_routine_19;
say__p=1;ParaContent();  print (PrintText) SC_1295; ParaContent();  print (number) say__n=( (the_time%ONE_HOUR) ); ParaContent();  print (PrintText) SC_1296; 
	if (~~(((((Adj_80_t1_v9(I461_water_fountain))))))) jump L_Say1009;
		ParaContent();  print (PrintText) SC_1274; 
	.L_Say1009; .L_SayX963;
		ParaContent();  print (PrintText) SC_1297;  .L_Say1010; .L_SayX964;
    rtrue;
];

[ text_routine_20;
say__p=1;ParaContent();  print (PrintText) SC_1298; 
	if (~~(((((Adj_80_t1_v9(self))))))) jump L_Say1011;
		ParaContent();  print (PrintText) SC_387; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1299; 
	.L_Say1011; .L_SayX965;
		 .L_Say1012; .L_SayX966;
    rtrue;
];

[ text_routine_21;
say__p=1;ParaContent();  print (PrintText) SC_1300; 
	if (~~((((I447_outside_waterworks == ContainerOf(player)))))) jump L_Say1013;
		ParaContent();  print (PrintText) SC_1301; 
	jump L_SayX967; .L_Say1013;
		ParaContent();  print (PrintText) SC_1302; 
	.L_Say1014; .L_SayX967;
		ParaContent();  print (PrintText) SC_1303;  .L_Say1015; .L_SayX968;
    rtrue;
];

[ text_routine_22;
say__p=1;ParaContent();  print (PrintText) SC_1304; ParaContent();  print (number) say__n=( (the_time%ONE_HOUR) ); ParaContent();  print (PrintText) SC_1305;  .L_Say1016; .L_SayX969;
    rtrue;
];

[ text_routine_23;
say__p=1;
	if (~~((( (ExistsTableLookUpCorr(T12_pond_descriptions,121,120,real_location)) )))) jump L_Say1017;
		ParaContent();  print (PrintText) TableLookUpCorr(T12_pond_descriptions,121,120,real_location); 
	jump L_SayX970; .L_Say1017;
		ParaContent();  print (PrintText) SC_1306; ParaContent();  print (the)  (Prop_132()) ; ParaContent();  print (PrintText) SC_1307; 
	.L_Say1018; .L_SayX970;
		
	if (~~(((Prop_133())))) jump L_Say1019;
		ParaContent();  print (PrintText) SC_387; ParaContent();  I7_ST_say_one_of-->61 =
	i7_soo_stop(I7_ST_say_one_of-->61, 2);
	switch((I7_ST_say_one_of-->61)%(2+1)-1) {
		0: ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  @nop; 1: ParaContent();  } ParaContent();  print (PrintText) SC_1308; 
	.L_Say1019; .L_SayX971;
		
	if (~~(((Prop_134())))) jump L_Say1020;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1309; 
	.L_Say1020; .L_SayX972;
		 .L_Say1021; .L_SayX973;
    rtrue;
];

[ text_routine_24;
say__p=1;ParaContent();  print (PrintText) SC_1310; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1311; 
	if (~~(((((Adj_71_t1_v9(I483_community_center_door))))))) jump L_Say1022;
		ParaContent();  print (PrintText) SC_1312; 
	jump L_SayX974; .L_Say1022;
		ParaContent();  print (PrintText) SC_1313; 
	.L_Say1023; .L_SayX974;
		ParaContent();  print (PrintText) SC_1314;  .L_Say1024; .L_SayX975;
    rtrue;
];

[ text_routine_25;
say__p=1;ParaContent();  print (PrintText) SC_1315; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1316; 
	if (~~(((((scene_status-->(I430_third_pump-1)==1)))))) jump L_Say1025;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1317; 
	.L_Say1025; .L_SayX976;
		 .L_Say1026; .L_SayX977;
    rtrue;
];

[ text_routine_26;
say__p=1;ParaContent();  print (PrintText) SC_1318; 
	if (~~(((((scene_status-->(I430_third_pump-1)==1)))))) jump L_Say1027;
		ParaContent();  print (PrintText) SC_1319; 
	.L_Say1027; .L_SayX978;
		 .L_Say1028; .L_SayX979;
    rtrue;
];

[ text_routine_27;
say__p=1;
	if (~~((((Prop_135())) && (((~~(((scene_status-->(I430_third_pump-1)==1))))))))) jump L_Say1029;
		ParaContent();  print (PrintText) SC_1320; 
	.L_Say1029; .L_SayX980;
		
	if (~~((((Prop_136())) && (((~~(((scene_status-->(I430_third_pump-1)==1))))))))) jump L_Say1030;
		ParaContent();  print (PrintText) SC_1321; 
	.L_Say1030; .L_SayX981;
		
	if (~~((((~~(((scene_status-->(I430_third_pump-1)==1)))))))) jump L_Say1031;
		ParaContent();  print (PrintText) SC_1322; 
	.L_Say1031; .L_SayX982;
		
	if (~~(((((scene_status-->(I430_third_pump-1)==1)))))) jump L_Say1032;
		ParaContent();  print (PrintText) SC_1323; 
	.L_Say1032; .L_SayX983;
		ParaContent();  print (PrintText) SC_1324; 
	if (~~(((Prop_137())))) jump L_Say1033;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1308; 
	.L_Say1033; .L_SayX984;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1325;  .L_Say1034; .L_SayX985;
    rtrue;
];

[ text_routine_28;
say__p=1;ParaContent();  print (PrintText) SC_1326; 
	if (~~((((~~(((Adj_60_t1_v9(I476_wide_stick))))))))) jump L_Say1035;
		ParaContent();  print (PrintText) SC_1327; 
	.L_Say1035; .L_SayX986;
		ParaContent();  print (PrintText) SC_250;  .L_Say1036; .L_SayX987;
    rtrue;
];

[ text_routine_29;
say__p=1;ParaContent();  print (PrintText) SC_1328; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1329; 
	if (~~((((I661_wheel_holes == ContainerOf(I490_flagpole)))))) jump L_Say1037;
		ParaContent();  print (PrintText) SC_1330; 
	.L_Say1037; .L_SayX988;
		 .L_Say1038; .L_SayX989;
    rtrue;
];

[ text_routine_30;
say__p=1;ParaContent();  print (PrintText) SC_1331; ParaContent();  print (T75)  R_T75() ; ParaContent();  print (PrintText) SC_250;  .L_Say1039; .L_SayX990;
    rtrue;
];

[ text_routine_31;
say__p=1;ParaContent();  print (PrintText) SC_1332; 
	if (~~((((I661_wheel_holes == ContainerOf(I490_flagpole)))))) jump L_Say1040;
		ParaContent();  print (PrintText) SC_1330; 
	.L_Say1040; .L_SayX991;
		 .L_Say1041; .L_SayX992;
    rtrue;
];

[ text_routine_32;
say__p=1;ParaContent();  print (PrintText) SC_1333; 
	if (~~(((((scene_status-->(I430_third_pump-1)==1)))))) jump L_Say1042;
		ParaContent();  print (PrintText) SC_1334; 
	.L_Say1042; .L_SayX993;
		ParaContent();  print (PrintText) SC_1335; 
	if (~~(((((scene_status-->(I430_third_pump-1)==1)))))) jump L_Say1043;
		ParaContent();  print (PrintText) SC_1336; 
	jump L_SayX994; .L_Say1043;
		ParaContent();  print (PrintText) SC_1337; 
	.L_Say1044; .L_SayX994;
		ParaContent();  print (PrintText) SC_1338; 
	if (~~(((Prop_138())))) jump L_Say1045;
		ParaContent();  print (PrintText) SC_1339; 
	jump L_SayX995; .L_Say1045;
		ParaContent();  print (PrintText) SC_1340; 
	.L_Say1046; .L_SayX995;
		ParaContent();  print (PrintText) SC_579; ParaContent();  I7_ST_say_one_of-->62 =
	i7_soo_stop(I7_ST_say_one_of-->62, 2);
	switch((I7_ST_say_one_of-->62)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1341; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1342; 
	if (~~(((((Adj_49_t1_v9(I479_boat_house))))))) jump L_Say1047;
		ParaContent();  print (PrintText) SC_1343; 
	jump L_SayX996; .L_Say1047;
		ParaContent();  print (PrintText) SC_1344; 
	.L_Say1048; .L_SayX996;
		ParaContent();  print (PrintText) SC_1345; ParaContent();  } ParaContent();  print (PrintText) SC_579; 
	if (~~(((((~~(((Adj_60_t1_v9(I589_wooden_drawer))))))) && ((((scene_status-->(I430_third_pump-1)==1))))))) jump L_Say1049;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1346; ParaContent(); 
	jump L_SayX997; .L_Say1049; if (~~((((~~(((Adj_60_t1_v9(I589_wooden_drawer))))))))) jump L_Say1050;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1347; 
	.L_Say1050; .L_SayX997;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1348;  .L_Say1051; .L_SayX998;
    rtrue;
];

[ text_routine_33;
say__p=1;ParaContent();  print (PrintText) SC_1349; 
	if (~~((((~~(((Adj_60_t1_v9(I589_wooden_drawer))))))))) jump L_Say1052;
		ParaContent();  print (PrintText) SC_1350; 
	.L_Say1052; .L_SayX999;
		ParaContent();  print (PrintText) SC_1351; 
	if (~~((((((Adj_129_t1_v9(I589_wooden_drawer))))) && (((~~(((Adj_70_t1_v9(I591_secret_panel)))))))))) jump L_Say1053;
		ParaContent();  print (PrintText) SC_1352; ParaContent(); 
	jump L_SayX1000; .L_Say1053; if (~~(((((Adj_129_t1_v9(I589_wooden_drawer))))))) jump L_Say1054;
		ParaContent();  print (PrintText) SC_1353; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I591_secret_panel == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; 
	jump L_SayX1000; .L_Say1054;
		ParaContent();  print (PrintText) SC_1354; 
	.L_Say1055; .L_SayX1000;
		ParaContent();  print (PrintText) SC_250;  .L_Say1056; .L_SayX1001;
    rtrue;
];

[ text_routine_34;
say__p=1;ParaContent();  print (PrintText) SC_1355; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1356;  .L_Say1057; .L_SayX1002;
    rtrue;
];

[ text_routine_35;
say__p=1;ParaContent();  print (PrintText) SC_1357; 
	if (~~((((I470_rocky_beach == ContainerOf(player)))))) jump L_Say1058;
		ParaContent();  print (PrintText) SC_1358; ParaContent(); 
	jump L_SayX1003; .L_Say1058; if (~~((((I468_muddy_beach == ContainerOf(player)))))) jump L_Say1059;
		ParaContent();  print (PrintText) SC_1359; ParaContent(); 
	jump L_SayX1003; .L_Say1059; if (~~((((I447_outside_waterworks == ContainerOf(player)))))) jump L_Say1060;
		ParaContent();  print (PrintText) SC_1360; 
	.L_Say1060; .L_SayX1003;
		 .L_Say1061; .L_SayX1004;
    rtrue;
];

[ text_routine_36;
say__p=1;ParaContent();  print (PrintText) SC_1361; 
	if (~~((((I481_rowboat == ContainerOf(player)))))) jump L_Say1062;
		ParaContent();  print (PrintText) SC_1362; 
	jump L_SayX1005; .L_Say1062;
		ParaContent();  print (PrintText) SC_1363; 
	.L_Say1063; .L_SayX1005;
		ParaContent();  print (PrintText) SC_1364; 
	if (~~(((((Adj_70_t1_v9(I482_waterstained_door))))))) jump L_Say1064;
		ParaContent();  print (PrintText) SC_1272; 
	jump L_SayX1006; .L_Say1064;
		ParaContent();  print (PrintText) SC_1271; 
	.L_Say1065; .L_SayX1006;
		ParaContent();  print (PrintText) SC_1365;  .L_Say1066; .L_SayX1007;
    rtrue;
];

[ text_routine_37;
say__p=1;ParaContent();  print (PrintText) SC_1366; 
	if (~~((((I489_large_painted_mural == ContainerOf(I490_flagpole)))))) jump L_Say1067;
		ParaContent();  print (PrintText) SC_1367; 
	.L_Say1067; .L_SayX1008;
		ParaContent();  print (PrintText) SC_250;  .L_Say1068; .L_SayX1009;
    rtrue;
];

[ text_routine_38;
say__p=1;ParaContent();  print (PrintText) SC_1368; 
	if (~~(((((Adj_94_t1_v9(I579_pamphlet))))))) jump L_Say1069;
		ParaContent();  print (PrintText) SC_1369; 
	.L_Say1069; .L_SayX1010;
		ParaContent();  print (PrintText) SC_579; ParaContent();  DivideParagraphPoint(); new_line; 
	if (~~(((((Adj_112_t1_v9(I489_large_painted_mural))))))) jump L_Say1070;
		ParaContent();  print (PrintText) SC_1370; 
	jump L_SayX1011; .L_Say1070;
		ParaContent();  print (PrintText) SC_1371; 
	.L_Say1071; .L_SayX1011;
		
	if (~~((((I489_large_painted_mural == ContainerOf(I490_flagpole)))))) jump L_Say1072;
		ParaContent();  print (PrintText) SC_1372; 
	.L_Say1072; .L_SayX1012;
		 .L_Say1073; .L_SayX1013;
    rtrue;
];

[ text_routine_39;
say__p=1;ParaContent();  print (PrintText) SC_1373; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1374; 
	if (~~(((((Adj_81_t1_v9(I417_underground_pump))))))) jump L_Say1074;
		ParaContent();  print (PrintText) SC_1375; 
	jump L_SayX1014; .L_Say1074;
		ParaContent();  print (PrintText) SC_1376; 
	.L_Say1075; .L_SayX1014;
		ParaContent();  print (PrintText) SC_250; 
	if (~~(((((Adj_80_t1_v9(I418_big_pump))))))) jump L_Say1076;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1377; 
	.L_Say1076; .L_SayX1015;
		
	if (~~(((((Adj_104_t1_v9(I481_rowboat))))))) jump L_Say1077;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1378; 
	.L_Say1077; .L_SayX1016;
		
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I494_other_side_of_the_pond))))) jump L_Say1078;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1379; 
	.L_Say1078; .L_SayX1017;
		 .L_Say1079; .L_SayX1018;
    rtrue;
];

[ text_routine_40;
say__p=1;ParaContent();  print (PrintText) SC_1380; 
	if (~~(((((Adj_80_t1_v9(I418_big_pump))))))) jump L_Say1080;
		ParaContent();  print (PrintText) SC_1381; 
	jump L_SayX1019; .L_Say1080;
		ParaContent();  print (PrintText) SC_1382; 
	.L_Say1081; .L_SayX1019;
		ParaContent();  print (PrintText) SC_250;  .L_Say1082; .L_SayX1020;
    rtrue;
];

[ text_routine_41;
say__p=1;
	if (~~(((((Adj_98_t1_v9(real_location))))))) jump L_Say1083;
		ParaContent();  print (PrintText) SC_1383; 
	jump L_SayX1021; .L_Say1083;
		ParaContent();  print (PrintText) SC_1384; ParaContent();  print (the)  (Prop_139()) ; 
	.L_Say1084; .L_SayX1021;
		ParaContent();  print (PrintText) SC_250;  .L_Say1085; .L_SayX1022;
    rtrue;
];

[ text_routine_42;
say__p=1;ParaContent();  I7_ST_say_one_of-->63 =
	i7_soo_stop(I7_ST_say_one_of-->63, 2);
	switch((I7_ST_say_one_of-->63)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1385; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1386; ParaContent();  } ParaContent();  print (PrintText) SC_250;  .L_Say1086; .L_SayX1023;
    rtrue;
];

[ text_routine_43;
say__p=1;ParaContent();  print (PrintText) SC_1387; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1388;  .L_Say1087; .L_SayX1024;
    rtrue;
];

[ text_routine_44;
say__p=1;ParaContent();  print (PrintText) SC_1389; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_1390;  .L_Say1088; .L_SayX1025;
    rtrue;
];

[ text_routine_45;
say__p=1;ParaContent();  print (PrintText) SC_1391; ParaContent();  DivideParagraphPoint(); new_line; 
	if (~~(((((Adj_95_t1_v9(I633_graffiti))))))) jump L_Say1089;
		ParaContent();  print (PrintText) SC_1392; 
	jump L_SayX1026; .L_Say1089;
		ParaContent();  print (PrintText) SC_1393; ParaContent(); @push self;  StringDecap(GProperty(9, self=I635_metal_plate,description)); @pull self; 
	.L_Say1090; .L_SayX1026;
		 .L_Say1091; .L_SayX1027;
    rtrue;
];

[ text_routine_46;
say__p=1;
	if (~~(((((Adj_70_t1_v9(I635_metal_plate))))))) jump L_Say1092;
		ParaContent();  print (PrintText) SC_1394; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I635_metal_plate == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250; 
	jump L_SayX1028; .L_Say1092;
		ParaContent();  print (PrintText) SC_1395; 
	.L_Say1093; .L_SayX1028;
		 .L_Say1094; .L_SayX1029;
    rtrue;
];

[ text_routine_47;
say__p=1;ParaContent();  print (PrintText) SC_1396; 
	if (~~(((((Adj_134_t1_v9(I637_inside_the_cinderblock_))))))) jump L_Say1095;
		ParaContent();  print (PrintText) SC_1397; 
	jump L_SayX1030; .L_Say1095;
		ParaContent();  print (PrintText) SC_1398; 
	.L_Say1096; .L_SayX1030;
		 .L_Say1097; .L_SayX1031;
    rtrue;
];

[ text_routine_48;
say__p=1;ParaContent();  print (PrintText) SC_1399; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1400; 
	if (~~(((Prop_140())))) jump L_Say1098;
		ParaContent();  print (PrintText) SC_1401; 
	jump L_SayX1032; .L_Say1098;
		ParaContent();  print (PrintText) SC_1402; 
	.L_Say1099; .L_SayX1032;
		ParaContent();  print (PrintText) SC_1403;  .L_Say1100; .L_SayX1033;
    rtrue;
];

[ text_routine_49;
say__p=1;ParaContent();  print (PrintText) SC_1404; 
	if (~~(((Prop_141())))) jump L_Say1101;
		ParaContent();  print (PrintText) SC_1405; 
	jump L_SayX1034; .L_Say1101;
		ParaContent();  print (PrintText) SC_1406; 
	.L_Say1102; .L_SayX1034;
		ParaContent();  print (PrintText) SC_250;  .L_Say1103; .L_SayX1035;
    rtrue;
];

[ text_routine_50;
say__p=1;ParaContent();  print (PrintText) SC_1407; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1408; ParaContent();  DivideParagraphPoint(); new_line; 
	if (~~(((((Adj_3_t1_v9(I545_secretary_of_water))))))) jump L_Say1104;
		ParaContent();  I7_ST_say_one_of-->64 =
	i7_soo_stop(I7_ST_say_one_of-->64, 2);
	switch((I7_ST_say_one_of-->64)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1409; ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  } ParaContent();  print (PrintText) SC_1410; 
	.L_Say1104; .L_SayX1036;
		
	if (~~((((((Adj_3_t1_v9(I545_secretary_of_water))))) && ((((Adj_114_t1_v9(I545_secretary_of_water)))))))) jump L_Say1105;
		ParaContent();  print (PrintText) SC_1411; ParaContent(); 
	jump L_SayX1037; .L_Say1105; if (~~(((((Adj_3_t1_v9(I545_secretary_of_water))))))) jump L_Say1106;
		ParaContent();  print (PrintText) SC_1412; 
	.L_Say1106; .L_SayX1037;
		
	if (~~((((~~(((Adj_3_t1_v9(I545_secretary_of_water))))))))) jump L_Say1107;
		ParaContent();  print (PrintText) SC_1413; 
	.L_Say1107; .L_SayX1038;
		ParaContent();  print (PrintText) SC_1414;  .L_Say1108; .L_SayX1039;
    rtrue;
];

[ text_routine_51;
say__p=1;ParaContent();  print (PrintText) SC_1415; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1416;  .L_Say1109; .L_SayX1040;
    rtrue;
];

[ text_routine_52;
say__p=1;ParaContent();  print (PrintText) SC_1417; 
	if (~~(((((I510_pump_room == ContainerOf(player)))) || ((((Adj_114_t1_v9(I545_secretary_of_water)))))))) jump L_Say1110;
		ParaContent();  print (PrintText) SC_1418; ParaContent(); 
	jump L_SayX1041; .L_Say1110; if (~~((((I506_inside_waterworks == ContainerOf(I545_secretary_of_water)))))) jump L_Say1111;
		ParaContent();  print (PrintText) SC_1419; 
	.L_Say1111; .L_SayX1041;
		ParaContent();  print (PrintText) SC_1420;  .L_Say1112; .L_SayX1042;
    rtrue;
];

[ text_routine_53;
say__p=1;ParaContent();  print (PrintText) SC_1421; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1422; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1423; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1424; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1425; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1426; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1196; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1427;  .L_Say1113; .L_SayX1043;
    rtrue;
];

[ text_routine_54;
say__p=1;ParaContent();  print (PrintText) SC_1428; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1429; ParaContent(); @push self;  StringDecap(GProperty(9, self=I509_grassy_area,short_name)); @pull self; ParaContent();  print (PrintText) SC_1430; 
	if (~~(((((GProperty(9, I439_steam_train,p16_station) == I507_freshwater_crossing))) && ((((Adj_137_t1_v9(I439_steam_train)))))))) jump L_Say1114;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1379; 
	.L_Say1114; .L_SayX1044;
		
	if (~~(((((Adj_136_t1_v9(I439_steam_train))))))) jump L_Say1115;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1431;  .L_Say1115; .L_SayX1045;
    rtrue;
];

[ text_routine_55;
say__p=1;ParaContent();  print (PrintText) SC_1432; ParaContent();  print (a)  (Prop_142()) ; ParaContent();  print (PrintText) SC_250;  .L_Say1116; .L_SayX1046;
    rtrue;
];

[ text_routine_56;
say__p=1;ParaContent();  print (PrintText) SC_1433; 
	if (~~((((I580_vending_machine == ContainerOf(I585_newspaper)))))) jump L_Say1117;
		ParaContent();  print (PrintText) SC_1434; 
	.L_Say1117; .L_SayX1047;
		ParaContent();  print (PrintText) SC_1435; 
	if (~~(((((Adj_71_t1_v9(I580_vending_machine))))))) jump L_Say1118;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1436; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I580_vending_machine == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250; 
	jump L_SayX1048; .L_Say1118;
		ParaContent();  print (PrintText) SC_1437; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I580_vending_machine == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250; 
	.L_Say1119; .L_SayX1048;
		 .L_Say1120; .L_SayX1049;
    rtrue;
];

[ text_routine_57;
say__p=1;ParaContent();  print (PrintText) SC_1438; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1439; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1440; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1441; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1442;  .L_Say1121; .L_SayX1050;
    rtrue;
];

[ text_routine_58;
say__p=1;
	if (~~((((~~(((scene_status-->(I424_first_pump-1)==1)))))))) jump L_Say1122;
		ParaContent();  print (PrintText) SC_1443; ParaContent(); 
	jump L_SayX1051; .L_Say1122; if (~~(((((scene_status-->(I429_second_pump-1)==1)))))) jump L_Say1123;
		ParaContent();  print (PrintText) SC_1444; 
	jump L_SayX1051; .L_Say1123;
		ParaContent();  print (PrintText) SC_1445; 
	.L_Say1124; .L_SayX1051;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1446; 
	if (~~(((((scene_status-->(I429_second_pump-1)==1)))))) jump L_Say1125;
		ParaContent();  print (PrintText) SC_1447; 
	.L_Say1125; .L_SayX1052;
		ParaContent();  print (PrintText) SC_1448; 
	if (~~(((Prop_143())))) jump L_Say1126;
		ParaContent();  print (PrintText) SC_1449; 
	jump L_SayX1053; .L_Say1126;
		ParaContent();  print (PrintText) SC_1450; 
	.L_Say1127; .L_SayX1053;
		ParaContent();  print (PrintText) SC_1451; 
	if (~~((((~~(((scene_status-->(I424_first_pump-1)==1)))))))) jump L_Say1128;
		ParaContent();  print (PrintText) SC_1452; 
	jump L_SayX1054; .L_Say1128;
		ParaContent();  print (PrintText) SC_1453; 
	.L_Say1129; .L_SayX1054;
		ParaContent();  print (PrintText) SC_1454; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1455;  .L_Say1130; .L_SayX1055;
    rtrue;
];

[ text_routine_59;
say__p=1;ParaContent();  print (PrintText) SC_1456; 
	if (~~(((Prop_144())))) jump L_Say1131;
		ParaContent();  print (PrintText) SC_1457; 
	.L_Say1131; .L_SayX1056;
		ParaContent();  print (PrintText) SC_250;  .L_Say1132; .L_SayX1057;
    rtrue;
];

[ text_routine_60;
say__p=1;ParaContent();  print (PrintText) SC_1458; 
	if (~~(((Prop_145())))) jump L_Say1133;
		ParaContent();  print (PrintText) SC_1457; 
	.L_Say1133; .L_SayX1058;
		ParaContent();  print (PrintText) SC_250;  .L_Say1134; .L_SayX1059;
    rtrue;
];

[ text_routine_61;
say__p=1;ParaContent();  print (PrintText) SC_1459; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1460;  .L_Say1135; .L_SayX1060;
    rtrue;
];

[ text_routine_62;
say__p=1;ParaContent();  print (PrintText) SC_1461; ParaContent();  print (PrintShortName) I574_tall_pine_trees; ParaContent();  print (PrintText) SC_291; ParaContent();  print (PrintShortName) I575_pine_sap; ParaContent();  print (PrintText) SC_1462; ParaContent();  print (PrintShortName) I573_pine_needles; 
	if (~~(((Prop_146())))) jump L_Say1136;
		ParaContent();  print (PrintText) SC_1463; 
	.L_Say1136; .L_SayX1061;
		ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1464;  .L_Say1137; .L_SayX1062;
    rtrue;
];

[ text_routine_63;
say__p=1;
	if (~~((((ContainerOf(player) ofclass K1_room) && ((Adj_99_t1_v9(ContainerOf(player)))))))) jump L_Say1138;
		ParaContent();  print (PrintText) SC_1465; ParaContent(); 
	jump L_SayX1063; .L_Say1138; if (~~((((I506_inside_waterworks == ContainerOf(player)))))) jump L_Say1139;
		ParaContent();  print (PrintText) SC_1466; 
	jump L_SayX1063; .L_Say1139;
		ParaContent();  print (PrintText) SC_1467; 
	.L_Say1140; .L_SayX1063;
		
	if (~~((((I441_hill == ContainerOf(player)))))) jump L_Say1141;
		ParaContent();  print (PrintText) SC_1468; 
	.L_Say1141; .L_SayX1064;
		 .L_Say1142; .L_SayX1065;
    rtrue;
];

[ text_routine_64;
say__p=1;ParaContent();  print (PrintText) SC_1469; 
	if (~~(((((Adj_80_t1_v9(I421_small_metal_detector))))))) jump L_Say1143;
		ParaContent();  print (PrintText) SC_1470; 
	.L_Say1143; .L_SayX1066;
		 .L_Say1144; .L_SayX1067;
    rtrue;
];

[ text_routine_65;
say__p=1;ParaContent();  print (PrintText) SC_1471; 
	if (~~(((((Adj_118_t1_v9(I526_leaky_hose))))))) jump L_Say1145;
		ParaContent();  print (PrintText) SC_1472; 
	jump L_SayX1068; .L_Say1145;
		ParaContent();  print (PrintText) SC_1473; 
	.L_Say1146; .L_SayX1068;
		ParaContent();  print (PrintText) SC_250;  .L_Say1147; .L_SayX1069;
    rtrue;
];

[ text_routine_66;
say__p=1;
	if (~~(((((Adj_121_t1_v9(I532_square_gizmo))))))) jump L_Say1148;
		ParaContent();  print (PrintText) SC_1474; 
	jump L_SayX1070; .L_Say1148;
		ParaContent();  print (PrintText) SC_1475; 
	.L_Say1149; .L_SayX1070;
		 .L_Say1150; .L_SayX1071;
    rtrue;
];

[ text_routine_67;
say__p=1;ParaContent();  print (PrintText) SC_1476; 
	if (~~(((((Adj_121_t1_v9(I532_square_gizmo))))))) jump L_Say1151;
		ParaContent();  print (PrintText) SC_1477; 
	jump L_SayX1072; .L_Say1151;
		ParaContent();  print (PrintText) SC_1478; 
	.L_Say1152; .L_SayX1072;
		ParaContent();  print (PrintText) SC_250;  .L_Say1153; .L_SayX1073;
    rtrue;
];

[ text_routine_68;
say__p=1;ParaContent();  print (PrintText) SC_1479; 
	if (~~(((((Adj_76_t1_v9(I536_keyhole_on_the_security))))))) jump L_Say1154;
		ParaContent();  print (PrintText) SC_1480; 
	jump L_SayX1074; .L_Say1154;
		ParaContent();  print (PrintText) SC_1481; 
	.L_Say1155; .L_SayX1074;
		ParaContent();  print (PrintText) SC_250;  .L_Say1156; .L_SayX1075;
    rtrue;
];

[ text_routine_69;
say__p=1;
	if (~~(((((Adj_76_t1_v9(I536_keyhole_on_the_security))))))) jump L_Say1157;
		ParaContent();  print (PrintText) SC_1482; 
	jump L_SayX1076; .L_Say1157;
		ParaContent();  print (PrintText) SC_1483; 
	.L_Say1158; .L_SayX1076;
		 .L_Say1159; .L_SayX1077;
    rtrue;
];

[ text_routine_70;
say__p=1;ParaContent();  print (PrintText) SC_1484; 
	if (~~((((I441_hill == ContainerOf(player)))))) jump L_Say1160;
		ParaContent();  print (PrintText) SC_1485; 
	.L_Say1160; .L_SayX1078;
		ParaContent();  print (PrintText) SC_1486; ParaContent(); (PHR_1396_r109 ());ParaContent();  print (PrintText) SC_1487; 
	if (~~((((I442_in_the_sweetgum_tree == ContainerOf(I563_metal_wind_chimes)))))) jump L_Say1161;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1488; 
	.L_Say1161; .L_SayX1079;
		 .L_Say1162; .L_SayX1080;
    rtrue;
];

[ text_routine_71;
say__p=1;ParaContent();  print (PrintText) SC_1190; ParaContent();  print "'"; ParaContent();  print (PrintText) SC_1489;  .L_Say1163; .L_SayX1081;
    rtrue;
];

[ text_routine_72;
say__p=1;ParaContent();  print (PrintText) SC_1490; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1491; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1492; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1493; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1494; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1495; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1496; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1497; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1498; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1499;  .L_Say1164; .L_SayX1082;
    rtrue;
];

[ text_routine_73;
say__p=1;
	if (~~((((real_location == GProperty(9, I439_steam_train,p16_station)))))) jump L_Say1165;
		ParaContent();  print (PrintText) SC_1500; 
	jump L_SayX1083; .L_Say1165;
		ParaContent();  print (PrintText) SC_1501; 
	.L_Say1166; .L_SayX1083;
		 .L_Say1167; .L_SayX1084;
    rtrue;
];

[ text_routine_74;
say__p=1;
	if (~~((~~(TestSinglePastState(0, 54, false, 5))))) jump L_Say1168;
		ParaContent();  print (PrintText) SC_1502; 
	jump L_SayX1085; .L_Say1168;
		ParaContent();  print (PrintText) SC_1503; 
	.L_Say1169; .L_SayX1085;
		 .L_Say1170; .L_SayX1086;
    rtrue;
];

[ text_routine_75;
say__p=1;ParaContent();  print (PrintText) SC_1504; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1505; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1506; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1507; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1508; ParaContent();  new_line; ParaContent();  print (PrintText) SC_1509; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1510; ParaContent();  style roman; ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1511;  .L_Say1171; .L_SayX1087;
    rtrue;
];

[ text_routine_76;
say__p=1;ParaContent();  I7_ST_say_one_of-->65 =
	i7_soo_ran(I7_ST_say_one_of-->65, 2);
	switch((I7_ST_say_one_of-->65)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1512; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1513; ParaContent();  } ParaContent();  print (PrintText) SC_1210; ParaContent();  I7_ST_say_one_of-->66 =
	i7_soo_ran(I7_ST_say_one_of-->66, 3);
	switch((I7_ST_say_one_of-->66)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1514; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1515; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1516; ParaContent();  } ParaContent();  print (PrintText) SC_1517;  .L_Say1172; .L_SayX1088;
    rtrue;
];

[ text_routine_77;
say__p=1;
	if (~~(((((Adj_134_t1_v9(I637_inside_the_cinderblock_))))))) jump L_Say1173;
		ParaContent();  print (PrintText) SC_1518; 
	jump L_SayX1089; .L_Say1173;
		ParaContent();  print (PrintText) SC_545; 
	.L_Say1174; .L_SayX1089;
		 .L_Say1175; .L_SayX1090;
    rtrue;
];

[ text_routine_78;
say__p=1;ParaContent();  print (PrintText) SC_1519; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1520;  .L_Say1176; .L_SayX1091;
    rtrue;
];

[ text_routine_79;
say__p=1;ParaContent();  print (PrintText) SC_1521; 
	if (~~(((Prop_147())))) jump L_Say1177;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1522; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K2_thing) && (I639_deep_crack == ContainerOf(subst__v))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_1523; 
	jump L_SayX1092; .L_Say1177;
		ParaContent();  print (PrintText) SC_1524; 
	.L_Say1178; .L_SayX1092;
		 .L_Say1179; .L_SayX1093;
    rtrue;
];

[ text_routine_80;
say__p=1;
	if (~~((((real_location == I637_inside_the_cinderblock_))))) jump L_Say1180;
		ParaContent();  print (PrintText) SC_1525; ParaContent(); 
	jump L_SayX1094; .L_Say1180; if (~~((((real_location == I479_boat_house))))) jump L_Say1181;
		ParaContent();  print (PrintText) SC_1526; ParaContent(); 
	jump L_SayX1094; .L_Say1181; if (~~((((real_location == I439_steam_train))))) jump L_Say1182;
		ParaContent();  print (PrintText) SC_1527; 
	jump L_SayX1094; .L_Say1182;
		ParaContent();  print (PrintText) SC_1528; 
	.L_Say1183; .L_SayX1094;
		 .L_Say1184; .L_SayX1095;
    rtrue;
];

[ text_routine_81;
say__p=1;ParaContent();  print (PrintText) SC_1529; 
	if (~~(((((Adj_80_t1_v9(I417_underground_pump))))))) jump L_Say1185;
		ParaContent();  print (PrintText) SC_1530; 
	.L_Say1185; .L_SayX1096;
		ParaContent();  print (PrintText) SC_250;  .L_Say1186; .L_SayX1097;
    rtrue;
];

[ text_routine_82;
say__p=1;ParaContent();  print (PrintText) SC_1531; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  I7_ST_say_one_of-->67 =
	i7_soo_stop(I7_ST_say_one_of-->67, 2);
	switch((I7_ST_say_one_of-->67)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1532; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1533; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1534; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1535; ParaContent();  }  .L_Say1187; .L_SayX1098;
    rtrue;
];

[ text_routine_83;
say__p=1;ParaContent();  I7_ST_say_one_of-->68 =
	i7_soo_stop(I7_ST_say_one_of-->68, 2);
	switch((I7_ST_say_one_of-->68)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1536; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1537; ParaContent();  } ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1188; .L_SayX1099;
    rtrue;
];

[ text_routine_84;
say__p=1;ParaContent();  print (PrintText) SC_1538; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1539; 
	if (~~((( (GenerateRandomNumber(1, 3) <= 1) )))) jump L_Say1189;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1540; 
	.L_Say1189; .L_SayX1100;
		 .L_Say1190; .L_SayX1101;
    rtrue;
];

[ text_routine_85;
say__p=1;ParaContent();  print (PrintText) SC_1541; 
	if (~~(((((Adj_138_t1_v9(I698_giant_metal_wheel))))))) jump L_Say1191;
		ParaContent();  print (PrintText) SC_1542; 
	jump L_SayX1102; .L_Say1191;
		ParaContent();  print (PrintText) SC_1543; 
	.L_Say1192; .L_SayX1102;
		ParaContent();  print (PrintText) SC_1544; 
	if (~~(((((Adj_138_t1_v9(I699_large_crystal_gear))))))) jump L_Say1193;
		ParaContent();  print (PrintText) SC_1545; 
	jump L_SayX1103; .L_Say1193;
		ParaContent();  print (PrintText) SC_1546; 
	.L_Say1194; .L_SayX1103;
		ParaContent();  print (PrintText) SC_1547;  .L_Say1195; .L_SayX1104;
    rtrue;
];

[ text_routine_86;
say__p=1;ParaContent();  I7_ST_say_one_of-->69 =
	i7_soo_stop(I7_ST_say_one_of-->69, 2);
	switch((I7_ST_say_one_of-->69)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1548; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1549; ParaContent();  } ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1196; .L_SayX1105;
    rtrue;
];

[ text_routine_87;
say__p=1;ParaContent();  I7_ST_say_one_of-->70 =
	i7_soo_stop(I7_ST_say_one_of-->70, 2);
	switch((I7_ST_say_one_of-->70)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1550; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1551; ParaContent();  } ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1197; .L_SayX1106;
    rtrue;
];

[ text_routine_88;
say__p=1;
	if (~~(((((Adj_140_t1_v9(I701_cavity))))))) jump L_Say1198;
		ParaContent();  print (PrintText) SC_1552; 
	jump L_SayX1107; .L_Say1198;
		ParaContent();  print (PrintText) SC_1553; 
	.L_Say1199; .L_SayX1107;
		ParaContent();  print (PrintText) SC_250;  .L_Say1200; .L_SayX1108;
    rtrue;
];

[ text_routine_89;
say__p=1;ParaContent();  print (PrintText) SC_1554; 
	if (~~(((((Adj_138_t1_v9(I699_large_crystal_gear))))))) jump L_Say1201;
		ParaContent();  print (PrintText) SC_1555; 
	jump L_SayX1109; .L_Say1201;
		ParaContent();  print (PrintText) SC_1556;  .L_Say1202; .L_SayX1109;
    rtrue;
];

[ text_routine_90;
say__p=1;ParaContent(); (PHR_740_r28 ());ParaContent();  print (PrintText) SC_1557; ParaContent(); (PHR_741_r29 ());ParaContent();  new_line;  .L_Say1203; .L_SayX1110;
    rtrue;
];

[ text_routine_91;
say__p=1;ParaContent(); (PHR_740_r28 ());ParaContent();  print (PrintText) SC_1558; ParaContent(); (PHR_741_r29 ());ParaContent();  new_line;  .L_Say1204; .L_SayX1111;
    rtrue;
];

[ text_routine_92;
say__p=1;ParaContent(); (PHR_740_r28 ());ParaContent();  print (PrintText) SC_1559; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K3_direction) && ((Adj_31_t1_v9(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250; ParaContent(); (PHR_741_r29 ());ParaContent();  new_line;  .L_Say1205; .L_SayX1112;
    rtrue;
];

[ text_routine_93;
say__p=1;ParaContent(); (PHR_740_r28 ());ParaContent();  print (PrintText) SC_1560; ParaContent();  @push subst__v;
		objectloop (subst__v ofclass Object) if (((subst__v ofclass K3_direction) && ((Adj_31_t1_v9(subst__v)))))
		give subst__v workflag2; else give subst__v ~workflag2;
		WriteListOfMarkedObjects(ENGLISH_BIT+NOARTICLE_BIT);
		@pull subst__v; ParaContent();  print (PrintText) SC_250; ParaContent(); (PHR_741_r29 ());ParaContent();  new_line;  .L_Say1206; .L_SayX1113;
    rtrue;
];

[ text_routine_94;
say__p=1;ParaContent();  print (PrintText) SC_1561; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_386;  .L_Say1207; .L_SayX1114;
    rtrue;
];

[ text_routine_95;
say__p=1;ParaContent();  print (PrintText) SC_1562; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_386;  .L_Say1208; .L_SayX1115;
    rtrue;
];

[ text_routine_96;
say__p=1;ParaContent();  print (PrintText) SC_1561; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_922; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1209; .L_SayX1116;
    rtrue;
];

[ text_routine_97;
say__p=1;ParaContent();  print (PrintText) SC_1562; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_922; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1210; .L_SayX1117;
    rtrue;
];

[ text_routine_98;
say__p=1;ParaContent();  print (PrintText) SC_1563; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_386;  .L_Say1211; .L_SayX1118;
    rtrue;
];

[ text_routine_99;
say__p=1;ParaContent();  print (PrintText) SC_1564; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_386;  .L_Say1212; .L_SayX1119;
    rtrue;
];

[ text_routine_100;
say__p=1;ParaContent();  print (PrintText) SC_1563; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_922; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1213; .L_SayX1120;
    rtrue;
];

[ text_routine_101;
say__p=1;ParaContent();  print (PrintText) SC_1564; ParaContent(); ActorOrPlayer(); ParaContent();  print (PrintText) SC_984; ParaContent();  PrintOrConstruct(); ParaContent();  print (PrintText) SC_922; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1214; .L_SayX1121;
    rtrue;
];

[ text_routine_102;
say__p=1;ParaContent();  print (PrintText) SC_922; ParaContent();  new_line;  .L_Say1215; .L_SayX1122;
    rtrue;
];

[ text_routine_103;
say__p=1;ParaContent();  print (PrintText) SC_922; ParaContent();  DivideParagraphPoint(); new_line;  .L_Say1216; .L_SayX1123;
    rtrue;
];

[ text_routine_104;
say__p=1;ParaContent();  print (PrintText) SC_555; ParaContent();  new_line;  .L_Say1217; .L_SayX1124;
    rtrue;
];

[ text_routine_105;
say__p=1;ParaContent();  print (PrintText) SC_1565; ParaContent();  new_line;  .L_Say1218; .L_SayX1125;
    rtrue;
];

[ text_routine_106;
say__p=1;ParaContent();  print (PrintText) SC_555; ParaContent();  new_line;  .L_Say1219; .L_SayX1126;
    rtrue;
];

[ text_routine_107;
say__p=1;ParaContent();  print (PrintText) SC_1566; ParaContent();  new_line;  .L_Say1220; .L_SayX1127;
    rtrue;
];

[ text_routine_108;
say__p=1;ParaContent();  print (The) (Global_Vars-->17); ParaContent();  print (PrintText) SC_1567; ParaContent();  new_line;  .L_Say1221; .L_SayX1128;
    rtrue;
];

[ text_routine_109;
say__p=1;ParaContent();  print (PrintText) SC_1568; ParaContent();  new_line;  .L_Say1222; .L_SayX1129;
    rtrue;
];

[ text_routine_110;
say__p=1;ParaContent();  print (PrintText) SC_1569; ParaContent();  new_line;  .L_Say1223; .L_SayX1130;
    rtrue;
];

[ text_routine_111;
say__p=1;ParaContent();  print (PrintText) SC_1570; ParaContent();  new_line;  .L_Say1224; .L_SayX1131;
    rtrue;
];

[ text_routine_112;
say__p=1;ParaContent();  print (PrintText) SC_1570; ParaContent();  new_line;  .L_Say1225; .L_SayX1132;
    rtrue;
];

[ text_routine_113;
say__p=1;ParaContent();  print (PrintText) SC_1571; ParaContent();  print (the) (Global_Vars-->17); ParaContent();  print (PrintText) SC_250; ParaContent();  new_line;  .L_Say1226; .L_SayX1133;
    rtrue;
];

[ text_routine_114;
say__p=1;ParaContent();  print (PrintText) SC_1572; ParaContent();  new_line;  .L_Say1227; .L_SayX1134;
    rtrue;
];

[ text_routine_115;
say__p=1;ParaContent();  print (PrintText) SC_1573; ParaContent();  new_line;  .L_Say1228; .L_SayX1135;
    rtrue;
];

[ text_routine_116;
say__p=1;ParaContent();  print (PrintText) SC_1574; ParaContent();  new_line;  .L_Say1229; .L_SayX1136;
    rtrue;
];

[ text_routine_117;
say__p=1;ParaContent();  print (PrintText) SC_1575; ParaContent();  new_line;  .L_Say1230; .L_SayX1137;
    rtrue;
];

[ text_routine_118;
say__p=1;ParaContent();  I7_ST_say_one_of-->71 =
	i7_soo_ran(I7_ST_say_one_of-->71, 2);
	switch((I7_ST_say_one_of-->71)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1576; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1577; ParaContent();  } ParaContent();  print (PrintText) SC_250; ParaContent();  new_line;  .L_Say1231; .L_SayX1138;
    rtrue;
];

[ text_routine_119;
say__p=1;ParaContent();  print (PrintText) SC_1578; ParaContent();  new_line;  .L_Say1232; .L_SayX1139;
    rtrue;
];

[ text_routine_120;
say__p=1;ParaContent();  print (PrintText) SC_1579; ParaContent();  new_line;  .L_Say1233; .L_SayX1140;
    rtrue;
];

[ text_routine_121;
say__p=1;ParaContent(); (Resolver_13((Global_Vars-->17),"source", 1));ParaContent();  print (PrintText) SC_1580; ParaContent();  new_line;  .L_Say1234; .L_SayX1141;
    rtrue;
];

[ text_routine_122;
say__p=1;ParaContent(); (Resolver_13((Global_Vars-->17),"source", 1));ParaContent();  print (PrintText) SC_1580; ParaContent();  new_line;  .L_Say1235; .L_SayX1142;
    rtrue;
];

[ text_routine_123;
say__p=1;ParaContent();  print (PrintText) SC_1581; ParaContent();  print (the) (Global_Vars-->17); ParaContent();  print (PrintText) SC_631; ParaContent();  new_line;  .L_Say1236; .L_SayX1143;
    rtrue;
];

[ text_routine_124;
say__p=1;ParaContent();  print (PrintText) SC_1582; ParaContent();  print (the) (Global_Vars-->17); ParaContent();  print (PrintText) SC_631;  .L_Say1237; .L_SayX1144;
    rtrue;
];

[ text_routine_125;
say__p=1;ParaContent();  print (PrintShortName) real_location;  .L_Say1238; .L_SayX1145;
    rtrue;
];

[ text_routine_126;
say__p=1;ParaContent();  print (say__n=score); ParaContent();  print (PrintText) SC_1583; ParaContent();  print (say__n=turns);  .L_Say1239; .L_SayX1146;
    rtrue;
];

[ text_routine_127;
say__p=1;
	if (~~(((~~((NAP_0()) &&  (actor==player)))))) jump L_Say1240;
		ParaContent();  print (PrintText) SC_1584; ParaContent();  DivideParagraphPoint(); new_line; 
	.L_Say1240; .L_SayX1147;
		ParaContent();  print (PrintText) SC_1585;  .L_Say1241; .L_SayX1148;
    rtrue;
];

[ text_routine_128;
say__p=1;ParaContent();  print (PrintText) SC_1586; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1587; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1588;  .L_Say1242; .L_SayX1149;
    rtrue;
];

[ text_routine_129;
say__p=1;
	if (~~(((~~((NAP_0()) &&  (actor==player)))))) jump L_Say1243;
		ParaContent();  print (PrintText) SC_1589; 
	.L_Say1243; .L_SayX1150;
		ParaContent();  print (PrintText) SC_1590;  .L_Say1244; .L_SayX1151;
    rtrue;
];

[ text_routine_130;
say__p=1;
	if (~~(((~~((NAP_0()) &&  (actor==player)))))) jump L_Say1245;
		ParaContent();  print (PrintText) SC_1591; 
	.L_Say1245; .L_SayX1152;
		ParaContent();  print (PrintText) SC_1592;  .L_Say1246; .L_SayX1153;
    rtrue;
];

[ text_routine_131;
say__p=1;ParaContent();  print (PrintText) SC_1593; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1594; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1188; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1595;  .L_Say1247; .L_SayX1154;
    rtrue;
];

[ text_routine_132;
say__p=1;
	if (~~(((~~((NAP_0()) &&  (actor==player)))))) jump L_Say1248;
		ParaContent();  print (PrintText) SC_1596; 
	.L_Say1248; .L_SayX1155;
		ParaContent();  print (PrintText) SC_1597; 
	if (~~(((NAP_0()) &&  (actor==player)))) jump L_Say1249;
		ParaContent();  print (PrintText) SC_1598; 
	.L_Say1249; .L_SayX1156;
		ParaContent();  print (PrintText) SC_1599; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1600; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1601;  .L_Say1250; .L_SayX1157;
    rtrue;
];

[ text_routine_133;
say__p=1;ParaContent();  print (PrintText) SC_1602; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1603;  .L_Say1251; .L_SayX1158;
    rtrue;
];

[ text_routine_134;
say__p=1;ParaContent();  print (PrintText) SC_1604; 
	if (~~((( (GenerateRandomNumber(1, 2) <= 1) )))) jump L_Say1252;
		ParaContent();  print (PrintText) SC_250; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1605; 
	.L_Say1252; .L_SayX1159;
		ParaContent();  print (PrintText) SC_250;  .L_Say1253; .L_SayX1160;
    rtrue;
];

[ text_routine_135;
say__p=1;ParaContent();  print (PrintText) SC_1606; ParaContent();  print (T75)  R_T75() ; ParaContent();  print (PrintText) SC_1607;  .L_Say1254; .L_SayX1161;
    rtrue;
];

[ text_routine_136;
say__p=1;ParaContent();  print (PrintText) SC_1606; ParaContent();  print (T75)  R_T75() ; ParaContent();  print (PrintText) SC_1608;  .L_Say1255; .L_SayX1162;
    rtrue;
];

[ text_routine_137;
say__p=1;ParaContent();  print (PrintText) SC_1609; 
	if (~~((( (GenerateRandomNumber(1, 2) <= 1) )))) jump L_Say1256;
		ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1610; 
	.L_Say1256; .L_SayX1163;
		 .L_Say1257; .L_SayX1164;
    rtrue;
];

[ text_routine_138;
say__p=1;ParaContent();  print (PrintText) SC_1611; 
	if (~~(((NAP_0()) &&  (actor==player)))) jump L_Say1258;
		ParaContent();  print (PrintText) SC_1158; 
	jump L_SayX1165; .L_Say1258;
		ParaContent();  print (PrintText) SC_1612; 
	.L_Say1259; .L_SayX1165;
		ParaContent();  print (PrintText) SC_387; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1163; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1613;  .L_Say1260; .L_SayX1166;
    rtrue;
];

[ text_routine_139;
say__p=1;ParaContent();  print (PrintText) SC_1614; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1615; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1616; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1617; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1618;  .L_Say1261; .L_SayX1167;
    rtrue;
];

[ text_routine_140;
say__p=1;ParaContent();  print (PrintText) SC_1619; 
	if (~~((TestSinglePastState(0, 55, false, 6) >= 2 ))) jump L_Say1262;
		ParaContent();  print (PrintText) SC_1620; 
	.L_Say1262; .L_SayX1168;
		ParaContent();  print (PrintText) SC_250;  .L_Say1263; .L_SayX1169;
    rtrue;
];

[ text_routine_141;
say__p=1;ParaContent();  print (PrintText) SC_1621; ParaContent();  print (number) say__n=( (Prop_148()) ); ParaContent();  print (PrintText) SC_1622; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1623; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1624;  .L_Say1264; .L_SayX1170;
    rtrue;
];

[ text_routine_142;
say__p=1;ParaContent();  print (PrintText) SC_1625; ParaContent();  style bold; ParaContent();  print (PrintText) SC_529; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1626;  .L_Say1265; .L_SayX1171;
    rtrue;
];

[ text_routine_143;
say__p=1;ParaContent();  I7_ST_say_one_of-->72 =
	i7_soo_stop(I7_ST_say_one_of-->72, 2);
	switch((I7_ST_say_one_of-->72)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1627; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1628; ParaContent();  }  .L_Say1266; .L_SayX1172;
    rtrue;
];

[ text_routine_144;
say__p=1;ParaContent();  I7_ST_say_one_of-->73 =
	i7_soo_stop(I7_ST_say_one_of-->73, 2);
	switch((I7_ST_say_one_of-->73)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1629; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1630; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1631; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1632; ParaContent();  }  .L_Say1267; .L_SayX1173;
    rtrue;
];

[ text_routine_145;
say__p=1;ParaContent();  I7_ST_say_one_of-->74 =
	i7_soo_stop(I7_ST_say_one_of-->74, 2);
	switch((I7_ST_say_one_of-->74)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1633; ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1634; ParaContent();  }  .L_Say1268; .L_SayX1174;
    rtrue;
];

[ text_routine_146;
say__p=1;ParaContent();  I7_ST_say_one_of-->75 =
	i7_soo_stop(I7_ST_say_one_of-->75, 2);
	switch((I7_ST_say_one_of-->75)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1635; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1636; ParaContent();  }  .L_Say1269; .L_SayX1175;
    rtrue;
];

[ text_routine_147;
say__p=1;ParaContent();  I7_ST_say_one_of-->76 =
	i7_soo_stop(I7_ST_say_one_of-->76, 2);
	switch((I7_ST_say_one_of-->76)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1637; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1638; ParaContent();  }  .L_Say1270; .L_SayX1176;
    rtrue;
];

[ text_routine_148;
say__p=1;ParaContent();  I7_ST_say_one_of-->77 =
	i7_soo_stop(I7_ST_say_one_of-->77, 2);
	switch((I7_ST_say_one_of-->77)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1639; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1640; ParaContent();  }  .L_Say1271; .L_SayX1177;
    rtrue;
];

[ text_routine_149;
say__p=1;ParaContent();  I7_ST_say_one_of-->78 =
	i7_soo_stop(I7_ST_say_one_of-->78, 2);
	switch((I7_ST_say_one_of-->78)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1641; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1642; ParaContent();  }  .L_Say1272; .L_SayX1178;
    rtrue;
];

[ text_routine_150;
say__p=1;ParaContent();  I7_ST_say_one_of-->79 =
	i7_soo_stop(I7_ST_say_one_of-->79, 2);
	switch((I7_ST_say_one_of-->79)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1643; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1644; ParaContent();  }  .L_Say1273; .L_SayX1179;
    rtrue;
];

[ text_routine_151;
say__p=1;ParaContent();  I7_ST_say_one_of-->80 =
	i7_soo_stop(I7_ST_say_one_of-->80, 2);
	switch((I7_ST_say_one_of-->80)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1645; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1646; ParaContent();  }  .L_Say1274; .L_SayX1180;
    rtrue;
];

[ text_routine_152;
say__p=1;ParaContent();  I7_ST_say_one_of-->81 =
	i7_soo_stop(I7_ST_say_one_of-->81, 2);
	switch((I7_ST_say_one_of-->81)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1647; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1648; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1649; ParaContent();  style roman; ParaContent();  print (PrintText) SC_250; ParaContent();  }  .L_Say1275; .L_SayX1181;
    rtrue;
];

[ text_routine_153;
say__p=1;ParaContent();  I7_ST_say_one_of-->82 =
	i7_soo_stop(I7_ST_say_one_of-->82, 2);
	switch((I7_ST_say_one_of-->82)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1650; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1651; ParaContent();  }  .L_Say1276; .L_SayX1182;
    rtrue;
];

[ text_routine_154;
say__p=1;ParaContent();  I7_ST_say_one_of-->83 =
	i7_soo_stop(I7_ST_say_one_of-->83, 2);
	switch((I7_ST_say_one_of-->83)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1652; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1653; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1654; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1655; ParaContent();  }  .L_Say1277; .L_SayX1183;
    rtrue;
];

[ text_routine_155;
say__p=1;ParaContent();  I7_ST_say_one_of-->84 =
	i7_soo_stop(I7_ST_say_one_of-->84, 2);
	switch((I7_ST_say_one_of-->84)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1656; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1657; ParaContent();  }  .L_Say1278; .L_SayX1184;
    rtrue;
];

[ text_routine_156;
say__p=1;ParaContent();  I7_ST_say_one_of-->85 =
	i7_soo_stop(I7_ST_say_one_of-->85, 2);
	switch((I7_ST_say_one_of-->85)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1658; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1659; ParaContent();  }  .L_Say1279; .L_SayX1185;
    rtrue;
];

[ text_routine_157;
say__p=1;ParaContent();  I7_ST_say_one_of-->86 =
	i7_soo_stop(I7_ST_say_one_of-->86, 2);
	switch((I7_ST_say_one_of-->86)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1660; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1661; ParaContent();  }  .L_Say1280; .L_SayX1186;
    rtrue;
];

[ text_routine_158;
say__p=1;ParaContent();  I7_ST_say_one_of-->87 =
	i7_soo_stop(I7_ST_say_one_of-->87, 2);
	switch((I7_ST_say_one_of-->87)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1662; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1663; ParaContent();  }  .L_Say1281; .L_SayX1187;
    rtrue;
];

[ text_routine_159;
say__p=1;ParaContent();  I7_ST_say_one_of-->88 =
	i7_soo_stop(I7_ST_say_one_of-->88, 2);
	switch((I7_ST_say_one_of-->88)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1664; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1665; ParaContent();  }  .L_Say1282; .L_SayX1188;
    rtrue;
];

[ text_routine_160;
say__p=1;ParaContent();  I7_ST_say_one_of-->89 =
	i7_soo_stop(I7_ST_say_one_of-->89, 2);
	switch((I7_ST_say_one_of-->89)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1666; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1667; ParaContent();  }  .L_Say1283; .L_SayX1189;
    rtrue;
];

[ text_routine_161;
say__p=1;ParaContent();  I7_ST_say_one_of-->90 =
	i7_soo_stop(I7_ST_say_one_of-->90, 2);
	switch((I7_ST_say_one_of-->90)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1668; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1669; ParaContent();  }  .L_Say1284; .L_SayX1190;
    rtrue;
];

[ text_routine_162;
say__p=1;ParaContent();  I7_ST_say_one_of-->91 =
	i7_soo_stop(I7_ST_say_one_of-->91, 2);
	switch((I7_ST_say_one_of-->91)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1670; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1671; ParaContent();  }  .L_Say1285; .L_SayX1191;
    rtrue;
];

[ text_routine_163;
say__p=1;ParaContent();  I7_ST_say_one_of-->92 =
	i7_soo_stop(I7_ST_say_one_of-->92, 2);
	switch((I7_ST_say_one_of-->92)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1672; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1673; ParaContent();  }  .L_Say1286; .L_SayX1192;
    rtrue;
];

[ text_routine_164;
say__p=1;ParaContent();  I7_ST_say_one_of-->93 =
	i7_soo_stop(I7_ST_say_one_of-->93, 2);
	switch((I7_ST_say_one_of-->93)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1674; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1675; ParaContent();  }  .L_Say1287; .L_SayX1193;
    rtrue;
];

[ text_routine_165;
say__p=1;ParaContent();  I7_ST_say_one_of-->94 =
	i7_soo_stop(I7_ST_say_one_of-->94, 2);
	switch((I7_ST_say_one_of-->94)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1676; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1677; ParaContent();  }  .L_Say1288; .L_SayX1194;
    rtrue;
];

[ text_routine_166;
say__p=1;ParaContent();  I7_ST_say_one_of-->95 =
	i7_soo_stop(I7_ST_say_one_of-->95, 2);
	switch((I7_ST_say_one_of-->95)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1678; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1679; ParaContent();  }  .L_Say1289; .L_SayX1195;
    rtrue;
];

[ text_routine_167;
say__p=1;ParaContent();  I7_ST_say_one_of-->96 =
	i7_soo_stop(I7_ST_say_one_of-->96, 2);
	switch((I7_ST_say_one_of-->96)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1680; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1681; ParaContent();  }  .L_Say1290; .L_SayX1196;
    rtrue;
];

[ text_routine_168;
say__p=1;ParaContent();  I7_ST_say_one_of-->97 =
	i7_soo_stop(I7_ST_say_one_of-->97, 2);
	switch((I7_ST_say_one_of-->97)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1682; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1683; ParaContent();  }  .L_Say1291; .L_SayX1197;
    rtrue;
];

[ text_routine_169;
say__p=1;ParaContent();  I7_ST_say_one_of-->98 =
	i7_soo_stop(I7_ST_say_one_of-->98, 2);
	switch((I7_ST_say_one_of-->98)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1684; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1685; ParaContent();  }  .L_Say1292; .L_SayX1198;
    rtrue;
];

[ text_routine_170;
say__p=1;ParaContent();  I7_ST_say_one_of-->99 =
	i7_soo_stop(I7_ST_say_one_of-->99, 2);
	switch((I7_ST_say_one_of-->99)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1686; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1687; ParaContent();  }  .L_Say1293; .L_SayX1199;
    rtrue;
];

[ text_routine_171;
say__p=1;ParaContent();  I7_ST_say_one_of-->100 =
	i7_soo_stop(I7_ST_say_one_of-->100, 2);
	switch((I7_ST_say_one_of-->100)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1688; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1689; ParaContent();  }  .L_Say1294; .L_SayX1200;
    rtrue;
];

[ text_routine_172;
say__p=1;ParaContent();  I7_ST_say_one_of-->101 =
	i7_soo_stop(I7_ST_say_one_of-->101, 2);
	switch((I7_ST_say_one_of-->101)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1690; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1691; ParaContent();  }  .L_Say1295; .L_SayX1201;
    rtrue;
];

[ text_routine_173;
say__p=1;ParaContent();  I7_ST_say_one_of-->102 =
	i7_soo_stop(I7_ST_say_one_of-->102, 2);
	switch((I7_ST_say_one_of-->102)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1692; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1693; ParaContent();  }  .L_Say1296; .L_SayX1202;
    rtrue;
];

[ text_routine_174;
say__p=1;ParaContent();  I7_ST_say_one_of-->103 =
	i7_soo_stop(I7_ST_say_one_of-->103, 2);
	switch((I7_ST_say_one_of-->103)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1694; ParaContent();  @nop; 1: ParaContent();  print (The) I545_secretary_of_water; ParaContent();  print (PrintText) SC_1695; ParaContent();  }  .L_Say1297; .L_SayX1203;
    rtrue;
];

[ text_routine_175;
say__p=1;ParaContent();  I7_ST_say_one_of-->104 =
	i7_soo_stop(I7_ST_say_one_of-->104, 2);
	switch((I7_ST_say_one_of-->104)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1696; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1697; ParaContent();  }  .L_Say1298; .L_SayX1204;
    rtrue;
];

[ text_routine_176;
say__p=1;ParaContent();  I7_ST_say_one_of-->105 =
	i7_soo_stop(I7_ST_say_one_of-->105, 2);
	switch((I7_ST_say_one_of-->105)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1698; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1697; ParaContent();  }  .L_Say1299; .L_SayX1205;
    rtrue;
];

[ text_routine_177;
say__p=1;ParaContent();  I7_ST_say_one_of-->106 =
	i7_soo_stop(I7_ST_say_one_of-->106, 2);
	switch((I7_ST_say_one_of-->106)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1699; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1700; ParaContent();  }  .L_Say1300; .L_SayX1206;
    rtrue;
];

[ text_routine_178;
say__p=1;ParaContent();  I7_ST_say_one_of-->107 =
	i7_soo_stop(I7_ST_say_one_of-->107, 2);
	switch((I7_ST_say_one_of-->107)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1699; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1700; ParaContent();  }  .L_Say1301; .L_SayX1207;
    rtrue;
];

[ text_routine_179;
say__p=1;ParaContent();  I7_ST_say_one_of-->108 =
	i7_soo_stop(I7_ST_say_one_of-->108, 2);
	switch((I7_ST_say_one_of-->108)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1699; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1700; ParaContent();  }  .L_Say1302; .L_SayX1208;
    rtrue;
];

[ text_routine_180;
say__p=1;ParaContent();  I7_ST_say_one_of-->109 =
	i7_soo_stop(I7_ST_say_one_of-->109, 2);
	switch((I7_ST_say_one_of-->109)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1701; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1702; ParaContent();  }  .L_Say1303; .L_SayX1209;
    rtrue;
];

[ text_routine_181;
say__p=1;ParaContent();  I7_ST_say_one_of-->110 =
	i7_soo_stop(I7_ST_say_one_of-->110, 2);
	switch((I7_ST_say_one_of-->110)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1703; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1704; ParaContent();  }  .L_Say1304; .L_SayX1210;
    rtrue;
];

[ text_routine_182;
say__p=1;ParaContent();  I7_ST_say_one_of-->111 =
	i7_soo_stop(I7_ST_say_one_of-->111, 2);
	switch((I7_ST_say_one_of-->111)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1705; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1706; ParaContent();  }  .L_Say1305; .L_SayX1211;
    rtrue;
];

[ text_routine_183;
say__p=1;ParaContent();  I7_ST_say_one_of-->112 =
	i7_soo_stop(I7_ST_say_one_of-->112, 2);
	switch((I7_ST_say_one_of-->112)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1707; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1708; ParaContent();  }  .L_Say1306; .L_SayX1212;
    rtrue;
];

[ text_routine_184;
say__p=1;ParaContent();  I7_ST_say_one_of-->113 =
	i7_soo_stop(I7_ST_say_one_of-->113, 2);
	switch((I7_ST_say_one_of-->113)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1709; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1710; ParaContent();  }  .L_Say1307; .L_SayX1213;
    rtrue;
];

[ text_routine_185;
say__p=1;ParaContent();  I7_ST_say_one_of-->114 =
	i7_soo_stop(I7_ST_say_one_of-->114, 2);
	switch((I7_ST_say_one_of-->114)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1711; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1712; ParaContent();  }  .L_Say1308; .L_SayX1214;
    rtrue;
];

[ text_routine_186;
say__p=1;ParaContent();  I7_ST_say_one_of-->115 =
	i7_soo_stop(I7_ST_say_one_of-->115, 2);
	switch((I7_ST_say_one_of-->115)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1713; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1714; ParaContent();  }  .L_Say1309; .L_SayX1215;
    rtrue;
];

[ text_routine_187;
say__p=1;ParaContent();  I7_ST_say_one_of-->116 =
	i7_soo_stop(I7_ST_say_one_of-->116, 2);
	switch((I7_ST_say_one_of-->116)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1715; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1716; ParaContent();  }  .L_Say1310; .L_SayX1216;
    rtrue;
];

[ text_routine_188;
say__p=1;ParaContent();  print (PrintText) SC_1717; ParaContent();  style bold; ParaContent();  print (PrintText) SC_529; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1718;  .L_Say1311; .L_SayX1217;
    rtrue;
];

[ text_routine_189;
say__p=1;ParaContent();  print (PrintText) SC_1719; ParaContent();  style bold; ParaContent();  print (PrintText) SC_529; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1720;  .L_Say1312; .L_SayX1218;
    rtrue;
];

[ text_routine_190;
say__p=1;ParaContent();  print (PrintText) SC_1721; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1722;  .L_Say1313; .L_SayX1219;
    rtrue;
];

[ text_routine_191;
say__p=1;ParaContent();  print (PrintText) SC_1723; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1724; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1725;  .L_Say1314; .L_SayX1220;
    rtrue;
];

[ text_routine_192;
say__p=1;ParaContent();  print (PrintText) SC_1726; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1727;  .L_Say1315; .L_SayX1221;
    rtrue;
];

[ text_routine_193;
say__p=1;ParaContent();  print (PrintText) SC_1728; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1729; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1730;  .L_Say1316; .L_SayX1222;
    rtrue;
];

[ text_routine_194;
say__p=1;ParaContent();  print (PrintText) SC_1731; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1732; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1733; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1734; ParaContent();  DivideParagraphPoint(); new_line; ParaContent();  print (PrintText) SC_1735;  .L_Say1317; .L_SayX1223;
    rtrue;
];

[ text_routine_195;
say__p=1;ParaContent();  I7_ST_say_one_of-->117 =
	i7_soo_stop(I7_ST_say_one_of-->117, 2);
	switch((I7_ST_say_one_of-->117)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1736; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1737; ParaContent();  }  .L_Say1318; .L_SayX1224;
    rtrue;
];

[ text_routine_196;
say__p=1;ParaContent();  I7_ST_say_one_of-->118 =
	i7_soo_stop(I7_ST_say_one_of-->118, 2);
	switch((I7_ST_say_one_of-->118)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1738; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1739; ParaContent();  }  .L_Say1319; .L_SayX1225;
    rtrue;
];

[ text_routine_197;
say__p=1;ParaContent();  I7_ST_say_one_of-->119 =
	i7_soo_stop(I7_ST_say_one_of-->119, 2);
	switch((I7_ST_say_one_of-->119)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1740; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1741; ParaContent();  }  .L_Say1320; .L_SayX1226;
    rtrue;
];

[ text_routine_198;
say__p=1;ParaContent();  I7_ST_say_one_of-->120 =
	i7_soo_stop(I7_ST_say_one_of-->120, 2);
	switch((I7_ST_say_one_of-->120)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1742; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1743; ParaContent();  }  .L_Say1321; .L_SayX1227;
    rtrue;
];

[ text_routine_199;
say__p=1;ParaContent();  I7_ST_say_one_of-->121 =
	i7_soo_stop(I7_ST_say_one_of-->121, 2);
	switch((I7_ST_say_one_of-->121)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_517; 
	if (~~((((GProperty(9, I439_steam_train,p16_station) == I439_steam_train))))) jump L_Say1322;
		ParaContent();  print (PrintText) SC_1744; 
	jump L_SayX1228; .L_Say1322;
		ParaContent();  print (PrintText) SC_1745; 
	.L_Say1323; .L_SayX1228;
		ParaContent();  print (PrintText) SC_1746; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1747; ParaContent();  }  .L_Say1324; .L_SayX1229;
    rtrue;
];

[ text_routine_200;
say__p=1;ParaContent();  I7_ST_say_one_of-->122 =
	i7_soo_stop(I7_ST_say_one_of-->122, 2);
	switch((I7_ST_say_one_of-->122)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1748; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1749; ParaContent();  }  .L_Say1325; .L_SayX1230;
    rtrue;
];

[ text_routine_201;
say__p=1;
	if (~~((((~~(((Adj_2_t1_v9(I584_ticket))))))))) jump L_Say1326;
		ParaContent();  print (PrintText) SC_1750; 
	jump L_SayX1231; .L_Say1326;
		ParaContent();  print (PrintText) SC_1751; 
	.L_Say1327; .L_SayX1231;
		 .L_Say1328; .L_SayX1232;
    rtrue;
];

[ text_routine_202;
say__p=1;ParaContent();  I7_ST_say_one_of-->123 =
	i7_soo_stop(I7_ST_say_one_of-->123, 2);
	switch((I7_ST_say_one_of-->123)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1752; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1753; ParaContent();  }  .L_Say1329; .L_SayX1233;
    rtrue;
];

[ text_routine_203;
say__p=1;ParaContent();  I7_ST_say_one_of-->124 =
	i7_soo_stop(I7_ST_say_one_of-->124, 2);
	switch((I7_ST_say_one_of-->124)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1754; ParaContent();  style bold; ParaContent();  print (PrintText) SC_1188; ParaContent();  style roman; ParaContent();  print (PrintText) SC_1755; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1756; ParaContent();  }  .L_Say1330; .L_SayX1234;
    rtrue;
];

[ text_routine_204;
say__p=1;ParaContent();  I7_ST_say_one_of-->125 =
	i7_soo_stop(I7_ST_say_one_of-->125, 2);
	switch((I7_ST_say_one_of-->125)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1757; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1758; ParaContent();  }  .L_Say1331; .L_SayX1235;
    rtrue;
];

[ text_routine_205;
say__p=1;ParaContent();  I7_ST_say_one_of-->126 =
	i7_soo_stop(I7_ST_say_one_of-->126, 2);
	switch((I7_ST_say_one_of-->126)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1759; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1758; ParaContent();  }  .L_Say1332; .L_SayX1236;
    rtrue;
];

[ text_routine_206;
say__p=1;ParaContent();  I7_ST_say_one_of-->127 =
	i7_soo_stop(I7_ST_say_one_of-->127, 2);
	switch((I7_ST_say_one_of-->127)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1760; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1761; ParaContent();  }  .L_Say1333; .L_SayX1237;
    rtrue;
];

[ text_routine_207;
say__p=1;ParaContent();  I7_ST_say_one_of-->128 =
	i7_soo_stop(I7_ST_say_one_of-->128, 2);
	switch((I7_ST_say_one_of-->128)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1762; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1763; ParaContent();  }  .L_Say1334; .L_SayX1238;
    rtrue;
];

[ text_routine_208;
say__p=1;ParaContent();  I7_ST_say_one_of-->129 =
	i7_soo_stop(I7_ST_say_one_of-->129, 2);
	switch((I7_ST_say_one_of-->129)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1764; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1765; ParaContent();  }  .L_Say1335; .L_SayX1239;
    rtrue;
];

[ text_routine_209;
say__p=1;ParaContent();  I7_ST_say_one_of-->130 =
	i7_soo_stop(I7_ST_say_one_of-->130, 2);
	switch((I7_ST_say_one_of-->130)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1766; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1767; ParaContent();  print (the) I545_secretary_of_water; ParaContent();  print (PrintText) SC_250; ParaContent();  }  .L_Say1336; .L_SayX1240;
    rtrue;
];

[ text_routine_210;
say__p=1;ParaContent();  I7_ST_say_one_of-->131 =
	i7_soo_stop(I7_ST_say_one_of-->131, 2);
	switch((I7_ST_say_one_of-->131)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1768; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1769; ParaContent();  }  .L_Say1337; .L_SayX1241;
    rtrue;
];

[ text_routine_211;
say__p=1;ParaContent();  I7_ST_say_one_of-->132 =
	i7_soo_stop(I7_ST_say_one_of-->132, 2);
	switch((I7_ST_say_one_of-->132)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1770; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1771; ParaContent();  }  .L_Say1338; .L_SayX1242;
    rtrue;
];

[ text_routine_212;
say__p=1;ParaContent();  I7_ST_say_one_of-->133 =
	i7_soo_stop(I7_ST_say_one_of-->133, 2);
	switch((I7_ST_say_one_of-->133)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1772; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1773; ParaContent();  }  .L_Say1339; .L_SayX1243;
    rtrue;
];

[ text_routine_213;
say__p=1;ParaContent();  I7_ST_say_one_of-->134 =
	i7_soo_stop(I7_ST_say_one_of-->134, 2);
	switch((I7_ST_say_one_of-->134)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1774; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1775; ParaContent();  }  .L_Say1340; .L_SayX1244;
    rtrue;
];

[ text_routine_214;
say__p=1;ParaContent();  I7_ST_say_one_of-->135 =
	i7_soo_stop(I7_ST_say_one_of-->135, 2);
	switch((I7_ST_say_one_of-->135)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1776; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1777; ParaContent();  }  .L_Say1341; .L_SayX1245;
    rtrue;
];

[ text_routine_215;
say__p=1;ParaContent();  I7_ST_say_one_of-->136 =
	i7_soo_stop(I7_ST_say_one_of-->136, 2);
	switch((I7_ST_say_one_of-->136)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1778; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1779; ParaContent();  }  .L_Say1342; .L_SayX1246;
    rtrue;
];

[ text_routine_216;
say__p=1;ParaContent();  I7_ST_say_one_of-->137 =
	i7_soo_stop(I7_ST_say_one_of-->137, 2);
	switch((I7_ST_say_one_of-->137)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1780; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1781; ParaContent();  }  .L_Say1343; .L_SayX1247;
    rtrue;
];

[ text_routine_217;
say__p=1;ParaContent();  I7_ST_say_one_of-->138 =
	i7_soo_stop(I7_ST_say_one_of-->138, 2);
	switch((I7_ST_say_one_of-->138)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1782; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1783; ParaContent();  }  .L_Say1344; .L_SayX1248;
    rtrue;
];

[ text_routine_218;
say__p=1;ParaContent();  I7_ST_say_one_of-->139 =
	i7_soo_stop(I7_ST_say_one_of-->139, 2);
	switch((I7_ST_say_one_of-->139)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1784; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1785; ParaContent();  } ParaContent();  print (PrintText) SC_250;  .L_Say1345; .L_SayX1249;
    rtrue;
];

[ text_routine_219;
say__p=1;ParaContent();  I7_ST_say_one_of-->140 =
	i7_soo_stop(I7_ST_say_one_of-->140, 3);
	switch((I7_ST_say_one_of-->140)%(3+1)-1) {
		0: ParaContent();  print (PrintText) SC_1786; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1787; ParaContent();  @nop; 2: ParaContent();  print (PrintText) SC_1788; ParaContent();  }  .L_Say1346; .L_SayX1250;
    rtrue;
];

[ text_routine_220;
say__p=1;ParaContent();  I7_ST_say_one_of-->141 =
	i7_soo_stop(I7_ST_say_one_of-->141, 2);
	switch((I7_ST_say_one_of-->141)%(2+1)-1) {
		0: ParaContent();  print (PrintText) SC_1789; ParaContent();  @nop; 1: ParaContent();  print (PrintText) SC_1790; ParaContent();  }  .L_Say1347; .L_SayX1251;
    rtrue;
];

[ text_routine_221;
say__p=1;ParaContent();  print (PrintText) SC_1791; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  .L_Say1348; .L_SayX1252;
    rtrue;
];

[ text_routine_222;
say__p=1;ParaContent();  print (PrintText) SC_1791; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  .L_Say1349; .L_SayX1253;
    rtrue;
];

[ text_routine_223;
say__p=1;ParaContent();  print (PrintText) SC_1791; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_250;  .L_Say1350; .L_SayX1254;
    rtrue;
];

[ text_routine_224;blockv_stack-->(blockv_sp+1) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_stack-->(blockv_sp+0) = BlkValueCreate(INDEXED_TEXT_TY,0,INDEXED_TEXT_TY);
    blockv_sp = blockv_sp + 2;
    blockv_stack-->(blockv_sp++) = R_SHELL_11(blockv_sp-2);
    blockv_sp = blockv_sp - 3;
    BlkFree(blockv_stack-->(blockv_sp+1));
    BlkFree(blockv_stack-->(blockv_sp+0));
    return blockv_stack-->(blockv_sp+2);
];
[ R_SHELL_11 I7BASPL ;
say__p=1;ParaContent();  print (PrintText) Story; ParaContent();  print (PrintText) SC_1792; ParaContent();  print (PrintText) (Global_Vars-->1); ParaContent();  print (PrintText) SC_1793; ParaContent();  print (INDEXED_TEXT_TY_Say)  IT_CharactersToCase((blockv_stack-->(I7BASPL+0)), BlkValueCast((blockv_stack-->(I7BASPL+1)),INDEXED_TEXT_TY,TEXT_TY,GProperty(9,  (Prop_149()) ,short_name)), 1) ; ParaContent();  print (PrintText) SC_1794;  .L_Say1351; .L_SayX1255;
    rtrue;
];

[ text_routine_225;
say__p=1;ParaContent();  print (PrintText) SC_1795; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1796; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1797;  .L_Say1352; .L_SayX1256;
    rtrue;
];

[ text_routine_226;
say__p=1;ParaContent();  print (PrintText) SC_1795; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1796; ParaContent();  print (the) noun; ParaContent();  print (PrintText) SC_1797;  .L_Say1353; .L_SayX1257;
    rtrue;
];

[ text_routine_227;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1354;
		ParaContent();  print (PrintText) SC_1798; 
	jump L_SayX1258; .L_Say1354;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1355; .L_SayX1258;
		ParaContent();  print (PrintText) SC_250;  .L_Say1356; .L_SayX1259;
    rtrue;
];

[ text_routine_228;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1357;
		ParaContent();  print (PrintText) SC_1798; 
	jump L_SayX1260; .L_Say1357;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1358; .L_SayX1260;
		ParaContent();  print (PrintText) SC_250;  .L_Say1359; .L_SayX1261;
    rtrue;
];

[ text_routine_229;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1360;
		ParaContent();  print (PrintText) SC_1798; 
	jump L_SayX1262; .L_Say1360;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1361; .L_SayX1262;
		ParaContent();  print (PrintText) SC_250;  .L_Say1362; .L_SayX1263;
    rtrue;
];

[ text_routine_230;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1363;
		ParaContent();  print (PrintText) SC_1798; 
	jump L_SayX1264; .L_Say1363;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1364; .L_SayX1264;
		ParaContent();  print (PrintText) SC_250;  .L_Say1365; .L_SayX1265;
    rtrue;
];

[ text_routine_231;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1366;
		ParaContent();  print (PrintText) SC_1798; 
	jump L_SayX1266; .L_Say1366;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1367; .L_SayX1266;
		ParaContent();  print (PrintText) SC_250;  .L_Say1368; .L_SayX1267;
    rtrue;
];

[ text_routine_232;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1369;
		ParaContent();  print (PrintText) SC_1798; 
	jump L_SayX1268; .L_Say1369;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1370; .L_SayX1268;
		ParaContent();  print (PrintText) SC_250;  .L_Say1371; .L_SayX1269;
    rtrue;
];

[ text_routine_233;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1372;
		ParaContent();  print (PrintText) SC_1800; 
	jump L_SayX1270; .L_Say1372;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1373; .L_SayX1270;
		ParaContent();  print (PrintText) SC_250;  .L_Say1374; .L_SayX1271;
    rtrue;
];

[ text_routine_234;
say__p=1;
	if (~~(((((Adj_99_t1_v9(player))))))) jump L_Say1375;
		ParaContent();  print (PrintText) SC_1800; 
	jump L_SayX1272; .L_Say1375;
		ParaContent();  print (PrintText) SC_1799; 
	.L_Say1376; .L_SayX1272;
		ParaContent();  print (PrintText) SC_250;  .L_Say1377; .L_SayX1273;
    rtrue;
];

[ text_routine_235;
say__p=1;ParaContent();  SL_Location(); ParaContent();  print (PrintText) SC_1801; ParaContent();  print (PrintText) (Global_Vars-->22); ParaContent();  print (PrintText) SC_413;  .L_Say1378; .L_SayX1274;
    rtrue;
];









[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSE_CONDS:pt++)
		past_chronological_record-->pt = present_chronological_record-->pt;
];

[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
	for (pt=0: pt<NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);
	ChronologyPoint();
	rfalse;
];

[ PAPR_0 ;
if ((action ==##Go) &&  (actor==player) && ((noun == I55_down) && (true)) && ((real_location == I506_inside_waterworks) && (true)) && (self=actor,true) && (((((Adj_3_t1_v9(I545_secretary_of_water))))) && ((((Adj_115_t1_v9(I545_secretary_of_water))))))) rtrue;
    rfalse;
];
[ PAPR_1 ;
if ((action ==##Go) &&  (actor==player) && ((noun == I46_north) && (true)) && ((real_location == I447_outside_waterworks) && (true))) rtrue;
    rfalse;
];
[ PAPR_2 ;
if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I480_door_to_the_structure) && (true))) rtrue;
    rfalse;
];
[ PAPR_3 ;
if ((action ==##A86_unlocking_keylessly) &&  (actor==player) && ((noun == I483_community_center_door) && (true))) rtrue;
    rfalse;
];
[ PAPR_4 ;
if ((action ==##Examine) &&  (actor==player) && ((noun == I463_pond) && (true)) && (self=actor,true) && ((((Adj_81_t1_v9(I417_underground_pump)))))) rtrue;
    rfalse;
];
[ PAPR_5 ;
if ((action ==##Examine) &&  (actor==player) && ((noun == I592_engineer_s_blueprint) && (true))) rtrue;
    rfalse;
];
[ PAPR_6 ;
if ((action ==##Wear) &&  (actor==player) && ((noun == I666_diving_mask) && (true))) rtrue;
    rfalse;
];
[ PAPR_7 ;
if ((action ==##Enter) &&  (actor==player) && ((noun == I707_seat) && (true))) rtrue;
    rfalse;
];
Array PastActionsI6Routines --> PAPR_0 PAPR_1 PAPR_2 PAPR_3 PAPR_4 PAPR_5 PAPR_6 PAPR_7 0 0;

Constant NO_PAST_TENSE_CONDS 56;
Constant NO_PAST_TENSE_ACTIONS 8;

[ TestSinglePastState past_flag pt turn_end wanted
	old new trips consecutives ct_0 ct_1 I7BASPL;
	if (past_flag) {
		new = (past_chronological_record-->pt) & 1;
		trips = ((past_chronological_record-->pt) & $$11111110)/2;
		consecutives = ((past_chronological_record-->pt) & $$111111100000000)/256;
	} else {
		old = (present_chronological_record-->pt) & 1;
		trips = ((present_chronological_record-->pt) & $$11111110)/2;
		consecutives = ((present_chronological_record-->pt) & $$111111100000000)/256;
! Test cases for conditions by PT number: each sets "new" to whether it is true or false now
I7BASPL = blockv_sp;
blockv_sp = blockv_sp + 16;
switch(pt) {
    0: new = ((((Adj_94_t1_v9(I561_lone_sweetgum_tree)))));
    1: new = (((I442_in_the_sweetgum_tree == ContainerOf(player))));
    2: new = ((((Adj_94_t1_v9(I561_lone_sweetgum_tree)))));
    3: new = (((I442_in_the_sweetgum_tree == ContainerOf(player))));
    4: new = ((((Adj_3_t1_v9(I604_large_magnet)))));
    5: new = (((I669_underwater == ContainerOf(player))));
    6: new = (((I669_underwater == ContainerOf(player))));
    7: new = ((((Adj_60_t1_v9(I486_red_foam_keychain)))));
    8: new = ((((Adj_60_t1_v9(I486_red_foam_keychain)))));
    9: new = ((((Adj_138_t1_v9(I699_large_crystal_gear)))));
    10: new = ((((Adj_80_t1_v9(I421_small_metal_detector)))));
    11: new = ((((scene_status-->(I431_conductor_s_story-1)==1))));
    12: new = ((((scene_status-->(I431_conductor_s_story-1)==1))));
    13: new = ((((scene_status-->(I428_hose_action-1)==1))));
    14: new = ((((scene_status-->(I428_hose_action-1)==1))));
    15: new = ((((scene_status-->(I611_secretary_s_story-1)==1))));
    16: new = ((((Adj_130_t1_v9(player)))));
    17: new = ((((Adj_130_t1_v9(player)))));
    18: new = ((((Adj_136_t1_v9(I506_inside_waterworks)))));
    19: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    20: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    21: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    22: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    23: new = (((I510_pump_room == ContainerOf(player))));
    24: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    25: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    26: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    27: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    28: new = (((I506_inside_waterworks == ContainerOf(player))));
    29: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    30: new = (((I506_inside_waterworks == ContainerOf(player))));
    31: new = (((I510_pump_room == ContainerOf(player))));
    32: new = (((I506_inside_waterworks == ContainerOf(I545_secretary_of_water))));
    33: new = ((((Adj_2_t1_v9(I589_wooden_drawer)))));
    34: new = ((((Adj_2_t1_v9(I589_wooden_drawer)))));
    35: new = (((I444_woods == ContainerOf(player))));
    36: new = (((I444_woods == ContainerOf(I443_dog))));
    37: new = (((I444_woods == ContainerOf(player))));
    38: new = (((I444_woods == ContainerOf(I443_dog))));
    39: new = ((((Adj_80_t1_v9(I417_underground_pump)))));
    40: new = ((((Adj_80_t1_v9(I417_underground_pump)))));
    41: new = ((((Adj_80_t1_v9(I417_underground_pump)))));
    42: new = ((((Adj_80_t1_v9(I417_underground_pump)))));
    43: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    44: new = ((((Adj_80_t1_v9(I416_complicated_pump)))));
    45: new = ((((Adj_130_t1_v9(player)))));
    46: new = (((I506_inside_waterworks == ContainerOf(player))));
    47: new = ((((Adj_70_t1_v9(I591_secret_panel)))));
    48: new = ((((Adj_144_t1_v9(I711_conductor)))));
    49: new = (((I510_pump_room == ContainerOf(player))));
    50: new = (((I510_pump_room == ContainerOf(player))));
    51: new = (((I442_in_the_sweetgum_tree == ContainerOf(player))));
    52: new = ((((Adj_70_t1_v9(I591_secret_panel)))));
    53: new = ((((Adj_138_t1_v9(I699_large_crystal_gear)))));
    54: new = ((((Adj_70_t1_v9(I591_secret_panel)))));
    55: new = ((((Adj_130_t1_v9(player)))));
    default: print "*** No such past tense condition ***^"; new = false;
}
blockv_sp = blockv_sp - 16;

		if (new == false) {
			consecutives = 0;
		} else {
			if (old == false) { trips++; if (trips > 127) trips = 127; }
			if (turn_end) { consecutives++; if (consecutives > 127) consecutives = 127; }
		}
		present_chronological_record-->pt = new + 2*trips + 256*consecutives;
	}
	! print pt, ": old=", old, " new=", new, " trips=", trips, " consec=", consecutives,
	!	" wanted=", wanted, "^";
	switch(wanted) {
		0: if (new) return new;
		1: if (new) return trips;
		2: if (new) return consecutives+1; ! Plus one because we count the current turn
		4: return new;
		5: return trips;
		6: return consecutives;
	}
	return 0;
];

[ TrackActions readjust oow ct_0 ct_1 i;
	for (i=0: PastActionsI6Routines-->i: i++) {
		if ((PastActionsI6Routines-->i).call()) {
			! Yes, the current action matches action pattern i:
			if (readjust) continue;
			(TimesActionHasHappened-->i)++;
			if (LastTurnActionHappenedOn-->i ~= turns + 5) {
				LastTurnActionHappenedOn-->i = turns + 5;
				ActionCurrentlyHappeningFlag->i = 1;
				if (keep_silent == false)
					(TurnsActionHasBeenHappening-->i)++;
			}
		} else {
			! No, the current action doesn't match action pattern i:
			if (oow == false) {
				if (keep_silent == false) { TurnsActionHasBeenHappening-->i = 0; }
				if (LastTurnActionHappenedOn-->i ~= turns + 5)
					ActionCurrentlyHappeningFlag->i = 0;
			}
		}
	}
];

Array TimesActionHasHappened-->(NO_PAST_TENSE_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_TENSE_ACTIONS+1);
Array LastTurnActionHappenedOn-->(NO_PAST_TENSE_ACTIONS+1);
Array ActionCurrentlyHappeningFlag->(NO_PAST_TENSE_ACTIONS+1);

Array past_chronological_record-->(NO_PAST_TENSE_CONDS+1);
Array present_chronological_record-->(NO_PAST_TENSE_CONDS+1);




[ GPR_Line_129
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'who') jump Fail_1;
        return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'what') jump Fail_2;
        return rv;
        .Fail_2; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'when') jump Fail_3;
        return rv;
        .Fail_3; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'where') jump Fail_4;
        return rv;
        .Fail_4; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'why') jump Fail_5;
        return rv;
        .Fail_5; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'how') jump Fail_6;
        return rv;
        .Fail_6; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'who^s') jump Fail_7;
        return rv;
        .Fail_7; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'what^s') jump Fail_8;
        return rv;
        .Fail_8; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'when^s') jump Fail_9;
        return rv;
        .Fail_9; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'where^s') jump Fail_10;
        return rv;
        .Fail_10; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'why^s') jump Fail_11;
        return rv;
        .Fail_11; rv = GPR_PREPOSITION; wn = original_wn;
        if (NextWordStopped() ~= 'how^s') jump Fail_12;
        return rv;
        .Fail_12; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

Verb 'take' 'carry' 'hold' 'steal' 'grab' 'acquire' 'snatch' 'bring'
    * Cond_Token_366 Mistake_Token_366 'leaves'  -> MistakeAction
    * Cond_Token_367 Mistake_Token_367 'leaf'  -> MistakeAction
    * 'inventory'  -> Inv
    * 'nap'  -> Sleep
    * multi  -> Take
    * 'a//' 'nap'  -> Sleep
    * 'out' noun=Noun_Filter_0  -> Take
    * noun=Noun_Filter_1 'out'  -> Take
    * 'off' noun  -> Disrobe
    * noun 'off'  -> Disrobe
    * noun=Noun_Filter_2 'with' noun=Noun_Filter_3  -> Insert
    * multiinside 'from' noun  -> Remove
    * multiinside 'off' noun  -> Remove
    * noun 'in' noun=Noun_Filter_4  -> A130_taking_it_with
    * noun 'with' noun  -> A130_taking_it_with
;
Verb 'get'
    * 'out' / 'off' / 'down' / 'up'  -> Exit
    * 'in' / 'on'  -> Enter
    * multi  -> Take
    * 'on' 'train'  -> A104_boarding
    * 'in' 'train'  -> A104_boarding
    * 'off' 'train'  -> Exit
    * 'out' noun=Noun_Filter_8  -> Take
    * noun=Noun_Filter_9 'out'  -> Take
    * 'in' / 'into' / 'on' / 'onto' noun  -> Enter
    * 'off' / 'down' noun  -> GetOff
    * 'on' 'steam' 'train'  -> A104_boarding
    * 'on' 'the' 'train'  -> A104_boarding
    * 'out' 'of' noun=Noun_Filter_6  -> A97_vehicle_exiting
    * 'out' 'of' noun=Noun_Filter_7  -> A98_supporter_exiting
    * 'out' 'of' noun=Noun_Filter_5  -> GetOff
    * multiinside 'from' noun  -> Remove
    * noun 'in' noun=Noun_Filter_10  -> A130_taking_it_with
    * noun 'with' noun  -> A130_taking_it_with
;
Verb 'pick'
    * noun  -> A136_lock_picking
    * 'up' multi  -> Take
    * multi 'up'  -> Take
    * noun 'with' noun  -> A137_double_lock_picking
;
Verb 'stand'
    *  -> Exit
    * 'up'  -> Exit
    * 'on' noun  -> Enter
;
Verb 'remove'
    * held  -> Disrobe
    * multiinside 'from' noun  -> Remove
;
Verb 'shed' 'doff' 'disrobe'
    * held  -> Disrobe
;
Verb 'wear' 'don'
    * held  -> Wear
;
Verb 'put' 'place' 'stick' 'shove' 'stuff'
    * 'on' held  -> Wear
    * held 'on'  -> Wear
    * 'down' multiheld  -> Drop
    * multiheld 'down'  -> Drop
    * noun=Noun_Filter_15 'near' noun=Noun_Filter_16  -> A131_magnet_waving
    * noun=Noun_Filter_17 'near' noun=Noun_Filter_18  -> A131_magnet_waving
    * noun=Noun_Filter_11 'on' noun=Noun_Filter_12  -> PutOn
    * noun=Noun_Filter_13 'in' noun=Noun_Filter_14  -> A101_pouring_it_into
    * noun=Noun_Filter_19 'through' noun  -> Insert
    * held 'on' 'floor' / 'ground'  -> Drop
    * multiexcept 'in' / 'inside' / 'into' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
    * noun 'on' 'ground'  -> Drop
    * noun 'on' 'the' 'ground'  -> Drop
;
Verb 'insert'
    * multiexcept 'in' / 'into' noun  -> Insert
;
Verb 'drop' 'throw' 'discard' 'toss' 'fling' 'hurl'
    * multiheld  -> Drop
    * held 'away'  -> Drop
    * 'away' held  -> Drop
    * held 'at' / 'against' noun  -> ThrowAt
    * held 'into' / 'through' / 'to' noun  -> ThrowAt
    * multiexcept 'in' / 'into' / 'down' noun  -> Insert
    * multiexcept 'on' / 'onto' noun  -> PutOn
;
Verb 'give' 'pay' 'offer' 'feed' 'hand' 'deliver'
    * creature held  -> Give reverse
    * held 'to' creature  -> Give
;
Verb 'show' 'present' 'display'
    * creature held  -> Show reverse
    * held 'to' creature  -> Show
;
Verb 'go' 'walk' 'run' 'proceed' 'wander' 'explore'
    *  -> Go
    * 'back'  -> A80_retreating
    * noun=Noun_Filter_20  -> Go
    * noun  -> Enter
    * 'on' 'train'  -> A104_boarding
    * 'to' noun=Noun_Filter_21  -> Go
    * 'into' / 'in' / 'inside' / 'through' noun  -> Enter
    * 'to' scope=Scope_Filter_22  -> A116_rowing_toward
    * 'toward' scope=Scope_Filter_23  -> A116_rowing_toward
    * 'to' scope=Scope_Filter_24  -> A116_rowing_toward
    * 'toward' scope=Scope_Filter_25  -> A116_rowing_toward
    * 'on' 'steam' 'train'  -> A104_boarding
;
Verb 'inventory' 'i//' 'inv'
    *  -> Inv
;
Verb 'look' 'l//' 'see'
    *  -> Look
    * Mistake_Token_356 'starling' / 'starlings' / 'goose' / 'geese' / 'lark' / 'larks' / 'mallard' / 'mallards' / 'teal' / 'magpie' / 'magpies' / 'birds' / 'minnows' / 'bitterns' / 'siege' / 'bittern' / 'dissimulation'  -> MistakeAction
    * Mistake_Token_358 'fish' / 'heron'  -> MistakeAction
    * Cond_Token_361 Mistake_Token_361 'leaves'  -> MistakeAction
    * Cond_Token_364 Mistake_Token_364 'leaf'  -> MistakeAction
    * 'around' / 'about'  -> Look
    * Cond_Token_606 'boat'  -> A133_boat_examining
    * Cond_Token_610 'rowboat'  -> A133_boat_examining
    * 'up'  -> A117_looking_up
    * noun=Noun_Filter_28  -> A81_overly_elaborate_looking
    * noun=Noun_Filter_29  -> A94_facing
    * noun  -> Examine
    * Mistake_Token_355 'at' 'starling' / 'starlings' / 'goose' / 'geese' / 'lark' / 'larks' / 'mallard' / 'mallards' / 'teal' / 'magpie' / 'magpies' / 'birds' / 'minnows' / 'bitterns' / 'siege' / 'bittern' / 'dissimulation'  -> MistakeAction
    * Mistake_Token_359 'at' 'fish' / 'heron'  -> MistakeAction
    * Cond_Token_362 Mistake_Token_362 'at' 'leaves'  -> MistakeAction
    * Cond_Token_365 Mistake_Token_365 'at' 'leaf'  -> MistakeAction
    * Cond_Token_607 'at' 'boat'  -> A133_boat_examining
    * Cond_Token_609 'at' 'rowboat'  -> A133_boat_examining
    * 'out' noun=Noun_Filter_31  -> Examine
    * 'at' / 'around' / 'in' / 'into' noun=Noun_Filter_27  -> A81_overly_elaborate_looking
    * 'at' noun  -> Examine
    * 'inside' / 'in' / 'into' / 'through' noun  -> Search
    * 'under' noun  -> LookUnder
    * 'behind' noun  -> LookUnder
    * 'toward' scope=Scope_Filter_30  -> A95_looking_toward
    * 'at' / 'around' / 'in' / 'into' 'the' / 'a//' / 'an' / 'some' noun=Noun_Filter_26  -> A81_overly_elaborate_looking
    * 'up' topic 'in' noun  -> Consult reverse
;
Verb 'consult'
    * noun 'on' / 'about' topic  -> Consult
;
Verb 'unwrap'
    * noun  -> Open
;
Verb 'close' 'shut' 'cover'
    * noun  -> Close
    * 'up' noun  -> Close
    * 'off' noun  -> SwitchOff
    * noun 'with' held  -> A118_plugging_it_with
;
Verb 'enter' 'cross' 'board'
    *  -> Enter
    *  -> A104_boarding
    * 'train'  -> A104_boarding
    * noun  -> Enter
    * DECIMAL_TOKEN  -> A132_typing
    * DECIMAL_TOKEN 'on' noun=Noun_Filter_32  -> A132_typing
;
Verb 'sit'
    * 'down'  -> Enter
    * noun  -> Enter
    * 'on' / 'in' / 'inside' noun  -> Enter
    * 'down' 'on' / 'in' noun  -> Enter
    * 'on' 'top' 'of' noun  -> Enter
;
Verb 'exit' 'leave' 'out' 'escape' 'depart'
    *  -> Exit
    * 'room' / 'area' / 'place' / 'here'  -> Exit
    * noun=Noun_Filter_36  -> Enter
    * noun=Noun_Filter_38  -> A97_vehicle_exiting
    * noun=Noun_Filter_39  -> A97_vehicle_exiting
    * noun=Noun_Filter_40  -> A98_supporter_exiting
    * noun=Noun_Filter_41  -> A98_supporter_exiting
    * noun=Noun_Filter_33  -> GetOff
    * noun=Noun_Filter_34  -> GetOff
    * noun=Noun_Filter_35  -> GetOff
    * 'through' / 'using' / 'by' / 'out' noun=Noun_Filter_37  -> Enter
;
Verb 'examine' 'x//' 'watch' 'describe' 'check' 'view' 'observe' 'inspect'
    * Mistake_Token_354 'starling' / 'starlings' / 'goose' / 'geese' / 'lark' / 'larks' / 'mallard' / 'mallards' / 'teal' / 'magpie' / 'magpies' / 'birds' / 'minnows' / 'bitterns' / 'siege' / 'bittern' / 'dissimulation'  -> MistakeAction
    * Mistake_Token_357 'fish' / 'heron'  -> MistakeAction
    * Mistake_Token_378 'duck' / 'ducks'  -> MistakeAction
    * Cond_Token_360 Mistake_Token_360 'leaves'  -> MistakeAction
    * Cond_Token_363 Mistake_Token_363 'leaf'  -> MistakeAction
    * Cond_Token_490 Mistake_Token_490 'gull'  -> MistakeAction
    * Cond_Token_536 Mistake_Token_536 'paint'  -> MistakeAction
    * Cond_Token_615 Mistake_Token_615 'pond'  -> MistakeAction
    * Cond_Token_616 Mistake_Token_616 'water'  -> MistakeAction
    * Cond_Token_604 'boat'  -> A133_boat_examining
    * Cond_Token_605 'boat'  -> A133_boat_examining
    * Cond_Token_608 'rowboat'  -> A133_boat_examining
    * Cond_Token_611 'rowboat'  -> A133_boat_examining
    * 'levers'  -> A120_lever_examining
    * 'switches'  -> A121_switch_examining
    * 'gizmoes'  -> A122_gizmo_examining
    * 'gizmos'  -> A122_gizmo_examining
    * 'train'  -> A135_train_examining
    * 'car'  -> A135_train_examining
    * 'engine'  -> A135_train_examining
    * noun=Noun_Filter_42  -> A81_overly_elaborate_looking
    * noun=Noun_Filter_43  -> A81_overly_elaborate_looking
    * noun  -> Examine
    * scope=Scope_Filter_44  -> A95_looking_toward
    * 'steam' 'train'  -> A135_train_examining
    * Mistake_Token_346 'heron' / 'flying' 'fish' / 'fish' / 'squirrel' / 'black' 'squirrel' / 'chipmunk'  -> MistakeAction
;
Verb 'read'
    * noun  -> Examine
    * 'about' topic 'in' noun  -> Consult reverse
    * topic 'in' noun  -> Consult reverse
;
Verb 'yes' 'y//'
    *  -> Yes
;
Verb 'no'
    *  -> No
;
Verb 'sorry'
    *  -> Sorry
;
Verb 'search'
    * noun=Noun_Filter_45  -> A81_overly_elaborate_looking
    * noun  -> Search
;
Verb 'wave'
    *  -> WaveHands
    * noun  -> Wave
;
Verb 'set' 'adjust'
    * noun 'to' topic  -> SetTo
;
Verb 'pull' 'drag' 'raise' 'lift'
    * noun  -> Pull
;
Verb 'push' 'move' 'shift' 'clear' 'press' 'lower'
    * 'train'  -> A134_train_moving
    * 'car'  -> A134_train_moving
    * 'engine'  -> A134_train_moving
    * 'train'  -> A134_train_moving
    * 'car'  -> A134_train_moving
    * 'engine'  -> A134_train_moving
    * noun  -> Push
    * DECIMAL_TOKEN  -> A132_typing
    * 'steam' 'train'  -> A134_train_moving
    * 'steam' 'train'  -> A134_train_moving
    * noun noun=Noun_Filter_46  -> PushDir
    * 'on' noun  -> Push
    * noun=Noun_Filter_48 'with' noun  -> A126_prying_it_with
    * noun=Noun_Filter_49 'with' noun  -> A126_prying_it_with
    * noun 'to' noun=Noun_Filter_47  -> PushDir
;
Verb 'turn' 'rotate' 'twist' 'screw' 'spin'
    *  -> A115_dancing
    * noun=Noun_Filter_51  -> A119_tightening
    * noun  -> Turn
    * noun  -> Turn
    * noun=Noun_Filter_52 'upside-down'  -> Turn
    * noun=Noun_Filter_53 'right-side-up'  -> Turn
    * 'over' noun=Noun_Filter_56  -> Turn
    * noun 'on'  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
    * noun 'over'  -> Turn
    * noun=Noun_Filter_54 'upside' 'down'  -> Turn
    * noun=Noun_Filter_50 'with' noun  -> A119_tightening
    * Cond_Token_445 noun 'in' noun  -> Unlock
    * Cond_Token_446 noun 'in' noun  -> Unlock
    * noun 'with' noun  -> Lock
    * noun=Noun_Filter_55 'right' 'side' 'up'  -> Turn
;
Verb 'switch' 'activate' 'start' 'deactivate' 'stop'
    * noun=Noun_Filter_57  -> SwitchOff
    * noun  -> SwitchOn
    * 'on' noun  -> SwitchOn
    * noun 'on'  -> SwitchOn
    * noun 'off'  -> SwitchOff
    * 'off' noun  -> SwitchOff
;
Verb 'lock'
    * noun=Noun_Filter_60  -> A87_locking_keylessly
    * noun=Noun_Filter_61  -> A87_locking_keylessly
    * noun  -> A87_locking_keylessly
    * noun=Noun_Filter_58 'with' noun  -> Lock
    * noun=Noun_Filter_59 'with' noun  -> Lock
    * noun 'with' noun  -> Lock
;
Verb 'unlock'
    * noun=Noun_Filter_64  -> A86_unlocking_keylessly
    * noun=Noun_Filter_65  -> A86_unlocking_keylessly
    * noun  -> A86_unlocking_keylessly
    * noun=Noun_Filter_62 'with' noun  -> Unlock
    * noun=Noun_Filter_63 'with' noun  -> Unlock
    * noun 'with' noun  -> Unlock
;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump' 'injure' 'kick' 'strike' 'smack'
    * Cond_Token_491 Mistake_Token_491 'gull'  -> MistakeAction
    * noun=Noun_Filter_66  -> A124_shaking
    * noun  -> Attack
    * noun  -> Attack
    * noun  -> Attack
    * 'in' / 'into' / 'down' / 'through' noun  -> Attack
    * noun 'in' / 'down'  -> Attack
    * Mistake_Token_270 noun 'with' noun  -> MistakeAction
    * Mistake_Token_271 noun 'with' noun  -> MistakeAction
    * Mistake_Token_272 noun 'with' noun  -> MistakeAction
;
Verb 'wait' 'z//'
    *  -> Wait
    * 'train'  -> A105_train_waiting
    * 'train'  -> A105_train_waiting
    * RELATIVE_TIME_TOKEN  -> A106_waiting_more
    * DECIMAL_TOKEN  -> A106_waiting_more
    * 'a//' / 'an' RELATIVE_TIME_TOKEN  -> A106_waiting_more
    * 'for' 'train'  -> A105_train_waiting
    * 'for' RELATIVE_TIME_TOKEN  -> A106_waiting_more
    * 'for' 'a//' / 'an' RELATIVE_TIME_TOKEN  -> A106_waiting_more
    * 'for' 'the' 'train'  -> A105_train_waiting
;
Verb 'answer' 'say' 'shout' 'speak'
    *  -> A93_shouting
    * creature topic  -> Answer
    * topic 'to' creature  -> Answer reverse
;
Verb 'tell'
    * creature 'about' topic  -> Tell
    * Mistake_Token_336 'about' topic  -> MistakeAction
    * creature topic  -> Tell
;
Verb 'ask'
    * creature 'for' noun  -> AskFor
    * creature 'about' topic  -> Ask
    * creature 'for' topic  -> Ask
    * Mistake_Token_334 'about' topic  -> MistakeAction
    * creature topic  -> Ask
;
Verb 'eat'
    * held  -> Eat
;
Verb 'sleep' 'nap'
    *  -> Sleep
;
Verb 'sing'
    *  -> Sing
;
Verb 'climb' 'scale'
    * 'train'  -> A134_train_moving
    * 'car'  -> A134_train_moving
    * 'engine'  -> A134_train_moving
    * noun=Noun_Filter_68  -> Go
    * noun  -> Climb
    * 'steam' 'train'  -> A134_train_moving
    * 'on' / 'onto' / 'in' / 'into' noun=Noun_Filter_67  -> Enter
    * 'up' / 'over' noun  -> Climb
    * 'on' / 'in' / 'into' / 'onto' noun  -> Climb
    * 'out' 'of' noun=Noun_Filter_69  -> A97_vehicle_exiting
    * 'out' 'of' noun=Noun_Filter_70  -> A98_supporter_exiting
    * 'off' 'of' noun=Noun_Filter_71  -> A98_supporter_exiting
;
Verb 'buy' 'purchase'
    * noun  -> Buy
;
Verb 'squeeze' 'squash'
    * noun  -> Squeeze
;
Verb 'swing'
    * noun  -> Swing
    * 'on' noun  -> Swing
;
Verb 'wake' 'awake' 'awaken'
    *  -> Wake
    * 'up'  -> Wake
    * creature  -> WakeOther
    * creature 'up'  -> WakeOther
    * 'up' creature  -> WakeOther
;
Verb 'kiss' 'embrace' 'hug'
    * creature  -> Kiss
;
Verb 'think'
    *  -> Think
;
Verb 'smell' 'sniff'
    *  -> Smell
    * noun  -> Smell
;
Verb 'listen'
    *  -> Listen
    * noun  -> Listen
    * 'to' noun  -> Listen
;
Verb 'hear'
    * noun  -> Listen
;
Verb 'taste'
    * noun  -> Taste
;
Verb 'touch' 'feel'
    * noun=Noun_Filter_72  -> A124_shaking
    * noun  -> Touch
;
Verb 'rub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe' 'scrub'
    * noun=Noun_Filter_73  -> SwitchOn
    * noun  -> Rub
;
Verb 'tie' 'attach' 'fasten'
    * noun 'to' noun  -> Tie
;
Verb 'burn' 'light' 'melt' 'ignite' 'incinerate' 'kindle' 'bake' 'toast'
    * noun  -> Burn
;
Verb 'drink' 'swallow' 'sip'
    *  -> Drink
    * noun  -> Drink
    * 'from' noun=Noun_Filter_74  -> Drink
    * Kind_GPR_46 'from' noun=Noun_Filter_75  -> A99_liquid_drinking
;
Verb 'cut' 'slice' 'prune' 'chop' 'carve'
    * noun  -> Cut
;
Verb 'jump' 'hop'
    *  -> Jump
    * Cond_Token_414 'overboard'  -> Exit
    * 'on' / 'in' / 'into' / 'onto' noun  -> Enter
;
Verb 'score'
    *  -> Score
;
Verb 'quit'
    *  -> Quit
;
Verb 'q//'
    *  -> Quit
;
Verb 'save'
    *  -> Save
;
Verb 'restart'
    *  -> Restart
;
Verb 'restore'
    *  -> Restore
;
Verb 'verify'
    *  -> Verify
;
Verb 'version'
    *  -> Version
;
Verb 'script'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'transcript'
    *  -> ScriptOn
    * 'on'  -> ScriptOn
    * 'off'  -> ScriptOff
;
Verb 'superbrief'
    *  -> LMode3
;
Verb 'short'
    *  -> LMode3
;
Verb 'verbose'
    *  -> LMode2
;
Verb 'long'
    *  -> LMode2
;
Verb 'brief'
    *  -> LMode1
;
Verb 'normal'
    *  -> LMode1
;
Verb 'nouns'
    *  -> Pronouns
;
Verb 'pronouns'
    *  -> Pronouns
;
Verb 'notify'
    *  -> NotifyOn
    * 'on'  -> NotifyOn
    * 'off'  -> NotifyOff
;
Verb 'back'
    *  -> A80_retreating
;
Verb 'return'
    *  -> A80_retreating
;
Verb 'retreat'
    *  -> A80_retreating
;
Verb 'flee'
    * noun=Noun_Filter_76  -> GetOff
;
Verb 'exits'
    *  -> A82_listing_exits
;
Verb 'use'
    * Mistake_Token_235  -> MistakeAction
    * Mistake_Token_236 noun  -> MistakeAction
    * noun=Noun_Filter_79  -> Open
    * noun=Noun_Filter_80  -> Close
    * noun=Noun_Filter_86  -> Enter
    * noun=Noun_Filter_87  -> Enter
    * noun=Noun_Filter_83  -> SwitchOn
    * noun=Noun_Filter_84  -> Open
    * noun=Noun_Filter_85  -> Enter
    * noun=Noun_Filter_77  -> Eat
    * noun=Noun_Filter_78  -> Wear
    * noun  -> A83_using
    * Mistake_Token_237 noun 'on' noun  -> MistakeAction
    * Mistake_Token_238 noun 'in' noun  -> MistakeAction
    * Mistake_Token_239 noun 'with' noun  -> MistakeAction
    * held 'on' noun=Noun_Filter_81  -> Unlock reverse
    * held 'on' noun=Noun_Filter_82  -> Lock reverse
    * noun 'to' 'get' noun  -> A130_taking_it_with
    * noun 'to' 'take' noun  -> A130_taking_it_with
;
Verb 'ride'
    * noun  -> A84_mounting
;
Verb 'mount'
    * noun  -> A84_mounting
;
Verb 'dismount'
    *  -> A85_dismounting
;
Verb 'open'
    * noun  -> Open
    * noun=Noun_Filter_90 'with' noun  -> A126_prying_it_with
    * noun=Noun_Filter_88 'with' noun  -> Unlock
    * noun=Noun_Filter_89 'with' noun  -> Unlock
    * noun 'with' noun  -> Unlock
;
Verb 'uncover'
    * noun  -> Open
;
Verb 'unlockall'
    *  -> A88_universal_unlocking
;
Verb 'okay'
    *  -> Yes
;
Verb 'ok'
    *  -> Yes
;
Verb '*//'
    * topic  -> A89_commenting
;
Verb 'dig'
    * 'in' noun  -> Search
;
Verb 'greet'
    * creature  -> A90_greeting
;
Verb 'unscrew'
    * noun 'with' noun  -> Unlock
;
Verb 'pray'
    *  -> A91_praying
;
Verb 'blow'
    * noun  -> A92_blowing
    * 'on' noun  -> A92_blowing
    * 'through' noun  -> A92_blowing
;
Verb 'scream'
    *  -> A93_shouting
;
Verb 'yell'
    *  -> A93_shouting
;
Verb 'cry'
    *  -> A93_shouting
;
Verb 'follow' 'chase' 'pursue'
    * noun=Noun_Filter_92  -> Examine
    * scope=Scope_Filter_91  -> A96_following
;
Verb 'fill'
    * noun=Noun_Filter_93 'with' / 'from' noun=Noun_Filter_94  -> A100_filling_it_with
    * noun=Noun_Filter_95 'with' / 'from' noun=Noun_Filter_96  -> A100_filling_it_with
    * noun=Noun_Filter_97 'with' held  -> A118_plugging_it_with
    * noun 'with' / 'from' noun  -> A100_filling_it_with
;
Verb 'pour'
    * 'out' noun  -> A103_spilling
    * noun=Noun_Filter_98 'in' / 'into' / 'on' / 'onto' noun=Noun_Filter_99  -> A101_pouring_it_into
    * noun 'in' / 'into' / 'on' / 'onto' noun  -> A101_pouring_it_into
;
Verb 'empty'
    * noun=Noun_Filter_102  -> A103_spilling
    * noun=Noun_Filter_100 'into' noun=Noun_Filter_101  -> A101_pouring_it_into
    * noun 'into' noun  -> A101_pouring_it_into
;
Verb 'swim'
    *  -> A102_swimming
    * Cond_Token_621 noun=Noun_Filter_103  -> Go
;
Verb 'dive'
    *  -> A102_swimming
;
Verb 'spill'
    * noun  -> A103_spilling
;
Verb 'dump'
    * noun=Noun_Filter_104  -> A103_spilling
    * 'out' noun=Noun_Filter_105  -> A103_spilling
    * noun=Noun_Filter_106 'in' noun  -> A101_pouring_it_into
;
Verb 'no.verb'
    * Mistake_Token_331 GPR_Line_129 topic  -> MistakeAction
;
Verb 'talk'
    * Mistake_Token_335  -> MistakeAction
    * Mistake_Token_333 creature  -> MistakeAction
    * Mistake_Token_332 'to' creature  -> MistakeAction
;
Verb 'help'
    *  -> A107_asking_for_help
;
Verb 'about'
    *  -> A107_asking_for_help
;
Verb 'info'
    *  -> A107_asking_for_help
;
Verb 'credits'
    *  -> A108_crediting
;
Verb 'hint'
    *  -> A109_hinting
;
Verb 'hints'
    *  -> A109_hinting
;
Verb 'full'
    *  -> A110_requesting_the_full_sco
    * 'score'  -> A110_requesting_the_full_sco
;
Verb 'xyzzy'
    *  -> A111_xyzzy
;
Verb 'pet'
    * noun  -> Rub
;
Verb 'knock'
    * 'on' noun  -> A112_knocking_on
;
Verb 'wade'
    *  -> A113_wading
;
Verb 'row'
    * Mistake_Token_393  -> MistakeAction
    * Cond_Token_398 noun=Noun_Filter_108  -> Go
    * Mistake_Token_394 'with' noun  -> MistakeAction
    * 'to' scope=Scope_Filter_109  -> A116_rowing_toward
    * 'toward' scope=Scope_Filter_110  -> A116_rowing_toward
    * 'to' scope=Scope_Filter_111  -> A116_rowing_toward
    * 'toward' scope=Scope_Filter_112  -> A116_rowing_toward
    * noun=Noun_Filter_107 'with' noun  -> A114_rowing
;
Verb 'paddle'
    * Cond_Token_399 noun=Noun_Filter_114  -> Go
    * Mistake_Token_395 'with' noun  -> MistakeAction
    * noun=Noun_Filter_113 'with' noun  -> A114_rowing
;
Verb 'peel'
    * noun=Noun_Filter_115  -> Take
    * noun=Noun_Filter_116  -> Take
;
Verb 'dance'
    *  -> A115_dancing
;
Verb 'twirl'
    *  -> A115_dancing
;
Verb 'launch'
    * Mistake_Token_413 noun=Noun_Filter_117  -> MistakeAction
;
Verb 'disembark'
    * Cond_Token_415  -> Exit
;
Verb 'plug'
    * noun 'with' held  -> A118_plugging_it_with
;
Verb 'block'
    * noun 'with' held  -> A118_plugging_it_with
;
Verb 'fix'
    * Mistake_Token_439  -> MistakeAction
    * Mistake_Token_440 noun  -> MistakeAction
    * Mistake_Token_441 noun 'with' noun  -> MistakeAction
;
Verb 'tighten'
    * noun 'with' noun  -> A119_tightening
;
Verb 'flip'
    * multi  -> A123_flipping
;
Verb 'shake'
    * noun  -> A124_shaking
;
Verb 'clatter'
    * noun  -> A124_shaking
;
Verb 'jangle'
    * noun  -> A124_shaking
    * noun  -> A124_shaking
;
Verb 'ring'
    * noun=Noun_Filter_118  -> A124_shaking
;
Verb 'tip'
    * noun=Noun_Filter_119  -> Push
    * 'over' noun=Noun_Filter_120  -> Push
;
Verb 'pry'
    * noun 'with' noun  -> A126_prying_it_with
    * 'open' noun 'with' noun  -> A126_prying_it_with
    * noun 'open' 'with' noun  -> A126_prying_it_with
;
Verb 'slide'
    * noun  -> Open
;
Verb 'skip'
    * noun  -> A127_skipping
;
Verb 'panic'
    * Mistake_Token_543  -> MistakeAction
;
Verb 'bark'
    *  -> A128_barking
    * 'at' scope=Scope_Filter_121  -> A129_thing_barking
;
Verb 'type'
    * DECIMAL_TOKEN  -> A132_typing
    * DECIMAL_TOKEN 'on' noun=Noun_Filter_122  -> A132_typing
;
Verb 'thread'
    * noun=Noun_Filter_123 'through' noun  -> Insert
;
Verb 'play'
    * noun=Noun_Filter_124  -> A124_shaking
;
Verb 'bang'
    * 'on' noun  -> Attack
;
[ Parse_Name_GV1
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_400() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'enter') jump Fail_1;
                if (NextWordStopped() ~= 'building') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_401() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'enter') jump Fail_2;
                if (NextWordStopped() ~= 'church') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV2
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV3
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV4
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV5
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV6
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV7
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_463() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'go') jump Fail_1;
                if (NextWordStopped() ~= 'down') jump Fail_1;
                group_wn = wn;
                .group_473_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'stairs') jump group_473_1_2;
                jump group_473_1_end;
                .group_473_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'downstairs') jump group_473_1_3;
                jump group_473_1_end;
                .group_473_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'go') jump Fail_1;
                .group_473_1_end;
                if (NextWordStopped() ~= 'downstairs') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV8
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV9
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_474_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'upstairs') jump group_474_1_2;
                jump group_474_1_end;
                .group_474_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'ascend') jump Fail_1;
                .group_474_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV10
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_462() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'go') jump Fail_1;
                if (NextWordStopped() ~= 'down') jump Fail_1;
                group_wn = wn;
                .group_475_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'stairs') jump group_475_1_2;
                jump group_475_1_end;
                .group_475_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'downstairs') jump group_475_1_3;
                jump group_475_1_end;
                .group_475_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'go') jump Fail_1;
                .group_475_1_end;
                if (NextWordStopped() ~= 'downstairs') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                group_wn = wn;
                .group_476_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'downstairs') jump group_476_1_2;
                jump group_476_1_end;
                .group_476_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'descend') jump Fail_2;
                .group_476_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV11
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV12
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV119
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV124
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                if (parser_action==##TheSame) {
                    if (parser_trace >= 4) print "p1, p2 = ", parser_one, ", ", parser_two, "^";
                    ss = self;
                    ! Distinguishing property p85_liquid
                    if (parser_one.p85_liquid ~= parser_two.p85_liquid) return -2;
                    self = ss; return 0;
                }
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV140
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV141
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV143
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_477_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'illustration') jump group_477_1_2;
                jump group_477_1_end;
                .group_477_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'image') jump group_477_1_3;
                jump group_477_1_end;
                .group_477_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'drawing') jump Fail_1;
                .group_477_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV144
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV145
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV146
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV148
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV149
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_478_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'onion') jump group_478_1_2;
                jump group_478_1_end;
                .group_478_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'dome') jump Fail_1;
                .group_478_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV150
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'fountain') jump Fail_1;
                if (NextWordStopped() ~= 'body') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV151
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_552() == GPR_FAIL) jump Fail_1;
                group_wn = wn;
                .group_480_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'trickling') jump group_480_1_2;
                jump group_480_1_end;
                .group_480_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'trickling') jump Fail_1;
                .group_480_1_end;
                if (NextWordStopped() ~= 'water') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV152
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_481_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'glass') jump group_481_1_2;
                jump group_481_1_end;
                .group_481_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'waterhouse') jump Fail_1;
                .group_481_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV153
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_482_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'mud') jump group_482_1_2;
                jump group_482_1_end;
                .group_482_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'brush') jump group_482_1_3;
                jump group_482_1_end;
                .group_482_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'shore') jump group_482_1_4;
                jump group_482_1_end;
                .group_482_1_4; wn = group_wn;
                if (NextWordStopped() ~= 'nest') jump group_482_1_5;
                jump group_482_1_end;
                .group_482_1_5; wn = group_wn;
                if (NextWordStopped() ~= 'pile') jump Fail_1;
                .group_482_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV154
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV155
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'boat') jump Fail_1;
                if (NextWordStopped() ~= 'house') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'spring') jump Fail_2;
                if (NextWordStopped() ~= 'house') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (Cond_Token_383() == GPR_FAIL) jump Fail_3;
                if (NextWordStopped() ~= 'building') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV157
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_486_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'boat') jump group_486_1_2;
                jump group_486_1_end;
                .group_486_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'dinghy') jump Fail_1;
                .group_486_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV160
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV161
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV163
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV164
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV167
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_487_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'green') jump group_487_1_2;
                jump group_487_1_end;
                .group_487_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'silk') jump Fail_1;
                .group_487_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV170
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV171
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV172
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_488_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'transparent') jump group_488_1_2;
                jump group_488_1_end;
                .group_488_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'plastic') jump Fail_1;
                .group_488_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV173
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV174
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV175
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV176
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV179
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV180
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV183
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV184
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV185
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV187
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'secretary^s') jump Fail_1;
                if (NextWordStopped() ~= 'notebook') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'her') jump Fail_2;
                if (NextWordStopped() ~= 'notebook') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'adriana^s') jump Fail_3;
                if (NextWordStopped() ~= 'notebook') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
                group_wn = wn;
                .group_492_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'blocks') jump group_492_1_2;
                jump group_492_1_end;
                .group_492_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'sketch') jump Fail_4;
                .group_492_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_4; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV188
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV189
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV190
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (Cond_Token_465() == GPR_FAIL) jump Fail_1;
                if (NextWordStopped() ~= 'building') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV191
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV192
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_494_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'paint') jump group_494_1_2;
                jump group_494_1_end;
                .group_494_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'green') jump group_494_1_3;
                jump group_494_1_end;
                .group_494_1_3; wn = group_wn;
                if (NextWordStopped() ~= 'layers') jump Fail_1;
                .group_494_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV193
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_495_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'branch') jump group_495_1_2;
                jump group_495_1_end;
                .group_495_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'branches') jump Fail_1;
                .group_495_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV194
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV199
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_496_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'cone') jump group_496_1_2;
                jump group_496_1_end;
                .group_496_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'cones') jump Fail_1;
                .group_496_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV200
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV201
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV203
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV204
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_497_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'cartoon') jump group_497_1_2;
                jump group_497_1_end;
                .group_497_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'animals') jump Fail_1;
                .group_497_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV205
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV206
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV207
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV208
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'hiding') jump Fail_1;
                if (NextWordStopped() ~= 'space') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'raised') jump Fail_2;
                if (NextWordStopped() ~= 'square') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV209
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV210
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_500_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'schematic') jump group_500_1_2;
                jump group_500_1_end;
                .group_500_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'diagram') jump Fail_1;
                .group_500_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV213
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'bunch') jump Fail_1;
                if (NextWordStopped() ~= 'of') jump Fail_1;
                if (NextWordStopped() ~= 'rocks') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (Cond_Token_525() == GPR_FAIL) jump Fail_2;
                if (NextWordStopped() ~= 'small') jump Fail_2;
                if (NextWordStopped() ~= 'rock') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'rocky') jump Fail_3;
                if (NextWordStopped() ~= 'beach') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV214
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'small') jump Fail_1;
                if (NextWordStopped() ~= 'disclike') jump Fail_1;
                if (NextWordStopped() ~= 'rock') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'disclike') jump Fail_2;
                if (NextWordStopped() ~= 'rock') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV216
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV217
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV218
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV219
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_506_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'crossing') jump group_506_1_2;
                jump group_506_1_end;
                .group_506_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'railroad') jump Fail_1;
                .group_506_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV220
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV222
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV223
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
                ! Match any number of visible property values
                try_from_wn = wn; g = true; while (g) {
                    g = false;
                    ! Parsing property p85_liquid
                    wn = try_from_wn; spn = parsed_number; if ((Kind_GPR_46() == GPR_NUMBER) && (self.p85_liquid == parsed_number)) {
                        try_from_wn = wn;
                        g = true;
                        f = true;
                    }
                    parsed_number = spn;
                }
                ! try_from_wn is now advanced past any visible property values
                wn = try_from_wn;
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV224
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV225
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_507_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'boat') jump group_507_1_2;
                jump group_507_1_end;
                .group_507_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'ship') jump Fail_1;
                .group_507_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV226
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV227
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_508_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'glint') jump group_508_1_2;
                jump group_508_1_end;
                .group_508_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'glint') jump Fail_1;
                .group_508_1_end;
                if (NextWordStopped() ~= 'of') jump Fail_1;
                if (NextWordStopped() ~= 'light') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV228
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV229
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_509_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'blocks') jump group_509_1_2;
                jump group_509_1_end;
                .group_509_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'wet') jump Fail_1;
                .group_509_1_end;
                if (NextWordStopped() ~= 'steps') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV230
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV232
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV233
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_510_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'rocks') jump group_510_1_2;
                jump group_510_1_end;
                .group_510_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'rock') jump Fail_1;
                .group_510_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV234
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV235
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV236
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV237
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'spray') jump Fail_1;
                if (NextWordStopped() ~= 'paint') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV238
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV239
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV240
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_512_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'wall') jump group_512_1_2;
                jump group_512_1_end;
                .group_512_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'south') jump Fail_1;
                .group_512_1_end;
                if (NextWordStopped() ~= 'wall') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV241
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV242
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV244
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV245
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'medium') jump Fail_1;
                if (NextWordStopped() ~= 'sized') jump Fail_1;
                if (NextWordStopped() ~= 'wheel') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'medium') jump Fail_2;
                if (NextWordStopped() ~= 'sized') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV247
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_515_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'pondweed') jump group_515_1_2;
                jump group_515_1_end;
                .group_515_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'twists') jump Fail_1;
                .group_515_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV248
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV249
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_516_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'person') jump group_516_1_2;
                jump group_516_1_end;
                .group_516_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'woman') jump Fail_1;
                .group_516_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV250
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'something') jump Fail_1;
                if (NextWordStopped() ~= 'green') jump Fail_1;
                if (NextWordStopped() ~= 'and') jump Fail_1;
                if (NextWordStopped() ~= 'clingy') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
                if (NextWordStopped() ~= 'something') jump Fail_2;
                if (NextWordStopped() ~= 'green') jump Fail_2;
                try_from_wn = wn; f = true; continue;
                .Fail_2; wn = try_from_wn;
                if (NextWordStopped() ~= 'something') jump Fail_3;
                if (NextWordStopped() ~= 'clingy') jump Fail_3;
                try_from_wn = wn; f = true; continue;
                .Fail_3; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV252
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV253
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_520_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'dent') jump group_520_1_2;
                jump group_520_1_end;
                .group_520_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'indentation') jump Fail_1;
                .group_520_1_end;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV254
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV255
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                group_wn = wn;
                .group_521_1_1; wn = group_wn;
                if (NextWordStopped() ~= 'wheel') jump group_521_1_2;
                jump group_521_1_end;
                .group_521_1_2; wn = group_wn;
                if (NextWordStopped() ~= 'crystal') jump Fail_1;
                .group_521_1_end;
                if (NextWordStopped() ~= 'wheel') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV256
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV257
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV259
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV260
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'metal') jump Fail_1;
                if (NextWordStopped() ~= 'key') jump Fail_1;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV261
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV262
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV263
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV264
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV265
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'tools') jump Fail_1;
                parser_action = ##PluralFound;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV266
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'tools') jump Fail_1;
                parser_action = ##PluralFound;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV267
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
                if (NextWordStopped() ~= 'tools') jump Fail_1;
                parser_action = ##PluralFound;
                try_from_wn = wn; f = true; continue;
                .Fail_1; wn = try_from_wn;
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV268
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Parse_Name_GV269
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    spn  ! temporary: saves 'parsed_number' in parsing visibles
    pass  ! pass counter (1 to 3)
    pass1_n  ! value of n recorded during pass 1
    pass2_n  ! value of n recorded during pass 2
    ;
    if (parser_trace >= 3) print "Parse_name called^";
    if (parser_action == ##TheSame) return 0;
    original_wn = wn;
    for (pass = 1: pass <= 3: pass++) {
        wn = original_wn;
        try_from_wn = wn; f = false; n = 0;
        while (true) {
            ! On pass 1 only, advance wn past name property words
            ! (but do not do this for ##TheSame, when wn is undefined)
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            if (pass == 1 or 2) {
            }
            if ((parser_action ~= ##TheSame) && (pass == 1)) {
                while (WordInProperty(NextWordStopped(), self, name)) f = true;
                wn--; try_from_wn = wn;
            }
            break;
        } ! End of endless loop
        while (WordInProperty(NextWordStopped(), self, name)) n++;
        if ((f) || (n>0)) n = n + try_from_wn - original_wn;
        if (pass == 1) pass1_n = n;
        if (pass == 2) pass2_n = n;
    } ! End of pass loop
    if (parser_trace >= 3)
        print "Pass 1: ", pass1_n, " Pass 2: ", pass2_n, " Pass 3: ", n, "^";
    if (pass1_n > n) n = pass1_n;
    if (pass2_n > n) n = pass2_n;
    wn = original_wn + n;
    if (n == 0) return -1;
    DetectPluralWord(original_wn, n);
    return n;
];
[ Consult_Grammar_270
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restart') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_271
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'restore') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_272
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'amusing') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_273
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'quit') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_274
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'undo') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_275
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'water') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_276
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'parents') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_277
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_533_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'energy') jump group_533_1_2;
        jump group_533_1_end;
        .group_533_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'vibes') jump Fail_1;
        .group_533_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_278
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'pond') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_279
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_535_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'city') jump group_535_1_2;
        jump group_535_1_end;
        .group_535_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'underwater') jump Fail_1;
        .group_535_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_280
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_536_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'people') jump group_536_1_2;
        jump group_536_1_end;
        .group_536_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'city-people') jump Fail_1;
        .group_536_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_281
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_537_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'pump') jump group_537_1_2;
        jump group_537_1_end;
        .group_537_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'system') jump Fail_1;
        .group_537_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_282
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_538_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'reverse') jump group_538_1_2;
        jump group_538_1_end;
        .group_538_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'reversible') jump group_538_1_3;
        jump group_538_1_end;
        .group_538_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'reversibility') jump Fail_1;
        .group_538_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_283
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'train') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_284
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_540_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'city') jump group_540_1_2;
        jump group_540_1_end;
        .group_540_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'crystal') jump group_540_1_3;
        jump group_540_1_end;
        .group_540_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'island') jump Fail_1;
        .group_540_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_285
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'pondside') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_286
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'mud') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_287
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'boat') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_288
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_544_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'pump') jump group_544_1_2;
        jump group_544_1_end;
        .group_544_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'system') jump Fail_1;
        .group_544_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_289
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_545_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'procedures') jump group_545_1_2;
        jump group_545_1_end;
        .group_545_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'evacuation') jump Fail_1;
        .group_545_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_290
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_546_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'city') jump group_546_1_2;
        jump group_546_1_end;
        .group_546_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'crystal') jump group_546_1_3;
        jump group_546_1_end;
        .group_546_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'island') jump group_546_1_4;
        jump group_546_1_end;
        .group_546_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'page') jump group_546_1_5;
        jump group_546_1_end;
        .group_546_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'illustration') jump group_546_1_6;
        jump group_546_1_end;
        .group_546_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'drawing') jump Fail_1;
        .group_546_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_291
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_547_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'stories') jump group_547_1_2;
        jump group_547_1_end;
        .group_547_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'rumors') jump Fail_1;
        .group_547_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_292
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_548_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'pump') jump group_548_1_2;
        jump group_548_1_end;
        .group_548_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'device') jump Fail_1;
        .group_548_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_293
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'water') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_294
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'pond') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_295
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'boat') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_296
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_552_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'train') jump group_552_1_2;
        jump group_552_1_end;
        .group_552_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'tracks') jump group_552_1_3;
        jump group_552_1_end;
        .group_552_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'crossing') jump group_552_1_4;
        jump group_552_1_end;
        .group_552_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'schedule') jump Fail_1;
        .group_552_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_297
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ticket') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_298
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_554_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'visitor') jump group_554_1_2;
        jump group_554_1_end;
        .group_554_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'center') jump Fail_1;
        .group_554_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_299
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_555_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'technicians') jump group_555_1_2;
        jump group_555_1_end;
        .group_555_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'experts') jump Fail_1;
        .group_555_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_300
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_556_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'structure') jump group_556_1_2;
        jump group_556_1_end;
        .group_556_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'house') jump group_556_1_3;
        jump group_556_1_end;
        .group_556_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'boathouse') jump group_556_1_4;
        jump group_556_1_end;
        .group_556_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'boat-house') jump group_556_1_5;
        jump group_556_1_end;
        .group_556_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'waterworks') jump group_556_1_6;
        jump group_556_1_end;
        .group_556_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'springhouse') jump group_556_1_7;
        jump group_556_1_end;
        .group_556_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'spring-house') jump group_556_1_8;
        jump group_556_1_end;
        .group_556_1_8; wn = group_wn;
        if (NextWordStopped() ~= 'pumphouse') jump group_556_1_9;
        jump group_556_1_end;
        .group_556_1_9; wn = group_wn;
        if (NextWordStopped() ~= 'pump-house') jump Fail_1;
        .group_556_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_301
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_557_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'notebook') jump group_557_1_2;
        jump group_557_1_end;
        .group_557_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'book') jump group_557_1_3;
        jump group_557_1_end;
        .group_557_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'writing') jump group_557_1_4;
        jump group_557_1_end;
        .group_557_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'drawing') jump Fail_1;
        .group_557_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_302
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'fountain') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_303
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_559_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'hello') jump group_559_1_2;
        jump group_559_1_end;
        .group_559_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'hi') jump group_559_1_3;
        jump group_559_1_end;
        .group_559_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'hey') jump Fail_1;
        .group_559_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_304
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_560_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'self') jump group_560_1_2;
        jump group_560_1_end;
        .group_560_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'secretary') jump group_560_1_3;
        jump group_560_1_end;
        .group_560_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'name') jump Fail_1;
        .group_560_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_305
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'adriana') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_306
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_562_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'conductor') jump group_562_1_2;
        jump group_562_1_end;
        .group_562_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'eric') jump Fail_1;
        .group_562_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_307
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hill') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_308
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'beach') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_309
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_565_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'mud') jump group_565_1_2;
        jump group_565_1_end;
        .group_565_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'marsh') jump Fail_1;
        .group_565_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_310
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_566_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'machine') jump group_566_1_2;
        jump group_566_1_end;
        .group_566_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'levers') jump group_566_1_3;
        jump group_566_1_end;
        .group_566_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'gadgets') jump group_566_1_4;
        jump group_566_1_end;
        .group_566_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'gizmos') jump group_566_1_5;
        jump group_566_1_end;
        .group_566_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'gizmoes') jump group_566_1_6;
        jump group_566_1_end;
        .group_566_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'lever') jump group_566_1_7;
        jump group_566_1_end;
        .group_566_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'gadget') jump group_566_1_8;
        jump group_566_1_end;
        .group_566_1_8; wn = group_wn;
        if (NextWordStopped() ~= 'gizmo') jump Fail_1;
        .group_566_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_311
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'system') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_312
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'dog') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_313
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'boss') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_314
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_570_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'mom') jump group_570_1_2;
        jump group_570_1_end;
        .group_570_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'mother') jump Fail_1;
        .group_570_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_315
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_571_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'dad') jump group_571_1_2;
        jump group_571_1_end;
        .group_571_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'father') jump Fail_1;
        .group_571_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_316
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_572_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'stairs') jump group_572_1_2;
        jump group_572_1_end;
        .group_572_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'staircase') jump group_572_1_3;
        jump group_572_1_end;
        .group_572_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'deathtrap') jump Fail_1;
        .group_572_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_317
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_573_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'job') jump group_573_1_2;
        jump group_573_1_end;
        .group_573_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'nameplate') jump Fail_1;
        .group_573_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_318
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_574_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'slot') jump group_574_1_2;
        jump group_574_1_end;
        .group_574_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'vending') jump group_574_1_3;
        jump group_574_1_end;
        .group_574_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'newspaper') jump Fail_1;
        .group_574_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_319
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_575_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'coin') jump group_575_1_2;
        jump group_575_1_end;
        .group_575_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'money') jump Fail_1;
        .group_575_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_320
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'church') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_321
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'community') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_322
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hut') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_323
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'maintenance') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_324
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'wooden') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_325
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'wooden') jump Fail_1;
        if (NextWordStopped() ~= 'drawer') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_326
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'metal') jump Fail_1;
        if (NextWordStopped() ~= 'drawer') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_327
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'desk') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_328
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'drawer') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_329
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_585_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'me') jump group_585_1_2;
        jump group_585_1_end;
        .group_585_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'myself') jump Fail_1;
        .group_585_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_330
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_586_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'birds') jump group_586_1_2;
        jump group_586_1_end;
        .group_586_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'geese') jump group_586_1_3;
        jump group_586_1_end;
        .group_586_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'larks') jump group_586_1_4;
        jump group_586_1_end;
        .group_586_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'starlings') jump group_586_1_5;
        jump group_586_1_end;
        .group_586_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'bird') jump group_586_1_6;
        jump group_586_1_end;
        .group_586_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'starling') jump group_586_1_7;
        jump group_586_1_end;
        .group_586_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'goose') jump group_586_1_8;
        jump group_586_1_end;
        .group_586_1_8; wn = group_wn;
        if (NextWordStopped() ~= 'lark') jump group_586_1_9;
        jump group_586_1_end;
        .group_586_1_9; wn = group_wn;
        if (NextWordStopped() ~= 'heron') jump group_586_1_10;
        jump group_586_1_end;
        .group_586_1_10; wn = group_wn;
        if (NextWordStopped() ~= 'magpie') jump group_586_1_11;
        jump group_586_1_end;
        .group_586_1_11; wn = group_wn;
        if (NextWordStopped() ~= 'magpies') jump group_586_1_12;
        jump group_586_1_end;
        .group_586_1_12; wn = group_wn;
        if (NextWordStopped() ~= 'teal') jump group_586_1_13;
        jump group_586_1_end;
        .group_586_1_13; wn = group_wn;
        if (NextWordStopped() ~= 'mallard') jump group_586_1_14;
        jump group_586_1_end;
        .group_586_1_14; wn = group_wn;
        if (NextWordStopped() ~= 'mallards') jump group_586_1_15;
        jump group_586_1_end;
        .group_586_1_15; wn = group_wn;
        if (NextWordStopped() ~= 'herons') jump group_586_1_16;
        jump group_586_1_end;
        .group_586_1_16; wn = group_wn;
        if (NextWordStopped() ~= 'siege') jump group_586_1_17;
        jump group_586_1_end;
        .group_586_1_17; wn = group_wn;
        if (NextWordStopped() ~= 'bitterns') jump Fail_1;
        .group_586_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_331
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_587_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'woods') jump group_587_1_2;
        jump group_587_1_end;
        .group_587_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'forest') jump Fail_1;
        .group_587_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_332
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_588_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'key') jump group_588_1_2;
        jump group_588_1_end;
        .group_588_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'keychain') jump group_588_1_3;
        jump group_588_1_end;
        .group_588_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'red') jump group_588_1_4;
        jump group_588_1_end;
        .group_588_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'foam') jump group_588_1_5;
        jump group_588_1_end;
        .group_588_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'brass') jump Fail_1;
        .group_588_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_333
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_589_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'cylinder') jump group_589_1_2;
        jump group_589_1_end;
        .group_589_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'bubbling') jump Fail_1;
        .group_589_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_334
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'gull') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_335
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'family') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_336
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ladder') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_337
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_593_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'city') jump group_593_1_2;
        jump group_593_1_end;
        .group_593_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'crystal') jump group_593_1_3;
        jump group_593_1_end;
        .group_593_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'island') jump Fail_1;
        .group_593_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_338
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'legend') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_339
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_595_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'water') jump group_595_1_2;
        jump group_595_1_end;
        .group_595_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'pond') jump group_595_1_3;
        jump group_595_1_end;
        .group_595_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'pumps') jump group_595_1_4;
        jump group_595_1_end;
        .group_595_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'pump') jump group_595_1_5;
        jump group_595_1_end;
        .group_595_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'tank') jump Fail_1;
        .group_595_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_340
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_596_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'boat') jump group_596_1_2;
        jump group_596_1_end;
        .group_596_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'boats') jump Fail_1;
        .group_596_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_341
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_597_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'tracks') jump group_597_1_2;
        jump group_597_1_end;
        .group_597_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'crossing') jump group_597_1_3;
        jump group_597_1_end;
        .group_597_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'station') jump group_597_1_4;
        jump group_597_1_end;
        .group_597_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'stop') jump Fail_1;
        .group_597_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_342
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_598_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'visitor') jump group_598_1_2;
        jump group_598_1_end;
        .group_598_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'visitor') jump Fail_1;
        .group_598_1_end;
        if (NextWordStopped() ~= 'center') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_343
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'ticket') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_344
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'schedule') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_345
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_601_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'structure') jump group_601_1_2;
        jump group_601_1_end;
        .group_601_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'house') jump group_601_1_3;
        jump group_601_1_end;
        .group_601_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'waterworks') jump Fail_1;
        .group_601_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_346
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'nerd') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_347
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_603_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'mustache') jump group_603_1_2;
        jump group_603_1_end;
        .group_603_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'moustache') jump group_603_1_3;
        jump group_603_1_end;
        .group_603_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'stache') jump Fail_1;
        .group_603_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_348
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_604_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'hello') jump group_604_1_2;
        jump group_604_1_end;
        .group_604_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'hi') jump group_604_1_3;
        jump group_604_1_end;
        .group_604_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'hey') jump Fail_1;
        .group_604_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_349
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'panel') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_350
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_606_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'screwdriver') jump group_606_1_2;
        jump group_606_1_end;
        .group_606_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'wrench') jump group_606_1_3;
        jump group_606_1_end;
        .group_606_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'light') jump Fail_1;
        .group_606_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_351
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_607_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'self') jump group_607_1_2;
        jump group_607_1_end;
        .group_607_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'name') jump group_607_1_3;
        jump group_607_1_end;
        .group_607_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'conductor') jump Fail_1;
        .group_607_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_352
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'eric') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_353
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_609_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'adriana') jump group_609_1_2;
        jump group_609_1_end;
        .group_609_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'secretary') jump Fail_1;
        .group_609_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_354
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_610_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'px1105') jump group_610_1_2;
        jump group_610_1_end;
        .group_610_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'rolling') jump group_610_1_3;
        jump group_610_1_end;
        .group_610_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'resistance') jump group_610_1_4;
        jump group_610_1_end;
        .group_610_1_4; wn = group_wn;
        if (NextWordStopped() ~= 'boiler') jump group_610_1_5;
        jump group_610_1_end;
        .group_610_1_5; wn = group_wn;
        if (NextWordStopped() ~= 'steam') jump group_610_1_6;
        jump group_610_1_end;
        .group_610_1_6; wn = group_wn;
        if (NextWordStopped() ~= 'stoker') jump group_610_1_7;
        jump group_610_1_end;
        .group_610_1_7; wn = group_wn;
        if (NextWordStopped() ~= 'mechanical') jump group_610_1_8;
        jump group_610_1_end;
        .group_610_1_8; wn = group_wn;
        if (NextWordStopped() ~= 'mechanic') jump group_610_1_9;
        jump group_610_1_end;
        .group_610_1_9; wn = group_wn;
        if (NextWordStopped() ~= 'locomotive') jump group_610_1_10;
        jump group_610_1_end;
        .group_610_1_10; wn = group_wn;
        if (NextWordStopped() ~= '2-6-2') jump group_610_1_11;
        jump group_610_1_end;
        .group_610_1_11; wn = group_wn;
        if (NextWordStopped() ~= 'stock') jump group_610_1_12;
        jump group_610_1_end;
        .group_610_1_12; wn = group_wn;
        if (NextWordStopped() ~= 'local') jump Fail_1;
        .group_610_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_355
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_611_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'property') jump group_611_1_2;
        jump group_611_1_end;
        .group_611_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'train') jump Fail_1;
        .group_611_1_end;
        if (NextWordStopped() ~= 'property') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_356
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'seat') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_357
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'church') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_358
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_614_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'community') jump group_614_1_2;
        jump group_614_1_end;
        .group_614_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'community') jump Fail_1;
        .group_614_1_end;
        if (NextWordStopped() ~= 'center') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_359
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'job') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_360
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_616_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'hut') jump group_616_1_2;
        jump group_616_1_end;
        .group_616_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'keypad') jump group_616_1_3;
        jump group_616_1_end;
        .group_616_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'boulder') jump Fail_1;
        .group_616_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_361
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_617_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'coin') jump group_617_1_2;
        jump group_617_1_end;
        .group_617_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'money') jump Fail_1;
        .group_617_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_362
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'hill') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_363
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_619_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'me') jump group_619_1_2;
        jump group_619_1_end;
        .group_619_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'myself') jump Fail_1;
        .group_619_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_364
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_620_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'passenger') jump group_620_1_2;
        jump group_620_1_end;
        .group_620_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'passengers') jump Fail_1;
        .group_620_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_365
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'dog') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_366
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        group_wn = wn;
        .group_622_1_1; wn = group_wn;
        if (NextWordStopped() ~= 'self') jump group_622_1_2;
        jump group_622_1_end;
        .group_622_1_2; wn = group_wn;
        if (NextWordStopped() ~= 'secretary') jump group_622_1_3;
        jump group_622_1_end;
        .group_622_1_3; wn = group_wn;
        if (NextWordStopped() ~= 'name') jump Fail_1;
        .group_622_1_end;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_367
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'train') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_368
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'trains') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];

[ Consult_Grammar_369
    range_from  ! call parameter: word number of snippet start
    range_words  ! call parameter: snippet length
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    ;
    wn = range_from; original_wn = wn; rv = GPR_PREPOSITION;
        if (NextWordStopped() ~= 'steam') jump Fail_1;
        if (NextWordStopped() ~= 'train') jump Fail_1;
        if ((range_words==0) || (wn-range_from==range_words)) return rv;
        .Fail_1; rv = GPR_PREPOSITION; wn = original_wn;
    return GPR_FAIL;
];



#IFTRUE (1 == 1);
[ UnknownVerb; verb_wordnum = 0; return 'no.verb'; ];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#Ifnot;
[ UnknownVerb; rfalse; ]; [ PrintVerb v; rfalse; ];
#ENDIF;


Array Rel_Record_63 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "leading-through relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     door_to KD4_relation_of_rooms_to_doors Rel_Handler_63 "Leading-through relates one room (called the other side) to various doors";
[ Rel_Handler_63 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (X == (Y.door_to)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK4_First: Z1: Z1=Z1.IK4_Link) {
                if (Rel_Handler_63(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_63(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK4_First: Z3: Z3=Z3.IK4_Link) {
                    if (Rel_Handler_63(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: Y.door_to = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,door_to,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_65 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "lock-fitting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     with_key KD5_relation_of_things_to_thin Rel_Handler_65 "Lock-fitting relates one thing (called the matching key) to various things";
[ Rel_Handler_65 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (X == (Y.with_key)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_65(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_65(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_65(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: Y.with_key = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,with_key,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_67 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "unbolting relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_X_UNIQUE+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     p67_unbolting KD6_relation_of_passkeys_to_th Rel_Handler_67 "Unbolting relates one passkey to various things";
[ Rel_Handler_67 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if (X == (Y.p67_unbolting)) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK18_First: Z1: Z1=Z1.IK18_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK18_First: Z1: Z1=Z1.IK18_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK2_First: Z1: Z1=Z1.IK2_Link) {
                if (Rel_Handler_67(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK18_First: Z1: Z1=Z1.IK18_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK18_First: Z1: Z1=Z1.IK18_Link) {
                for (Z3=IK2_First: Z3: Z3=Z3.IK2_Link) {
                    if (Rel_Handler_67(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: Y.p67_unbolting = X; rtrue;
        RELS_ASSERT_FALSE: Relation_NowN1toV(Y,p67_unbolting,X); rtrue;
        RELS_SHOW: Relation_RShowOtoO(rr, false); rtrue;
        RELS_ROUTE_FIND: return OtoVRelRouteTo(rr-->RR_STORAGE, X, Y);
        RELS_ROUTE_FIND_COUNT: return RelFollowVector(OtoVRelRouteTo(rr-->RR_STORAGE, X, Y), X, Y);
    }
    rfalse;
];
Array Rel_Record_69 -->
    REL_BLOCK_HEADER
    RELATION_TY
    NULL NULL
    "approaching relation"
     RELS_TEST+RELS_LOOKUP_ANY+RELS_LOOKUP_ALL_X+RELS_LOOKUP_ALL_Y+RELS_LIST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW+RELS_ROUTE_FIND
     V2V_Bitmap_69 KD7_relation_of_rooms_to_rooms Rel_Handler_69 "Approaching relates various rooms to various rooms";
[ Rel_Handler_69 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST: if ((Relation_TestVtoV(X,Rel_Record_69,Y,false))) rtrue; rfalse;
        RELS_LOOKUP_ANY: if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        } else {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
                    return Z1;
                }
            }
            if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rfalse;
            return DefaultValueOfKOV(9);
        }
        RELS_LOOKUP_ALL_X, RELS_LOOKUP_ALL_Y: LIST_OF_TY_SetLength(Y, 0);
        if (task == RELS_LOOKUP_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, X, Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        } else {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                if (Rel_Handler_69(rr, RELS_TEST, Z1, X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
        }
        return Y;
        RELS_LIST: LIST_OF_TY_SetLength(X, 0);
        if (Y == RLIST_ALL_X) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK1_First: Z3: Z3=Z3.IK1_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z1, false, 0, true);
                    }
                }
            }
        } else if (Y == RLIST_ALL_Y) {
            for (Z1=IK1_First: Z1: Z1=Z1.IK1_Link) {
                for (Z3=IK1_First: Z3: Z3=Z3.IK1_Link) {
                    if (Rel_Handler_69(rr, RELS_TEST, Z1, Z3)) {
                        LIST_OF_TY_InsertItem(X, Z3, false, 0, true);
                    }
                }
            }
        }
        return X;
        RELS_ASSERT_TRUE: (Relation_NowVtoV(X,Rel_Record_69,Y,false)); rtrue;
        RELS_ASSERT_FALSE: (Relation_NowNVtoV(X,Rel_Record_69,Y,false)); rtrue;
        RELS_SHOW: Relation_ShowVtoV(rr, false); rtrue;
        RELS_ROUTE_FIND: return VtoVRelRouteTo(rr, X, Y);
        RELS_ROUTE_FIND_COUNT: return VtoVRelRouteTo(rr, X, Y, true);
    }
    rfalse;
];
[ CreateDynamicRelations i rel;
];

! True or false?
! [ Card>=1 x IN[ thing(x) & 'metal'(x) IN] : 'visible'(x) ]
[ Prop_0  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_102_t1_v9(x)))){
            qcn_0++;
            if (((Adj_3_t1_v9(x)))){
                qcy_0++;
            }
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & 'metal'(x) & 'visible'(x) ]
[ Prop_1  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_102_t1_v9(x))) && ((Adj_3_t1_v9(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ room(x) & adjacent-to(const_0, x) ]
[ Prop_2  const_0 x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK1_First: x: x=x.IK1_Link){
            if ((TestAdjacency(const_0,x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ room(x) & is(x, ContainerOf('dog')) ]
[ Prop_3  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK1_First: x: x=x.IK1_Link){
            if ((x == ContainerOf(I443_dog))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ direction(x) ]
[ Prop_4  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK3_First: x: x=x.IK3_Link){
            counter++;
            if (counter == selection) return x;
            jump NextOuterLoop_7;
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ thing(x) & 'visible'(x) ]
[ Prop_5  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v9(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : thing(x) & is('cavity', ContainerOf(x)) ]
[ Prop_6  x x_ix ;
    for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : flat paper(x) & called='leaflet'(x) & is('cavity', ContainerOf(x)) ]
[ Prop_7  x x_ix ;
    for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
        if ((x ofclass K31_flat_paper)){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ flat paper(x) NOT] & is('cavity', ContainerOf(x)) ]
[ Prop_8  x x_ix ;
    for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
        if ((x ofclass K2_thing)){
            if (~~((x ofclass K31_flat_paper))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'metal'(x) & is('cavity', ContainerOf(x)) ]
[ Prop_9  x x_ix ;
    for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
        if ((x ofclass K2_thing) && ((Adj_102_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & is('cavity', ContainerOf(x)) ]
[ Prop_10  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ thing(x) & NOT[ flat paper('cavity') NOT] & is('cavity', ContainerOf(x)) ]
[ Prop_11  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
            if ((x ofclass K2_thing)){
                if (~~((I701_cavity ofclass K31_flat_paper))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ thing(x) & NOT[ flat paper('cavity') NOT] & is('cavity', ContainerOf(x)) ]
[ Prop_12  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
            if ((x ofclass K2_thing)){
                if (~~((I701_cavity ofclass K31_flat_paper))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ thing(x) & NOT[ flat paper('cavity') NOT] & is('cavity', ContainerOf(x)) ]
[ Prop_13  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
            if ((x ofclass K2_thing)){
                if (~~((I701_cavity ofclass K31_flat_paper))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('cavity', ContainerOf(x)) & 'metal'(x) ]
[ Prop_14  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I701_cavity == ContainerOf(x)) && ((Adj_102_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & is('cavity', ContainerOf(x)) ]
[ Prop_15  x x_ix ;
    for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & is('cavity', ContainerOf(x)) ]
[ Prop_16  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ rideable animal(x) & is(x, CarrierOf('person asked')) ]
[ Prop_17  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=nothing: false: ){
            if ((x == CarrierOf(actor))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! Find a random x satisfying:
! [ rideable vehicle(x) & is(x, SupporterOf('person asked')) ]
[ Prop_18  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=nothing: false: ){
            if ((x == SupporterOf(actor))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : small rock(x) & 'handled'(x) & is('player', OwnerOf(x)) ]
[ Prop_19  x x_ix ;
    objectloop (x in player) if (OwnerOf(x)==parent(x)){
        if ((x ofclass K24_small_rock) && ((Adj_60_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ small rock(x) IN] : encloses('player', x) ]
[ Prop_20  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK24_First: x: x=x.IK24_Link){
        qcn_0++;
        if ((IndirectlyContains(player,x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ small rock(x) & is('player', HolderOf(x)) ]
[ Prop_21  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK24_First: x: x=x.IK24_Link){
            if ((player == HolderOf(x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_22  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_23  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card=2 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_24  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 2){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card=3 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_25  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 3){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ direction(x) ]
[ Prop_26  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK3_First: x: x=x.IK3_Link){
            counter++;
            if (counter == selection) return x;
            jump NextOuterLoop_7;
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : thing(x) & is('pipe holes', ContainerOf(x)) ]
[ Prop_27  x x_ix ;
    for (x=TestContainmentRange(I662_pipe_holes): x: x=TestContainmentRange(I662_pipe_holes,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & is('holes', ContainerOf(x)) ]
[ Prop_28  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I661_wheel_holes): x: x=TestContainmentRange(I661_wheel_holes,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : keychain(x) & is('tall cylinder', ContainerOf(x)) ]
[ Prop_29  x x_ix ;
    for (x=TestContainmentRange(I522_tall_cylinder): x: x=TestContainmentRange(I522_tall_cylinder,x)){
        if ((x ofclass K19_keychain)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ room(x) IN] : 'inward'(x) ]
[ Prop_30  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        qcn_0++;
        if (((Adj_40_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>1 x IN[ room(x) IN] : 'inward'(x) ]
[ Prop_31  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        qcn_0++;
        if (((Adj_40_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 > 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ room(x) & 'inward'(x) ]
[ Prop_32  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK1_First: x: x=x.IK1_Link){
            if (((Adj_40_t1_v9(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('pipe holes', ContainerOf(x)) ]
[ Prop_33  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I662_pipe_holes == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ small rock(x) IN] : is('rocky beach', ContainerOf(x)) ]
[ Prop_34  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK24_First: x: x=x.IK24_Link){
        qcn_0++;
        if ((I470_rocky_beach == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : wheel(x) & is('brass metal pipe', SupporterOf(x)) ]
[ Prop_35  x x_ix ;
    objectloop (x in I657_brass_metal_pipe) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K20_wheel)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : wheel(x) & NOT[ is('brass metal pipe', SupporterOf(x)) NOT] ]
[ Prop_36  x x_ix ;
    for (x=IK20_First: x: x=x.IK20_Link){
        if (~~((I657_brass_metal_pipe == SupporterOf(x)))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & is('noun', ContainerOf(x)) ]
[ Prop_37  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is('noun', ContainerOf(x)) ]
[ Prop_38  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find a random x satisfying:
! [ small rock(x) & is('rock limbo', ContainerOf(x)) ]
[ Prop_39  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I595_rock_limbo): x: x=TestContainmentRange(I595_rock_limbo,x)){
            if ((x ofclass K24_small_rock)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ supporter(x) IN] : is(x, SupporterOf('player')) ]
[ Prop_40  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK6_First: x: x=x.IK6_Link){
        qcn_0++;
        if ((x == SupporterOf(player))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ room(x) IN] : 'outward'(x) ]
[ Prop_41  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK1_First: x: x=x.IK1_Link){
        qcn_0++;
        if (((Adj_39_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ room(x) & 'outward'(x) ]
[ Prop_42  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK1_First: x: x=x.IK1_Link){
            if (((Adj_39_t1_v9(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ supporter(x) IN] : is(x, SupporterOf('player')) ]
[ Prop_43  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK6_First: x: x=x.IK6_Link){
        qcn_0++;
        if ((x == SupporterOf(player))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_44  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : person(x) & NOT[ is(x, 'player') NOT] & is(const_0, ContainerOf(x)) ]
[ Prop_45  const_0 x x_ix ;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K8_person)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
[ Prop_46  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v9(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : thing(x) & is('player', WearerOf(x)) ]
[ Prop_47  x x_ix ;
    objectloop (x in player) if (WearerOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('left pocket', ContainerOf(x)) ]
[ Prop_48  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I452_left_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('right pocket', ContainerOf(x)) ]
[ Prop_49  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I451_right_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('left pocket', ContainerOf(x)) ]
[ Prop_50  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I452_left_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('right pocket', ContainerOf(x)) ]
[ Prop_51  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I451_right_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('left pocket', ContainerOf(x)) ]
[ Prop_52  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I452_left_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('right pocket', ContainerOf(x)) ]
[ Prop_53  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I451_right_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('left pocket', ContainerOf(x)) ]
[ Prop_54  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I452_left_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ IN] : is('right pocket', ContainerOf(x)) ]
[ Prop_55  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    objectloop (x ofclass Object){
        qcn_0++;
        if ((I451_right_pocket == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & is('noun', ContainerOf(x)) ]
[ Prop_56  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : fluid container(x) & Exists y : thing(y) & is(x, ContainerOf(y)) ]
[ Prop_57  x x_ix y y_ix ;
    for (x=IK25_First: x: x=x.IK25_Link){
        for (y=TestContainmentRange(x): y: y=TestContainmentRange(x,y)){
            if ((y ofclass K2_thing)){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : fluid container(x) & 'empty'(x) ]
[ Prop_58  x x_ix ;
    for (x=IK25_First: x: x=x.IK25_Link){
        if (((Adj_16_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & 'switchable'(x) & encloses('location', x) ]
[ Prop_59  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_32_t1_v9(x))) && (IndirectlyContains(real_location,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) & is('in the sweetgum tree', ContainerOf(x)) ]
[ Prop_60  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(I442_in_the_sweetgum_tree): x: x=TestContainmentRange(I442_in_the_sweetgum_tree,x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) & is('hill', ContainerOf(x)) ]
[ Prop_61  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=TestContainmentRange(I441_hill): x: x=TestContainmentRange(I441_hill,x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : fluid container(x) & called='drinkme'(x) & 'visible'(x) ]
[ Prop_62  x x_ix ;
    for (x=IK25_First: x: x=x.IK25_Link){
        if (((Adj_3_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : fluid container(x) & called='drinkme'(x) & 'visible'(x) ]
[ Prop_63  x x_ix ;
    for (x=IK25_First: x: x=x.IK25_Link){
        if (((Adj_3_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : liquid source(x) & called='drinkme'(x) & 'visible'(x) ]
[ Prop_64  x x_ix ;
    for (x=IK26_First: x: x=x.IK26_Link){
        if (((Adj_3_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & called='box'(x) & 'enterable'(x) & is('location', ContainerOf(x)) ]
[ Prop_65  x x_ix ;
    for (x=TestContainmentRange(real_location): x: x=TestContainmentRange(real_location,x)){
        if ((x ofclass K2_thing) && ((Adj_67_t1_v9(x)))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) ]
[ Prop_66  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) ]
[ Prop_67  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) ]
[ Prop_68  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_69  x x_ix counter;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_63_t1_v9(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find next x satisfying:
! [ thing(x) & 'marked for listing'(x) ]
[ Prop_70  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_63_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Abstraction for set of x such that:
! [ thing(x) & 'unmentioned'(x) ]
[ Prop_71 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_66_t1_v9(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_66_t1_v9(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK2_First: x: x=x.IK2_Link){
                    if (((Adj_66_t1_v9(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_66_t1_v9(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK2_First: x: x=x.IK2_Link){
                if (((Adj_66_t1_v9(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K2_thing) && ((Adj_66_t1_v9(x)))){
                rtrue;
            }
            rfalse;
    }
];

! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_72  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_30_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_73  const_0 x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : thing(x) & 'locale-supportable'(x) & is(const_0, SupporterOf(x)) ]
[ Prop_74  const_0 x x_ix ;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_30_t1_v9(x)))){
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_75  const_0 x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! How many x satisfy this?
! [ thing(x) & is('player', CarrierOf(x)) ]
[ Prop_76  x x_ix counter;
    objectloop (x in player) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Force this to be true via 'now':
! [ ForAll x IN[ player's holdall(x) IN] : 'chunavailable'(x) ]
[ Prop_77  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK15_First: x: x=x.IK15_Link){
        qcn_0++;
        (Adj_87_t2_v9(x));
        qcy_0++;
    }
    if (qcy_0 == qcn_0){
    }
];

! Find next x satisfying:
! [ player's holdall(x) & encloses('player', x) ]
[ Prop_78  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK15_First: x: x=x.IK15_Link){
        if ((IndirectlyContains(player,x))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ player's holdall(x) & 'chavailable'(x) ]
[ Prop_79  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK15_First: x: x=x.IK15_Link){
        if (((Adj_86_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ thing(x) & is('player', CarrierOf(x)) ]
[ Prop_80  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in player) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find a random x satisfying:
! [ thing(x) & 'forgotten-about'(x) & 'chviable'(x) & is('player', HolderOf(x)) ]
[ Prop_81  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_34_t1_v9(x))) && ((Adj_88_t1_v9(x))) && (player == HolderOf(x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_82  x x_ix counter;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, SupporterOf(x)) ]
[ Prop_83  const_0 x x_ix counter;
    objectloop (x in const_0) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
[ Prop_84  const_0 x x_ix counter;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is('second noun', SupporterOf(x)) ]
[ Prop_85  x x_ix counter;
    objectloop (x in second) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is('second noun', ContainerOf(x)) ]
[ Prop_86  x x_ix counter;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_87  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_61_t1_v9(x)))){
            if (~~(((Adj_57_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', ContainerOf(x)) ]
[ Prop_88  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_89  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_61_t1_v9(x)))){
            if (~~(((Adj_57_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & NOT[ is(x, 'player') NOT] & is('noun', SupporterOf(x)) ]
[ Prop_90  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            if (~~((x == player))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', ContainerOf(x)) ]
[ Prop_91  x x_ix ;
    for (x=TestContainmentRange(noun): x: x=TestContainmentRange(noun,x)){
        if ((x ofclass K2_thing) && ((Adj_61_t1_v9(x)))){
            if (~~(((Adj_57_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & 'described'(x) & NOT[ 'scenery'(x) NOT] & is('noun', SupporterOf(x)) ]
[ Prop_92  x x_ix ;
    objectloop (x in noun) if (SupporterOf(x)==parent(x)){
        if ((x ofclass K2_thing) && ((Adj_61_t1_v9(x)))){
            if (~~(((Adj_57_t1_v9(x))))){
                rtrue;
            }
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & 'visible'(x) & is('noun', (x.component_parent)) ]
[ Prop_93  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v9(x))) && (noun == (x.component_parent))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Card>=4 x IN[ pump(x) IN] : 'switched off'(x) ]
[ Prop_94  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_81_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 4){
        rtrue;
    }
    rfalse;
];

! Abstraction for set of x such that:
! [ room(x) & 'visited'(x) ]
[ Prop_95 reason x x_ix total counter selection best best_with;
    if (reason >= 0) { x = reason; reason = -1; }
    switch (reason) {
        -6: ! Find the extremal x satisfying:
            if (property_loop_sign>0) best=MIN_NEGATIVE_NUMBER;
            else best=MAX_POSITIVE_NUMBER;
            for (x=IK1_First: x: x=x.IK1_Link){
                if (((Adj_49_t1_v9(x)))){
                    if (property_loop_sign>0) {
                        if (x.property_to_be_totalled >= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    } else {
                        if (x.property_to_be_totalled <= best) {
                            best = x.property_to_be_totalled;
                            best_with = x;
                        }
                    }
                }
                .NextOuterLoop_3;
            }
            return best_with;
        -5: ! Find a total property value over all x satisfying:
            for (x=IK1_First: x: x=x.IK1_Link){
                if (((Adj_49_t1_v9(x)))){
                    total = total + x.property_to_be_totalled;
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
        -4: ! Find a random x satisfying:
            selection = -1;
            while (true) {
                counter = 0;
                for (x=IK1_First: x: x=x.IK1_Link){
                    if (((Adj_49_t1_v9(x)))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                    .NextOuterLoop_7;
                }
                if ((counter == 0) || (selection >= 0)) return nothing;
                selection = random(counter);
            }
        -3: ! How many x satisfy this?
            for (x=IK1_First: x: x=x.IK1_Link){
                if (((Adj_49_t1_v9(x)))){
                    counter++;
                    jump NextOuterLoop_5;
                }
                .NextOuterLoop_5;
            }
            return counter;
        -2: ! Find next x satisfying:
            if (x_ix > 0) {
                x_ix--;
                jump NextOuterLoop_4;
            }
            if (x) jump NextOuterLoop_4;
            for (x=IK1_First: x: x=x.IK1_Link){
                if (((Adj_49_t1_v9(x)))){
                    return x;
                }
                .NextOuterLoop_4;
            }
            return nothing;
        -1: ! True or false?
            if ((x ofclass K1_room) && ((Adj_49_t1_v9(x)))){
                rtrue;
            }
            rfalse;
    }
];

! How many x satisfy this?
! [ direction(x) & 'viable'(x) ]
[ Prop_96  x x_ix counter;
    for (x=IK3_First: x: x=x.IK3_Link){
        if (((Adj_31_t1_v9(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ thing(x) & is(const_0, ContainerOf(x)) ]
[ Prop_97  const_0 x x_ix counter;
    for (x=TestContainmentRange(const_0): x: x=TestContainmentRange(const_0,x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : fluid container(x) & NOT[ 'empty'(x) NOT] ]
[ Prop_98  x x_ix ;
    for (x=IK25_First: x: x=x.IK25_Link){
        if (~~(((Adj_16_t1_v9(x))))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ rideable animal(x) IN] : is(x, CarrierOf('actor')) ]
[ Prop_99  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=nothing: false: ){
        qcn_0++;
        if ((x == CarrierOf(actor))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ rideable vehicle(x) IN] : is(x, SupporterOf('actor')) ]
[ Prop_100  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=nothing: false: ){
        qcn_0++;
        if ((x == SupporterOf(actor))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & 'locked'(x) ]
[ Prop_101  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK2_First: x: x=x.IK2_Link){
        if (((Adj_75_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : small rock(x) & is('rocky beach', ContainerOf(x)) ]
[ Prop_102  x x_ix ;
    for (x=TestContainmentRange(I470_rocky_beach): x: x=TestContainmentRange(I470_rocky_beach,x)){
        if ((x ofclass K24_small_rock)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ thing(x) & Exists y : person(y) & encloses(y, x) ]
[ Prop_103  x x_ix y y_ix ;
    if ((x ofclass K2_thing)){
        for (y=IK8_First: y: y=y.IK8_Link){
            if ((IndirectlyContains(y,x))){
                rtrue;
            }
        }
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & is('second noun', ContainerOf(x)) ]
[ Prop_104  x x_ix ;
    for (x=TestContainmentRange(second): x: x=TestContainmentRange(second,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & can-see('player', x) ]
[ Prop_105  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if ((TestVisibility(player,x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Card>=1 x IN[ person(x) & NOT[ is(x, 'player') NOT] IN] : 'visible'(x) ]
[ Prop_106  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (~~((x == player))){
            qcn_0++;
            if (((Adj_3_t1_v9(x)))){
                qcy_0++;
            }
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) ]
[ Prop_107  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v9(x)))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ DoesNotExist x IN[ lever(x) IN] : 'visible'(x) ]
[ Prop_108  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK27_First: x: x=x.IK27_Link){
        qcn_0++;
        if (((Adj_3_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find next x satisfying:
! [ lever(x) & 'visible'(x) ]
[ Prop_109  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK27_First: x: x=x.IK27_Link){
        if (((Adj_3_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ DoesNotExist x IN[ switch(x) IN] : 'visible'(x) ]
[ Prop_110  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK29_First: x: x=x.IK29_Link){
        qcn_0++;
        if (((Adj_3_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find next x satisfying:
! [ switch(x) & 'visible'(x) ]
[ Prop_111  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK29_First: x: x=x.IK29_Link){
        if (((Adj_3_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ DoesNotExist x IN[ gizmo(x) IN] : 'visible'(x) ]
[ Prop_112  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK28_First: x: x=x.IK28_Link){
        qcn_0++;
        if (((Adj_3_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find next x satisfying:
! [ gizmo(x) & 'visible'(x) ]
[ Prop_113  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK28_First: x: x=x.IK28_Link){
        if (((Adj_3_t1_v9(x)))){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! True or false?
! [ Exists x : person(x) & NOT[ is(x, 'player') NOT] & 'visible'(x) ]
[ Prop_114  x x_ix ;
    for (x=IK8_First: x: x=x.IK8_Link){
        if (~~((x == player))){
            if (((Adj_3_t1_v9(x)))){
                rtrue;
            }
        }
    }
    rfalse;
];

! Find a random x satisfying:
! [ person(x) & 'visible'(x) & NOT[ is(x, 'player') NOT] ]
[ Prop_115  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK8_First: x: x=x.IK8_Link){
            if (((Adj_3_t1_v9(x)))){
                if (~~((x == player))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! How many x satisfy this?
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_116  x x_ix counter;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : player's holdall(x) & called='current working sack'(x) & is('actor', HolderOf(x)) ]
[ Prop_117  x x_ix ;
    for (x=IK15_First: x: x=x.IK15_Link){
        if ((actor == HolderOf(x))){
            deferred_calling_list-->0 = x;
            rtrue;
        }
    }
    rfalse;
];

! Find next x satisfying:
! [ thing(x) & is('actor', CarrierOf(x)) ]
[ Prop_118  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    objectloop (x in actor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            return x;
        }
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find a random x satisfying:
! [ thing(x) & is('cavity', ContainerOf(x)) ]
[ Prop_119  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I701_cavity): x: x=TestContainmentRange(I701_cavity,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! How many x satisfy this?
! [ room(x) & adjacent-to(const_0, x) ]
[ Prop_120  const_0 x x_ix counter;
    for (x=IK1_First: x: x=x.IK1_Link){
        if ((TestAdjacency(const_0,x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ room(x) & adjacent-to('location', x) ]
[ Prop_121  x x_ix counter;
    for (x=IK1_First: x: x=x.IK1_Link){
        if ((TestAdjacency(real_location,x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ room(x) & adjacent-to(const_0, x) ]
[ Prop_122  const_0 x x_ix counter;
    for (x=IK1_First: x: x=x.IK1_Link){
        if ((TestAdjacency(const_0,x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! How many x satisfy this?
! [ room(x) & adjacent-to('location', x) ]
[ Prop_123  x x_ix counter;
    for (x=IK1_First: x: x=x.IK1_Link){
        if ((TestAdjacency(real_location,x))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! True or false?
! [ Exists x : thing(x) & is(const_0, (x.p67_unbolting)) ]
[ Prop_124  const_0 x x_ix ;
    for (x=IK2_First: x: x=x.IK2_Link){
        if ((const_0 == (x.p67_unbolting))){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ small rock(x) IN] : is('player', HolderOf(x)) ]
[ Prop_125  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK24_First: x: x=x.IK24_Link){
        qcn_0++;
        if ((player == HolderOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! Find next x satisfying:
! [ direction(x) ]
[ Prop_126  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find next x satisfying:
! [ direction(x) ]
[ Prop_127  x x_ix ;
    if (x_ix > 0) {
        x_ix--;
        jump NextOuterLoop_4;
    }
    if (x) jump NextOuterLoop_4;
    for (x=IK3_First: x: x=x.IK3_Link){
        return x;
        .NextOuterLoop_4;
    }
    return nothing;
];

! Find a random x satisfying:
! [ autumnal color(x) & NOT[ is(x, const_0) NOT] ]
[ Prop_128  const_0 x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=1: x<=5: x++){
            if (~~((x == const_0))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Exists x : thing(x) & is('conductor', CarrierOf(x)) ]
[ Prop_129  x x_ix ;
    objectloop (x in I711_conductor) if (CarrierOf(x)==parent(x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_130  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_131  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & 'visible'(x) & NOT[ NOT[ is('player', ContainerOf('pond')) NOT] & is(x, 'pond') NOT] ]
[ Prop_132  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v9(x)))){
                if ((player == ContainerOf(I463_pond))){
                    if (~~((x == I463_pond))){
                        counter++;
                        if (counter == selection) return x;
                        jump NextOuterLoop_7;
                    }
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_133  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=3 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_134  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 3){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_135  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ DoesNotExist x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_136  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 == 0){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_137  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_138  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & 'visible'(x) & NOT[ is(x, 'sunlight') NOT] ]
[ Prop_139  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if (((Adj_3_t1_v9(x)))){
                if (~~((x == I497_sunlight))){
                    counter++;
                    if (counter == selection) return x;
                    jump NextOuterLoop_7;
                }
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Card>=3 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_140  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 3){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=3 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_141  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 3){
        rtrue;
    }
    rfalse;
];

! Find a random x satisfying:
! [ thing(x) & is('hill', ContainerOf(x)) ]
[ Prop_142  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=TestContainmentRange(I441_hill): x: x=TestContainmentRange(I441_hill,x)){
            if ((x ofclass K2_thing)){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_143  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_144  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=2 x IN[ pump(x) IN] : 'switched on'(x) ]
[ Prop_145  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK23_First: x: x=x.IK23_Link){
        qcn_0++;
        if (((Adj_80_t1_v9(x)))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 2){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Card>=1 x IN[ pinecone(x) IN] : is('pine forest', ContainerOf(x)) ]
[ Prop_146  x x_ix qcy_0 qcn_0 ;
    qcy_0 = 0;
    qcn_0 = 0;
    for (x=IK30_First: x: x=x.IK30_Link){
        qcn_0++;
        if ((I511_pine_forest == ContainerOf(x))){
            qcy_0++;
        }
    }
    if (qcy_0 >= 1){
        rtrue;
    }
    rfalse;
];

! True or false?
! [ Exists x : thing(x) & is('crack', ContainerOf(x)) ]
[ Prop_147  x x_ix ;
    for (x=TestContainmentRange(I639_deep_crack): x: x=TestContainmentRange(I639_deep_crack,x)){
        if ((x ofclass K2_thing)){
            rtrue;
        }
    }
    rfalse;
];

! How many x satisfy this?
! [ pump(x) & 'switched on'(x) ]
[ Prop_148  x x_ix counter;
    for (x=IK23_First: x: x=x.IK23_Link){
        if (((Adj_80_t1_v9(x)))){
            counter++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];

! Find a random x satisfying:
! [ thing(x) & can-see('player', x) ]
[ Prop_149  x x_ix counter selection;
    selection = -1;
    while (true) {
        counter = 0;
        for (x=IK2_First: x: x=x.IK2_Link){
            if ((TestVisibility(player,x))){
                counter++;
                if (counter == selection) return x;
                jump NextOuterLoop_7;
            }
            .NextOuterLoop_7;
        }
        if ((counter == 0) || (selection >= 0)) return nothing;
        selection = random(counter);
    }
];




[ Resolver_0 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction)))) { return  RoomOrDoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_1 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door)))) { return  OtherSideOfDoor(t_0,t_1) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_2 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_987_r10 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_3 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_774_r11 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_4 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_5 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_975_r12 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_6 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_945_r13 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_7 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_8 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction)))) { return  MapConnection(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_9 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return  RoomOrDoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_10 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return  DoorFrom(t_1,t_0) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_11 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) {  Decapitalize(t_0);  rtrue; }
if ((((t_0 ofclass K1_room)))) {  Decapitalize(t_0);  rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_12 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door))) && (((t_1 ofclass K1_room)))) { return  OtherSideOfDoor(t_0,t_1) ; }
ArgumentTypeFailed(filename, line);
  rfalse; ];
[ Resolver_13 t_0 filename line;
if ((((t_0 ofclass K2_thing)))) { (PHR_979_r81 (t_0)); rtrue; }
if ((((t_0 ofclass K2_thing)))) { (PHR_975_r12 (t_0)); rtrue; }
ArgumentTypeFailed(filename, line);
  rfalse; ];



Array ConstantListPointers --> 
 0 0;

Constant SC_1801 = "          ...          (";
Constant SC_1092 = "    ";
Constant SC_387 = " ";
Constant SC_1590 = " ~It used to be that the city was in the middle of the pond, above water, and the pond stretched out to here. And the island with the city was full. So we couldn't live here unless somebody, well, made room!~";
Constant SC_1597 = " ~W";
Constant SC_1068 = " (";
Constant SC_910 = " (containing ";
Constant SC_916 = " (currently flipped ";
Constant SC_913 = " (right side up)";
Constant SC_914 = " (trapped in mud)";
Constant SC_912 = " (upside down)";
Constant SC_915 = " (which opens ";
Constant SC_1369 = " (you even see some of the same cartoon characters from the pamphlet)";
Constant SC_1129 = " - custom}";
Constant SC_531 = " -- and almost before you know it, a cloud of bubbles washes over you, dissolving to reveal a face, wet and grinning at you with an infectious enthusiasm.";
Constant SC_1451 = " -- it looks out of place amid the ";
Constant SC_355 = " -- then, with a horrible crunching, ";
Constant SC_1372 = " A green flag hangs from a pole stuck into the wall.";
Constant SC_1470 = " A small blue light on the detector is blinking wildly.";
Constant SC_1053 = " ABOUT SOMETHING, INVENTORY, SLEEP, WAIT X MINUTES, PUSH SOMETHING, CLIMB SOMETHING, TURN SOMETHING ON, JUMP, SCORE, UNDO and more...	";
Constant SC_1796 = " ABOUT something or TELL ";
Constant SC_1797 = " ABOUT something.";
Constant SC_241 = " Crystal City; well, is there such a thing? It's just something you read about in a children's book -- a real city couldn't cure and prevent illness in those who lived there, or keep its glass towers maintained with no one working on them. Even if there is something here, it's just an ordinary city -- nothing to justify your ever-increasing obsession. Nothing to justify coming so far from your home just to look for it.";
Constant SC_1234 = " He seems completely oblivious to you now that he's talking about trains.";
Constant SC_1420 = " Her hair is long and braided, and she's wearing some kind of flowy dress.";
Constant SC_1755 = " I can tell you about.~";
Constant SC_1468 = " The branches of the sweetgum tree stretch above you.";
Constant SC_1009 = " The crystal spire rises several feet more out of the water, and something else, too. A weird, lumpy island, rising up from the pond to the north of the spire.";
Constant SC_1319 = " There is a weedy island to the north.";
Constant SC_1530 = " Water pulses through the hoses";
Constant SC_1746 = " You can get a schedule at the visitor center if you want to know the details.~";
Constant SC_1324 = " You can see some kind of structure rising out of the pond to the north -- it looks like a small boat-house or spring-house.";
Constant SC_967 = " a few feet. The dog runs toward it, picks it up, and returns it to you.";
Constant SC_577 = " admires the secret panel.";
Constant SC_1046 = " after the hour, according to your waterproof watch.";
Constant SC_1294 = " after.";
Constant SC_638 = " all sticky and ruined.";
Constant SC_388 = " already riding ";
Constant SC_1210 = " and ";
Constant SC_285 = " and flaps up and away.";
Constant SC_562 = " and grab the bottom branch of the tree, hauling yourself up.";
Constant SC_1233 = " and is carrying ";
Constant SC_479 = " and move slowly through the still water, but nothing much changes about your location.";
Constant SC_1555 = " and moving";
Constant SC_855 = " and peer out the window";
Constant SC_484 = " and pushes you away from the staircase";
Constant SC_348 = " and rips it to pieces.";
Constant SC_321 = " and shuddering.";
Constant SC_1457 = " and spewing water";
Constant SC_1259 = " and spinning in the wind";
Constant SC_1014 = " and the conductor and the family and even the dog, floating away from their homes, going who knows where.";
Constant SC_571 = " and think about it, but something about the murky depths suggests you're better off on land.";
Constant SC_277 = " anxiously.";
Constant SC_750 = " anyway.";
Constant SC_856 = " at Freshwater Crossing.";
Constant SC_608 = " at the cylinder, but it bounces harmlessly to the ground.";
Constant SC_606 = " at the gull, but it hops out of the way, squawking.";
Constant SC_957 = " back into place.";
Constant SC_345 = " before you fall, and the water is on top of you and you can't breathe.";
Constant SC_738 = " blushes.";
Constant SC_530 = " can swim.";
Constant SC_1580 = " can't be picked up.";
Constant SC_389 = " cannot be ridden.";
Constant SC_1030 = " cannot contain any more than it already holds.";
Constant SC_1427 = " city, in fact. The Crystal City. The sketch matches the illustration you carry perfectly.";
Constant SC_370 = " clatters down the staircase into the Pump Room.";
Constant SC_1271 = " closed";
Constant SC_901 = " contains ";
Constant SC_698 = " did, but nothing happens.";
Constant SC_975 = " dismount";
Constant SC_267 = " distant";
Constant SC_955 = " does not fit ";
Constant SC_1626 = " don't finish turning on all the pumps!~";
Constant SC_1273 = " door; a water fountain";
Constant SC_1613 = " down there, under the pond. And, I mean, I've always loved the idea about it, I kind of collect pictures of it and stuff, but around here we're more encouraged to, you know, pretend it doesn't exist.~";
Constant SC_743 = " empty";
Constant SC_558 = " falls to the ground beneath the tree.";
Constant SC_1167 = " fluid ounce";
Constant SC_1165 = " fluid ounces";
Constant SC_745 = " from ";
Constant SC_411 = " from in the tree.";
Constant SC_1258 = " from the tree and twisting in the wind";
Constant SC_249 = " from the wind chimes";
Constant SC_365 = " giant metal wheel is turning slowly clockwise within the pump";
Constant SC_1211 = " gives the rope another jerk, and you pull free from the mud, which fills the hole you left behind with a sickening squelch. She unties the rope and coils it back into her bag.";
Constant SC_796 = " gives you a little half-smile, without answering.";
Constant SC_772 = " had looked... agitated? nervous?, and you can't help feeling that you're part of the cause of her distress, and that maybe you shouldn't run away from her.";
Constant SC_724 = " has a firm hold on the rope.";
Constant SC_988 = " has gone.";
Constant SC_632 = " has too narrow a mouth to accept ";
Constant SC_933 = " here";
Constant SC_1103 = " hops.";
Constant SC_1117 = " how this works!~";
Constant SC_368 = " hurries past you to the southwest, carrying a large bag. Something about her demeanor gives you a chill.";
Constant SC_787 = " ignores your question.";
Constant SC_1567 = " ignores your request.";
Constant SC_740 = " in ";
Constant SC_585 = " in it.";
Constant SC_1314 = " in the front of the building.";
Constant SC_888 = " in the security gadget's keyhole; the complicated pump emits a series of beeps, and the warning lights turn off.";
Constant SC_1523 = " in there.";
Constant SC_367 = " inside the cavity";
Constant SC_628 = " into ";
Constant SC_1021 = " into itself.";
Constant SC_611 = " into the slot, but it doesn";
Constant SC_784 = " irritably";
Constant SC_626 = " is already empty.";
Constant SC_503 = " is already in the holes.";
Constant SC_732 = " is already open.";
Constant SC_1048 = " is an interactive quagmire, interactive fiction, or text adventure game.	";
Constant SC_1280 = " is blocking you from going right up to the pond. ";
Constant SC_1213 = " is currently ";
Constant SC_900 = " is empty.";
Constant SC_748 = " is full of ";
Constant SC_625 = " is not a key.";
Constant SC_1031 = " is now empty;";
Constant SC_986 = " is right here.";
Constant SC_1410 = " is sitting at a simple metal desk, ";
Constant SC_1006 = " is starting to shudder --";
Constant SC_356 = " is torn apart, and the metal wheel continues its motion.";
Constant SC_1345 = " is visible at the edge of the water to the west";
Constant SC_1060 = " is written and programmed by Clara Raubertas, copyright 2011. Clara is a programmer and musician living in New England; she welcomes comments or bug reports on Wetlands at clara.raubertas@@64gmail.com.	";
Constant SC_989 = " isn't anywhere you can follow.";
Constant SC_799 = " just looks confused.";
Constant SC_1695 = " just reminds you about the technicians.";
Constant SC_1154 = " keeps pulling";
Constant SC_765 = " laughs";
Constant SC_1269 = " leading uphill to the south and downhill to the north.";
Constant SC_275 = " leans down over the top of the staircase and looks at you.";
Constant SC_1608 = " leaves in front of them, but a building that looks like a church is closest and clearest.";
Constant SC_1607 = " leaves of the distant trees in front of them, but a building that looks like a church is closest and clearest.";
Constant SC_1424 = " likes.";
Constant SC_1107 = " looks at you like you are crazy";
Constant SC_872 = " looks at you; a little wary, a little intrigued, you suspect.";
Constant SC_818 = " looks startled";
Constant SC_1601 = " maybe reverse it. A couple of kids from the city have even tried, now that sentiments have changed down there -- they lived their whole life underwater, without trains! -- but they didn't get very far.~";
Constant SC_972 = " mount";
Constant SC_390 = " not riding anything.";
Constant SC_778 = " notices your attempt. ";
Constant SC_1032 = " now contains ";
Constant SC_902 = " of ";
Constant SC_1622 = " of the four pumps on. And if ";
Constant SC_408 = " of the small rocks)";
Constant SC_1624 = " of them gets turned on, some of us start getting warning lights that tell us to start evacuation procedures. Which, honestly, has never happened that I can remember.~";
Constant SC_401 = " onto the drawer and then on to the grassy earth";
Constant SC_1462 = " oozing out in clumps from between cracks in their rough bark. The ground is covered in a carpet of soft ";
Constant SC_329 = " opens her bag and pulls out a rope. ~Don't worry, this happens a lot,~ she says. She ties the rope under your shoulders, knots tightly, and starts to pull.";
Constant SC_513 = " opens the door ";
Constant SC_924 = " or ";
Constant SC_1037 = " out on the ";
Constant SC_598 = " out onto the top of the tank.";
Constant SC_1296 = " past the hour). A lighted archway on this side tunnels inward to frame a door, and a water fountain";
Constant SC_1305 = " past the hour.";
Constant SC_282 = " peers at what you are doing. ~Could you please leave that thing to the technicians?~";
Constant SC_1071 = " points (out of ";
Constant SC_1069 = " points)";
Constant SC_804 = " pokes some piece of train machinery, ignoring your question.";
Constant SC_1072 = " possible)";
Constant SC_383 = " quakes.";
Constant SC_946 = " reach the bottom branch from here; you scramble up into the tree.";
Constant SC_1026 = " remains in ";
Constant SC_1634 = " reminds you again that only qualified technicians are supposed to use the pumps.";
Constant SC_1065 = " right now!";
Constant SC_1544 = " right under the only opening in the pump's smooth crystal shell. A large crystal gear is placed perpendicularly behind it, vibrating ";
Constant SC_369 = " rushes out of the Waterworks, looking agitated. She dashes past you so quickly that, moments later, you realize you have no idea where she went.";
Constant SC_659 = " says";
Constant SC_631 = " seems pointless.";
Constant SC_1019 = " seems pretty pointless.";
Constant SC_380 = " shakes and vibrates.";
Constant SC_660 = " shakes her head at you";
Constant SC_758 = " shakes his head and blocks your way. ~Sorry, friend! I'd love to let you on, but you gotta have a ticket.~";
Constant SC_871 = " smiles. ~Hello!~";
Constant SC_247 = " sound";
Constant SC_1137 = " sound, weirdly distorted by the water.";
Constant SC_1275 = " stands to one side in the archway. ";
Constant SC_1297 = " stands to one side in the archway.";
Constant SC_1447 = " starting to float a little on the watery mud,";
Constant SC_318 = " steals a glance at the page you are holding, then turns back to her notebook, blushing.";
Constant SC_1029 = " still contains ";
Constant SC_584 = " still has ";
Constant SC_536 = " stops you. ~Don't mess with my stuff!~";
Constant SC_1056 = " stuck (unless you do something obviously dumb like throw out stuff you've found). There are fatal mistakes, but it should be clear when you're about to make them and you can always UNDO if necessary. Or SAVE your game to a file to return to your current situation later.	";
Constant SC_1631 = " that there is a city under the pond. A beautiful, sparkling city.~";
Constant SC_688 = " the drawer when it's oriented like this.";
Constant SC_1322 = " the pile of brush and sticks accumulated here on the muddy shore.";
Constant SC_1588 = " them happier and healthier. And my parents noticed, their friends noticed, a buncha people got together and wanted to move here. They wanted to give the benefits to their children -- us! I mean, it's hard to think that was bad.~ He shrugs. ~But maybe it was. I'm a train engineer, not an ethics expert. I don't know.~";
Constant SC_593 = " through the holes in the ";
Constant SC_600 = " through the holes.";
Constant SC_984 = " to ";
Constant SC_1734 = " to figure it out,~ Cordelia says. ~People have a lot invested in the honorability of the thing.~";
Constant SC_999 = " to life";
Constant SC_684 = " to the ground";
Constant SC_268 = " train whistle.";
Constant SC_1256 = " tree, far above the blue curve of the pond.";
Constant SC_1266 = " trees, and small rocks and boulders dot the ground underfoot, breaking up the monotony of the damp mat of red and brown leaves.";
Constant SC_1517 = " trees, in their full autumnal glory.";
Constant SC_1151 = " tugs firmly on the rope";
Constant SC_683 = " tumble";
Constant SC_1104 = " turns and looks at you. ~Oh!~ she says, and her brown eyes widen. You think she's shaking a little bit. ~You're the one looking for the city.~";
Constant SC_867 = " unclenches her hands and returns to her desk. ~";
Constant SC_1792 = " understands commands, such as ~";
Constant SC_896 = " unlocks ";
Constant SC_885 = " up with ";
Constant SC_1212 = " walks up to the large boat, and presses it with her hand; a hitherto invisible door slides open. She turns back to you with a pained face, and then enters the boat. The door slides neatly shut behind her and is invisible again; there's no trace it was ever there.";
Constant SC_1618 = " water, just mud and stuff. So,~ she twists her mouth uncomfortably, ~they built this stuff to switch it, so we could live here. But now, with what you've done, it's being reversed again, which: I don't know how to feel about it. I don't!~ She glares defensively at you.";
Constant SC_1616 = " water. And where we are now, that was ";
Constant SC_1365 = " waterstained door set in the west side of the building; the water level comes partway up the door.";
Constant SC_1028 = " while ";
Constant SC_1023 = " with ";
Constant SC_1448 = " with an anchor ";
Constant SC_1088 = " with that.";
Constant SC_620 = " won't fit in ";
Constant SC_936 = " won't fit.";
Constant SC_414 = " would get lost and never be seen again.";
Constant SC_1024 = " would give unsavory results.";
Constant SC_928 = " you ";
Constant SC_487 = " you I'll get in trouble if you go down there.~";
Constant SC_791 = " you not to mess with the pump. I'll definitely get in trouble now if I talk to you more.~";
Constant SC_869 = " you!,~ she says.";
Constant SC_794 = " you're curious! I'm definitely curious about... well, never mind. But I'll get in trouble if anyone finds out you saw the pump, and I'll get in trouble if I talk to you any more about that.~";
Constant SC_1720 = "! A neutral party.~ She squeezes your hand -- then lets go as her face turns serious. ~But it's your choice. We don't want to force you. Why don't you come with us and see the city?~";
Constant SC_1654 = "! Of course!~";
Constant SC_883 = "!~ says Vivian, stretching forward to see what will happen";
Constant SC_1718 = "!~";
Constant SC_1247 = "~ and ~";
Constant SC_517 = "~";
Constant SC_1794 = "~, but not questions. For more instructions, type HELP.";
Constant SC_576 = "~A secret panel! Neat.~";
Constant SC_879 = "~Aha!~ Cordelia says, looking intently at the wheel";
Constant SC_221 = "~And, the water is changing things. The city's -- energies aren't as strong. Things fall apart,~ Douglas says. He glances behind him at the turrets.";
Constant SC_1727 = "~At the time, we said sign me up!~ Cordelia says. ~Not everyone was on board, of course, but enough people were -- especially since the Pondsiders could give us the resources to make these.~ She points at her mask.";
Constant SC_1585 = "~At this point it's not a secret anymore. You've turned on the second to last pump. Things're getting serious!~ He looks down and fiddles with his suspenders. ~I know maybe my parents weren't right about this; I know maybe we never had a right to push those people underwater like we did. Maybe. I don't know.~";
Constant SC_1735 = "~But if it's a neutral party who does it?~ Vivian looks at you hopefully, eyes sparkling.";
Constant SC_1724 = "~Cord and I had just started dating,~ Douglas says, touching her hand, ~and they'd just invented those things,~ he points at your mask, ~so we were under the pond every weekend, having a great time.~";
Constant SC_1789 = "~Cute, right?~";
Constant SC_1717 = "~Don't worry, I understand you can't really talk with that thing on. It's an early prototype, not as advanced as the ones we have. But I want to talk to ";
Constant SC_604 = "~Fantastic! Thanks!~ He pockets it.";
Constant SC_1782 = "~Great view!~";
Constant SC_1660 = "~He's a nice guy! Big nerd, though. Once you get him talking about trains, it's hard to get his attention with anything else.~";
Constant SC_1678 = "~He's always kind of joking around like that, throwing stuff and whatever. Usually it's funny!~";
Constant SC_222 = "~Hello yourself!~";
Constant SC_532 = "~Hi! I'm Vivian!~ she burbles, and grabs your hand.";
Constant SC_1772 = "~Hmm, I'm not sure... maybe you're thinking of the Community Center?~";
Constant SC_573 = "~Huh~, she says. ~Looks like a secret panel, but I can't get it open with my fingers.~";
Constant SC_1698 = "~Huh, weird. I heard some of the pump technicians have built secret panels in their desk drawers -- you think there's one in there?~";
Constant SC_789 = "~I ";
Constant SC_1659 = "~I already told you I'm Adriana!~";
Constant SC_1688 = "~I can't think of any churches around here. Maybe you're thinking of the Community Center?~";
Constant SC_1603 = "~I do know I'm going to miss this train.~ He touches the side of the train car wistfully.";
Constant SC_1701 = "~I don't know, tell me about yourself!~ she says, laughing.";
Constant SC_1666 = "~I know!~ She giggles. ~It's easy to get stuck in the mud over by the marsh.~";
Constant SC_1715 = "~I think Dad was going to try to bring one over tomorrow.~";
Constant SC_801 = "~I think we already talked about that.~";
Constant SC_782 = "~I thought I already explained that, ~";
Constant SC_764 = "~I tried that too! It doesn't work,~ says ";
Constant SC_1764 = "~I'm Eric! Pleased to meet ya!~ He shakes your hand vigorously.";
Constant SC_783 = "~I'm telling you a bunch of stuff I'm not supposed to, so the least you can do is remember it,~";
Constant SC_1682 = "~I'm the secretary! Well, it's really more like  a receptionist thing, I guess. They just want someone here to watch the place.~";
Constant SC_1629 = "~I've heard...~ Is she blushing? ~I've ";
Constant SC_1548 = "~If you were staying longer, we'd fit you for one of the newer masks where you can talk, but unfortunately the old one you're wearing will have to do,~ she says";
Constant SC_1725 = "~It was great!~ Cordelia smiles. ~We were under here every chance we got, and so were our friends.~";
Constant SC_1726 = "~It was kind of a fad,~ Douglas says. ~But it happened that that was the time that the Pondsiders, well, the people who live there now, came to the island -- we were an island at the time -- and proposed this system, where the city would move underwater, and the pond would get smaller, and they'd be able to live in the area.~";
Constant SC_1722 = "~It's an honor to meet you,~ Douglas says politely, and Cordelia gives you a wet hug.";
Constant SC_1705 = "~It's easy to get lost in there,~ she says, pushing her hair out of her face.";
Constant SC_589 = "~It's good for another week! You hang on to that.~";
Constant SC_1709 = "~It's just for show, really. A demonstration of the clean water we produce.~";
Constant SC_1760 = "~It's just got tools in it, nothing fancy.~";
Constant SC_1645 = "~It's just up the hill.~";
Constant SC_1650 = "~It's part of the whole...~ She catches herself. ~Well, the whole system, of course!~";
Constant SC_1748 = "~It's right there, up the stairs!~";
Constant SC_580 = "~It's the city!~ she says excitedly, and then smothers her excitement, looking down as she hands the page back to you.";
Constant SC_779 = "~Just come back up here and we can talk.~";
Constant SC_781 = "~Just stop what you're doing and come back upstairs.~ She tries to look authoritative, but it comes across more... petulant.";
Constant SC_1770 = "~Kinda old, I know. But the mechanics of the train are what's important!~";
Constant SC_803 = "~Let's not get into that now,~ he says.";
Constant SC_780 = "~Look, all I need right now is for you to stop messing with the pump.~";
Constant SC_788 = "~Look, you can get into a lot of trouble here if you're too curious.~";
Constant SC_1611 = "~Look, you clearly get it!~ She laughs nervously. ~Of course ";
Constant SC_1787 = "~Looks like it's just you and me today!~";
Constant SC_590 = "~Looks like you're in order!~ says the conductor, and he lets you pass.";
Constant SC_810 = "~Mmm,~ says the conductor";
Constant SC_1658 = "~My name's Adriana. Nice to meet you!~";
Constant SC_1686 = "~Naah, we don't keep money here. It's noncommercial.~";
Constant SC_806 = "~Now this one we're riding is the PX1105; she has a rolling resistance of about 0.0005, which means she has to be pretty heavy to get enough traction. Almost three tons! Steam-powered, of course; there are those who say it's obsolete, but give me a taper boiler like this one any day.~";
Constant SC_394 = "~OK, I understand. You don't want to come to the city,~ she says, a little sadly";
Constant SC_1676 = "~OK, it was really nice of her to get me this job! She's really organized like that -- always finding stuff for people to do.~";
Constant SC_1674 = "~OK, it's actually my mom! She's still going to be mad if I tell you stuff, though.~";
Constant SC_298 = "~OK, let's go!~ She takes your hand, and pulls you downward with surprising force. Once you reach the bottom, you realize that though you're still underwater, you're no longer being pulled buoyantly upward, and your feet touch solid ground as Vivian leads you expertly through the shining streets.";
Constant SC_371 = "~OK, look, if my boss finds out I was letting a stranger mess around with this stuff, I would be in big trouble. So you gotta go,~ says ";
Constant SC_1728 = "~OK, so how come we don't want to live underwater any more, you might be wondering?~ says Douglas.";
Constant SC_880 = "~Of course!~ Doug snaps his fingers";
Constant SC_328 = "~Oh gosh, you're trapped in the mud, aren't you?~ ";
Constant SC_609 = "~Oh no, you can keep that,~ she says.";
Constant SC_1780 = "~Oh no, you don't pay me for the ticket; I don't have any change. You should pick it up at the visitor center!~";
Constant SC_353 = "~Oh!~ Vivian says. Doug and Cordelia grab each other's hands, looking forward intensely.";
Constant SC_881 = "~Oh, ";
Constant SC_588 = "~Oh, I have it memorized!~";
Constant SC_1656 = "~Oh, it's totally safe to drink. It's safe to drink the pond water too, but it just tastes better after it's been filtered.~";
Constant SC_1707 = "~Oh, jeez, you're probably wondering how the key got in that cyliner!~ She laughs. ~My dad and I were kidding around, throwing it at each other, and he ended up tossing it in there by mistake. So now we have to wait until he has a chance to bring a ladder or something over in order to get it out.~";
Constant SC_349 = "~Oh,~ Doug says, disappointed.";
Constant SC_1696 = "~On the beach? Weird. I heard some of the pump technicians put secret panels in their desk drawers -- maybe this has one!~";
Constant SC_357 = "~Ooh,~ says Vivian, wrinkling her nose";
Constant SC_1594 = "~People from Pondside and people from the city were friendly. We would visit each other.~ He looks out the window for a minute. ~When I was a kid I had a buddy from down there. We'd meet up at the beach and go fishing.~ He grins. ~But since then -- it's a new generation of people, and everyone's just been getting madder and madder. Resentment. They've started saying that they were tricked, that it was never fair, that they never wanted it. Even though they said that they did. So for the past several years, everyone on both sides has just not been talking to each other at all! Which, I mean, I'm not sure who's right or wrong here but I know ";
Constant SC_1738 = "~People say there's a city under... well, people say a lot of things, don't they!~";
Constant SC_1776 = "~Running the train, of course! And I love it.~ He grins.";
Constant SC_1621 = "~So right now we're at ";
Constant SC_1719 = "~So that's why we need ";
Constant SC_1731 = "~So we can't figure this thing out!~ Vivian smacks the pump, and it shudders.";
Constant SC_220 = "~So, are you going to help us get back above water?~ Vivian asks. ~Up where there is air, and birds, and dogs?~ She grins.";
Constant SC_797 = "~Sorry, can't help you.~";
Constant SC_809 = "~Sorry, trains are really more my bag,~ he replies";
Constant SC_1692 = "~That should be locked -- only the technicians have the code to go in there. For maintenance.~";
Constant SC_709 = "~That wasn't very nice!~";
Constant SC_216 = "~That's my name, don't wear it out!~ She smiles.";
Constant SC_786 = "~That's not important right now,~ she says.";
Constant SC_1778 = "~That's... I'm not supposed to give too much away.~";
Constant SC_1690 = "~The Community Center is across the pond.~";
Constant SC_1774 = "~The Community Center's across the pond, but the train doesn't go there.~";
Constant SC_1627 = "~The Crystal City!~ A broad grin flashes across her face, but she quickly suppresses it. ~I've, uh, heard of it. Stories.~";
Constant SC_1619 = "~The boat is a fail-safe. For if, well, exactly what you're doing now happens. The pumps get turned on, we get in the boat, et cetera et cetera and so forth.~ She waves one hand vaguely";
Constant SC_658 = "~The key's not coming out of there,~ ";
Constant SC_1754 = "~The pump system is not really my department -- sorry, friend! Now trains, ";
Constant SC_1680 = "~The stairs are kind of a deathtrap. But mostly just the technicians are supposed to go down there anyway.~";
Constant SC_1762 = "~The stuff in the panel is property of the train company!~";
Constant SC_1768 = "~The train's gotta have tools!~";
Constant SC_798 = "~The what?~";
Constant SC_1730 = "~There are a lot of things from above that we miss, or that the people who are too young to have ever lived there really wonder about.~ says Cordelia.";
Constant SC_1752 = "~There ought to be a schedule at the visitor center.~";
Constant SC_1750 = "~There ought to be tickets at the visitor center up the hill.~";
Constant SC_1664 = "~There's some beach area on the other side of the fence. It's pretty much more mud than, like, nice seaside beach, though.~";
Constant SC_1721 = "~These are my parents, Cordelia and Douglas!~ Vivian says, pressing your hands into theirs.";
Constant SC_1647 = "~They're experts. That's the point.~";
Constant SC_1144 = "~This locomotive is a 2-6-2, you know. Originally designed to work with a tender, but we just refill the boiler every run since we have plenty of water around here! And we got a mechanical stoker, so I can take a break from that to come out here and talk the ears off of the passengers.~";
Constant SC_1142 = "~This track here is narrow gauge; it's just Pondside local, so we don't join up with the national system or anything. Oh, and check out this rolling stock!~ He kicks the floor of the train with a pleased smile. ~Decades old and still solid as a rock. All steel!~";
Constant SC_805 = "~Trains! Now there's something I know about!~ The conductor smiles, and gets a glazed look in his eye; in fact, now that he's on his favorite subject, he doesn't seem to be paying attention to anything you're doing.";
Constant SC_1729 = "~Trees and plants! Roads! Dirt!~ Vivian says, grabbing your hand again and holding tight.";
Constant SC_214 = "~Ugh, it's a nightmare! We have these issues all the time if anything at all malfunctions in the pump system. So we're pretty used to pulling folks out!~";
Constant SC_1711 = "~Ugh, those things are annoying!~";
Constant SC_1670 = "~Uh.~ She looks at her notebook. ~I'm not supposed to talk about it.~";
Constant SC_276 = "~Um, could you...?~ says ";
Constant SC_1643 = "~Usually you can get them in the visitor center.~";
Constant SC_1723 = "~Vivian has never lived above water,~ Cordelia explains. ~We never really thought about that when we moved down here -- what effect it would have on the children.~";
Constant SC_392 = "~Wait!~ says ";
Constant SC_1592 = "~We -- they -- my parents and their friends -- had meetings with the city-people. Meeting, discussions, voting! And they agreed -- we'd set up the pump system that pushed them underwater, and we'd help them develop the technology that they use to live and breathe there.~";
Constant SC_218 = "~We all pretty much agree that the living underwater thing was a mistake. And when we're sharing the vibes and energy of the place with a whole other community, it's really just not as good. But none of us wants to be responsible for taking action -- especially since the Pondside people might consider that an act of aggression. And we're always a little nervous about this bad karma stuff, since the city's good vibes keep us so healthy!~ She grins at you, flashing white teeth, and you can't help grinning back.";
Constant SC_1672 = "~We call him Ebba. He just sort of, runs around the community, you know? He's super friendly.~";
Constant SC_219 = "~We don't want to pressure you into it. If you don't want to do it, all you have to do is swim back up and leave, and everything here will go back to normal.~";
Constant SC_1694 = "~We have some technicians that check up on things -- technical experts, you know?~";
Constant SC_217 = "~We hear you've been trying to find the city. Well, I can take you there -- and I assure you it is as awesome as you've heard! We want your help to bring it above water.~";
Constant SC_1625 = "~We start boarding the boat a few at a time, in shifts. They don't even alert the later shifts until more pumps are on. I'm one of the ones who's supposed to get on first, set things up and whatnot, and then some of my friends may not even notice what's happening if...~ Another hidden smile. ~Well, if ";
Constant SC_1786 = "~We're never that busy, but today seems like a particularly slow day!~ He laughs.";
Constant SC_1635 = "~We, uh, process the water. From the pond.~ She waves her hands abstractly.";
Constant SC_1740 = "~Well, I think the pumps... process the pond water, or something. Not something I know too much about... unlike this baby!~ He hits the side of the train car affectionately.";
Constant SC_1713 = "~Well, my mom's the manager here, and my dad does building maintenance over at the community center.~";
Constant SC_1732 = "~Well, no one here really wants to ";
Constant SC_1639 = "~Well, that's just in...~ She stops, and her face changes. Embarrassment? ~Just in case.~";
Constant SC_1641 = "~Well, the train can take you to the other side of the pond, if that's what you're looking for. And you should be able to pick up a schedule in the visitor center.~";
Constant SC_1742 = "~Well, we have a boat in case we need to --~ He stops ~I don't know too much about boats, that is. I'm strictly a train guy here.~";
Constant SC_1209 = "~Well, we're here. I gotta -- gotta, er, prepare the train for storage, and go get on the boat.~ He shakes your hand gravely. ~It was nice to meet you, however this turns out! I hope I'll be back to this train someday, but even if not, well, there's other trains in the sea! Or, well, in the pond!~ He flashes you a final, wistful smile, and is gone.";
Constant SC_1784 = "~Well, we've just met, so there's not much to say!~";
Constant SC_1614 = "~When our parents and grandparents came here, the city was ";
Constant SC_1766 = "~Who, the secretary over at the Waterworks? Yeah, we've met. Nice gal. Kinda flaky, though.~";
Constant SC_1703 = "~Yeah, they're everywhere! I think they're pretty.~";
Constant SC_1751 = "~You already have a ticket!~";
Constant SC_1684 = "~You can get a newspaper if you put a coin in the vending machine.~";
Constant SC_1637 = "~You can probably tell it's pretty much the center of life around here!~";
Constant SC_568 = "~You're back!~ Vivian grins happily";
Constant SC_1757 = "~Yup, I sure am!~";
Constant SC_223 = "~Yup, that's me!~";
Constant SC_1595 = "'s not great.~";
Constant SC_1422 = "'s notebook.";
Constant SC_415 = "(first closing ";
Constant SC_391 = "(first getting out of the rowboat)";
Constant SC_412 = "(first opening ";
Constant SC_1125 = "(first taking ";
Constant SC_420 = "(first taking the ticket)";
Constant SC_419 = "(first unlocking ";
Constant SC_990 = "(heading ";
Constant SC_405 = "(picking up ";
Constant SC_508 = "(that is, ";
Constant SC_977 = "(with ";
Constant SC_413 = ")";
Constant SC_291 = ", ";
Constant SC_1051 = ", ASK ";
Constant SC_834 = ", and ";
Constant SC_1367 = ", and a green flag hangs from a pole stuck into the wall";
Constant SC_1033 = ", and is now full";
Constant SC_351 = ", and stops altogether after a minute.";
Constant SC_516 = ", and then returns to her desk.";
Constant SC_909 = ", and waves you aboard.";
Constant SC_1434 = ", and, indeed, seems to have a copy of that publication inside it";
Constant SC_614 = ", but doesn't seem interested";
Constant SC_303 = ", but not on yet";
Constant SC_815 = ", but nothing happens.";
Constant SC_1556 = ", but something is keeping it from spinning freely counterclockwise.";
Constant SC_995 = ", but still doesn't seem to be fully on";
Constant SC_941 = ", but then stop. ";
Constant SC_734 = ", but there is no reply.";
Constant SC_624 = ", but you just succeed in making a mess.";
Constant SC_474 = ", but you soon find yourself sinking into the mud, and retreat.";
Constant SC_1231 = ", but you think you'll be able to get it open";
Constant SC_1463 = ", dotted with pinecones";
Constant SC_731 = ", even from ";
Constant SC_991 = ", following ";
Constant SC_320 = ", humming,";
Constant SC_785 = ", jerking hard on the rope";
Constant SC_742 = ", leaving ";
Constant SC_398 = ", nearly falling but catching on to the railing before you hurt yourself";
Constant SC_1534 = ", or something, at least, moving around in the streets of the city.";
Constant SC_488 = ", reminding you that she can't let you mess with the pump.";
Constant SC_965 = ", revealing ";
Constant SC_1274 = ", spewing water,";
Constant SC_1350 = ", that appears to have washed up here and is now half-buried in the shore";
Constant SC_1620 = ", the other holding tight to the rope";
Constant SC_445 = ", the unstable ground gives way beneath you, and you're encircled in mud to the waist, trapped and unable to move!";
Constant SC_444 = ", the unstable ground gives way to sinking mud beneath you, and you're encircled in the marsh to the waist, trapped and unable to move!";
Constant SC_617 = ", then drops it back in your hand";
Constant SC_1080 = ", to no effect.";
Constant SC_857 = ", where you see a misty clearing.";
Constant SC_366 = ", with ";
Constant SC_1279 = ", with a small structure rising from the water to the northwest, although ";
Constant SC_1127 = ", you can do nothing.";
Constant SC_923 = ",";
Constant SC_579 = ". ";
Constant SC_907 = ". ~Hello, again! Welcome aboard!~";
Constant SC_485 = ". ~I ";
Constant SC_603 = ". ~Thanks!~";
Constant SC_908 = ". ~Welcome back!~";
Constant SC_393 = ". ~You're not allowed down there.~";
Constant SC_1414 = ". A nameplate on the desk reads ~Secretary of Water, Pondside Waterworks~.";
Constant SC_1454 = ". In the distance, beyond the flat, marshy area that surrounds you on almost all sides, you can see the edges of a forest.";
Constant SC_1303 = ". It probably connects the pond with the building.";
Constant SC_1435 = ". It's made of dented blue metal and has a slot in the side where you can put in a coin to get a paper. ";
Constant SC_1307 = ". On the other side of the pond you can vaguely make out a row of buildings, all seeming to blend together.";
Constant SC_1547 = ". Several switches are also visible emerging from the pump's shiny exterior.";
Constant SC_372 = ". She grabs your wrist -- with surprising strength, considering her youth and size -- dragging you back up the twisty stairs and escorting you outside.";
Constant SC_496 = ". The crossing and the train are inaccessible; ";
Constant SC_362 = ". The crystal gear struggles to move forward under its own power, then slides backwards a few notches, blocked by the spike.";
Constant SC_1351 = ". The drawer is about a foot deep; it is made of unfinished pine, smoothed to driftwood over its long sojourn in the water, and ";
Constant SC_1240 = ". The hill stretches out, covered in a carpet of brown and yellow leaves. A lone sweetgum tree stands atop the hill, and just under the tree, a bench faces northwest out over the pond.";
Constant SC_1364 = ". There is a";
Constant SC_431 = ". This whole idea was probably silly, anyway. It's just a story -- there's no city.";
Constant SC_1430 = ". To the east are dense, gnarled pine trees.";
Constant SC_250 = ".";
Constant SC_1000 = "... for a moment you think you've gotten it working, but then you see that one of the hoses on the pump has a small hole in it, and water is pouring out of the hole instead of traversing the pump";
Constant SC_848 = "...";
Constant SC_1583 = "/";
Constant SC_1170 = "/unicode 33/";
Constant SC_1169 = "/unicode 46/";
Constant SC_1171 = "/unicode 63/";
Constant SC_1172 = "/unicode 91/";
Constant SC_1173 = "/unicode 93/";
Constant SC_1506 = "1. An underground pump, in the woods on the far side of the pond. (Near the drawing of this pump, you can see the numbers ~30359~ penciled in.)";
Constant SC_1507 = "2. The complicated pump housed inside the Waterworks.";
Constant SC_1508 = "3. A large pump connected to several tanks, on the edge of the woods on the far side of the pond.";
Constant SC_1509 = "4. The largest pump, deep ";
Constant SC_386 = ": ";
Constant SC_934 = ":";
Constant SC_682 = "; ";
Constant SC_1327 = "; a particularly wide stick is threaded through them";
Constant SC_430 = "; as you go, you crumple the illustration into a ball and toss it aside";
Constant SC_1338 = "; sunlight ";
Constant SC_1487 = "; tiny twinkling lights twine up and around the tree and into its branches. ";
Constant SC_1403 = "; to the northeast is the smaller clearing from which you came; and in every other direction, the dense woods envelop you.";
Constant SC_925 = "> ";
Constant SC_166 = ">";
Constant SC_922 = "?";
Constant SC_1075 = "A black squirrel skitters by you";
Constant SC_1276 = "A blinking light above the door to the building catches your eye";
Constant SC_1476 = "A bolt that looks ";
Constant SC_1329 = "A brass metal pipe sticks up out of the top of the tank; in addition to having a hole in the regular vertical direction, it has a pair of diametrically opposed horizontal holes as well. ";
Constant SC_1295 = "A broad brick building, with a pointed tower on the top featuring a large, unnumbered, glowing clock (the time is ";
Constant SC_44 = "A bunch of small, flat, disclike rocks, worn smooth by the water.";
Constant SC_1552 = "A cavity in the giant metal wheel is visible in the opening";
Constant SC_1076 = "A chipmunk chatters at you and then zips away";
Constant SC_60 = "A collection of different-sized buildings on the far side of the pond, blurry and indistinct.";
Constant SC_1281 = "A crystal spire emerges from the water in the center of the pond, sparkling brilliantly in the sunlight. ";
Constant SC_1308 = "A crystal spire emerges from the water in the center of the pond, sparkling brilliantly in the sunlight.";
Constant SC_1385 = "A crystal spire, rising out of the center of the pond";
Constant SC_27 = "A curved, covered archway in brick and concrete -- relatively recent construction, you suspect -- and framing the water fountain and the door to the building.";
Constant SC_129 = "A damp fog that seems to keep appearing and disappearing around you.";
Constant SC_338 = "A damp stain starts to spread over the floor.";
Constant SC_136 = "A damp, muddy stain on the floor, growing rapidly as the water level rises.";
Constant SC_62 = "A deep emerald green, moist and soft.";
Constant SC_665 = "A deep musk of forest.";
Constant SC_15 = "A dense grove of aromatic trees.";
Constant SC_1461 = "A dense grove of twisty ";
Constant SC_330 = "A dense patch of mist passes through you";
Constant SC_317 = "A dissimulation of tiny birds settles in a tree, then flutters off again";
Constant SC_1291 = "A fairly heavy-duty red number, mostly intended to keep you dry in the rain, or in other wet situations.";
Constant SC_64 = "A father and daughter playing a game together.";
Constant SC_1330 = "A flagpole is stuck through the holes.";
Constant SC_1373 = "A foggy clearing in the woods that fades out into a small, dirty beach -- the railroad tracks pass through, entwined in purple viburnum vines, straight lines over the damp ground. ";
Constant SC_145 = "A garment of indeterminate shape and fabric, in a shimmery green that flatters Vivian's freckled face.";
Constant SC_66 = "A girl of about seven in a green shirt, the top of her head barely visible through the window.";
Constant SC_864 = "A glint of light from the pond catches your eye.";
Constant SC_253 = "A gull swoops down and pecks at ";
Constant SC_127 = "A heavy metal chain.";
Constant SC_9 = "A heavy-duty waterproof model, with a powerful battery that should last all day.";
Constant SC_77 = "A keychain with a piece of red foam on it that looks like it would float; the words ~PONDSIDE HIGH~ are printed on the foam in white.";
Constant SC_89 = "A large boat -- its smooth wooden sides stretch above you to two or three times your height, and you can just barely make out its towering masts far above you, sails furled.";
Constant SC_1446 = "A large boat is here,";
Constant SC_122 = "A large canvas duffel, eggplant-colored.";
Constant SC_1554 = "A large crystal gear in the pump; it seems to be powered";
Constant SC_126 = "A large metal anchor, rusty in places, but without the barnacles typical for a seafaring boat.";
Constant SC_1432 = "A large multi-paned window, slightly dusty, but still admitting plenty of sunlight -- outside, you catch a glimpse of ";
Constant SC_134 = "A large steel wheel, set into the pump; turning it activates the pump.";
Constant SC_92 = "A large, complex pump of some kind -- covered in gadgets and gizmos and levers and wires and hoses.";
Constant SC_1311 = "A large, curved door stands ";
Constant SC_53 = "A large, curved wooden door, with the words ~Pondside Community Center~ painted on it.";
Constant SC_118 = "A large, powerful horseshoe magnet.";
Constant SC_26 = "A large, waterproof pocket.";
Constant SC_72 = "A latched box made of some hard, transparent material -- glass, or crystal -- with the words ~EMERGENCY SUPPLIES~ stenciled on the top in purple letters.";
Constant SC_327 = "A leaky hose in the nest is spewing water from a hole, preventing the pipe from working properly.";
Constant SC_29 = "A light a couple of inches in diameter, blinking red.";
Constant SC_746 = "A little muddy, but not too bad.";
Constant SC_83 = "A little torn, but still good -- in fact, it's a monthly pass with a week left on it.";
Constant SC_1484 = "A lone sweetgum tree, ";
Constant SC_106 = "A long brown braid, messily constructed and with flyaway strands everywhere.";
Constant SC_79 = "A long, flowy dress made of some shimmery stuff; it seems to be purple, or red, depending on what angle you look at it from.";
Constant SC_54 = "A long, thin pole supporting a flag in deep emerald green.";
Constant SC_979 = "A loud stereophonic click assures you that everything in the game has been unlocked.";
Constant SC_1309 = "A lumpy island is visible to the north of the spire.";
Constant SC_1541 = "A melange of crystal and metal parts; the pump's exterior is sparkling translucent crystal, while inside its shell are a tangle of metal pipes. Inside the pump, a giant metal wheel is the most obvious moving part; it is ";
Constant SC_1458 = "A metal pipe, a few inches in diameter, sticking straight up about three feet out of the ground";
Constant SC_161 = "A metal spike that sticks out the side of the giant metal wheel, rust-spotted from its years under the water.";
Constant SC_65 = "A middle-aged man in jeans, happily engaged in a game with his daughter.";
Constant SC_309 = "A murmuration of starlings flies by you";
Constant SC_1521 = "A narrow crack extending some inches into the cinderblock wall. ";
Constant SC_1326 = "A nest of dirty, waterlogged sticks, partially embedded in the mud of the pond shore";
Constant SC_1074 = "A noise in the pond catches your attention -- you turn and just see a shining flying fish leap out and back in";
Constant SC_57 = "A part of the mural, painted the blue-green of the pond, that's peeling back from the wall.";
Constant SC_1502 = "A pattern of grooves is visible on the bottom of the drawer, outlining a small raised square.";
Constant SC_25 = "A paved path that ends at the top of a large hill to the south.";
Constant SC_1475 = "A perfectly functioning square gizmo.";
Constant SC_104 = "A perfectly functioning triangular gizmo.";
Constant SC_84 = "A pine wood shelf, dusty, but quality craftsmanship.";
Constant SC_131 = "A pump with hoses coming out of it in several places, all snaking under the ground like tentacles. Emerging from the nest at the front of the pump is a large metal wheel that can be turned to switch on the pump.";
Constant SC_116 = "A quick pencil drawing of a spire with oval indentations -- it matches your familiar illustration.";
Constant SC_58 = "A rectangle of emerald green silk.";
Constant SC_1416 = "A red keychain with a small brass key on it is floating on the top of the water.";
Constant SC_1456 = "A rusty pipe, a few inches in diameter, sticking straight up about two feet out of the ground";
Constant SC_1605 = "A school of minnows swims over the pipe";
Constant SC_1610 = "A school of minnows swims up to the steps, then away again.";
Constant SC_244 = "A series of indistinct ";
Constant SC_1257 = "A set of different sizes and lengths of metal pipe, all hanging on strings";
Constant SC_1488 = "A set of metal wind chimes hangs from one of the branches.";
Constant SC_135 = "A shallow puddle of mucky water, pooling on the paved path.";
Constant SC_1238 = "A shining crystal spire rises out of the center of the pond.";
Constant SC_311 = "A siege of bitterns passes in the sky";
Constant SC_248 = "A single ~tink!~ breaks the silence";
Constant SC_98 = "A single drawer in the metal desk.";
Constant SC_308 = "A skein of geese passes overhead";
Constant SC_889 = "A small blue light on the detector starts blinking wildly.";
Constant SC_208 = "A small boat-house or spring-house emerges from the water to the west, close enough for you to wade to; around it, a few leaves bob gently in the muddy water.";
Constant SC_18 = "A small brick building east of you.";
Constant SC_11 = "A small but sturdy metal wrench.";
Constant SC_1396 = "A small cinderblock hut adjoining a large granite boulder, almost entirely covered in a carpet of moss. ";
Constant SC_1519 = "A small cinderblock hut with damp walls and a dirt floor; most of the hut is filled with a machine which trails hoses into the ground, some of them pulsating with water.";
Constant SC_1469 = "A small hand-held metal detector... you turn it on by pushing a button on the bottom, and then it automatically turns off after a couple minutes.";
Constant SC_68 = "A small island, or what is now a small island now that it's not underwater; it's just a few feet long in every direction. Marsh grasses poke up from the lumps in the wet, sandy ground, seaweed hanging off them in every direction.";
Constant SC_1395 = "A small metal plate that is screwed in to the boulder.";
Constant SC_1394 = "A small metal plate, fixed in the rock, that is open, revealing ";
Constant SC_4 = "A small rock, an inch or so in diameter, smoothed and worn to a flat disc by years of water.";
Constant SC_1333 = "A small strip of ";
Constant SC_1225 = "A small window, a little streaked; through it you can make out ";
Constant SC_50 = "A small wooden boat, just about big enough for you.";
Constant SC_41 = "A small, lumpy island, covered in green pondweed.";
Constant SC_36 = "A small, weedy island.";
Constant SC_1518 = "A smooth metal sheet in the front of the hut.";
Constant SC_163 = "A smooth, solid piece of crystal.";
Constant SC_93 = "A soft, thick carpet of pine needles, strewn with pinecones.";
Constant SC_102 = "A somewhat treacherous-looking spiral staircase, made of metal and painted solid black.";
Constant SC_314 = "A sord of mallards appears above you and then disappears into the distance";
Constant SC_1407 = "A spacious interior, with bare brick walls supported by metal girders. To the west is the door back outside, and an unsteady-looking spiral staircase in a corner leads down.";
Constant SC_360 = "A spike sticking out the side of the metal wheel moves downward with the wheel, blocking the crystal gear from continuing its movement";
Constant SC_315 = "A spring of teal passes in the sky";
Constant SC_1474 = "A square gizmo with a janky bolt.";
Constant SC_263 = "A steam train comes barreling down the tracks in your direction.";
Constant SC_273 = "A steam train is barreling toward you along the tracks.";
Constant SC_1500 = "A steam train is stopped on the tracks.";
Constant SC_108 = "A sturdy branch that looks like it could hold your weight.";
Constant SC_1408 = "A tall cylinder full of bubbling water stands in a corner.";
Constant SC_146 = "A tangle of clear plastic tubes that circles Vivian's face and neck; you can't quite follow how they work, but their purpose -- enabling speech and breath underwater -- is clear.";
Constant SC_101 = "A tangled nest of hoses.";
Constant SC_100 = "A tangled nest of wires.";
Constant SC_1503 = "A thin wooden panel in the bottom of the drawer that can be slid open to reveal a small hiding space.";
Constant SC_316 = "A tidings of magpies soars past you";
Constant SC_1431 = "A train is stopped on the tracks, completely still.";
Constant SC_1379 = "A train is stopped on the tracks, puffing steam.";
Constant SC_269 = "A train pulls up and stops in front of you.";
Constant SC_1415 = "A transparent plastic cylinder almost as high as the ceiling, and filled up almost to the brim with water; bubbles are emerging from the bottom of the cylinder, rising slowly to the top.";
Constant SC_144 = "A wet person wearing something green and clingy; she has some kind of tangle of tubes around her head, presumably enabling her to breathe and talk underwater. Her presence is magnetic.";
Constant SC_156 = "A wet, freckled person.";
Constant SC_158 = "A wet, gangly person.";
Constant SC_40 = "A wheel a couple of feet in diameter, resembling a ship's wheel; the wheel has holes in it.";
Constant SC_17 = "A white building with a steeple, too far away to make out details.";
Constant SC_1409 = "A woman";
Constant SC_1243 = "A wooden bench in several layers of chipped green paint in different shades; it's obviously been here for years, accumulating witticisms like ~";
Constant SC_1310 = "A wooden building, painted a clean, shining white, with a tall steeple rising up to the sky.";
Constant SC_1347 = "A wooden drawer is half-buried in the beach.";
Constant SC_1346 = "A wooden drawer is half-floating in the murky water.";
Constant SC_1349 = "A wooden drawer, apparently once part of a desk";
Constant SC_363 = "A";
Constant SC_1466 = "Above you is the high ceiling of the tower.";
Constant SC_795 = "Adriana";
Constant SC_167 = "Adventure";
Constant SC_528 = "After what seems to be a brief parley, one of them breaks away from the city and starts to move toward you. The small figure moves remarkably fast -- certainly much faster than ";
Constant SC_1669 = "Again, she invokes the technicians.";
Constant SC_1495 = "Alex A.";
Constant SC_1526 = "All that's below you is a puddle of water.";
Constant SC_663 = "Alternatingly mushy and angsty.";
Constant SC_2 = "An Interactive Quagmire";
Constant SC_1232 = "An affable young man with reddish hair and a redder droopy mustache; he is wearing pants that are slightly too big for him, suspenders, and a striped cap";
Constant SC_162 = "An deep indentation in the giant metal wheel, several inches square.";
Constant SC_310 = "An exultation of larks soars past you";
Constant SC_1284 = "An illustration torn out of a book -- you read it when you were seven, and though the other stories have long since faded from your mind, you've never really stopped thinking about this one. The illustration is in full color, a reproduction of a painting -- it depicts the possibly-mythical Crystal City. ";
Constant SC_1120 = "An old-fashioned steam train, with a rounded engine and a single moss-colored car dotted with windows; ";
Constant SC_28 = "An onion dome in brick and slate, ornamenting the top of the building and supporting a large, glowing clock.";
Constant SC_78 = "An ordinary brass key.";
Constant SC_10 = "An ordinary flathead screwdriver.";
Constant SC_123 = "An ordinary length of nylon cord.";
Constant SC_5 = "An ordinary pinecone, with an evocative scent.";
Constant SC_1404 = "An ordinary suburban house; ";
Constant SC_164 = "An ordinary-looking keyhole.";
Constant SC_1015 = "And meanwhile the city is rising, rising up above the water, crystal vehicles on translucent streets, Vivian holding your hand and her family standing near as you all break through and reach the surface, taking off your masks and breathing grateful gasps of fresh muddy air.";
Constant SC_1532 = "And wait... there are ";
Constant SC_1152 = "Another pull of the rope";
Constant SC_1174 = "Are";
Constant SC_384 = "As if from deep below you, you hear the rumbling of rushing water.";
Constant SC_443 = "As you step toward ";
Constant SC_756 = "As you try to walk past the conductor onto the train, he startles, and seems to realize where he is again.";
Constant SC_535 = "As you tug on the green silk, the flagpole comes out of the wall with it.";
Constant SC_1497 = "Ashley M.";
Constant SC_1417 = "At first you thought she was older, but when you look closer, you realize she's probably only a teenager. ";
Constant SC_1325 = "Behind you to the east you can climb the fence back to where you came from, and to the northeast the shoreline continues.";
Constant SC_1246 = "Bennie and Taylor 4eva!";
Constant SC_1400 = "Beyond the tank to the west you can dimly make out a faraway house ";
Constant SC_1512 = "Birch";
Constant SC_1483 = "Blinking ominously.";
Constant SC_14 = "Blue and white.";
Constant SC_890 = "Both the pockets are empty.";
Constant SC_831 = "Both the pockets of your coat are empty.";
Constant SC_1331 = "Bright ";
Constant SC_1384 = "Bright sunlight strikes ";
Constant SC_120 = "Bright yellow.";
Constant SC_37 = "Brown glass, and labeled ~Waterhouse Brew~; alas, no beer remains.";
Constant SC_155 = "Bustling with action, though silent under the water.";
Constant SC_233 = "But how?";
Constant SC_985 = "But you're already here!";
Constant SC_519 = "Can I help you?~ she asks.~";
Constant SC_476 = "Cardinal directions mean little under the pond's surface. You ";
Constant SC_374 = "Carrying the drawer is a pain! You're tired and you set it down, ";
Constant SC_33 = "Center of the Pond";
Constant SC_1492 = "Chris C.";
Constant SC_3 = "Clara Raubertas";
Constant SC_31 = "Clean running water, spewing from the fountain.";
Constant SC_747 = "Clear and refreshing.";
Constant SC_1581 = "Climbing ";
Constant SC_49 = "Cold, dirty water.";
Constant SC_1528 = "Concrete and slightly damp.";
Constant SC_1062 = "Constant alpha-testing and valuable advice provided by Jesse Raber. Beta-testing by Michael Fransioli, Chris Conley, Tucker Bennett, Eric Purdy, Katherine McFall, Alex Amann, Ashley Meyer, Ruth Raubertas and Dan Pratt.";
Constant SC_1501 = "Coppery viburnum vines twist around the burnished metal tracks.";
Constant SC_359 = "Cordelia jumps a little at the sound";
Constant SC_300 = "Cordelia looks at you, outwardly calm, but something about her eyes gives away tension";
Constant SC_80 = "Covered in papery, peeling bark and bright yellow leaves.";
Constant SC_506 = "Damn. It's locked.";
Constant SC_76 = "Damp and starting to crumble, but still sturdy.";
Constant SC_1498 = "Dan P.";
Constant SC_12 = "Dark grey, and pinstriped; slightly too big on the conductor, but held up by suspenders.";
Constant SC_140 = "Diametrically opposed holes on either side of the brass metal pipe; a couple inches in diameter.";
Constant SC_358 = "Doug cringes at the noise";
Constant SC_301 = "Doug is looking intently at the pump";
Constant SC_1115 = "Doug looks startled, then smiles. ~So ";
Constant SC_1118 = "Doug smiles.";
Constant SC_1793 = "EXAMINE ";
Constant SC_1494 = "Eric P.";
Constant SC_1008 = "Even your boat is carried away by the shuddering waves, floating and bobbing back to the boat house.";
Constant SC_87 = "Far away, across the flat marsh.";
Constant SC_48 = "Fine white grains.";
Constant SC_919 = "First time players type HELP for more instructions.";
Constant SC_22 = "Fluffy.";
Constant SC_873 = "For a moment you think you see the sparkle of a crystal tower in the pond, but it's just a trick of the sunlight.";
Constant SC_1606 = "From here you have a great view of the pond -- it sparkles sapphire-blue in the sunlight, and in the distance, a congregation of tiny white birds bob gently on the water. On the other side of the pond, you can see a vague row of buildings; most are obscured by the ";
Constant SC_206 = "From here you have a great view of the pond -- it sparkles sapphire-blue in the sunlight, and in the distance, a congregation of tiny white birds bob gently on the water. On the other side of the pond, you can see the small boat-house rising from the water, and can faintly make out the rocky beach.";
Constant SC_1242 = "From here, just a blur of ";
Constant SC_1531 = "From here, the city looks small and far away, the spire that stretches out of the pond incongruously large. Tiny turrets glimmer in the oddly reflected light.";
Constant SC_1560 = "From here, you can go ";
Constant SC_716 = "From here, you can only see the curved surface of the pipe, and can't see or reach inside it.";
Constant SC_450 = "From here, you'd have to swim to the structure, but you could probably get close enough to wade from up the shore to the northeast.";
Constant SC_1359 = "From here, you'd have to swim to the structure, but you could probably get close enough to wade up the shore to the northeast.";
Constant SC_296 = "From the east, you can feel a misty chill";
Constant SC_942 = "From your position standing on the bench, you are just able to reach the bottom branch, and scramble up.";
Constant SC_165 = "Full and thick.";
Constant SC_111 = "Globs and oozings of sweet, sticky sap, partly crusted over with white.";
Constant SC_112 = "Gooey, sticky pine sap.";
Constant SC_1525 = "Hard-packed dirt, with hoses from the pump stretching down into it.";
Constant SC_1179 = "Has";
Constant SC_1178 = "Have";
Constant SC_1586 = "He adjusts his suspenders self-consciously. ~People who lived in this area were -- healthier, happier than most. They didn't get sick. They didn't get depressed. Everyone started to think that it was the city ";
Constant SC_711 = "He blocks you expertly.";
Constant SC_1593 = "He brushes some dirt off a seat, carefully avoiding your gaze. ~We didn't mean to hurt them! At the time, they agreed to everything. They said it would be refreshing to live underwater!~ He laughs softly.";
Constant SC_1753 = "He directs you to the visitor center.";
Constant SC_1749 = "He directs you up the stairs.";
Constant SC_548 = "He doesn't seem to be paying attention to you.";
Constant SC_1761 = "He explains again that the panel contains tools.";
Constant SC_582 = "He glances briefly at it. ~That's a pretty picture!~";
Constant SC_618 = "He grins at you and shakes his head. ~Nope, I don't need that. The ticket's enough!~";
Constant SC_1771 = "He laments the stains on the seat.";
Constant SC_1736 = "He looks away from you. ~Um, I think that's just an urban legend. Or rural legend. Whatever.~";
Constant SC_1785 = "He mumbles a pleasantry about you.";
Constant SC_1551 = "He puts up his hands in a gesture of uncomprehension.";
Constant SC_1737 = "He refuses to talk further about the city.";
Constant SC_1779 = "He refuses to talk further about the hut.";
Constant SC_1739 = "He refuses to talk further about the legend.";
Constant SC_1765 = "He reminds you again of his name -- Eric.";
Constant SC_1781 = "He reminds you that he doesn't have money on him.";
Constant SC_1763 = "He reminds you that the tools in the panel belong to the train.";
Constant SC_1775 = "He reminds you that the train doesn't go there.";
Constant SC_1773 = "He reminds you that you're probably thinking of the Community Center.";
Constant SC_1767 = "He says something vague and inoffensive about ";
Constant SC_1783 = "He smiles and mentions the hill's great view.";
Constant SC_1758 = "He smiles proudly.";
Constant SC_1550 = "He smiles warmly. ~I wish we could hear what you want to say!~";
Constant SC_1790 = "He smiles, saying the dog is cute.";
Constant SC_1747 = "He smiles, telling you that you'll be there soon.";
Constant SC_1759 = "He smooths it down. ~You like it?~";
Constant SC_1769 = "He tells you again that the tools belong to the train.";
Constant SC_1743 = "He tells you that he knows a lot more about trains than about botats.";
Constant SC_1756 = "He tells you that he knows a lot more about trains than pumps.";
Constant SC_1741 = "He tells you that he knows a lot more about trains than the pond and the pumps.";
Constant SC_1788 = "He tells you that today  is a quieter day than usual.";
Constant SC_737 = "He";
Constant SC_52 = "Heavily water-stained.";
Constant SC_1198 = "Her";
Constant SC_1609 = "Here some wet steps lead directly down into the murky water, and a vague mist seems to rise off the pond's surface.";
Constant SC_1207 = "Hers";
Constant SC_518 = "Hi! ";
Constant SC_1201 = "Him";
Constant SC_715 = "His lean arm expertly blocks your attack.";
Constant SC_1197 = "His";
Constant SC_139 = "Holes a couple of inches in diameter.";
Constant SC_1791 = "I only understood you as far as wanting to hit ";
Constant SC_1049 = "If you're new to the genre: Emily Short has written a great introduction to playing IF, available at http://inform-fiction.org/I7Downloads/Examples/dm/IntroductionToIF.pdf.	";
Constant SC_1058 = "If you're stuck, try opening things, examining things, going in all the directions you can, thinking of unique ways objects can be used, revisiting old locations to see if your actions have changed them... and if all else fails, email the author for hints at clara.raubertas@@64gmail.com.
";
Constant SC_927 = "In ";
Constant SC_1332 = "In addition to having a hole in the regular vertical direction, it has a pair of diametrically opposed holes in the opposite direction, like a flute. ";
Constant SC_1558 = "In fact, you can't see any obvious exits.";
Constant SC_470 = "In that direction the hill drops precipitously down -- too precipitously to risk -- directly into the pond, a tumble of rocks and mud and tree roots and little marsh plants.";
Constant SC_1539 = "In the center of the courtyard is a crystal shell holding a tangle of metal pipes -- the final pump. Three wet figures are standing anxiously beside it.";
Constant SC_892 = "In the left pocket ";
Constant SC_833 = "In the left pocket of your coat ";
Constant SC_1511 = "In the middle of the pond on the blueprint is a quick sketch of a crystal spire.";
Constant SC_69 = "Incredibly bright green.";
Constant SC_1175 = "Is";
Constant SC_642 = "It bites your hand in a lightning-fast reaction, almost drawing blood.";
Constant SC_959 = "It doesn't seem to turn on with that ";
Constant SC_726 = "It flaps just out of your reach.";
Constant SC_51 = "It has an ordinary-looking locking mechanism.";
Constant SC_701 = "It is damp and soft to the touch.";
Constant SC_1007 = "It is definitely moving, shaking and quivering, water spilling out onto the beaches.";
Constant SC_1045 = "It is now ";
Constant SC_1569 = "It is too dark to see anything or do much.";
Constant SC_641 = "It licks your face in return.";
Constant SC_117 = "It looks the same as the rest of the sand.";
Constant SC_721 = "It maybe sinks a little deeper into the mud after your efforts -- that's about it.";
Constant SC_727 = "It pecks at your hand, hard. You yelp in pain.";
Constant SC_119 = "It reads ~FRESHWATER CROSSING~ in peeling black-on-white paint.";
Constant SC_690 = "It runs through your fingers, and you can't hold on to any.";
Constant SC_1524 = "It seems to be empty.";
Constant SC_717 = "It seems to be firmly fixed in place.";
Constant SC_141 = "It seems to be full.";
Constant SC_713 = "It shudders for a minute.";
Constant SC_878 = "It slips smoothly into the machine, and you hear a click.";
Constant SC_875 = "It smells both stale and wet inside, but the rubber holds tight against your skin and you have no trouble breathing.";
Constant SC_725 = "It snaps at you and almost bites your finger. You jump back.";
Constant SC_903 = "It starts to twitch a little.";
Constant SC_35 = "It stretches above the pond only a few feet, but it's almost blindingly bright in the reflected sunlight. It's obelisk-shaped, with several oval indentations.";
Constant SC_7 = "It turns on the detector.";
Constant SC_591 = "It won't fit.";
Constant SC_1190 = "It";
Constant SC_1578 = "It's OK.";
Constant SC_1358 = "It's a few feet into the water, but you could probably wade.";
Constant SC_38 = "It's a flattish stick, nearly your height, several inches wide on one end and narrowing a little toward the other end.";
Constant SC_720 = "It's a giant boat on dry land -- it's probably not going anywhere.";
Constant SC_133 = "It's a long, old-fashioned metal key, stained with rust in a few spots.";
Constant SC_46 = "It's about six feet high, rusty in places but still quite solid.";
Constant SC_662 = "It's completely smooth.";
Constant SC_1035 = "It's empty.";
Constant SC_537 = "It's firmly stuck on there.";
Constant SC_418 = "It's going to be pretty heavy and annoying to cart around with you, but okay.";
Constant SC_229 = "It's gone.";
Constant SC_729 = "It's inside the cylinder, where you can't get at it.";
Constant SC_554 = "It's inside the pump now.";
Constant SC_227 = "It's magic. Maybe.";
Constant SC_607 = "It's much too high to reach the opening at the top.";
Constant SC_422 = "It's not here yet.";
Constant SC_714 = "It's not obvious how.";
Constant SC_540 = "It's packed too hard to dig in, and you have a feeling you might break part of the pump anyway.";
Constant SC_1391 = "It's quite tastefully and realistically done, at least as far as the medium of spray paint allows; the bright blue and white colors accurately portray a splash of fresh water.";
Constant SC_1360 = "It's rising up from the pond, some way away and on the other side of the fence. You could probably examine it more closely if you could get up to the edge of the pond.";
Constant SC_707 = "It's too big to carry around.";
Constant SC_651 = "It's too heavy to lift -- it's floating in the water, which is probably where it should stay.";
Constant SC_661 = "It's too smooth.";
Constant SC_712 = "Its surface is smooth, hard, and impenetrable.";
Constant SC_646 = "Its tail wags happily.";
Constant SC_1199 = "Its";
Constant SC_1490 = "Jesse R.";
Constant SC_1300 = "Just about wide enough for you to put your arms around, if it weren't ";
Constant SC_213 = "Just an occasional flash of blue-green from here.";
Constant SC_466 = "Just as before you felt too buoyant to swim down, now you feel gravity holding you to the ground.";
Constant SC_230 = "Just ducks.";
Constant SC_1798 = "Just leaves";
Constant SC_159 = "Just looking at them makes you dizzy.";
Constant SC_235 = "Just paint.";
Constant SC_1244 = "Kate loves Marta";
Constant SC_1496 = "Katherine M.";
Constant SC_59 = "Large indentations in the crystal spire -- probably for decoration.  Their shape seems unusually pleasing to you.";
Constant SC_1438 = "Last week's Pondside Times.";
Constant SC_312 = "Leaves swirl purposelessly around in the air";
Constant SC_307 = "Leaves waft intermittently to the ground";
Constant SC_113 = "Like most gulls, it looks angry.";
Constant SC_759 = "Listening to the conductor talk to you is keeping you awake.";
Constant SC_1286 = "Looking at the image, you smile as you recall childhood fantasies of ";
Constant SC_153 = "Made of a substance that still shines with reflected sunlight from above the pond, but chipped and broken in places.";
Constant SC_73 = "Made of rubber, it fits over your head and connects to a tank of air that straps on to your back.";
Constant SC_1245 = "Mark was here";
Constant SC_71 = "Marsh grasses stick up out of them.";
Constant SC_1001 = "Marsh";
Constant SC_74 = "Metal, and fairly nondescript except for a single drawer.";
Constant SC_1527 = "Metal.";
Constant SC_1491 = "Michael F.";
Constant SC_1022 = "Mixing ";
Constant SC_1050 = "More specifically: try simple commands like GO NORTH, EXAMINE ";
Constant SC_130 = "Moss-coated.";
Constant SC_124 = "Much too high for you to see much of from here.";
Constant SC_91 = "Muddy. You squelch around in it.";
Constant SC_1025 = "No more ";
Constant SC_700 = "None of the trees here look very climbable.";
Constant SC_463 = "None of the trees look very climbable.";
Constant SC_980 = "Noted.";
Constant SC_541 = "Nothing further happens.";
Constant SC_813 = "Nothing happens to your immediate surroundings, but you do feel a little better.";
Constant SC_702 = "Nothing happens. Maybe it's broken?";
Constant SC_180 = "Nothing happens.";
Constant SC_1579 = "Nothing interesting happens.";
Constant SC_754 = "Nothing much happens.";
Constant SC_1108 = "Nothing seems to happen";
Constant SC_1066 = "Nothing very interesting has happened yet -- your score is 0 out of ";
Constant SC_546 = "Nothing you do to the metal door seems to have any interesting effect.";
Constant SC_1392 = "Now that you're looking closely, you can see that some of the paint covers a small metal plate that is screwed in to the boulder.";
Constant SC_1482 = "Off and dark.";
Constant SC_929 = "On ";
Constant SC_1425 = "On another page, three blocks are filled in with colored pencil -- blue, purple, and yellow.
";
Constant SC_1440 = "On another page, you can see a list of sixth graders who made the honor roll.";
Constant SC_1426 = "On another page, you see a detailed pencil sketch of a city. ";
Constant SC_1441 = "On another page, you see a human-interest profile of the woman who runs the Waterworks -- she tells the interviewer that her daughter is getting valuable work experience at a part-time job working the Waterworks desk.";
Constant SC_1361 = "On the inside, the red brick walls of the structure are clammy and crumbling. ";
Constant SC_1471 = "One of the hoses in the nest ";
Constant SC_1439 = "One piece, titled ~Rolling for 25 Years!~, gives a profile of the train system (which celebrated its quarter-centennial last week, apparently) and the train conductor (who explains that running the train has been his lifelong ambition).";
Constant SC_823 = "Only the faint ";
Constant SC_456 = "Only the thick carpet of needles.";
Constant SC_70 = "Or pondweed, you guess. Ropy twists of ribbony green.";
Constant SC_90 = "Ordinary beach grasses, waving a little in the wind.";
Constant SC_132 = "Ordinary cinderblock walls, except for the deep crack in the south wall.";
Constant SC_1223 = "Outside the window you can see Freshwater Crossing.";
Constant SC_1224 = "Outside the window you can see a misty clearing.";
Constant SC_1221 = "Outside the windows you can see trees zooming by, with an occasional glimpse of pond between them.";
Constant SC_121 = "Papery and peeling.";
Constant SC_86 = "Part of the schedule seems to have gotten wet, and is too blurry to read. You can just make out that trains depart Freshwater Crossing at 10, 30, and 50 past each hour, and that they depart someplace whose name you can't make out at 20 and 40 past and on the hour.";
Constant SC_1057 = "Places you've been, things you've seen, and people  you've talked to may change somewhat as your actions in-game affect them and their situations, so you should occasionally wander back to places you've already been, and places that might have seemed like dead ends may open up as you change the state of the world.	";
Constant SC_1529 = "Plastic hoses that snake out of the pump and deep under the ground, presumably transporting water between the pond and the Waterworks, or fulfilling some other key function in the water system";
Constant SC_174 = "Please be more specific - ";
Constant SC_236 = "Please don't.";
Constant SC_1208 = "Please press SPACE to continue.";
Constant SC_1465 = "Poking out from the swirling clouds, you see the harvest moon, startlingly large and orange.";
Constant SC_105 = "Presumably a security measure of some kind, that can be bypassed with the proper key.";
Constant SC_21 = "Probably deposited here by a glacier, thousands of years ago.";
Constant SC_1018 = "Putting liquids on ";
Constant SC_630 = "Putting sand in ";
Constant SC_1582 = "Putting things on ";
Constant SC_172 = "QUIT";
Constant SC_169 = "RESTART";
Constant SC_170 = "RESTORE a saved game";
Constant SC_13 = "Red.";
Constant SC_110 = "Rough, cracked, and oozing sap.";
Constant SC_1499 = "Ruth R.";
Constant SC_1250 = "SMILE!";
Constant SC_1052 = "SOMEONE";
Constant SC_850 = "Scuse me. ";
Constant SC_334 = "Seams on the pump start cracking, bursting. The water pools around your feet.";
Constant SC_1357 = "Several feet wide on every side, and primarily made of red brick, with a pointed slate roof and a wooden door on this side. ";
Constant SC_1380 = "Several large blocks of wet stone ";
Constant SC_1423 = "Several pages are filled with handwritten pencil notes about the different boys and girls ";
Constant SC_655 = "Sharp, cold, damp.";
Constant SC_710 = "She blocks you expertly.";
Constant SC_1699 = "She checks to make sure the desk drawer is closed. ~It's private!~";
Constant SC_1652 = "She clutches it protectively. ~It's ";
Constant SC_1655 = "She clutches the notebook protectively again, preventing you from seeing any details.";
Constant SC_1646 = "She directs you to the hill.";
Constant SC_1665 = "She directs you to the other side of the fence.";
Constant SC_1644 = "She directs you to the visitor center.";
Constant SC_280 = "She drums her fingers on the railing. ~I";
Constant SC_708 = "She grabs your hands almost instantly and twists them into immobility, only letting go after a long, wary glance. ";
Constant SC_664 = "She grabs your wrist and throws you away from her with surprising force, considering her small size.";
Constant SC_581 = "She grins at the picture -- briefly looking as though she's going to put it in her notebook -- then hands it back.";
Constant SC_1628 = "She grins, telling you again about the rumors she's heard.";
Constant SC_792 = "She half smiles. ~Look, of ";
Constant SC_575 = "She hands the drawer back to you.";
Constant SC_279 = "She is biting her fingernails.";
Constant SC_1671 = "She just shuts her mouth pointedly.";
Constant SC_1708 = "She laughs, telling you how her dad threw the keychain in the cylinder as a joke -- but now no one can get it out without a ladder.";
Constant SC_1536 = "She laughs, then covers her mouth. ~Sorry, it's probably no fun for you that you can't say anything to us.~";
Constant SC_1418 = "She looks annoyed.";
Constant SC_1651 = "She looks down, mumbling something vague about a system.";
Constant SC_1419 = "She looks dreamily absorbed in whatever she is writing or drawing.";
Constant SC_278 = "She looks nervous.";
Constant SC_1648 = "She looks pointedly at you, as though she thinks you're dumb, as she reminds you that the technicians are ";
Constant SC_1706 = "She mentions a time when she got lost in the woods for the better part of a day.";
Constant SC_1697 = "She mentions the possibility of a secret panel in the wooden drawer.";
Constant SC_1636 = "She mumbles something vague about processing the water.";
Constant SC_1640 = "She mumbles something vague about the boat.";
Constant SC_1663 = "She praises the hill's view.";
Constant SC_574 = "She pushes the outline again, but still no luck.";
Constant SC_1632 = "She reminds you that it's rumored that the city is under the pond.";
Constant SC_1681 = "She reminds you that only technicians are supposed to enter the pump room anyway.";
Constant SC_1691 = "She reminds you that the community center is across the pond.";
Constant SC_1700 = "She reminds you that the desk drawer is off-limits.";
Constant SC_1687 = "She reminds you that there's no money in the Waterworks.";
Constant SC_1689 = "She reminds you that you're probably thinking of the Community Center.";
Constant SC_1667 = "She rolls her eyes and goes into a diatribe about the ubiquitous mud.";
Constant SC_1683 = "She says some things about her job that you don't really pay attention to.";
Constant SC_1657 = "She says something vague about filtering the water.";
Constant SC_1702 = "She smiles and reminds you that she doesn't know much about you.";
Constant SC_1661 = "She smiles as she tells you about the conductor's train obsession.";
Constant SC_1549 = "She smiles sympathetically";
Constant SC_1710 = "She smiles, asking you to check out how clear the water is.";
Constant SC_602 = "She smiles, pocketing ";
Constant SC_1638 = "She smiles, saying again that the pond is central to her community.";
Constant SC_1704 = "She smiles, telling you about some of the kinds of birds that live in the area.";
Constant SC_215 = "She smiles. ~Hi!~";
Constant SC_1662 = "She smiles. ~Nice view!~";
Constant SC_1675 = "She starts complaining a little about her mom making her work here, which you ignore.";
Constant SC_572 = "She takes the drawer. ";
Constant SC_1714 = "She talks a little about her parents.";
Constant SC_1673 = "She tells you a little story about the dog's previous owner.";
Constant SC_1685 = "She tells you again that newspapers are available from the vending machine.";
Constant SC_1693 = "She tells you again that the hut is supposed to be locked.";
Constant SC_1642 = "She tells you again that there are train schedules in the visitor center, if you want to cross the pond.";
Constant SC_1716 = "She tells you that her dad is going to bring a ladder tomorrow.";
Constant SC_1679 = "She tells you that her dad likes to joke around.";
Constant SC_1677 = "She tells you that her mom is organized and efficient.";
Constant SC_1537 = "She touches your mask in response.";
Constant SC_1633 = "She tucks a strand of hair behind her ear and recites almost robotically: ~Only qualified technicians are supposed to mess with the pump system.~";
Constant SC_735 = "She turns away from you.";
Constant SC_1712 = "She wrinkles her nose when you mention the gull.";
Constant SC_1668 = "She wrinkles her nose. ~Look, I don't really understand that stuff, and it's supposed to be classified, anyway. The qualified technicians. Right?~";
Constant SC_736 = "She";
Constant SC_55 = "Shiny and slick.";
Constant SC_32 = "Short, marshy grass grows all the way up to the pond, and even underwater, here. To the north, a series of steps leads up to a white, steepled building, and the center of the pond is back to the southeast.";
Constant SC_149 = "Slimy green trails on every surface.";
Constant SC_23 = "Slobbery.";
Constant SC_109 = "Small and bright.";
Constant SC_99 = "Small and shiny, faintly labelled with lettering you can't read.";
Constant SC_1535 = "Small figures, barely visible at this distance, seem to bustle among the streets.";
Constant SC_63 = "Soft, moist, bright green.";
Constant SC_75 = "Solid and faintly rust-spotted.";
Constant SC_1393 = "Some of the paint covers ";
Constant SC_1370 = "Some paint has been pulled away from the center of the mural, revealing an older, earlier image -- a painting of the crystal city, turrets sparkling.";
Constant SC_1371 = "Some paint in the center of the mural seems to be peeling away.";
Constant SC_19 = "Some sort of mutt, of the large, cheerful variety, soft, fluffy, and dappled with white and grey. No collar or anything, just a dog, wandering happily around.";
Constant SC_1241 = "Some twisty, broken stairs lead down to the southwest; to the east is a small brick building; to the north is the path back to the Waterworks; and to the south is a dense grove of pine trees.";
Constant SC_1114 = "Something inside the pump whirrs to life, and it starts to rumble.";
Constant SC_555 = "Something you mentioned is either not here or not important.";
Constant SC_755 = "Somewhere below you you hear a gurgling.";
Constant SC_1063 = "Sorry, this release of this game has no hints.";
Constant SC_1386 = "Sparkling and reflecting sunlight so brilliantly you can barely look at it";
Constant SC_1513 = "Spruce";
Constant SC_652 = "Squishy.";
Constant SC_520 = "Still locked. You wade back to the beach.";
Constant SC_521 = "Still locked.";
Constant SC_82 = "Still polished to a reflective shine.";
Constant SC_242 = "Still, that's what you've done so far.";
Constant SC_151 = "Stray ribbons of pondweed sprouting out of unexpected crevices.";
Constant SC_286 = "Suddenly the unstable ground gives way to sinking mud beneath you, and you're encircled in the marsh to the waist, trapped and unable to move!";
Constant SC_1568 = "Suddenly you are unable to see anything.";
Constant SC_1293 = "Supposedly waterproof up to 300 feet. The time reads ";
Constant SC_699 = "Surprisingly smooth.";
Constant SC_1443 = "Tall grasses rustle around your feet. Two pipes stick up out of the ground.";
Constant SC_56 = "Tall, pointed, and white against the blue sky.";
Constant SC_147 = "Taller by far than anything else here, it reaches all the way up and out of the pond.";
Constant SC_61 = "Ten metal buttons -- the numbers 0-9 -- smoothed by years of pressing.";
Constant SC_868 = "Thank";
Constant SC_448 = "That direction just leads back to where you came from... you could head that way, but you're not sure yet if you want to give up on looking for the city.";
Constant SC_1096 = "That doesn't seem necessary";
Constant SC_639 = "That seems like overkill when you have hands.";
Constant SC_1086 = "That seems pointless.";
Constant SC_481 = "That way is only a wall.";
Constant SC_452 = "That way is only the ceiling.";
Constant SC_458 = "That way is only the ground.";
Constant SC_460 = "That way is only the mud.";
Constant SC_459 = "That way is only the sky.";
Constant SC_453 = "That way the hill slopes down a little and bumps into the Waterworks building; to the north, you can head back towards the Waterworks.";
Constant SC_619 = "That wouldn't do you much good when the wheel is freestanding.";
Constant SC_1186 = "That";
Constant SC_675 = "That's already closed.";
Constant SC_753 = "That's not something you can play.";
Constant SC_1083 = "That's not suitable to paddle with.";
Constant SC_601 = "That's not the right shape to put on the pipe.";
Constant SC_239 = "The ";
Constant SC_1459 = "The basement of the Waterworks, concrete on every side, windowless, and waterstained; almost the entire room is taken up by a large device.";
Constant SC_1504 = "The blueprint -- tattered and water-stained, but still legible -- shows an engineer's diagram of the water system around the area.";
Constant SC_1316 = "The boat house is to the northeast; to the west, you can see a dirty shore with a few stone steps poking out of it; and to the northwest, you can land on a grassy shore.";
Constant SC_1389 = "The boulder is a large lump of smooth granite almost your height, with a soft carpet of moss climbing up the side. Someone appears to have graffiti";
Constant SC_1133 = "The cavity in the metal wheel slips below the smooth crystal surface of the pump.";
Constant SC_441 = "The chain-link fence blocks your way.";
Constant SC_526 = "The chimes ring deep, distorted, and melodic under the water.";
Constant SC_527 = "The city is far away, but sound travels quickly under the water; it's only a moment before the tiny figures turn to look towards the origin of the sound.";
Constant SC_1292 = "The coat has two giant pockets that should keep their contents pretty dry as well.";
Constant SC_994 = "The complicated pump starts to hum";
Constant SC_996 = "The complicated pump starts to shudder";
Constant SC_997 = "The complicated pump starts to thump against the floor";
Constant SC_1584 = "The conductor adjusts his cap. ~You're the one turning on these pumps, right? So, uh, we should talk.~";
Constant SC_544 = "The conductor catches what you're doing and stops you. ~Hey! That's train property, that is!~";
Constant SC_905 = "The conductor checks your ticket, and smiles at you. ~Thanks, friend!~ he says.";
Constant SC_1143 = "The conductor continues to ramble.";
Constant SC_1589 = "The conductor continues.";
Constant SC_224 = "The conductor gives you a technical explanation that you don't follow.";
Constant SC_553 = "The conductor interrupts you. ~Leave that there, then! It belongs to the train!~";
Constant SC_802 = "The conductor just gives you a look.";
Constant SC_1148 = "The conductor looks at you and seems to be startled by your presence. He apologizes for boring you.";
Constant SC_904 = "The conductor looks at you, his customary grin faded. ~Oh, hey.~";
Constant SC_1147 = "The conductor looks up at you and realizes you weren't following his explanations. ~Sorry for nerding out,~ he says sheepishly.";
Constant SC_1591 = "The conductor paces up and down the train car as he continues to talk.";
Constant SC_1596 = "The conductor paces up and down the train car, hands behind his back, still avoiding looking directly at you.";
Constant SC_1602 = "The conductor pauses to rub some dirt off the window. ~Look, I know maybe it wasn't right, and maybe it's right to give them a chance now. I don't know! It's a decision I don't want to make myself.~";
Constant SC_1777 = "The conductor proudly tells you how much he loves running the train.";
Constant SC_183 = "The conductor says, ~Now that we've lived here for so long, of course nobody in Pondside wants to leave!~ He sighs. ~It's so beautiful here, and so pleasant. I've lived here all my life -- working on the train, running the train...~";
Constant SC_1146 = "The conductor seems to remember where he is, with a bit of a start. ~Oh, sorry for boring you with all that. Sometimes I forget not everyone finds this stuff so fascinating!~";
Constant SC_906 = "The conductor smiles";
Constant SC_807 = "The conductor starts up again telling you about the many features of his train; you don't really follow the purpose of most of them, but he clearly seems to think they're exciting. While he's talking about the train, he doesn't seem to be paying attention to you.";
Constant SC_182 = "The conductor tightens something unseen on the train, looking away from you. ~I think my parents were good people! Like everyone else, they just wanted to build a community here, near the city's positive energy. But at the time, the pond covered where we are now -- and if you turn on the last pump, we'll be back to that for real.~";
Constant SC_808 = "The conductor turns away from you, whistling";
Constant SC_1145 = "The conductor's train monologue goes on. He points to some things in the train, trying to explain them; you nod noncommittally, but he seems to be ignoring you anyway.";
Constant SC_539 = "The crack is too narrow for you to reach very far inside.";
Constant SC_341 = "The crack spreads, and the floor beneath your feet collapses with a horrible crunching noise, dropping you into the flooded basement.";
Constant SC_1139 = "The crystal gear starts to turn counterclockwise, and approaches the metal wheel.";
Constant SC_352 = "The crystal gear turns past the metal wheel.";
Constant SC_730 = "The cylinder is much too high to reach the opening at the top";
Constant SC_552 = "The cylinder is much too high to reach the opening at the top, even while standing on something.";
Constant SC_339 = "The damp stain on the floor widens, turning brown, growing to the size of the whole room.";
Constant SC_767 = "The diving mask gives off a stale, wet odor directly into your nostrils.";
Constant SC_800 = "The dog barks softly.";
Constant SC_1150 = "The dog chases its own tail";
Constant SC_615 = "The dog ignores you";
Constant SC_377 = "The dog looks up at you expectantly.";
Constant SC_951 = "The dog pads in from ";
Constant SC_613 = "The dog sniffs at ";
Constant SC_1149 = "The dog sniffs at the ground";
Constant SC_616 = "The dog tries to chew on ";
Constant SC_952 = "The dog trots away to ";
Constant SC_258 = "The dog wags its tail";
Constant SC_257 = "The dog's tongue lolls out, panting";
Constant SC_545 = "The door seems to have retracted into the hut's wall.";
Constant SC_373 = "The drawer is getting pretty heavy.";
Constant SC_1442 = "The facing page features classified ads -- someone looking for tutoring in Algebra, someone trying to sell her mural-painting services, someone looking for a dance partner.";
Constant SC_644 = "The flag drags in the water.";
Constant SC_502 = "The flagpole is in the way.";
Constant SC_898 = "The flashlight flickers once or twice, and then provides a steady beam that illuminates your surroundings.";
Constant SC_340 = "The floor under the desk cracks -- breaks -- collapses entirely, the desk falling into the space below with a loud splash, and the cylinder cracking into innumerable pieces, the keychain finally floating within your reach.";
Constant SC_381 = "The floor";
Constant SC_417 = "The flow of water stops.";
Constant SC_1464 = "The forest opens up to the north, back to the hill, and slopes down to the west, where you can see railroad tracks.";
Constant SC_492 = "The former sandy beach is now completely flooded; you take a step in that direction, splashing into the deepening water, and feel your boot sink into the sand. Hurriedly you shift your weight and retreat back to the comparative safety of the wet beach.";
Constant SC_633 = "The fountain is off.";
Constant SC_1299 = "The fountain is spewing clean water.";
Constant SC_648 = "The fountain isn't on.";
Constant SC_1437 = "The front of the machine is hanging open, and the machine contains ";
Constant SC_1140 = "The gears of the crystal wheel catch another gear inside the pump, and another. Soon the pump is vibrating as wheels within wheels turn and turn each other.";
Constant SC_1138 = "The giant metal wheel grates along, slower than usual.";
Constant SC_1304 = "The glowing clock has no numbers, and just one long hand, pointed at the tip; the time reads ";
Constant SC_468 = "The grass that way is too wet and muddy to step in.";
Constant SC_209 = "The grey-blue pond stretches flatly away from the island in every direction; to the south is the sparkling spire, the sun reflected off its indentations into flecks of light on the water.";
Constant SC_1282 = "The ground dips a little on this side of the fence, exposing a large rusty pipe.";
Constant SC_472 = "The ground is too marshy and unstable in that direction.";
Constant SC_382 = "The ground";
Constant SC_234 = "The gull has left.";
Constant SC_283 = "The gull tires of ";
Constant SC_1230 = "The handle of the panel is bent and twisted, and there's a substantial dent in the side of the panel";
Constant SC_95 = "The harvest moon, large, orange, and visible even in the middle of the day.";
Constant SC_454 = "The hill descends steeply into the woods in that direction; you can enter the woods directly to the south.";
Constant SC_455 = "The hill drops off too steeply in that direction.";
Constant SC_1085 = "The hose is already plugged.";
Constant SC_722 = "The house is far away and the family is inside.";
Constant SC_464 = "The house is far away, and the family is inside.";
Constant SC_723 = "The house is far away.";
Constant SC_1398 = "The hut is open.";
Constant SC_1397 = "The hut seems to have a metal door, but you can't see any keyhole or handle or any way to open it.";
Constant SC_894 = "The hut starts to shake for a few seconds -- even making you lose your balance -- and water rushes through the hoses.";
Constant SC_379 = "The hut";
Constant SC_440 = "The island is small, and you could only dive into the water in that direction.";
Constant SC_150 = "The kelp twists are everywhere, some rising taller than you and almost resembling aboveground trees -- they were clearly shaped by a human artistry.";
Constant SC_505 = "The key is too far in there.";
Constant SC_891 = "The left pocket is empty";
Constant SC_832 = "The left pocket of your coat is empty";
Constant SC_501 = "The magnet pulls the key toward the front of the crack, until it's close enough for you to grab with the tips of your fingers, which you do.";
Constant SC_489 = "The marsh is clearly too flooded and unstable to hold your weight. You shudder at the thought of getting stuck in that mud again.";
Constant SC_776 = "The mask blocks access to your mouth.";
Constant SC_775 = "The mask is tight against your face, and no sound escapes.";
Constant SC_251 = "The metal detector beeps a little in response to ";
Constant SC_305 = "The metal detector powers down with a whirr.";
Constant SC_252 = "The metal detector seems to beep when you hold it near a particular spot in the sand.";
Constant SC_350 = "The metal wheel slows, and starts to emit a banging and cranking sound, distorted by the water. It whirrs and grunts, straining against ";
Constant SC_354 = "The metal wheel slows, and starts to emit a crunching sound, distorted by the water. It whirrs and grunts, straining against ";
Constant SC_346 = "The metal wheel turns clockwise. A cavity in the metal wheel rises to the top.";
Constant SC_449 = "The mud and sticks are impassable in that direction.";
Constant SC_97 = "The nameplate reads ~Secretary of Water, Pondside Waterworks~.";
Constant SC_1559 = "The only way to go is ";
Constant SC_1388 = "The opening gets larger to the southwest, and in every other direction, you see only the dense woods.";
Constant SC_1368 = "The painting depicts Pondside life at its most optimistic -- children swimming or fishing in the pond, the train swerving around the railroad bridge with a grinning conductor sticking his head out the side, the dog romping in the woods, families playing games in their homes, machinery turning efficiently at the waterworks";
Constant SC_85 = "The pamphlet says ~Welcome to the Waterworks!~ and features several nauseatingly cute cartoon animals explaining that the Waterworks turns dirty pond water into clean drinking water.";
Constant SC_551 = "The part of the wheel the cavity is on is now inside the pump's crystal shell.";
Constant SC_261 = "The people below seem unaware of your presence.";
Constant SC_154 = "The people in the city float buoyantly through the streets.";
Constant SC_1285 = "The picture shows the city, full of buildings: here, a large translucent egg dotted with tiny windows; there, a tall pointed tower with an antenna stretching to the sky; behind them, a rectangular structure completely visible through the transparent other buildings, and all surrounded by water - a moat? A lake? ";
Constant SC_622 = "The pinecone is already sticky and sappy.";
Constant SC_1413 = "The place is abandoned. A simple metal desk is the only piece of furniture you can see";
Constant SC_1320 = "The pond has almost submerged";
Constant SC_212 = "The pond here is completely smooth and still, aside from the occasional splash of your stick into the water.";
Constant SC_205 = "The pond is partly obscured through the chain-link fence, but you can see the blue-green water rippling a little in the wind, a few leaves bobbing in it gently.";
Constant SC_259 = "The pond is still, and quiet.";
Constant SC_1321 = "The pond laps gently up to";
Constant SC_1134 = "The pump gives off a ";
Constant SC_326 = "The pump is humming a little.";
Constant SC_302 = "The pump is rumbling";
Constant SC_325 = "The pump is shuddering a little.";
Constant SC_323 = "The pump is shuddering and humming.";
Constant SC_324 = "The pump is thumping a little.";
Constant SC_322 = "The pump is thumping and humming.";
Constant SC_319 = "The pump is thumping";
Constant SC_304 = "The pump is vibrating";
Constant SC_895 = "The pump rattles.";
Constant SC_1011 = "The pump rumbles and vibrates to life, and suddenly the ground beneath you is violently rocked. You can feel the hydraulics beneath you start to turn, and push the island upward.";
Constant SC_998 = "The pump shakes and whirrs";
Constant SC_877 = "The pump stops humming.";
Constant SC_1119 = "The pump stops rumbling. Vivian looks disappointed.";
Constant SC_1002 = "The pump whirrs to life, shaking as it starts up. It gurgles, and shudders, and stomps.";
Constant SC_378 = "The pump";
Constant SC_1455 = "The railroad tracks are behind you to the northeast.";
Constant SC_1323 = "The rising water covers the beach; you squelch in your boots.";
Constant SC_1355 = "The rocks get sparser until here there is only sand, fading under the water into the pond. ";
Constant SC_865 = "The rowboat bumps gently against the doorway, wet from its journey across the pond.";
Constant SC_876 = "The rowboat floats into the boat house as you open the door.";
Constant SC_385 = "The rumbling slows to a steady, almost unnoticeable vibration beneath you.";
Constant SC_138 = "The rungs are set into the side of the tank, beginning a couple feet above you.";
Constant SC_157 = "The same tangle of clear plastic tubes that everyone here seems to wear.";
Constant SC_207 = "The sand here dissolves gradually into the muddy water; it's hard to tell where beach ends and pond begins.";
Constant SC_457 = "The sandy beach continues, but there doesn't seem to be much more of interest there.";
Constant SC_8 = "The seats have seen better days; the damage ranges from the clear evidence of spilled coffee to a few cigarette burns.";
Constant SC_1356 = "The shoreline continues to the southwest and northeast, and the fence is to the south and east.";
Constant SC_1348 = "The shoreline continues to the southwest and to the northeast, and behind you to the south and east is a chain-link fence.";
Constant SC_719 = "The sides are too sleek to climb, and the boat is much taller than you.";
Constant SC_1342 = "The small ";
Constant SC_1216 = "The small blue light is ";
Constant SC_1306 = "The smooth ripples of the pond's surface reflect the trees and buildings that surround it -- you catch a blurred, muddy version of ";
Constant SC_1553 = "The smooth surface of the giant metal wheel is visible in the opening";
Constant SC_656 = "The smooth swirls of the indentations seem almost soft under your fingers.";
Constant SC_67 = "The smooth tank looms high above you, the word ~PONDSIDE~ stenciled onto it in large green letters; it's made of some substance you can't quite identify. Some rungs are set into the side of the tank.";
Constant SC_1235 = "The sound is coming from above you";
Constant SC_1236 = "The sound is coming from the chimes";
Constant SC_1399 = "The space in the woods opens out to a broader area, carpeted with lush grass. A large tank towers high above you.";
Constant SC_361 = "The spike blocks the crystal wheel again";
Constant SC_210 = "The spiky marsh grasses here dissolve gradually into the muddy water; it's hard to tell where grass ends and pond begins.";
Constant SC_1460 = "The spiral staircase leads back up to the main building.";
Constant SC_107 = "The stairs are made from pieces of gray slate, long cracked and broken by erosion.";
Constant SC_274 = "The steam train pulls up, and comes to a halt.";
Constant SC_211 = "The surface of the pond is smooth under your boat; you see the tiny ripple of some fish or animal surfacing and then diving again.";
Constant SC_1004 = "The tank starts to shudder violently. Below you, you hear a loud grinding noise that seems to spread into the pond -- in fact, it looks like the pond ";
Constant SC_1328 = "The top of the tank is higher than the tips of most of the trees in the woods that surround you. From here, across the rippled surface of the pond, you can even make out the colorful tip of the distant sweetgum tree.";
Constant SC_39 = "The top of the tank is made of the same smooth, unidentifiable substance you touched on the ground; there's only a few feet of space here for you to maneuver in. The words ~Pondside Pump #3~ are stenciled onto the surface in a deep forest green.";
Constant SC_270 = "The train comes to a halt.";
Constant SC_271 = "The train hurtles away, leaving you behind.";
Constant SC_306 = "The train hurtles away, taking you with it.";
Constant SC_1042 = "The train is already here.";
Constant SC_773 = "The train is closed, locked, and shut down. Either the conductor is preparing it for storage and the anticipated flood, or he's already gone; either way, this doesn't look like the train is going anywhere anytime soon.";
Constant SC_1220 = "The train is hurtling along. ";
Constant SC_1040 = "The train is no longer running.";
Constant SC_1219 = "The train is outfitted on the inside with several seats, each upholstered in a dingy rust-colored corduroy at least twenty years old. At one end of the car is an access panel in dull, dented metal. ";
Constant SC_1123 = "The train is slowing down as it approaches you";
Constant SC_1124 = "The train is stopped here on the tracks, puffing steam";
Constant SC_272 = "The train rolls away, taking you with it.";
Constant SC_1222 = "The train rushes past the pond.";
Constant SC_264 = "The train starts to slow down.";
Constant SC_1267 = "The trees cluster around you into a dense mesh. You could probably push your way through them in any direction, but they're so uniform that you can't visually distinguish which way leads anywhere except to more woods.";
Constant SC_471 = "The trees get too dense and too dark in that direction.";
Constant SC_1433 = "The vending machine is labeled ~Pondside Times~";
Constant SC_1277 = "The warning light above the door is blinking";
Constant SC_1298 = "The water fountain is made of bronze; in a weird display of mimesis, the entire fountain body is shaped like a splash of water.";
Constant SC_1377 = "The water level is much higher than before. The dirt here has turned to mud, and you are almost sinking in your boots.";
Constant SC_490 = "The water level is up to the top of the stairs -- it was treacherous enough when the room wasn't flooded, but now, there's definitely no safe way to get down there.";
Constant SC_335 = "The water level rises alarmingly speedily.";
Constant SC_336 = "The water level rises faster than you can keep up with it, gushing, mud and dirt and little pieces of algae.";
Constant SC_1013 = "The water level rises over the boathouse, over the Waterworks, over the forest, over the tank, and you see the large wooden boat rising, floating on the water, sails unfurling, everyone in it, ";
Constant SC_343 = "The water swirls faster than you can handle -- up, around, over you --";
Constant SC_160 = "The wheel is mostly smooth and round, distinguished by a metal spike sticking out of one part of it and a substantial cavity denting it at another spot.";
Constant SC_509 = "The wheel spins freely around the pipe, but nothing happens.";
Constant SC_524 = "The wheel turns only a little further, and then you meet resistance.";
Constant SC_621 = "The wheel won't fit.";
Constant SC_870 = "The woman looks up and smiles at you. ~Can I help you?~";
Constant SC_696 = "The wooden sides of the boat are smooth, with little evidence that the boat has been to sea.";
Constant SC_364 = "The";
Constant SC_1195 = "Their";
Constant SC_1205 = "Theirs";
Constant SC_1200 = "Them";
Constant SC_288 = "Then a rush of water. A large gush of water erupts ";
Constant SC_1054 = "There are not actually any time limits in this game. Nothing important will pass you by irrevocably, and it shouldn't be possible to get yourself ";
Constant SC_636 = "There doesn't seem to be a way to unlock this with a key. You'll have to find another way in.";
Constant SC_1520 = "There is a deep crack in the south wall of the hut.";
Constant SC_1479 = "There is a single gadget on the pump: some kind of security gadget, with a keyhole in it, and featuring three small warning lights ";
Constant SC_1317 = "There is also a weedy island to the north.";
Constant SC_739 = "There is no more ";
Constant SC_819 = "There is no response";
Constant SC_1522 = "There seems to be ";
Constant SC_1574 = "There's no point to climbing that.";
Constant SC_564 = "There's not enough room up here to do that safely -- just a glance downward makes you dizzy.";
Constant SC_461 = "There's nothing down there but a mat of leaves.";
Constant SC_462 = "There's nothing down there.";
Constant SC_820 = "There's nothing here to swim in.";
Constant SC_667 = "They ~ting!~ softly in the wind.";
Constant SC_24 = "They are canary yellow, and should keep your feet dry in all but the most extreme of situations.";
Constant SC_16 = "They crunch satisfyingly under your feet.";
Constant SC_20 = "They crunch under your feet, and cling wetly to your boots.";
Constant SC_668 = "They don't make any noise when you're not shaking them.";
Constant SC_542 = "They play the same distorted melody.";
Constant SC_669 = "They ring with a melodious jangle -- a random cluster of tones that somehow manage to combine into a pleasing sound.";
Constant SC_152 = "They sparkle, but they seem cracked in places, disintegrating.";
Constant SC_128 = "They twist around the railroad tracks in curling tendrils.";
Constant SC_1189 = "They";
Constant SC_228 = "They're gone.";
Constant SC_695 = "They're too slender to support your weight, and the nearest branch is too far away.";
Constant SC_1064 = "Things seem to be ";
Constant SC_1538 = "This is an oval courtyard among the glass-pebble turrets and tall cylindrical towers of the city; behind them, you can see the smooth crystal streets of the city, all underwater, populated by more people wearing the twisty tubes, and behind that, the tall spire, stretching up above the water. Where normally you'd expect trees, grass, and flowers, you see coatings of algae, kelp twisted into ropy trees, ribbons of pondweed.";
Constant SC_1366 = "This is one large, single room, with a hardwood floor -- maybe once used for dancing, but now clearly empty, at least for today. The far wall is covered in a large painted mural";
Constant SC_81 = "This one-room brick building is paneled on the inside with thick slabs of wood; sunlight through the single window reflects lustrously off the panels. Against one of the walls is an old vending machine and a shelf.";
Constant SC_1184 = "Those";
Constant SC_1436 = "Through the plexiglass front you can just make out that the machine contains ";
Constant SC_840 = "Tightening ";
Constant SC_45 = "Tiny white birds, bobbing gently on the water.";
Constant SC_1795 = "To start a conversation, try to ASK ";
Constant SC_226 = "To start a conversation, try to ASK someone ABOUT something or TELL someone ABOUT something.";
Constant SC_1270 = "To the east is a broad brick building on which a lighted archway frames a";
Constant SC_1374 = "To the east is the shore of the familiar pond, with a few stone steps leading into the misty water, and in every other direction, you can enter the dense woods. Water is ";
Constant SC_297 = "To the east you think you can hear the faint lapping of the pond";
Constant SC_1278 = "To the west you can see what looks like a ";
Constant SC_143 = "Too far away for you to make out much detail, but something about them strikes you as unusual. Maybe it's just the fact that they're living underwater.";
Constant SC_1248 = "Trains rule!";
Constant SC_1493 = "Tucker B.";
Constant SC_1429 = "Twisty stairs lead up to the northeast, and to the southwest is a ";
Constant SC_94 = "Twisty, windblown trees, with sap oozing and dripping out of them.";
Constant SC_1428 = "Two slim, papery birch trees flank a set of rusty, vine-covered railroad tracks at the bottom of the hill. A sign reading ~FRESHWATER CROSSING~ hangs crookedly from one of the trees.";
Constant SC_1059 = "Type CREDITS for game credits.";
Constant SC_173 = "UNDO the last command";
Constant SC_978 = "Unlocking ";
Constant SC_1091 = "Visible on the pump are:";
Constant SC_480 = "Vivian and her family, friendly as they are, are clear in their expressions when you move to step outside the courtyard.";
Constant SC_299 = "Vivian dances impatiently";
Constant SC_1141 = "Vivian is jumping lightly on her toes.";
Constant SC_569 = "Vivian smiles when she sees you";
Constant SC_395 = "Vivian waves wistfully at you as you leave";
Constant SC_148 = "Vivian, Cordelia, and Douglas.";
Constant SC_446 = "Water continues to pour out of the two pipes, and the marsh is too treacherous to venture any direction except back to the railroad tracks, to the northeast.";
Constant SC_416 = "Water starts to gurgle forth from the fountain.";
Constant SC_333 = "Water starts to gush out of the pump.";
Constant SC_851 = "We're here.~ You get up and ";
Constant SC_1745 = "We're in the station now!";
Constant SC_992 = "Wet Area";
Constant SC_1010 = "Wet Beach";
Constant SC_179 = "Wet and Dark";
Constant SC_168 = "Wetlands is an interactive quagmire that leads you from the image of a fantastical city to a choice about the actual city's future, via a collection of mechanical puzzles in a watery setting.";
Constant SC_1061 = "Wetlands is written in Inform 7; thanks to the creators of this great tool and of the several extensions used in this game.	";
Constant SC_1047 = "Wetlands";
Constant SC_1562 = "What do you want";
Constant SC_1561 = "Whom do you want";
Constant SC_1098 = "With the help of the screwdriver, you are able to slide open what turns out to be a secret panel in the drawer, and reveal the small hiding space below it -- which contains ";
Constant SC_1126 = "Without holding ";
Constant SC_921 = "Would you like to ";
Constant SC_125 = "Wrapped around the masts.";
Constant SC_963 = "Y";
Constant SC_1744 = "Yep, we'll be in the station in a few minutes.";
Constant SC_926 = "You ";
Constant SC_437 = "You abandon the shining spire, the weedy island, the flooded beaches, the underwater city; you leave the people of Pondside to their rebuilding project, and leave the people of the Crystal City still underwater, suspended deep beneath the pond...";
Constant SC_586 = "You already took some sap.";
Constant SC_1315 = "You are able to boat right up to the crystal spire -- here it is, in its glittering glory.";
Constant SC_970 = "You are already riding ";
Constant SC_1445 = "You are ankle-deep in soft mud and tall grass. A rusty pipe sticks up out of the ground, spewing water, and another metal pipe sticks up out of the ground.";
Constant SC_1251 = "You are hanging on to the lowest branches of the ";
Constant SC_829 = "You are holding ";
Constant SC_1387 = "You are in a small opening in the otherwise almost impassably dense forest; someone appears to have chopped down a few trees to create some space directly around a particular large boulder -- the space is partially filled with a small cinderblock hut. ";
Constant SC_1362 = "You are in a small rowboat floating on the shallow, dirty water";
Constant SC_1444 = "You are knee-deep in soft mud and tall grass. Two pipes stick up out of the ground, both spewing water.";
Constant SC_973 = "You are not riding anything.";
Constant SC_1237 = "You are on a bench on the top of a small hill; in front of you the pond stretches into a blurry vista, with brightly colored trees and indistinct clusters of buildings lining the far shore, and bright leaves drift down from the sweetgum tree which rises directly above you.";
Constant SC_1318 = "You are sitting in a rowboat, floating on the pond. Everything around you -- from the blurry row of houses on the other side of the pond, to the twinkling crystal spire to the southwest, to the solid brick of the boat house behind you to the east -- fills you with peace.";
Constant SC_1268 = "You are standing on a paved ";
Constant SC_1363 = "You are standing on a stone step, knee-deep in water -- good thing you're wearing these boots -- and the water only gets deeper in front of you";
Constant SC_1239 = "You are standing on the top of a small hill, overlooking the ";
Constant SC_1260 = "You are surrounded by colorful ";
Constant SC_142 = "You are suspended under the water.  In the distance, below you, you can see the Crystal City -- the spire reaching up to the surface of the water is much taller than you'd imagined, and the pond much deeper, unless it's an optical illusion caused by light refracted in the water. The city shimmers oddly as the sunlight hits it at odd angles, twisted and reflected through the water.";
Constant SC_525 = "You are unable to turn the wheel further.";
Constant SC_567 = "You are very wet.";
Constant SC_830 = "You are wearing ";
Constant SC_849 = "You awake with a jolt, uncertain how long you've slept, as the conductor taps you on the shoulder. ~";
Constant SC_1106 = "You bark your best imitation of a dog. ";
Constant SC_1109 = "You bark. The dog barks back. ";
Constant SC_814 = "You blow on ";
Constant SC_943 = "You can ";
Constant SC_949 = "You can ROW a direction WITH something to paddle with.";
Constant SC_42 = "You can barely make out its gray roof.";
Constant SC_1020 = "You can hardly pour ";
Constant SC_866 = "You can hear the rowboat outside bumping against the door.";
Constant SC_841 = "You can just make out the rowboat floating near the ";
Constant SC_703 = "You can just reach the bottom-most rung from here.";
Constant SC_175 = "You can only have one item here. Which exactly?";
Constant SC_232 = "You can row the boat to where you want to go.";
Constant SC_1378 = "You can see the faint traces in the mud left by your boat as the pond's rising carried it back toward the boat house.";
Constant SC_500 = "You can see the pond from here, but you can't access it.";
Constant SC_1341 = "You can see the structure to the west more clearly now -- it looks like a small boat-house or spring-house -- and it's probably close enough to wade";
Constant SC_96 = "You can see the words ~Pondside Waterworks~ painted on the door.";
Constant SC_674 = "You can't -- it's painted shut.";
Constant SC_583 = "You can't do that while ";
Constant SC_768 = "You can't drink anything while you're wearing the diving mask.";
Constant SC_1571 = "You can't even see ";
Constant SC_752 = "You can't exactly drink ";
Constant SC_1027 = "You can't fill ";
Constant SC_1097 = "You can't get enough leverage using that.";
Constant SC_550 = "You can't get to that while the drawer is right side up.";
Constant SC_549 = "You can't get to that while the drawer is upside down.";
Constant SC_137 = "You can't make out any details from here.";
Constant SC_557 = "You can't make out any details through the plexiglass.";
Constant SC_843 = "You can't pick that!";
Constant SC_1017 = "You can't pour ";
Constant SC_410 = "You can't reach ";
Constant SC_547 = "You can't reach it from here.";
Constant SC_728 = "You can't reach it; it's inside the pump's crystal shell.";
Constant SC_469 = "You can't reach the rest of the tree -- you can only go down from here.";
Constant SC_704 = "You can't reach the rungs -- the bottom-most rung is several inches too high for you to reach.";
Constant SC_694 = "You can't reach them.";
Constant SC_670 = "You can't see a way to get them off the tree, and besides, they look so picturesque here.";
Constant SC_982 = "You can't see anything promising that way.";
Constant SC_428 = "You can't see how to row to that from here.";
Constant SC_522 = "You can't see it from here.";
Constant SC_1383 = "You can't see it";
Constant SC_599 = "You can't seem to fit ";
Constant SC_1087 = "You can't seem to plug ";
Constant SC_510 = "You can't seem to push with enough force to get anything moving.";
Constant SC_426 = "You can't seem to see which way to row.";
Constant SC_1100 = "You can't skip that!";
Constant SC_1101 = "You can't skip the rock without water to skip it on.";
Constant SC_1034 = "You can't spill that!";
Constant SC_935 = "You can't take it while you're standing on it.";
Constant SC_451 = "You can't take the boat out of the water.";
Constant SC_1110 = "You can't type on that!";
Constant SC_837 = "You can't wade from here.";
Constant SC_822 = "You catch a faint damp, muddy whiff.";
Constant SC_399 = "You clamber down from the tree.";
Constant SC_402 = "You clatter down the twisting staircase. ";
Constant SC_400 = "You climb down the rungs and drop to the ground, giving yourself a nasty jolt as you drop";
Constant SC_760 = "You consider leaping from the moving train, but think better of it.";
Constant SC_718 = "You consider yourself pretty good with technology, but you're not really sure which of the levers or gizmos or gadgets you should manipulate.";
Constant SC_859 = "You curl up on the bench and toss and turn for a few minutes...";
Constant SC_861 = "You curl up on the carpet of needles and fall into a restless sleep...";
Constant SC_811 = "You curse in frustration.";
Constant SC_693 = "You dig in the sand, but find nothing further.";
Constant SC_691 = "You dig in the sand, in the spot where the metal detector beeps the most intensely, and find a large magnet.";
Constant SC_974 = "You dismount ";
Constant SC_565 = "You dive in...";
Constant SC_1082 = "You don't have that!";
Constant SC_987 = "You don't know where ";
Constant SC_423 = "You don't see a train here.";
Constant SC_1094 = "You don't see any gizmoes.";
Constant SC_1090 = "You don't see any levers.";
Constant SC_1093 = "You don't see any switches.";
Constant SC_1799 = "You don't see that here";
Constant SC_1505 = "You don't understand the details, but it's clear that there are four different pumps that are hubs of the system:";
Constant SC_637 = "You don't want to get ";
Constant SC_635 = "You don't want to take it with your hands.";
Constant SC_447 = "You drift around, not rowing toward any particular landmark.";
Constant SC_744 = "You drink some ";
Constant SC_673 = "You drop back down to the ground.";
Constant SC_534 = "You drop the stick, but the dog runs toward it, picks it up, and returns it to you.";
Constant SC_627 = "You dump out ";
Constant SC_1077 = "You feel a faint chill, like the echo of a hollow voice.";
Constant SC_874 = "You feel a tingle as you realize how close you must be to the Crystal City.";
Constant SC_1540 = "You feel strangely elated just to be here.";
Constant SC_1153 = "You feel the rope cut into your back as ";
Constant SC_313 = "You feel the wind ruffle your hair";
Constant SC_884 = "You fill ";
Constant SC_1095 = "You flip ";
Constant SC_1421 = "You flip through the pages of ";
Constant SC_1570 = "You fumble around in the dark, but can't seem to do much.";
Constant SC_842 = "You fumble around, but you really don't have the skills to pick a lock.";
Constant SC_1572 = "You get a hold of yourself.";
Constant SC_1800 = "You grab a leaf from the air, but then let go -- it's not important";
Constant SC_578 = "You hand the page to ";
Constant SC_647 = "You have a feeling you're better off keeping them on... it seems like things are likely to get pretty muddy around here.";
Constant SC_1067 = "You have completed:";
Constant SC_438 = "You have decided not to restore the Crystal City.";
Constant SC_434 = "You have decided not to satisfy your curiosity.";
Constant SC_436 = "You have decided to leave well enough alone.";
Constant SC_432 = "You have given up.";
Constant SC_705 = "You have no leverage to turn it with.";
Constant SC_751 = "You have no source of fire, and probably don't want to destroy ";
Constant SC_749 = "You have nothing to cut with, and probably don't want to destroy ";
Constant SC_1016 = "You have restored the Crystal City!";
Constant SC_968 = "You have to be holding it.";
Constant SC_231 = "You have to row in a particular direction.";
Constant SC_920 = "You have to specify which direction to row in.";
Constant SC_1113 = "You hear a ~bzzt~ from what sounds like deep within the boulder, but nothing else happens.";
Constant SC_1111 = "You hear a ~click~ from the hut... and then a moment later, the door slides open.";
Constant SC_1112 = "You hear a click from the hut, but since the door is already open, nothing further happens.";
Constant SC_243 = "You hear a faint tinkling sound";
Constant SC_761 = "You hear a faint tinkling.";
Constant SC_287 = "You hear a loud crack from the Waterworks --";
Constant SC_1073 = "You hear a splash, and turn to the pond -- you catch just a glimpse of a heron's wings as it dives underwater";
Constant SC_347 = "You hear a tearing sound from the pump as the metal wheel cuts through the insubstantial ";
Constant SC_265 = "You hear a";
Constant SC_706 = "You hit the box, and it rings with a clear vibration.";
Constant SC_676 = "You hit the vending machine with a satisfying ~thwack!~. It shakes a little, but remains intact, and seems to be made of stuff too solid for you to damage.";
Constant SC_672 = "You hoist yourself up and climb a few branches, but you don't find anything interesting.";
Constant SC_816 = "You hum a few bars.";
Constant SC_404 = "You ignore the secretary's warning, and clatter down the twisting staircase. ";
Constant SC_1566 = "You juggle what you're holding in a futile attempt, but you really can't carry anything more in your hands.";
Constant SC_1467 = "You just see the ceiling.";
Constant SC_733 = "You knock on ";
Constant SC_511 = "You knock on the door. After a moment, ";
Constant SC_976 = "You lack a key that fits ";
Constant SC_560 = "You leap up from ";
Constant SC_563 = "You leap up from the ground and try to grab the bottom branch of the tree, but your fingers just brush it and you can't get a grip.";
Constant SC_821 = "You leap up, and are several inches off the ground before gravity returns you to it.";
Constant SC_766 = "You leap up, and just grab the bottom-most rung. From there you easily climb the long series of rungs to the top of the tank.";
Constant SC_763 = "You leap up, and scrape your fingers against the smooth side of the cylinder, but the top is still inaccessible to you.";
Constant SC_397 = "You make your way up the treacherous stairs";
Constant SC_969 = "You manage to pull yourself up to the top of the fence and drop down on the other side, without causing yourself too much damage.";
Constant SC_971 = "You mount ";
Constant SC_774 = "You only sink further.";
Constant SC_1131 = "You open ";
Constant SC_961 = "You open the vending machine, revealing ";
Constant SC_342 = "You paddle helplessly in the dirty water, mud, crumbling leaves, algae bobbing and swirling around you.";
Constant SC_570 = "You peer into ";
Constant SC_491 = "You peer into the door. The entire floor seems to have collapsed, leaving only a deep, gaping hole and an ominous pool of muddy water, algae and dirt and little twigs swirling and bobbing. There's no way you could enter safely, and no chance that anything inside hasn't been ruined by the water.";
Constant SC_439 = "You peer into the murky water, but decide against entering it without a boat.";
Constant SC_1604 = "You peer into the water. Behind the pile of sticks, you can see a large rusty pipe under the water, visible through the blue-green undulating waves";
Constant SC_666 = "You pick up a few, but then let them drift through your fingers again; you don't need to carry them around.";
Constant SC_592 = "You poke ";
Constant SC_812 = "You ponder your situation.";
Constant SC_657 = "You pound on the cylinder, but seems to be impervious to your efforts.";
Constant SC_1036 = "You pour the ";
Constant SC_960 = "You press firmly on the outline, but you can't get the wood to budge with your fingers; you need more leverage.";
Constant SC_689 = "You probably have enough. You have better things to do than cart rocks around all day.";
Constant SC_543 = "You pull the mask away from your face -- and immediately get a lungful of water. Choking and spluttering, you quickly replace the mask, and gratefully breathe in air from the tank.";
Constant SC_1089 = "You push the clump of sap up against the hole in the leaky hose. The flow of water strains against the makeshift seal -- and the seal holds.";
Constant SC_677 = "You push the vending machine; it shakes a little, but seems to be firmly fixed in place.";
Constant SC_1079 = "You rap your knuckles against ";
Constant SC_1044 = "You really haven't got that kind of patience.";
Constant SC_762 = "You rock the boat.";
Constant SC_427 = "You row toward ";
Constant SC_587 = "You scrape a clump of sticky sap into the bottle.";
Constant SC_956 = "You screw the ";
Constant SC_983 = "You see ";
Constant SC_893 = "You see a paddling of ducks bobbing on the water.";
Constant SC_442 = "You see no way to open it.";
Constant SC_769 = "You see only a blurred shaft of sunlight through the water.";
Constant SC_1012 = "You see the muddy water of what's left of the pond gurgle, and spin outwards, forced out of the pond and over the shoreline -- or what used to be the shoreline --";
Constant SC_844 = "You settle down on one of the seats and nap fitfully, soothed by the gentle rumble of the train; you dream of ";
Constant SC_649 = "You shake the rusty fence, but it shows no signs of giving way.";
Constant SC_331 = "You shiver a little in the fog";
Constant SC_332 = "You shiver, a little shaken by what's happened to the Waterworks. But your curiosity about the Crystal City is as strong as ever.";
Constant SC_954 = "You sit down on one of the dingy seats.";
Constant SC_953 = "You sit down on one of the seats... it's certainly seen better days. The damage ranges from the clear evidence of spilled coffee to a few cigarette burns.";
Constant SC_1102 = "You skip the small, disclike rock across the smooth service of the water -- ";
Constant SC_860 = "You slowly open your eyes, uncertain how long you've slept.";
Constant SC_962 = "You sneak a glance at the conductor -- he's still wrapped up talking about trains, and doesn't seem to be paying attention to you. Feeling a bit guilty, y";
Constant SC_1105 = "You squelch knee-deep in the marsh, which is getting wetter every moment.";
Constant SC_1043 = "You stand around, keeping an eye out for the train.";
Constant SC_1577 = "You stare vaguely at nothing for a minute";
Constant SC_403 = "You start to slip, but catch yourself just in time.";
Constant SC_504 = "You still can't reach ";
Constant SC_653 = "You strip back part of the paint, and see that there's another picture underneath this mural -- a picture of shining turrets and translucent eggs. The Crystal City, of course.";
Constant SC_473 = "You take a few steps to ";
Constant SC_741 = "You take a sip of ";
Constant SC_940 = "You take a step to ";
Constant SC_771 = "You take a step toward the train, but then stop. ";
Constant SC_262 = "You think about how to alert the people of the Crystal City that you're here.";
Constant SC_937 = "You thread the flagpole through ";
Constant SC_966 = "You throw ";
Constant SC_838 = "You tighten the janky bolt on the square gizmo, and switch it on. It starts to twitch a little.";
Constant SC_605 = "You toss ";
Constant SC_556 = "You toss the pinecone to the dog; the dog catches it in its mouth and returns it to you.";
Constant SC_260 = "You tread water in the almost eerie silence.";
Constant SC_475 = "You tromp through the trees for a few steps, but it feels like you might have just walked in a circle.";
Constant SC_429 = "You trudge back along the path from which you came";
Constant SC_433 = "You trudge back along the path from which you came, leaving the strange world of pond and trains behind. You may never find out what's at the bottom of that spire. But you don't have to know everything, do you?";
Constant SC_692 = "You try digging in the sand, but without having a better idea of where to dig, you aren't that likely to find anything.";
Constant SC_344 = "You try to find something to grab onto, but only briefly touch ";
Constant SC_858 = "You try to get comfortable, but you just toss and turn on the train seat.";
Constant SC_757 = "You try to get on the train, but the conductor";
Constant SC_947 = "You try to grab the bottom branch, but you're just a foot or so short of being able to reach it.";
Constant SC_697 = "You try to press your hand against the boat, just as ";
Constant SC_777 = "You try to speak, but with the diving mask on it just comes out an incomprehensible burble.";
Constant SC_623 = "You try to stick the sap onto ";
Constant SC_465 = "You try to swim downward, but your own natural buoyancy, plus the tank of air that you need to breathe, push you back up toward the surface.";
Constant SC_610 = "You try to wedge the ";
Constant SC_887 = "You turn ";
Constant SC_897 = "You turn off ";
Constant SC_899 = "You turn on the flashlight. Its beam is weak compared to the sunlight.";
Constant SC_680 = "You turn the drawer right side up.";
Constant SC_681 = "You turn the drawer upside down";
Constant SC_523 = "You turn the wheel, and because the flagpole is threaded through the wheel and pipe, the pipe turns with it. You hear a grinding noise. You keep turning.";
Constant SC_1576 = "You twiddle your thumbs";
Constant SC_1084 = "You twirl around.";
Constant SC_886 = "You unlock the structure with ";
Constant SC_958 = "You unscrew the ";
Constant SC_396 = "You wade a few feet up to the structure.";
Constant SC_507 = "You wade back to the beach.";
Constant SC_948 = "You wade into the water a few steps, but retreat before it gets too deep.";
Constant SC_862 = "You wake with a start and stand up, uncertain how long you've slept.";
Constant SC_950 = "You walk into something very wet, and just manage to catch your balance.";
Constant SC_645 = "You wave the flag proudly.";
Constant SC_643 = "You wave the flag proudly; it billows in the wind.";
Constant SC_826 = "You wave your hands, feeling the cool, damp ";
Constant SC_678 = "You wipe off some dust, but it's clear there's nothing interesting under there.";
Constant SC_679 = "You wipe off some of the dust, but the only result is a clearer view of the hill outside.";
Constant SC_686 = "You won't gain much height from just standing ";
Constant SC_559 = "You would lose it forever.";
Constant SC_538 = "You would need to unscrew it.";
Constant SC_671 = "You would only hurt the trees by doing that.";
Constant SC_629 = "You would spill it.";
Constant SC_1185 = "You";
Constant SC_640 = "You'd have to be a bit more of a contortionist.";
Constant SC_533 = "You'd have to be in the tree to reach them.";
Constant SC_409 = "You'd have to climb the tree to reach them.";
Constant SC_650 = "You'd have to get up to the edge of the pond first.";
Constant SC_685 = "You'd have to put it down first.";
Constant SC_225 = "You'll have to be more specific about how.";
Constant SC_424 = "You'll have to be more specific about which way you want to go.";
Constant SC_1557 = "You'll have to try a more specific verb than use.";
Constant SC_103 = "You'll want to hang on to this, since the staircase looks easy to slip on.";
Constant SC_421 = "You're already on the train.";
Constant SC_770 = "You're already swimming!";
Constant SC_425 = "You're already there!";
Constant SC_237 = "You're in it!";
Constant SC_1575 = "You're not asleep.";
Constant SC_1573 = "You're not hungry.";
Constant SC_1081 = "You're not in anything rowable.";
Constant SC_1041 = "You're not likely to have much luck waiting for a train here.";
Constant SC_493 = "You're not really surprised when your boot meets the familiar squelch of unstable mud ";
Constant SC_863 = "You're not so sleepy that you'd nap here; there's nowhere very comfortable to rest.";
Constant SC_467 = "You're stuck in mud to your waist, and trying to move only entrenches you deeper.";
Constant SC_634 = "You've already bypassed the pump's security measure.";
Constant SC_654 = "You've already peeled back as much of the paint as you can.";
Constant SC_1283 = "You've always considered yourself pretty average in the physical department  -- average height, average build, average looks. Maybe a little more athletic than the average person, or with a slightly better sense of direction.";
Constant SC_435 = "You've done enough damage here. You turn away from the flooded Waterworks, hoping that the people of Pondside won't have too much trouble rebuilding it. Much as you would have loved to see the city, to visit it, to bask in its energies, it's not worth the havoc you'd cause.";
Constant SC_1078 = "Your knuckles make no sound against ";
Constant SC_1565 = "Your mind is a blank.";
Constant SC_337 = "Your mouth and nose fill with it -- you try to escape, but you can't, you're sinking--";
Constant SC_817 = "Your voice echoes. ";
Constant SC_1196 = "Your";
Constant SC_1206 = "Yours";
Constant SC_1121 = "a conductor is standing in the car's open door";
Constant SC_1228 = "a couple of birch trees";
Constant SC_1229 = "a dirty clearing";
Constant SC_1353 = "a small secret panel on the bottom of the drawer is open, revealing ";
Constant SC_1164 = "a swallow or two";
Constant SC_512 = "a woman";
Constant SC_1486 = "ablaze in brilliantly autumnal ";
Constant SC_1166 = "about ";
Constant SC_1615 = "above";
Constant SC_187 = "acquiring a flashlight";
Constant SC_188 = "acquiring a screwdriver";
Constant SC_189 = "acquiring a wrench";
Constant SC_828 = "air";
Constant SC_1382 = "along the edge of the water";
Constant SC_931 = "also ";
Constant SC_1227 = "an occasional glimpse of the pond";
Constant SC_1545 = "and rotating";
Constant SC_515 = "and welcomes you in";
Constant SC_1336 = "ankle-deep in pond water";
Constant SC_406 = "another";
Constant SC_1623 = "any";
Constant SC_1162 = "are";
Constant SC_790 = "asked";
Constant SC_191 = "attracting the attention of the city";
Constant SC_1136 = "banging";
Constant SC_495 = "before you can reach the train";
Constant SC_847 = "being in a boat, a small boat, and somehow it tips over and you're drowning, drowning...";
Constant SC_1617 = "below";
Constant SC_1263 = "birch and maple";
Constant SC_1217 = "blinking wildly";
Constant SC_88 = "boat";
Constant SC_1343 = "boat-house";
Constant SC_43 = "bunch of rocks";
Constant SC_930 = "can ";
Constant SC_1412 = "carefully sketching something in a notebook";
Constant SC_292 = "carrying the red keychain with it and ";
Constant SC_246 = "chimes";
Constant SC_184 = "climbing the fence";
Constant SC_195 = "climbing the tank";
Constant SC_1312 = "closed";
Constant SC_793 = "course";
Constant SC_1253 = "crimson and ochre";
Constant SC_1135 = "crunching";
Constant SC_34 = "crystal spire";
Constant SC_1390 = "d the image of a splash of water onto the boulder.";
Constant SC_498 = "down the hill ";
Constant SC_918 = "down";
Constant SC_238 = "dry land";
Constant SC_1599 = "e always wanted it to be reversible, because, even though they were interested in living underwater, it didn't seem fair for it to be permanent. There's a lot of pumps, some of them hydraulics that move the earth, some of them moving water around, some of them both. We've had a lot of debates, among ourselves, and with them, about whether we ";
Constant SC_944 = "easily";
Constant SC_1598 = "ell, w";
Constant SC_911 = "empty ";
Constant SC_204 = "entering the Pump Room";
Constant SC_196 = "entering the boathouse";
Constant SC_1181 = "es";
Constant SC_882 = "exciting";
Constant SC_1649 = "experts";
Constant SC_190 = "finding a key";
Constant SC_193 = "finding a magnet";
Constant SC_185 = "finding a ticket";
Constant SC_1215 = "flipped down";
Constant SC_1214 = "flipped up";
Constant SC_1334 = "flooded ";
Constant SC_1039 = "floor";
Constant SC_30 = "fountain";
Constant SC_186 = "getting on a train";
Constant SC_200 = "getting underwater";
Constant SC_1452 = "grass";
Constant SC_483 = "grimaces";
Constant SC_1038 = "ground";
Constant SC_514 = "grudgingly";
Constant SC_1003 = "gushing along";
Constant SC_1352 = "has a pattern of grooves on the bottom, outlining a small raised square";
Constant SC_1473 = "has a small hole in it, spewing water";
Constant SC_1177 = "has";
Constant SC_1176 = "have";
Constant SC_1160 = "he";
Constant SC_1630 = "heard";
Constant SC_981 = "hello";
Constant SC_1157 = "her";
Constant SC_1204 = "hers";
Constant SC_1156 = "him";
Constant SC_1193 = "his";
Constant SC_1183 = "ies";
Constant SC_836 = "in the right pocket ";
Constant SC_687 = "in";
Constant SC_1252 = "indigo and crimson";
Constant SC_1472 = "is plugged up with a clump of sap";
Constant SC_1354 = "is turned upside down";
Constant SC_1163 = "is";
Constant SC_1405 = "it looks empty";
Constant SC_1158 = "it";
Constant SC_1194 = "its";
Constant SC_1005 = "itself";
Constant SC_294 = "just beachy";
Constant SC_945 = "just";
Constant SC_477 = "kick your legs";
Constant SC_824 = "lapping of the pond";
Constant SC_197 = "launching the boat";
Constant SC_293 = "leaving a dirty puddle on the path.";
Constant SC_1337 = "littered with small disclike rocks";
Constant SC_1411 = "looking at you through narrowed eyes";
Constant SC_281 = "m really not supposed to let you mess with the pump!~";
Constant SC_1587 = "making";
Constant SC_1516 = "maple";
Constant SC_1301 = "mostly underground";
Constant SC_478 = "move your arms";
Constant SC_1453 = "mud";
Constant SC_266 = "n approaching";
Constant SC_1272 = "n open";
Constant SC_596 = "n't the right shape to stay put there, and clatter";
Constant SC_494 = "near the bottom of the steps";
Constant SC_245 = "notes";
Constant SC_1132 = "nothing.";
Constant SC_1262 = "oak and birch";
Constant SC_1515 = "oak";
Constant SC_1254 = "ochre and saffron";
Constant SC_1450 = "on the ground";
Constant SC_407 = "one";
Constant SC_1313 = "open";
Constant SC_202 = "opening a secret panel";
Constant SC_964 = "ou open ";
Constant SC_289 = "out the door";
Constant SC_1533 = "people";
Constant SC_595 = "pipe, but ";
Constant SC_846 = "plodding through an endless and seemingly identical parade of pondside beaches, digging in each one for something very important, you know it's important but you don't know what it is...";
Constant SC_1477 = "pretty janky";
Constant SC_1653 = "private";
Constant SC_1376 = "pumping steadily up onto the steps from an unseen hole";
Constant SC_177 = "put things in";
Constant SC_178 = "put things on";
Constant SC_115 = "raised square";
Constant SC_1180 = "re";
Constant SC_240 = "real";
Constant SC_1055 = "really";
Constant SC_1339 = "reflects off the crystal spire that emerges from the center of the pond";
Constant SC_376 = "right side up";
Constant SC_1290 = "royal, intelligent trees";
Constant SC_852 = "rub your eyes";
Constant SC_1489 = "s about an inch or so wide; it's designed to take a coin, and thus unlock the machine.";
Constant SC_597 = "s";
Constant SC_1255 = "saffron and tyrian purple";
Constant SC_1288 = "scholarly dinosaurs";
Constant SC_1287 = "scuba-diving princesses";
Constant SC_1099 = "secret panel";
Constant SC_839 = "secure bolt";
Constant SC_932 = "see ";
Constant SC_171 = "see some suggestions for AMUSING things to do";
Constant SC_993 = "shaking and quaking";
Constant SC_1161 = "she";
Constant SC_1335 = "shoreline, ";
Constant SC_1600 = "should";
Constant SC_1449 = "sinking slowly into the mud";
Constant SC_854 = "smile, embarrassed, at the conductor";
Constant SC_47 = "some";
Constant SC_295 = "starting to trickle";
Constant SC_1218 = "still and dark.";
Constant SC_1168 = "still on dry land";
Constant SC_1543 = "stopped";
Constant SC_853 = "stretch";
Constant SC_1340 = "strikes the rippling pond";
Constant SC_1344 = "structure";
Constant SC_1381 = "submerged under the water";
Constant SC_1264 = "sweetgum and birch";
Constant SC_1261 = "sweetgum and maple";
Constant SC_1265 = "sweetgum and oak";
Constant SC_1514 = "sweetgum";
Constant SC_612 = "t seem to fit.";
Constant SC_176 = "take things from";
Constant SC_1481 = "that are blinking ominously";
Constant SC_1480 = "that are currently off";
Constant SC_1401 = "that looks closed and empty";
Constant SC_1188 = "that";
Constant SC_1116 = "that's";
Constant SC_284 = "the beach";
Constant SC_561 = "the bench";
Constant SC_1485 = "the bottom branch just out of your reach, ";
Constant SC_1612 = "the city";
Constant SC_256 = "the drawer";
Constant SC_938 = "the holes in the wheel and pipe, anchoring the wheel to the pipe";
Constant SC_939 = "the pipe";
Constant SC_835 = "the right pocket is empty";
Constant SC_255 = "the rocky beach";
Constant SC_254 = "the top of your wet boot";
Constant SC_1122 = "the train is completely closed and silent";
Constant SC_6 = "the";
Constant SC_1191 = "their";
Constant SC_1202 = "theirs";
Constant SC_1155 = "them";
Constant SC_1159 = "they";
Constant SC_1187 = "those";
Constant SC_497 = "through the trees ";
Constant SC_1406 = "through the window, you can just make out a father and daughter playing a game together";
Constant SC_482 = "tightens her lips";
Constant SC_486 = "told";
Constant SC_1070 = "total score: ";
Constant SC_1478 = "totally secure";
Constant SC_203 = "traveling to further parts of the pond";
Constant SC_192 = "traveling to other parts of the pond";
Constant SC_1226 = "trees zooming by";
Constant SC_1375 = "trickling faintly onto the wet steps from underground";
Constant SC_1733 = "try";
Constant SC_199 = "turning on the big pump";
Constant SC_198 = "turning on the complicated pump";
Constant SC_194 = "turning on the underground pump";
Constant SC_201 = "turning on the underwater pump";
Constant SC_1542 = "turning slowly clockwise";
Constant SC_1249 = "u r living ur life";
Constant SC_290 = "under the door";
Constant SC_1510 = "under the pond itself";
Constant SC_1302 = "underwater";
Constant SC_917 = "up";
Constant SC_375 = "upside down";
Constant SC_845 = "wandering through the Crystal City, enveloped in its glittering reflections, sharing a deep love with its inhabitants.";
Constant SC_827 = "water";
Constant SC_1289 = "webbed, finned astronauts";
Constant SC_566 = "wet, wet, wet all over";
Constant SC_1564 = "what do you want";
Constant SC_594 = "wheel and ";
Constant SC_825 = "whistle of the wind";
Constant SC_1563 = "whom do you want";
Constant SC_1402 = "with a family visible through the window";
Constant SC_114 = "wooden drawer";
Constant SC_1182 = "y";
Constant SC_1546 = "yet not moving forward";
Constant SC_499 = "you can make out the train, more completely still than you've ever seen it, wheel-deep in a muddy film of water that covers the tracks.";
Constant SC_529 = "you";
Constant SC_1192 = "your";
Constant SC_1203 = "yours";
Constant SC_1128 = "{";
Constant SC_1130 = "}";
Constant SC_181 = "@@126";

#ifndef p0_specification; Constant p0_specification = 0; #endif;
#ifndef p1_indefinite_appearance_tex; Constant p1_indefinite_appearance_tex = 0; #endif;
#ifndef p2_variable_initial_value; Constant p2_variable_initial_value = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef map_region; Constant map_region = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef p9_opposite; Constant p9_opposite = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef p13_last_location; Constant p13_last_location = 0; #endif;
#ifndef p14_fluid_capacity; Constant p14_fluid_capacity = 0; #endif;
#ifndef p15_current_volume; Constant p15_current_volume = 0; #endif;
#ifndef p16_station; Constant p16_station = 0; #endif;
#ifndef p17_apology; Constant p17_apology = 0; #endif;
#ifndef pluralname; Constant pluralname = 0; #endif;
#ifndef proper; Constant proper = 0; #endif;
#ifndef privately_named; Constant privately_named = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef mentioned; Constant mentioned = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef p59_recurring; Constant p59_recurring = 0; #endif;
#ifndef p61_stashable; Constant p61_stashable = 0; #endif;
#ifndef p63_chavailable; Constant p63_chavailable = 0; #endif;
#ifndef p65_chviable; Constant p65_chviable = 0; #endif;
#ifndef p67_unbolting; Constant p67_unbolting = 0; #endif;
#ifndef p68_message_text; Constant p68_message_text = 0; #endif;
#ifndef p69_dbg_on; Constant p69_dbg_on = 0; #endif;
#ifndef p71_ambiguously_plural; Constant p71_ambiguously_plural = 0; #endif;
#ifndef p73_examined; Constant p73_examined = 0; #endif;
#ifndef p75_accessed; Constant p75_accessed = 0; #endif;
#ifndef p77_indoors; Constant p77_indoors = 0; #endif;
#ifndef p79_pocketed; Constant p79_pocketed = 0; #endif;
#ifndef p81_metal; Constant p81_metal = 0; #endif;
#ifndef p83_moved; Constant p83_moved = 0; #endif;
#ifndef p85_liquid; Constant p85_liquid = 0; #endif;
#ifndef p86_soft; Constant p86_soft = 0; #endif;
#ifndef p88_boaty; Constant p88_boaty = 0; #endif;
#ifndef p90_peeled; Constant p90_peeled = 0; #endif;
#ifndef p92_irked; Constant p92_irked = 0; #endif;
#ifndef p94_curious; Constant p94_curious = 0; #endif;
#ifndef p96_plugged; Constant p96_plugged = 0; #endif;
#ifndef p98_fixed; Constant p98_fixed = 0; #endif;
#ifndef p100_secure; Constant p100_secure = 0; #endif;
#ifndef p102_flipped_up; Constant p102_flipped_up = 0; #endif;
#ifndef p104_important; Constant p104_important = 0; #endif;
#ifndef p106_upside_down; Constant p106_upside_down = 0; #endif;
#ifndef p108_trapped; Constant p108_trapped = 0; #endif;
#ifndef p110_roaming; Constant p110_roaming = 0; #endif;
#ifndef p112_keyed; Constant p112_keyed = 0; #endif;
#ifndef p114_flooded; Constant p114_flooded = 0; #endif;
#ifndef p116_spinning; Constant p116_spinning = 0; #endif;
#ifndef p118_accessible; Constant p118_accessible = 0; #endif;
#ifndef p120_approaching; Constant p120_approaching = 0; #endif;
#ifndef p121_satisfied; Constant p121_satisfied = 0; #endif;
#ifndef p123_distracted; Constant p123_distracted = 0; #endif;
#ifndef p125_asleep; Constant p125_asleep = 0; #endif;
#ifndef worn; Constant worn = 0; #endif;
#ifndef vector; Constant vector = 0; #endif;
#ifndef room_index; Constant room_index = 0; #endif;
#ifndef door_dir; Constant door_dir = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef found_in; Constant found_in = 0; #endif;
#ifndef absent; Constant absent = 0; #endif;
#ifndef list_together; Constant list_together = 0; #endif;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef mark_as_room; Constant mark_as_room = 0; #endif;
#ifndef mark_as_thing; Constant mark_as_thing = 0; #endif;
#ifndef component_parent; Constant component_parent = 0; #endif;
#ifndef component_child; Constant component_child = 0; #endif;
#ifndef component_sibling; Constant component_sibling = 0; #endif;
#ifndef regional_found_in; Constant regional_found_in = 0; #endif;
#ifndef IK1_Count; Constant IK1_Count = 0; #endif;
#ifndef IK1_Link; Constant IK1_Link = 0; #endif;
#ifndef IK2_Count; Constant IK2_Count = 0; #endif;
#ifndef IK2_Link; Constant IK2_Link = 0; #endif;
#ifndef IK3_Count; Constant IK3_Count = 0; #endif;
#ifndef IK3_Link; Constant IK3_Link = 0; #endif;
#ifndef IK4_Count; Constant IK4_Count = 0; #endif;
#ifndef IK4_Link; Constant IK4_Link = 0; #endif;
#ifndef IK5_Count; Constant IK5_Count = 0; #endif;
#ifndef IK5_Link; Constant IK5_Link = 0; #endif;
#ifndef IK6_Count; Constant IK6_Count = 0; #endif;
#ifndef IK6_Link; Constant IK6_Link = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef IK7_Link; Constant IK7_Link = 0; #endif;
#ifndef IK8_Count; Constant IK8_Count = 0; #endif;
#ifndef IK8_Link; Constant IK8_Link = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef IK9_Link; Constant IK9_Link = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef IK10_Link; Constant IK10_Link = 0; #endif;
#ifndef IK11_Count; Constant IK11_Count = 0; #endif;
#ifndef IK11_Link; Constant IK11_Link = 0; #endif;
#ifndef IK12_Count; Constant IK12_Count = 0; #endif;
#ifndef IK12_Link; Constant IK12_Link = 0; #endif;
#ifndef IK13_Count; Constant IK13_Count = 0; #endif;
#ifndef IK13_Link; Constant IK13_Link = 0; #endif;
#ifndef IK14_Count; Constant IK14_Count = 0; #endif;
#ifndef IK14_Link; Constant IK14_Link = 0; #endif;
#ifndef IK15_Count; Constant IK15_Count = 0; #endif;
#ifndef IK15_Link; Constant IK15_Link = 0; #endif;
#ifndef IK16_Count; Constant IK16_Count = 0; #endif;
#ifndef IK16_Link; Constant IK16_Link = 0; #endif;
#ifndef IK17_Count; Constant IK17_Count = 0; #endif;
#ifndef IK17_Link; Constant IK17_Link = 0; #endif;
#ifndef IK18_Count; Constant IK18_Count = 0; #endif;
#ifndef IK18_Link; Constant IK18_Link = 0; #endif;
#ifndef IK19_Count; Constant IK19_Count = 0; #endif;
#ifndef IK19_Link; Constant IK19_Link = 0; #endif;
#ifndef IK20_Count; Constant IK20_Count = 0; #endif;
#ifndef IK20_Link; Constant IK20_Link = 0; #endif;
#ifndef IK21_Count; Constant IK21_Count = 0; #endif;
#ifndef IK21_Link; Constant IK21_Link = 0; #endif;
#ifndef IK22_Count; Constant IK22_Count = 0; #endif;
#ifndef IK22_Link; Constant IK22_Link = 0; #endif;
#ifndef IK23_Count; Constant IK23_Count = 0; #endif;
#ifndef IK23_Link; Constant IK23_Link = 0; #endif;
#ifndef IK24_Count; Constant IK24_Count = 0; #endif;
#ifndef IK24_Link; Constant IK24_Link = 0; #endif;
#ifndef IK25_Count; Constant IK25_Count = 0; #endif;
#ifndef IK25_Link; Constant IK25_Link = 0; #endif;
#ifndef IK26_Count; Constant IK26_Count = 0; #endif;
#ifndef IK26_Link; Constant IK26_Link = 0; #endif;
#ifndef IK27_Count; Constant IK27_Count = 0; #endif;
#ifndef IK27_Link; Constant IK27_Link = 0; #endif;
#ifndef IK28_Count; Constant IK28_Count = 0; #endif;
#ifndef IK28_Link; Constant IK28_Link = 0; #endif;
#ifndef IK29_Count; Constant IK29_Count = 0; #endif;
#ifndef IK29_Link; Constant IK29_Link = 0; #endif;
#ifndef IK30_Count; Constant IK30_Count = 0; #endif;
#ifndef IK30_Link; Constant IK30_Link = 0; #endif;
#ifndef IK31_Count; Constant IK31_Count = 0; #endif;
#ifndef IK31_Link; Constant IK31_Link = 0; #endif;
#ifndef KD_Count; Constant KD_Count = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef parse_name; Constant parse_name = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;

#IFNDEF cap_short_name;
Constant cap_short_name = short_name;
#ENDIF;
Array I7_ST_say_one_of --> 144;

Array Runtime_Quotations_Displayed --> 1;

[ InitialHeapAllocation obj pv;
];
[ DistributeBlockConstants obj pv;
];
#ifdef TARGET_ZCODE;
Constant MEMORY_HEAP_SIZE = 8192;
#ifnot;
Constant MEMORY_HEAP_SIZE = 32768;
#endif;


Array KD0_phrase_nothing_to_nothing --> ! phrase nothing -> nothing
    PHRASE_TY 1    UNKNOWN_TY;
Array Default_Value_0 --> KD0_phrase_nothing_to_nothing Def_Phrase_0 "default value of phrase nothing -> nothing";
[ Def_Phrase_0 a b c d e f g h;
    return false;
];

Array KD1_values_based_rule_producin --> ! values based rule producing values
    RULE_TY 2 VALUE_TY VALUE_TY;
Array KD2_activity --> ! activity
    ACTIVITY_TY 1 NIL_TY;
Array KD3_list_of_objects --> ! list of objects
    LIST_OF_TY 1 OBJECT_TY;
Array KD4_relation_of_rooms_to_doors --> ! relation of rooms to doors
    RELATION_TY 2 9 9;
Array KD5_relation_of_things_to_thin --> ! relation of things to things
    RELATION_TY 2 9 9;
Array KD6_relation_of_passkeys_to_th --> ! relation of passkeys to things
    RELATION_TY 2 9 9;
Array KD7_relation_of_rooms_to_rooms --> ! relation of rooms to rooms
    RELATION_TY 2 9 9;
[ DefaultValueFinder K;
    if (K == KD0_phrase_nothing_to_nothing) return Default_Value_0;
    return 0;
];


Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = $$00000001;
Constant BLK_FLAG_16_BIT   = $$00000010;
Constant BLK_FLAG_WORD     = $$00000100;
Constant BLK_FLAG_RESIDENT = $$00001000;
Constant BLK_HEADER_KOV = 1;

Constant BLK_DATA_OFFSET = 2*WORDSIZE;

Constant BLK_DATA_MULTI_OFFSET = 4*WORDSIZE;
Constant BLK_NEXT 2;
Constant BLK_PREV 3;

#IFDEF MEMORY_HEAP_SIZE;

! Constant SHOW_ALLOCATIONS = 1; ! Uncomment this for debugging purposes

[ BlkType txb;
	return txb-->BLK_HEADER_KOV;
];

[ BlkSize txb bsize n; ! Size of an individual block, including header
	if (txb == 0) return 0;
	for (bsize=1: n<txb->BLK_HEADER_N: bsize=bsize*2) n++;
	return bsize;
];

[ BlkTotalSize txb tsize; ! Combined size of multiple-blocks for a value
	if (txb == 0) return 0;
	if ((txb->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE == 0)
		return BlkSize(txb);
	for (:txb~=NULL:txb=txb-->BLK_NEXT) {
		tsize = tsize + BlkSize(txb);
	}
	return tsize;
];

[ BlkDebug txb n k i bsize tot dtot kov;
	if (txb == 0) "Block never created.";
	kov = txb-->BLK_HEADER_KOV;
	print "Block ", txb, " (kov ", kov, "): ";
	for (:txb~=NULL:txb = txb-->BLK_NEXT) {
		if (k++ == 100) " ... and so on.";
		if (txb-->BLK_HEADER_KOV ~= kov)
			print "*Wrong kov=", txb-->BLK_HEADER_KOV, "* ";
		n = txb->BLK_HEADER_N;
		for (bsize=1:n>0:n--) bsize=bsize*2;
		i = bsize - BLK_DATA_OFFSET;
		dtot = dtot+i;
		tot = tot+bsize;
		print txb, "(", bsize, ") > ";
	}
	print dtot, " data in ", tot, " bytes^";
];

[ BlkDebugDecomposition from to txb pf;
	if (to==0) to = NULL;
	for (txb=from:(txb~=to) && (txb~=NULL):txb=txb-->BLK_NEXT) {
		if (pf) print "+";
		print BlkSize(txb);
		pf = true;
	}
	print "^";
];

Array Blk_Heap -> MEMORY_HEAP_SIZE + 16; ! Plus 16 to allow room for head-free-block

[ HeapInitialise n bsize blk2;
	blk2 = Blk_Heap + 16;
	Blk_Heap->BLK_HEADER_N = 4;
	Blk_Heap-->BLK_HEADER_KOV = 0;
	Blk_Heap->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	Blk_Heap-->BLK_NEXT = blk2;
	Blk_Heap-->BLK_PREV = NULL;
	for (bsize=1: bsize < MEMORY_HEAP_SIZE: bsize=bsize*2) n++;
	blk2->BLK_HEADER_N = n;
	blk2-->BLK_HEADER_KOV = 0;
	blk2->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	blk2-->BLK_NEXT = NULL;
	blk2-->BLK_PREV = Blk_Heap;
];

[ HeapNetFreeSpace multiple txb asize;
	for (txb=Blk_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = asize + BlkSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
	}
	return asize;
];

Constant SMALLEST_BLK_WORTH_ALLOCATING = 12; ! i.e. 2^12 = 4096 bytes

[ HeapMakeSpace size multiple  newblocksize newblock B n;
	for (::) {
		if (multiple) {
			if (HeapNetFreeSpace(multiple) >= size) rtrue;
		} else {
			if (HeapLargestFreeBlock(0) >= size) rtrue;
		}
		newblocksize = 1;
		for (n=0: (n<SMALLEST_BLK_WORTH_ALLOCATING) || (newblocksize<size): n++)
			newblocksize = newblocksize*2;
		while (newblocksize < size+16) newblocksize = newblocksize*2;
		newblock = VM_AllocateMemory(newblocksize);
		if (newblock == 0) rfalse;
		newblock->BLK_HEADER_N = n;
		newblock-->BLK_HEADER_KOV = 0;
		newblock->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		newblock-->BLK_NEXT = NULL;
		newblock-->BLK_PREV = NULL;
		for (B = Blk_Heap-->BLK_NEXT:B ~= NULL:B = B-->BLK_NEXT)
			if (B-->BLK_NEXT == NULL) {
				B-->BLK_NEXT = newblock;
				newblock-->BLK_PREV = B;
				jump Linked;
			}
		Blk_Heap-->BLK_NEXT = newblock;
		newblock-->BLK_PREV = Blk_Heap;
		.Linked; ;
		#ifdef SHOW_ALLOCATIONS;
		print "Increasing heap to free space map: "; BlkDebugDecomposition(Blk_Heap, 0);
		#endif;
	}
	rtrue;
];

[ HeapLargestFreeBlock multiple txb asize best;
	best = 0;
	for (txb=Blk_Heap-->BLK_NEXT: txb~=NULL: txb=txb-->BLK_NEXT) {
		asize = BlkSize(txb);
		if (multiple) asize = asize - BLK_DATA_MULTI_OFFSET;
		else asize = asize - BLK_DATA_OFFSET;
		if (asize > best) best = asize;
	}
	return best;
];

[ BlkAllocate size kov flags
	dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
	
	if (HeapMakeSpace(size, flags & BLK_FLAG_MULTIPLE) == false) 
		return BlkAllocationError("ran out");

	! Calculate the header size for a block of this KOV
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;

	! Calculate the data size
	n=0; for (dsize=1: dsize < hsize+size: dsize=dsize*2) n++;

	! Seek a free block closest to the correct size, but starting from the
	! block after the fixed head-free-block, which we can't touch
	min_m = 10000; max_m = 0;
	for (free_block = Blk_Heap-->BLK_NEXT:
		free_block ~= NULL:
		free_block = free_block-->BLK_NEXT) {
		m = free_block->BLK_HEADER_N;
		! Current block the ideal size
		if (m == n) jump CorrectSizeFound;
		! Current block too large: find the smallest which is larger than needed
		if (m > n) {
			if (min_m > m) {
				min_m = m;
				smallest_oversized_block = free_block;
			}
		}
		! Current block too small: find the largest which is smaller than needed
		if (m < n) {
			if (max_m < m) {
				max_m = m;
			}
		}
	}

	if (min_m == 10000) {
		! Case I: No block is large enough to hold the entire size
		if (flags & BLK_FLAG_MULTIPLE == 0) return BlkAllocationError("too fragmented");
		! Set dsize to the size in bytes if the largest block available
		for (dsize=1: max_m > 0: dsize=dsize*2) max_m--;
		! Split as a head (dsize-hsize), which we can be sure fits into one block,
		! plus a tail (size-(dsize-hsize), which might be a list of blocks
		head = BlkAllocate(dsize-hsize, kov, flags);
		if (head == 0) return BlkAllocationError("head block not available");
		tail = BlkAllocate(size-(dsize-hsize), kov, flags);
		if (tail == 0) return BlkAllocationError("tail block not available");
		head-->BLK_NEXT = tail;
		tail-->BLK_PREV = head;
		return head;
	}

	! Case II: No block is the right size, but some exist which are too big
	! Set dsize to the size in bytes of the smallest oversized block
	for (dsize=1,m=1: m<=min_m: dsize=dsize*2) m++;
	free_block = smallest_oversized_block;
	while (min_m > n) {
		! Repeatedly halve free_block at the front until the two smallest
		! fragments left are the correct size: then take the frontmost
		dsize = dsize/2;
		secondhalf = free_block + dsize;
		secondhalf-->BLK_NEXT = free_block-->BLK_NEXT;
		if (secondhalf-->BLK_NEXT ~= NULL)
			(secondhalf-->BLK_NEXT)-->BLK_PREV = secondhalf;
		secondhalf-->BLK_PREV = free_block;
		free_block-->BLK_NEXT = secondhalf;
		free_block->BLK_HEADER_N = (free_block->BLK_HEADER_N) - 1;
		secondhalf->BLK_HEADER_N = free_block->BLK_HEADER_N;
		secondhalf-->BLK_HEADER_KOV = free_block-->BLK_HEADER_KOV;
		secondhalf->BLK_HEADER_FLAGS = free_block->BLK_HEADER_FLAGS;
		min_m--;
	}
	
	! Once that is done, free_block points to a block which is exactly the
	! right size, so we can fall into...
	
	! Case III: There is a free block which has the correct size.
	.CorrectSizeFound;
	! Delete the free block from the double linked list of free blocks: note
	! that it cannot be the head of this list, which is fixed
	if (free_block-->BLK_NEXT == NULL) {
		! We remove final block, so previous is now final
		(free_block-->BLK_PREV)-->BLK_NEXT = NULL;
	} else {
		! We remove a middle block, so join previous to next
		(free_block-->BLK_PREV)-->BLK_NEXT = free_block-->BLK_NEXT;
		(free_block-->BLK_NEXT)-->BLK_PREV = free_block-->BLK_PREV;
	}
	free_block-->BLK_HEADER_KOV = KindAtomic(kov);
	free_block->BLK_HEADER_FLAGS = flags;
	if (flags & BLK_FLAG_MULTIPLE) {
		free_block-->BLK_NEXT = NULL;
		free_block-->BLK_PREV = NULL;
	}
	
	! Zero out the data bytes in the memory allocated
	for (i=hsize:i<dsize:i++) free_block->i=0;
	return free_block;
];

[ BlkAllocationError reason;
	print "*** Memory ", (string) reason, " ***^";
	RunTimeProblem(RTP_HEAPERROR);
	rfalse;
];

[ BlkMerge block first last pv nx;
	first = block; last = block;
	while (last-->BLK_NEXT == last+BlkSize(last))
		last = last-->BLK_NEXT;
	while ((first-->BLK_PREV + BlkSize(first-->BLK_PREV) == first) &&
		(first-->BLK_PREV ~= Blk_Heap))
		first = first-->BLK_PREV;
	pv = first-->BLK_PREV;
	nx = last-->BLK_NEXT;
	#ifdef SHOW_ALLOCATIONS;
	print "Merging: "; BlkDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
	#endif;
	if (BlkRecut(first, last)) {
		#ifdef SHOW_ALLOCATIONS;
		print " --> "; BlkDebugDecomposition(pv-->BLK_NEXT, nx); print "^";
		#endif;
	}
];

[ BlkRecut first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
	if (first == last) rfalse;
	mfrom = first; mto = last + BlkSize(last);
	bnext = last-->BLK_NEXT;
	fine_so_far = true;
	for (:mto>mfrom: mto = mto - backsize) {
		for (n=0, backsize=1: backsize*2 <= mto-mfrom: n++) backsize=backsize*2;
		if ((fine_so_far) && (backsize == BlkSize(last))) {
			bnext = last; last = last-->BLK_PREV;
			bnext-->BLK_PREV = last;
			last-->BLK_NEXT = bnext;
			continue;
		}
		fine_so_far = false; ! From this point, "last" is meaningless
		backend = mto - backsize;
		backend->BLK_HEADER_N = n;
		backend-->BLK_HEADER_KOV = 0;
		backend->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
		backend-->BLK_NEXT = bnext;
		if (bnext ~= NULL) {
			bnext-->BLK_PREV = backend;
			bnext = backend;
		}
	}
	if (fine_so_far) rfalse;
	rtrue;
];

[ BlkFree block fromtxb ptxb;
	if (block == 0) return;
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_RESIDENT) return;
	BlkValueDestroy(block);
	if ((block->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) {
		if (block-->BLK_PREV ~= NULL) (block-->BLK_PREV)-->BLK_NEXT = NULL;
		fromtxb = block;
		for (:(block-->BLK_NEXT)~=NULL:block = block-->BLK_NEXT) ;
		while (block ~= fromtxb) {
			ptxb = block-->BLK_PREV; BlkFreeSingleBlock(block); block = ptxb;
		}
	}
	BlkFreeSingleBlock(block);
];

[ BlkFreeSingleBlock block free nx;
	block-->BLK_HEADER_KOV = 0;
	block->BLK_HEADER_FLAGS = BLK_FLAG_MULTIPLE;
	for (free = Blk_Heap:free ~= NULL:free = free-->BLK_NEXT) {
		nx = free-->BLK_NEXT;
		if (nx == NULL) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = NULL;
			BlkMerge(block);
			return;
		}
		if (UnsignedCompare(nx, block) == 1) {
			free-->BLK_NEXT = block;
			block-->BLK_PREV = free;
			block-->BLK_NEXT = nx;
			nx-->BLK_PREV = block;
			BlkMerge(block);
			return;
		}
	}
];

[ BlkResize block req newsize dsize newblk kov n i otxb flags;
	if (block == 0) "*** Cannot resize null block ***";
	kov = block-->BLK_HEADER_KOV;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0) "*** Cannot resize inextensible block ***";
	otxb = block;
	newsize = req;
	for (:: block = block-->BLK_NEXT) {
		n = block->BLK_HEADER_N;
		for (dsize=1: n>0: n--) dsize = dsize*2;
		i = dsize - BLK_DATA_MULTI_OFFSET;
		newsize = newsize - i;
		if (newsize > 0) {
			if (block-->BLK_NEXT ~= NULL) continue;
			newblk = BlkAllocate(newsize, kov, flags);
			if (newblk == 0) rfalse;
			block-->BLK_NEXT = newblk;
			newblk-->BLK_PREV = block;
			rtrue;
		}
		if (block-->BLK_NEXT ~= NULL) {
			BlkFree(block-->BLK_NEXT);
			block-->BLK_NEXT = NULL;
		}
		rtrue;
	}
];

[ DebugHeap;
	print "Managing a heap of initially ", MEMORY_HEAP_SIZE+16, " bytes.^";
	print HeapNetFreeSpace(false), " bytes currently free.^";
	print "Free space decomposition: "; BlkDebugDecomposition(Blk_Heap);
	print "Free space map: "; BlkDebug(Blk_Heap);
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ HeapInitialise; ];
[ BlkFree; ];
[ DebugHeap;
	"This story file does not use a heap of managed memory.";
];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE;

[ BlkValueExtent block  tsize flags;
	if (block == 0) return 0;
	flags = block->BLK_HEADER_FLAGS;
	if (flags & BLK_FLAG_MULTIPLE == 0)
		tsize = BlkSize(block) - BLK_DATA_OFFSET;
	else
		for (:block~=NULL:block=block-->BLK_NEXT)
			tsize = tsize + BlkSize(block) - BLK_DATA_MULTI_OFFSET;
	if (flags & BLK_FLAG_16_BIT) return tsize/2;
	if (flags & BLK_FLAG_WORD) return tsize/WORDSIZE;
	return tsize;
];

[ BlkValueSetExtent block tsize flags wsize;
	if (block == 0) return 0;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	return BlkResize(block, (tsize)*wsize);
];

[ BlkValueRead block pos dsize hsize flags wsize ot op;
	if (block==0) rfalse;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = block; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	for (:block~=NULL:block=block-->BLK_NEXT) {
		dsize = BlkSize(block) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			block = block + hsize + pos;
			switch(wsize) {
				1: return block->0;
				2:	#Iftrue (WORDSIZE == 2); return block-->0;
					#ifnot; return (block->0)*256 + (block->1);
					#endif;
				4: return block-->0;
			}
		}
		pos = pos - dsize;
	}
	"*** BlkValueRead: reading from index out of range: ", op, " in ", ot, " ***";
];

[ BlkValueWrite block pos val dsize hsize flags wsize ot op;
	if (block==0) rfalse;
	flags = block->BLK_HEADER_FLAGS; wsize = 1;
	if (flags & BLK_FLAG_WORD) wsize = WORDSIZE;
	if (flags & BLK_FLAG_16_BIT) wsize = 2;
	ot = block; op = pos;
	pos = pos*wsize;
	if (flags & BLK_FLAG_MULTIPLE) hsize = BLK_DATA_MULTI_OFFSET;
	else hsize = BLK_DATA_OFFSET;
	for (:block~=NULL:block=block-->BLK_NEXT) {
		dsize = BlkSize(block) - hsize;
		if ((pos >= 0) && (pos<dsize)) {
			block = block + hsize + pos;
			switch(wsize) {
				1: block->0 = val;
				2:	#Iftrue (WORDSIZE == 2); block-->0 = val;
					#ifnot; block->0 = (val/256)%256; block->1 = val%256;
					#endif;
				4: block-->0 = val;
			}
			return;
		}
		pos = pos - dsize;
	}
	"*** BlkValueWrite: writing to index out of range: ", op, " in ", ot, " ***";
];

Constant CREATE_KOVS     = 1;
Constant CAST_KOVS       = 2;
Constant DESTROY_KOVS    = 3;
Constant PRECOPY_KOVS    = 4;
Constant COPY_KOVS       = 5;
Constant COMPARE_KOVS    = 6;
Constant READ_FILE_KOVS  = 7;
Constant WRITE_FILE_KOVS = 8;
Constant HASH_KOVS       = 9;

Global block_value_tally;
[ BlkValueCreate kov cast_from skov  block sf;

	if (skov == 0 && (kov < 0 || kov >= BASE_KIND_HWM)) skov = kov;

	sf = KOVSupportFunction(kov);
	if (sf) block = sf(CREATE_KOVS, cast_from, skov);
	else { print "*** Impossible runtime creation ***^"; rfalse; }

#ifdef SHOW_ALLOCATIONS;
	print "[created ", kov, " at ", block, ": ", block_value_tally++, "]^";
#endif;
	return block;
];

[ BlkValueCast block tokov fromkov fromval  sf;
	sf = KOVSupportFunction(tokov);
	if (sf) return sf(CAST_KOVS, fromval, fromkov, block);
	else { print "*** Impossible runtime cast ***^"; rfalse; }
];

[ BlkValueDestroy block  k rv sf;
	if (block == 0) return;
	k = block-->BLK_HEADER_KOV;
	sf = KOVSupportFunction(k);
	if (sf) return sf(DESTROY_KOVS, block);
	else { print "*** Impossible runtime deallocation ***^"; rfalse; }
];

[ BlkValueCopy blockto blockfrom dsize i sf;
	if (blockto == 0) { print "*** Deep copy failed: destination empty ***^"; rfalse; }
	if (blockfrom == 0) { print "*** Deep copy failed: source empty ***^"; rfalse; }

	if (blockfrom->BLK_HEADER_N == 0) {
		! A hack to handle precompiled array constants: N=0 blocks otherwise don't exist
		LIST_OF_TY_CopyRawArray(blockto, blockfrom, 1, 0);
		return blockto;
	}

	if (blockfrom-->BLK_HEADER_KOV ~= blockto-->BLK_HEADER_KOV) {
		print "*** Deep copy failed: types mismatch ***^"; rfalse;
	}

	BlkValueDestroy(blockto);

	dsize = BlkValueExtent(blockfrom);

	if (((blockfrom->BLK_HEADER_FLAGS) & BLK_FLAG_MULTIPLE) &&
		(BlkValueSetExtent(blockto, dsize, -1) == false)) {
		print "*** Deep copy failed: resizing failed ***^"; rfalse;
	}

	sf = KOVSupportFunction(blockfrom-->BLK_HEADER_KOV);

	if (sf) sf(PRECOPY_KOVS, blockto, blockfrom);

	for (i=0:i<dsize:i++) BlkValueWrite(blockto, i, BlkValueRead(blockfrom, i));

	if (sf) sf(COPY_KOVS, blockto, blockfrom);
	else { print "*** Impossible runtime copy ***^"; rfalse; }
	return blockto;
];

[ BlkValueCompare blockleft blockright  kov sf;
	if ((blockleft == 0) && (blockright == 0)) return 0;
	if (blockleft == 0) return 1;
	if (blockright == 0) return -1;
	if (blockleft-->BLK_HEADER_KOV ~= blockright-->BLK_HEADER_KOV)
		return blockleft-->BLK_HEADER_KOV - blockright-->BLK_HEADER_KOV;
	kov = blockleft-->BLK_HEADER_KOV;

	sf = KOVSupportFunction(kov);
	if (sf) return sf(COMPARE_KOVS, blockleft, blockright);
	else { print "*** Impossible runtime comparison ***^"; rfalse; }
];

[ BlkValueInitialCopy blockto blockfrom dsize i;
	if (blockto == 0) { print "*** Initial copy failed: destination empty ***^"; rfalse; }
	if (blockfrom == 0) { print "*** Initial copy failed: source empty ***^"; rfalse; }
	dsize = 1; for (i=1: i<=blockfrom->BLK_HEADER_N: i++) dsize=dsize*2;
	for (i=0:i<dsize:i++) blockto->i = blockfrom->i;
	return blockto;
];

[ BlkValueHash block  kov sf;
	if (block == 0) return 0;
	kov = block-->BLK_HEADER_KOV;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(HASH_KOVS, block);
	else { print "*** Impossible runtime hashing ***^"; rfalse; }
];

[ KOVHashValue kov value;
	if (KOVIsBlockValue(kov)) return BlkValueHash(value);
	return value;
];

[ BlkValueReadFromFile block auxf ch kov  sf;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(READ_FILE_KOVS, block, auxf, ch);
	rfalse;
];

[ BlkValueWriteToFile block kov  sf;
	sf = KOVSupportFunction(kov);
	if (sf) return sf(WRITE_FILE_KOVS, block);
	rfalse;
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ BlkValueReadFromFile; rfalse; ];
[ BlkValueWriteToFile; rfalse; ];
[ BlkValueCreate x y z; ];
[ BlkValueDestroy x; ];
[ BlkValueCopy x y; ];
[ BlkValueCompare x y; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

#IFDEF TARGET_ZCODE;
Constant IT_Storage_Flags = BLK_FLAG_MULTIPLE;
Constant ZSCII_Tables;
#IFNOT;
Constant IT_Storage_Flags = BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT;
Constant Large_Unicode_Tables;
#ENDIF;

Constant UNIC_NCT = 10000; ! Safe as highest case-change delta is 8383

#IFDEF ZSCII_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $009b (   3) (       3) $00a1 (   1) (UNIC_NCT)
    $00a4 (   2) (       3) $00a6 (   1) (UNIC_NCT) $00a9 (   6) (       6)
    $00b5 (   5) (       5) $00bf (   5) (       5) $00c9 (  -3) (       1)
    $00cd (   3) (       3) $00d3 (  -3) (       1) $00d7 (   2) (       2)
    $00dc (   1) (       1) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $009e (   3) (      -3) $00a7 (   2) (      -3)
    $00af (   6) (      -6) $00ba (   5) (      -5) $00c4 (   5) (      -5)
    $00ca (  -3) (      -1) $00d0 (   3) (      -3) $00d4 (  -3) (      -1)
    $00d9 (   2) (      -2) $00dd (   1) (      -1) $0000
;
#ENDIF; ! ZSCII_Tables

#IFDEF Small_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (UNIC_NCT) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (UNIC_NCT)
    $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0000
;

#ENDIF; ! Small_Unicode_Tables

#IFDEF Large_Unicode_Tables;
Array CharCasingChart0 -->
    $0061 (  26) (     -32) $00aa (   1) (UNIC_NCT) $00b5 (   1) (     743) $00ba (   1) (UNIC_NCT)
    $00df (   1) (UNIC_NCT) $00e0 (  23) (     -32) $00f8 (   7) (     -32) $00ff (   1) (     121)
    $0101 ( -47) (      -1) $0131 (   1) (    -232) $0133 (  -5) (      -1) $0138 (   1) (UNIC_NCT)
    $013a ( -15) (      -1) $0149 (   1) (UNIC_NCT) $014b ( -45) (      -1) $017a (  -5) (      -1)
    $017f (   1) (    -300) $0180 (   1) (UNIC_NCT) $0183 (  -3) (      -1) $0188 (   1) (      -1)
    $018c (   1) (      -1) $018d (   1) (UNIC_NCT) $0192 (   1) (      -1) $0195 (   1) (      97)
    $0199 (   1) (      -1) $019a (   2) (UNIC_NCT) $019e (   1) (     130) $01a1 (  -5) (      -1)
    $01a8 (   1) (      -1) $01aa (   2) (UNIC_NCT) $01ad (   1) (      -1) $01b0 (   1) (      -1)
    $01b4 (  -3) (      -1) $01b9 (   1) (      -1) $01ba (   1) (UNIC_NCT) $01bd (   1) (      -1)
    $01be (   1) (UNIC_NCT) $01bf (   1) (      56) $01c6 (   1) (      -2) $01c9 (   1) (      -2)
    $01cc (   1) (      -2) $01ce ( -15) (      -1) $01dd (   1) (     -79) $01df ( -17) (      -1)
    $01f0 (   1) (UNIC_NCT) $01f3 (   1) (      -2) $01f5 (   1) (      -1) $01f9 ( -39) (      -1)
    $0221 (   1) (UNIC_NCT) $0223 ( -17) (      -1) $0234 (   3) (UNIC_NCT) $0250 (   3) (UNIC_NCT)
    $0253 (   1) (    -210) $0254 (   1) (    -206) $0255 (   1) (UNIC_NCT) $0256 (   2) (    -205)
    $0258 (   1) (UNIC_NCT) $0259 (   1) (    -202) $025a (   1) (UNIC_NCT) $025b (   1) (    -203)
    $025c (   4) (UNIC_NCT) $0260 (   1) (    -205) $0261 (   2) (UNIC_NCT) $0263 (   1) (    -207)
    $0264 (   4) (UNIC_NCT) $0268 (   1) (    -209) $0269 (   1) (    -211) $026a (   5) (UNIC_NCT)
    $026f (   1) (    -211) $0270 (   2) (UNIC_NCT) $0272 (   1) (    -213) $0273 (   2) (UNIC_NCT)
    $0275 (   1) (    -214) $0276 (  10) (UNIC_NCT) $0280 (   1) (    -218) $0281 (   2) (UNIC_NCT)
    $0283 (   1) (    -218) $0284 (   4) (UNIC_NCT) $0288 (   1) (    -218) $0289 (   1) (UNIC_NCT)
    $028a (   2) (    -217) $028c (   6) (UNIC_NCT) $0292 (   1) (    -219) $0293 (  29) (UNIC_NCT)
    $0390 (   1) (UNIC_NCT) $03ac (   1) (     -38) $03ad (   3) (     -37) $03b0 (   1) (UNIC_NCT)
    $03b1 (  17) (     -32) $03c2 (   1) (     -31) $03c3 (   9) (     -32) $03cc (   1) (     -64)
    $03cd (   2) (     -63) $03d0 (   1) (     -62) $03d1 (   1) (     -57) $03d5 (   1) (     -47)
    $03d6 (   1) (     -54) $03d7 (   1) (UNIC_NCT) $03d9 ( -23) (      -1) $03f0 (   1) (     -86)
    $03f1 (   1) (     -80) $03f2 (   1) (       7) $03f3 (   1) (UNIC_NCT) $03f5 (   1) (     -96)
    $03f8 (   1) (      -1) $03fb (   1) (      -1) $0430 (  32) (     -32) $0450 (  16) (     -80)
    $0461 ( -33) (      -1) $048b ( -53) (      -1) $04c2 ( -13) (      -1) $04d1 ( -37) (      -1)
    $04f9 (   1) (      -1) $0501 ( -15) (      -1) $0561 (  38) (     -48) $0587 (   1) (UNIC_NCT)
    $1d00 (  44) (UNIC_NCT) $1d62 (  10) (UNIC_NCT) $1e01 (-149) (      -1) $1e96 (   5) (UNIC_NCT)
    $1e9b (   1) (     -59) $1ea1 ( -89) (      -1) $1f00 (   8) (       8) $1f10 (   6) (       8)
    $1f20 (   8) (       8) $1f30 (   8) (       8) $1f40 (   6) (       8) $1f50 (   1) (UNIC_NCT)
    $1f51 (   1) (       8) $1f52 (   1) (UNIC_NCT) $1f53 (   1) (       8) $1f54 (   1) (UNIC_NCT)
    $1f55 (   1) (       8) $1f56 (   1) (UNIC_NCT) $1f57 (   1) (       8) $1f60 (   8) (       8)
    $1f70 (   2) (      74) $1f72 (   4) (      86) $1f76 (   2) (     100) $1f78 (   2) (     128)
    $1f7a (   2) (     112) $1f7c (   2) (     126) $1f80 (   8) (       8) $1f90 (   8) (       8)
    $1fa0 (   8) (       8) $1fb0 (   2) (       8) $1fb2 (   1) (UNIC_NCT) $1fb3 (   1) (       9)
    $1fb4 (  -3) (UNIC_NCT) $1fb7 (   1) (UNIC_NCT) $1fbe (   1) (   -7205) $1fc2 (   1) (UNIC_NCT)
    $1fc3 (   1) (       9) $1fc4 (  -3) (UNIC_NCT) $1fc7 (   1) (UNIC_NCT) $1fd0 (   2) (       8)
    $1fd2 (   2) (UNIC_NCT) $1fd6 (   2) (UNIC_NCT) $1fe0 (   2) (       8) $1fe2 (   3) (UNIC_NCT)
    $1fe5 (   1) (       7) $1fe6 (   2) (UNIC_NCT) $1ff2 (   1) (UNIC_NCT) $1ff3 (   1) (       9)
    $1ff4 (  -3) (UNIC_NCT) $1ff7 (   1) (UNIC_NCT) $2071 (   1) (UNIC_NCT) $207f (   1) (UNIC_NCT)
    $210a (   1) (UNIC_NCT) $210e (   2) (UNIC_NCT) $2113 (   1) (UNIC_NCT) $212f (   1) (UNIC_NCT)
    $2134 (   1) (UNIC_NCT) $2139 (   1) (UNIC_NCT) $213d (   1) (UNIC_NCT) $2146 (   4) (UNIC_NCT)
    $fb00 (   7) (UNIC_NCT) $fb13 (   5) (UNIC_NCT) $ff41 (  26) (     -32) $0000
;

Array CharCasingChart1 -->
    $0041 (  26) (      32) $00c0 (  23) (      32) $00d8 (   7) (      32) $0100 ( -47) (       1)
    $0130 (   1) (    -199) $0132 (  -5) (       1) $0139 ( -15) (       1) $014a ( -45) (       1)
    $0178 (   1) (    -121) $0179 (  -5) (       1) $0181 (   1) (     210) $0182 (  -3) (       1)
    $0186 (   1) (     206) $0187 (   1) (       1) $0189 (   2) (     205) $018b (   1) (       1)
    $018e (   1) (      79) $018f (   1) (     202) $0190 (   1) (     203) $0191 (   1) (       1)
    $0193 (   1) (     205) $0194 (   1) (     207) $0196 (   1) (     211) $0197 (   1) (     209)
    $0198 (   1) (       1) $019c (   1) (     211) $019d (   1) (     213) $019f (   1) (     214)
    $01a0 (  -5) (       1) $01a6 (   1) (     218) $01a7 (   1) (       1) $01a9 (   1) (     218)
    $01ac (   1) (       1) $01ae (   1) (     218) $01af (   1) (       1) $01b1 (   2) (     217)
    $01b3 (  -3) (       1) $01b7 (   1) (     219) $01b8 (   1) (       1) $01bc (   1) (       1)
    $01c4 (   1) (       2) $01c7 (   1) (       2) $01ca (   1) (       2) $01cd ( -15) (       1)
    $01de ( -17) (       1) $01f1 (   1) (       2) $01f4 (   1) (       1) $01f6 (   1) (     -97)
    $01f7 (   1) (     -56) $01f8 ( -39) (       1) $0220 (   1) (    -130) $0222 ( -17) (       1)
    $0386 (   1) (      38) $0388 (   3) (      37) $038c (   1) (      64) $038e (   2) (      63)
    $0391 (  17) (      32) $03a3 (   9) (      32) $03d2 (   3) (UNIC_NCT) $03d8 ( -23) (       1)
    $03f4 (   1) (     -60) $03f7 (   1) (       1) $03f9 (   1) (      -7) $03fa (   1) (       1)
    $0400 (  16) (      80) $0410 (  32) (      32) $0460 ( -33) (       1) $048a ( -53) (       1)
    $04c0 (   1) (UNIC_NCT) $04c1 ( -13) (       1) $04d0 ( -37) (       1) $04f8 (   1) (       1)
    $0500 ( -15) (       1) $0531 (  38) (      48) $10a0 (  38) (UNIC_NCT) $1e00 (-149) (       1)
    $1ea0 ( -89) (       1) $1f08 (   8) (      -8) $1f18 (   6) (      -8) $1f28 (   8) (      -8)
    $1f38 (   8) (      -8) $1f48 (   6) (      -8) $1f59 (  -7) (      -8) $1f68 (   8) (      -8)
    $1fb8 (   2) (      -8) $1fba (   2) (     -74) $1fc8 (   4) (     -86) $1fd8 (   2) (      -8)
    $1fda (   2) (    -100) $1fe8 (   2) (      -8) $1fea (   2) (    -112) $1fec (   1) (      -7)
    $1ff8 (   2) (    -128) $1ffa (   2) (    -126) $2102 (   1) (UNIC_NCT) $2107 (   1) (UNIC_NCT)
    $210b (   3) (UNIC_NCT) $2110 (   3) (UNIC_NCT) $2115 (   1) (UNIC_NCT) $2119 (   5) (UNIC_NCT)
    $2124 (   1) (UNIC_NCT) $2126 (   1) (   -7517) $2128 (   1) (UNIC_NCT) $212a (   1) (   -8383)
    $212b (   1) (   -8262) $212c (   2) (UNIC_NCT) $2130 (   2) (UNIC_NCT) $2133 (   1) (UNIC_NCT)
    $213e (   2) (UNIC_NCT) $2145 (   1) (UNIC_NCT) $ff21 (  26) (      32) $0000
;

#ENDIF; ! Large_Unicode_Tables

[ CharIsOfCase c case
	i tab min max len par;
	if (c<'A') rfalse;
	if (case == 0) {
		if ((c >= 'a') && (c <= 'z')) rtrue;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) rtrue;
		tab = CharCasingChart1;
	}
	if (c<128) rfalse;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) rfalse;
		if (c < min+len) {
			if (par) { if ((c-min) % 2 == 0) rtrue; }
			else { rtrue; }
		}
	}
	rfalse;
];

[ CharToCase c case
	i tab min max len par del f;
	if (c<'A') return c;
	if (case == 1) {
		if ((c >= 'a') && (c <= 'z')) return c-32;
		tab = CharCasingChart0;
	} else {
		if ((c >= 'A') && (c <= 'Z')) return c+32;
		tab = CharCasingChart1;
	}
	if (c<128) return c;
	while (tab-->i) {
		min = tab-->i; i++;
		len = tab-->i; i++;
		del = tab-->i; i++;
		par = 0;
		if (len<0) { par = 1; len = -len; }
		if (c < min) return c;
		if (c < min+len) {
			f = false;
			if (par) { if ((c-min) % 2 == 0) f = true; }
			else { f = true; }
			if (f) {
				if (del == UNIC_NCT) return c;
				return c+del;
			}
		}
	}
	return c;
];

#IFDEF TARGET_ZCODE;
[ IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if ((ch >= 155) && (ch <= 157)) return ch+3; ! a, o, u umlaut in ZSCII
	if ((ch >= 158) && (ch <= 160)) return ch-3; ! A, O, U umlaut
	if ((ch >= 164) && (ch <= 165)) return ch+3; ! e, i umlaut
	if ((ch >= 167) && (ch <= 168)) return ch-3; ! E, I umlaut
	if ((ch >= 169) && (ch <= 174)) return ch+6; ! a, e, i, o, u, y acute
	if ((ch >= 175) && (ch <= 180)) return ch-6; ! A, E, I, O, U, Y acute
	if ((ch >= 181) && (ch <= 185)) return ch+5; ! a, e, i, o, u grave
	if ((ch >= 186) && (ch <= 190)) return ch-5; ! A, E, I, O, U grave
	if ((ch >= 191) && (ch <= 195)) return ch+5; ! a, e, i, o, u circumflex
	if ((ch >= 196) && (ch <= 200)) return ch-5; ! A, E, I, O, U circumflex
	if (ch == 201) return 202; ! a circle
	if (ch == 202) return 201; ! A circle
	if (ch == 203) return 204; ! o slash
	if (ch == 204) return 203; ! O slash
	if ((ch >= 205) && (ch <= 207)) return ch+3; ! a, n, o tilde
	if ((ch >= 208) && (ch <= 210)) return ch-3; ! A, N, O tilde
	if (ch == 211) return 212; ! ae ligature
	if (ch == 212) return 211; ! AE ligature
	if (ch == 213) return 214; ! c cedilla
	if (ch == 214) return 213; ! C cedilla
	if (ch == 215 or 216) return ch+2; ! thorn, eth
	if (ch == 217 or 218) return ch-2; ! Thorn, Eth
	if (ch == 220) return 221; ! oe ligature
	if (ch == 221) return 220; ! OE ligature
	return ch;
];
#IFNOT;
[ IT_RevCase ch;
	if (ch<'A') return ch;
	if ((ch >= 'a') && (ch <= 'z')) return ch-'a'+'A';
	if ((ch >= 'A') && (ch <= 'Z')) return ch-'A'+'a';
	if (ch<128) return ch;
	if (CharIsOfCase(ch, 0)) return CharToCase(ch, 1);
	if (CharIsOfCase(ch, 1)) return CharToCase(ch, 0);
	return ch;
];
#ENDIF;

[ CharTestCases case i j;
	for (i=32: i<$E0; i++) {
		if ((i>=127) && (i<155)) continue;
		print i, " - ", (char) i, " -";
		if (CharIsOfCase(i, 0)) print "  lower";
		if (CharIsOfCase(i, 1)) print "  upper";
		j = CharToCase(i, 0); if (j ~= i) print "  tolower: ", (char) j;
		j = CharToCase(i, 1); if (j ~= i) print "  toupper: ", (char) j;
		print "^";
	}
];


[ INDEXED_TEXT_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     return INDEXED_TEXT_TY_Create(arg1);
		CAST_KOVS:       return INDEXED_TEXT_TY_Cast(arg1, arg2, arg3);
		DESTROY_KOVS:    rfalse;
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       rfalse;
		COMPARE_KOVS:    return INDEXED_TEXT_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  if (arg3 == -1) rtrue;
			             return INDEXED_TEXT_TY_ReadFile(arg1, arg2, arg3);
		WRITE_FILE_KOVS: return INDEXED_TEXT_TY_WriteFile(arg1);
		HASH_KOVS:       return INDEXED_TEXT_TY_Hash(arg1);
	}
];

[ INDEXED_TEXT_TY_Create opcast x;
	x =  BlkAllocate(32, INDEXED_TEXT_TY, IT_Storage_Flags);
	if (opcast) INDEXED_TEXT_TY_Cast(opcast, TEXT_TY, x);
	return x;
];

#ifndef IT_MemoryBufferSize;
Constant IT_MemoryBufferSize = 512;
#endif;

Constant IT_Memory_NoBuffers = 2;

#ifndef IT_Memory_NoBuffers;
Constant IT_Memory_NoBuffers = 1;
#endif;

#ifdef TARGET_ZCODE;
Array IT_MemoryBuffer -> IT_MemoryBufferSize*IT_Memory_NoBuffers; ! Where characters are bytes
#ifnot;
Array IT_MemoryBuffer --> (IT_MemoryBufferSize+2)*IT_Memory_NoBuffers; ! Where characters are words
#endif;

Global RawBufferAddress = IT_MemoryBuffer;
Global RawBufferSize = IT_MemoryBufferSize;

Global IT_cast_nesting;

[ INDEXED_TEXT_TY_Cast tx fromkov indt
	len i str oldstr offs realloc news buff buffx freebuff results;
	#ifdef TARGET_ZCODE;
	buffx = IT_MemoryBufferSize;
	#ifnot;
	buffx = (IT_MemoryBufferSize + 2)*WORDSIZE;
	#endif;
	
	buff = RawBufferAddress + IT_cast_nesting*buffx;
	IT_cast_nesting++;
	if (IT_cast_nesting > IT_Memory_NoBuffers) {
		buff = VM_AllocateMemory(buffx); freebuff = buff;
		if (buff == 0) {
			BlkAllocationError("ran out with too many simultaneous indexed text conversions");
			return;
		}
	}

	.RetryWithLargerBuffer;
	if (tx == 0) {
		#ifdef TARGET_ZCODE;
		buff-->0 = 1;
		buff->2 = 0;
		#ifnot;
		buff-->0 = 0;
		#endif;
		len = 1;
	} else {
		#ifdef TARGET_ZCODE;
		@output_stream 3 buff;
		#ifnot;
		if (unicode_gestalt_ok == false) { RunTimeProblem(RTP_NOGLULXUNICODE); jump Failed; }
		oldstr = glk_stream_get_current();
		str = glk_stream_open_memory_uni(buff, RawBufferSize, filemode_Write, 0);
		glk_stream_set_current(str);
		#endif;

		@push say__p; @push say__pc;
		ClearParagraphing();
		if (fromkov == SNIPPET_TY) print (PrintSnippet) tx;
		else {
			if (tx ofclass String) print (string) tx;
			if (tx ofclass Routine) (tx)();	
		}
		@pull say__pc; @pull say__p;

		#ifdef TARGET_ZCODE;

		@output_stream -3;
		len = buff-->0;
		if (len > RawBufferSize-1) len = RawBufferSize-1;
		offs = 2;
		buff->(len+2) = 0;

		#ifnot; ! i.e. GLULX
		
		results = buff + buffx - 2*WORDSIZE;
		glk_stream_close(str, results);
		if (oldstr) glk_stream_set_current(oldstr);
		len = results-->1;
		if (len > RawBufferSize-1) {
			! Glulx had to truncate text output because the buffer ran out:
			! len is the number of characters which it tried to print
			news = RawBufferSize;
			while (news < len) news=news*2;
			news = news*4; ! Bytes rather than words
			i = VM_AllocateMemory(news);
			if (i ~= 0) {
				if (freebuff) VM_FreeMemory(freebuff);
				freebuff = i;
				buff = i;
				RawBufferSize = news/4;
				jump RetryWithLargerBuffer;
			}
			! Memory allocation refused: all we can do is to truncate the text
			len = RawBufferSize-1;
		}
		offs = 0;
		buff-->(len) = 0;

		#endif;

		len++;
	}

	IT_cast_nesting--;

	if (indt == 0) {
		indt = BlkAllocate(len+1, INDEXED_TEXT_TY, IT_Storage_Flags);
		if (indt == 0) jump Failed;
	} else {
		if (BlkValueSetExtent(indt, len+1, 1) == false) { indt = 0; jump Failed; }
	}

	#ifdef TARGET_ZCODE;
	for (i=0:i<=len:i++) BlkValueWrite(indt, i, buff->(i+offs));
	#ifnot;
	for (i=0:i<=len:i++) BlkValueWrite(indt, i, buff-->(i+offs));
	#endif;

	.Failed;
	if (freebuff) VM_FreeMemory(freebuff);

	return indt;
];

[ INDEXED_TEXT_TY_Compare indtleft indtright pos ch1 ch2 dsizeleft dsizeright;
	dsizeleft = BlkValueExtent(indtleft);
	dsizeright = BlkValueExtent(indtright);
	for (pos=0:(pos<dsizeleft) && (pos<dsizeright):pos++) {
		ch1 = BlkValueRead(indtleft, pos);
		ch2 = BlkValueRead(indtright, pos);
		if (ch1 ~= ch2) return ch1-ch2;
		if (ch1 == 0) return 0;
	}
	if (pos == dsizeleft) return -1;
	return 1;
];

[ INDEXED_TEXT_TY_Distinguish indtleft indtright;
	if (INDEXED_TEXT_TY_Compare(indtleft, indtright) == 0) rfalse;
	rtrue;
];

[ INDEXED_TEXT_TY_Hash indt  rv len i;
	rv = 0;
	len = BlkValueExtent(indt);
	for (i=0: i<len: i++)
		rv = rv * 33 + BlkValueRead(indt, i);
	return rv;
];

[ INDEXED_TEXT_TY_Say indt  ch i dsize;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	dsize = BlkValueExtent(indt);
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) break;
		#ifdef TARGET_ZCODE;
		print (char) ch;
		#ifnot; ! TARGET_ZCODE
		glk_put_char_uni(ch);
		#endif;
	}
];

[ INDEXED_TEXT_TY_WriteFile txb len pos ch;
	len = BlkValueExtent(txb);
	print "S";
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(txb, pos);
		if (ch == 0) {
			print "0;"; break;
		} else {
			print ch, ",";
		}
	}
];

[ INDEXED_TEXT_TY_ReadFile indt auxf ch i v dg pos tsize;
	tsize = BlkValueExtent(indt);
	while (ch ~= 32 or 9 or 10 or 13 or 0 or -1) {
		ch = FileIO_GetC(auxf);
		if (ch == ',' or ';') {
			if (pos+1 >= tsize) {
				if (BlkValueSetExtent(indt, 2*pos, 20) == false) break;
				tsize = BlkValueExtent(indt);
			}
			BlkValueWrite(indt, pos++, v);
			v = 0;
			if (ch == ';') break;
		} else {
			dg = ch - '0';
			v = v*10 + dg;
		}
	}
	BlkValueWrite(indt, pos, 0);
	return indt;
];

[ INDEXED_TEXT_TY_ROGPR indt
	pos len wa wl wpos bdm ch own;
	if (indt == 0) return GPR_FAIL;
	bdm = true; own = wn;
	len = BlkValueExtent(indt);
	for (pos=0: pos<=len: pos++) {
		if (pos == len) ch = 0; else ch = BlkValueRead(indt, pos);
		if (ch == 32 or 9 or 10 or 0) {
			if (bdm) continue;
			bdm = true;
			if (wpos ~= wl) return GPR_FAIL;
			if (ch == 0) break;
		} else {
			if (bdm) {
				bdm = false;
				if (NextWordStopped() == -1) return GPR_FAIL;
				wa = WordAddress(wn-1);
				wl = WordLength(wn-1);
				wpos = 0;
			}
			if (wa->wpos ~= ch or IT_RevCase(ch)) return GPR_FAIL;
			wpos++;
		}
	}
	if (wn == own) return GPR_FAIL; ! Progress must be made to avoid looping
	return GPR_PREPOSITION;
];

Constant CHR_BLOB = 1; ! Construe as an array of characters
Constant WORD_BLOB = 2; ! Of words
Constant PWORD_BLOB = 3; ! Of punctuated words
Constant UWORD_BLOB = 4; ! Of unpunctuated words
Constant PARA_BLOB = 5; ! Of paragraphs
Constant LINE_BLOB = 6; ! Of lines

Constant REGEXP_BLOB = 7; ! Not a blob type as such, but needed as a distinct value

Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;

[ IT_BlobAccess indt blobtype cindt wanted rindt
	brm oldbrm ch i dsize csize blobcount gp cl j;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return 0;
	if (blobtype == CHR_BLOB) return IT_CharacterLength(indt);
	dsize = BlkValueExtent(indt);
	if (cindt) csize = BlkValueExtent(cindt);
	else if (rindt) "*** rindt without cindt ***";
	brm = WS_BRM;
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) break;
		oldbrm = brm;
		if (ch == 10 or 13 or 32 or 9) {
			if (oldbrm ~= WS_BRM) {
				gp = 0;
				for (j=i:j<dsize:j++) {
					ch = BlkValueRead(indt, j);
					if (ch == 0) { brm = WS_BRM; break; }
					if (ch == 10 or 13) { gp++; continue; }
					if (ch ~= 32 or 9) break;
				}
				ch = BlkValueRead(indt, i);
				if (j == dsize) brm = WS_BRM;
				switch (blobtype) {
					PARA_BLOB: if (gp >= 2) brm = WS_BRM;
					LINE_BLOB: if (gp >= 1) brm = WS_BRM;
					default: brm = WS_BRM;
				}
			}
		} else {
			gp = false;
			if ((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB) &&
				(ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}'))
				gp = true;
			switch (oldbrm) {
				WS_BRM:
					brm = ACCEPTED_BRM;
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				SKIPPED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
					}
				ACCEPTED_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDP_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
				ACCEPTEDN_BRM:
					if (blobtype == WORD_BLOB) {
						if (gp) brm = SKIPPED_BRM;
					}
					if (blobtype == PWORD_BLOB) {
						if (gp) brm = ACCEPTEDP_BRM;
					}
				ACCEPTEDPN_BRM:
					if (blobtype == PWORD_BLOB) {
						if (gp == false) brm = ACCEPTED_BRM;
						else {
							if ((ch == BlkValueRead(indt, i-1)) &&
								(ch == '-' or '.')) blobcount--;
							blobcount++;
						}
					}
			}
		}
		if (brm == ACCEPTED_BRM or ACCEPTEDP_BRM) {
			if (oldbrm ~= brm) blobcount++;
			if ((cindt) && (blobcount == wanted)) {
				if (rindt) {
					BlkValueWrite(cindt, cl, 0);
					IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = BlkValueExtent(cindt);
					cl = IT_CharacterLength(cindt);
					if (brm == ACCEPTED_BRM) brm = ACCEPTEDN_BRM;
					if (brm == ACCEPTEDP_BRM) brm = ACCEPTEDPN_BRM;
				} else {
					if (cl+1 >= csize) {
						if (BlkValueSetExtent(cindt, 2*cl, 2) == false) break;
						csize = BlkValueExtent(cindt);
					}
					BlkValueWrite(cindt, cl++, ch);
				}
			} else {
				if (rindt) {
					if (cl+1 >= csize) {
						if (BlkValueSetExtent(cindt, 2*cl, 3) == false) break;
						csize = BlkValueExtent(cindt);
					}
					BlkValueWrite(cindt, cl++, ch);
				}
			}
		} else {
			if ((rindt) && (brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)) {
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 4) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
		}
	}
	if (cindt) BlkValueWrite(cindt, cl++, 0);
	return blobcount;
];

[ IT_GetBlob cindt indt wanted blobtype;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	if (blobtype == CHR_BLOB) return IT_GetCharacter(cindt, indt, wanted);
	IT_BlobAccess(indt, blobtype, cindt, wanted);
	return cindt;
];

[ IT_ReplaceBlob blobtype indt wanted rindt cindt ilen rlen i;
	if (blobtype == CHR_BLOB) {
		ilen = IT_CharacterLength(indt);
		rlen = IT_CharacterLength(rindt);
		wanted--;
		if ((wanted >= 0) && (wanted<ilen)) {
			if (rlen == 1) {
				BlkValueWrite(indt, wanted, BlkValueRead(rindt, 0));
			} else {
				cindt = BlkValueCreate(INDEXED_TEXT_TY);
				if (BlkValueSetExtent(cindt, ilen+rlen+1, 5)) {
					for (i=0:i<wanted:i++)
						BlkValueWrite(cindt, i, BlkValueRead(indt, i));
					for (i=0:i<rlen:i++)
						BlkValueWrite(cindt, wanted+i, BlkValueRead(rindt, i));
					for (i=wanted+1:i<ilen:i++)
						BlkValueWrite(cindt, rlen+i-1, BlkValueRead(indt, i));
					BlkValueWrite(cindt, rlen+ilen, 0);
					BlkValueCopy(indt, cindt);
				}
				BlkFree(cindt);
			}
		}
	} else {
		cindt = BlkValueCreate(INDEXED_TEXT_TY);
		IT_BlobAccess(indt, blobtype, cindt, wanted, rindt);
		BlkValueCopy(indt, cindt);	
		BlkFree(cindt);
	}
];

[ IT_ReplaceText blobtype indt findt rindt
	cindt csize ilen flen i cl mpos ch chm whitespace punctuation;
	
	if (blobtype == REGEXP_BLOB or CHR_BLOB) 
		return IT_Replace_RE(blobtype, indt, findt, rindt);
	
	ilen = IT_CharacterLength(indt);
	flen = IT_CharacterLength(findt);
	cindt = BlkValueCreate(INDEXED_TEXT_TY);
	csize = BlkValueExtent(cindt);
	mpos = 0;

	whitespace = true; punctuation = false;
	for (i=0:i<=ilen:i++) {
		ch = BlkValueRead(indt, i);
		.MoreMatching;
		chm = BlkValueRead(findt, mpos++);
		if (mpos == 1) {
			switch (blobtype) {
				WORD_BLOB:
					if ((whitespace == false) && (punctuation == false)) chm = -1;
			}
		}
		whitespace = false;
		if (ch == 10 or 13 or 32 or 9) whitespace = true;
		punctuation = false;
		if (ch == '.' or ',' or '!' or '?'
			or '-' or '/' or '"' or ':' or ';'
			or '(' or ')' or '[' or ']' or '{' or '}') {
			if (blobtype == WORD_BLOB) chm = -1;
			punctuation = true;
		}
		if (ch == chm) {
			if (mpos == flen) {
				if (i == ilen) chm = 0;
				else chm = BlkValueRead(indt, i+1);
				if ((blobtype == CHR_BLOB) ||
					(chm == 0 or 10 or 13 or 32 or 9) ||
					(chm == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) {
					mpos = 0;
					cl = cl - (flen-1);
					BlkValueWrite(cindt, cl, 0);
					IT_Concatenate(cindt, rindt, CHR_BLOB);
					csize = BlkValueExtent(cindt);
					cl = IT_CharacterLength(cindt);
					continue;
				}
			}
		} else {
			mpos = 0;
		}
		if (cl+1 >= csize) {
			if (BlkValueSetExtent(cindt, 2*cl, 9) == false) break;
			csize = BlkValueExtent(cindt);
		}
		BlkValueWrite(cindt, cl++, ch);
	}
	BlkValueCopy(indt, cindt);	
	BlkFree(cindt);
];

[ IT_CharacterLength indt ch i dsize;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return 0;
	dsize = BlkValueExtent(indt);
	for (i=0:i<dsize:i++) {
		ch = BlkValueRead(indt, i);
		if (ch == 0) return i;
	}
	return dsize;
];

[ INDEXED_TEXT_TY_Empty indt;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) rfalse;
	if (IT_CharacterLength(indt) == 0) rtrue;
	rfalse;
];

[ IT_GetCharacter cindt indt i ch;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	if ((i<=0) || (i>IT_CharacterLength(indt))) ch = 0;
	else ch = BlkValueRead(indt, i-1);
	BlkValueWrite(cindt, 0, ch);
	BlkValueWrite(cindt, 1, 0);
	return cindt;
];

[ IT_CharactersOfCase indt case i ch len;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) rfalse;
	len = IT_CharacterLength(indt);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt, i);
		if ((ch) && (CharIsOfCase(ch, case) == false)) rfalse;
	}
	rtrue;
];

[ IT_CharactersToCase cindt indt case i ch len bnd;
	if ((indt==0) || (BlkType(indt) ~= INDEXED_TEXT_TY)) return;
	len = IT_CharacterLength(indt);
	if (BlkValueSetExtent(cindt, len+1, 11) == false) return cindt;
	bnd = 1;
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt, i);
		if (case < 2) {
			BlkValueWrite(cindt, i, CharToCase(ch, case));
		} else {
			BlkValueWrite(cindt, i, CharToCase(ch, bnd));
			if (case == 2) {
				bnd = 0;
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') bnd = 1;
			}
			if (case == 3) {
				if (ch ~= 0 or 10 or 13 or 32 or 9) {
					if (bnd == 1) bnd = 0;
					else {
						if (ch == '.' or '!' or '?') bnd = 1;
					}
				}
			}
		}
	}
	BlkValueWrite(cindt, len, 0);
	return cindt;
];

[ IT_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (BlkType(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (BlkType(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	switch(blobtype) {
		CHR_BLOB, 0:
			pos = IT_CharacterLength(indt_to);
			len = IT_CharacterLength(indt_from);
			if (BlkValueSetExtent(indt_to, pos+len+1, 10) == false) return indt_to;
			for (i=0:i<len:i++) {
				ch = BlkValueRead(indt_from, i);
				BlkValueWrite(indt_to, i+pos, ch);
			}
			BlkValueWrite(indt_to, len+pos, 0);
			return indt_to;
		REGEXP_BLOB:
			return IT_RE_Concatenate(indt_to, indt_from, blobtype, indt_ref);
		default:
			print "*** IT_Concatenate used on impossible blob type ***^";
			rfalse;
	}
];

[ SetPlayersCommand indt_from i len at;
	len = IT_CharacterLength(indt_from);
	if (len > 118) len = 118;
	#ifdef TARGET_ZCODE;
	buffer->1 = len; at = 2;
	#ifnot;
	buffer-->0 = len; at = 4;
	#endif;
	for (i=0:i<len:i++) buffer->(i+at) = CharToCase(BlkValueRead(indt_from, i), 0);
	for (:at+i<120:i++) buffer->(at+i) = ' ';
	VM_Tokenise(buffer, parse);
	players_command = 100 + WordCount(); ! The snippet variable ``player's command''
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ INDEXED_TEXT_TY_Support t a b c; rfalse; ];
[ INDEXED_TEXT_TY_Say indt; ];
[ SetPlayersCommand indt_from; ];
[ INDEXED_TEXT_TY_Create; ];
[ INDEXED_TEXT_TY_Cast a b c; ];
[ INDEXED_TEXT_TY_Empty t; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

Global IT_RE_Trace = false; ! Change to true for (a lot of) debugging data in use
[ IT_RE_SetTrace F; IT_RE_Trace = F; ];

! Character classes

Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;

! Control structures

Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;

! Substring matchers

Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;

! Positional matchers

Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;

! Mode switches

Constant SENSITIVITY_RE_CC = -50;

Constant RE_MAX_PACKETS = 32;

Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet
Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet

Array RE_PACKET_space --> RE_MAX_PACKETS*RE_PACKET_SIZE;

Constant RE_CCLASS = 0;      ! One of the class codes defined above
Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree
Constant RE_PREVIOUS = 5;    ! Elder sibling
Constant RE_DOWN = 6;        ! Child
Constant RE_UP = 7;          ! Parent
Constant RE_DATA1 = 8;       ! Backtracking data
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;

[ IT_RE_Node n cc par1 par2 par3  offset;
	if ((n<0) || (n >= RE_MAX_PACKETS)) rfalse;
	offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
	offset-->RE_CCLASS = cc;
	offset-->RE_PAR1 = par1;
	offset-->RE_PAR2 = par2;
	offset-->RE_PAR3 = par3;
	offset-->RE_NEXT = NULL;
	offset-->RE_PREVIOUS = NULL;
	offset-->RE_DOWN = NULL;
	offset-->RE_UP = NULL;
	offset-->RE_DATA1 = -1; ! Match start
	offset-->RE_DATA2 = -1; ! Match end
	offset-->RE_CONSTRAINT = -1; ! Rewind edge
	return offset;
];

[ IT_RE_NodeAddress n;
	if ((n<0) || (n >= RE_MAX_PACKETS)) return -1;
	return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;
];

Array RE_Subexpressions --> 11; ! Address of node for this subexpression
Array Allocated_Match_Vars --> 10; ! Indexed text to hold values of the variables

[ IT_RE_DebugMatchVars indt
	offset n i;
	print RE_Subexpressions-->10, " collecting subexps^";
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		print "Subexp ", offset-->RE_PAR1,
			" = [", offset-->RE_DATA1, ",", offset-->RE_DATA2, "] = ";
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++)
			print (char) BlkValueRead(indt, i);
		print "^";
	}
];

[ IT_RE_CreateMatchVars indt
	offset n i ch cindt cl csize;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++) {
		offset = RE_Subexpressions-->n;
		if (Allocated_Match_Vars-->n == 0)
			Allocated_Match_Vars-->n = INDEXED_TEXT_TY_Create(); ! Permanently
		cindt = Allocated_Match_Vars-->n;
		csize = BlkValueExtent(cindt);
		cl = 0;
		for (i=offset-->RE_DATA1:i<offset-->RE_DATA2:i++) {
			ch = BlkValueRead(indt, i);
			if (cl+1 >= csize) {
				if (BlkValueSetExtent(cindt, 2*cl, 6) == false) break;
				csize = BlkValueExtent(cindt);
			}
			BlkValueWrite(cindt, cl++, ch);
		}
		BlkValueWrite(cindt, cl, 0);
	}
];

[ IT_RE_EmptyMatchVars indt
	n;
	for (n=0:(n<RE_Subexpressions-->10) && (n<10): n++)
		if (Allocated_Match_Vars-->n ~= 0)
			BlkValueWrite(Allocated_Match_Vars-->n, 0, 0);
];

[ IT_RE_GetMatchVar indt vn
	offset;
	if ((vn<0) || (vn>=10) || (vn >= RE_Subexpressions-->10)) jump Nope;
	offset = RE_Subexpressions-->vn;
	if (offset == 0) jump Nope;
	if (offset-->RE_DATA1 < 0) jump Nope;
	if (Allocated_Match_Vars-->vn == 0) {
		print "*** ", vn, " unallocated! ***^";
		jump Nope;
	}
	BlkValueCopy(indt, Allocated_Match_Vars-->vn);
	return indt;

	.Nope;
	BlkValueWrite(indt, 0, 0);
	return indt;
];

[ IT_MV_End n end
	offset;
	offset = RE_Subexpressions-->n;
	if (end==0) return offset-->RE_DATA1;
	return offset-->RE_DATA2;
];

[ IT_RE_Clear_Markers token;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) IT_RE_Clear_Markers(token-->RE_DOWN);
		token-->RE_DATA1 = -1;
		token-->RE_DATA2 = -1;
		token-->RE_CONSTRAINT = -1;
	}
];

[ IT_RE_DebugTree findt detail;
	print "Pattern: ", (INDEXED_TEXT_TY_Say) findt, "^";
	IT_RE_DebugSubtree(findt, 1, RE_PACKET_space, detail);
];

[ IT_RE_DebugSubtree findt depth offset detail
	cup;
	if (offset ~= NULL) {
		cup = offset-->RE_UP;
		if (offset-->RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";
	}
	while (offset ~= NULL) {
		if (offset-->RE_UP ~= cup) print "*** broken up matching ***^";
		spaces(depth*2);
		IT_RE_DebugNode(offset, findt, detail);
		if (offset-->RE_DOWN ~= NULL) {
			if ((offset-->RE_DOWN)-->RE_UP ~= offset)
				print "*** broken down/up ***^";
			IT_RE_DebugSubtree(findt, depth+1, offset-->RE_DOWN, detail);
		}
		if (offset-->RE_NEXT ~= NULL) {
			if ((offset-->RE_NEXT)-->RE_PREVIOUS ~= offset)
				print "*** broken next/previous ***^";
		}
		offset = offset-->RE_NEXT;
	}
];

[ IT_RE_DebugNode offset findt detail
	i par1 par2 par3;
	if (offset == NULL) "[NULL]";
	print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";
	! for (i=0:i<RE_PACKET_SIZE:i++) print offset-->i, " ";
	par1 = offset-->RE_PAR1;
	par2 = offset-->RE_PAR2;
	par3 = offset-->RE_PAR3;
	switch (offset-->RE_CCLASS) {
		DIGIT_RE_CC: print "DIGIT";
		NONDIGIT_RE_CC: print "NONDIGIT";
		UCASE_RE_CC: print "UCASE";
		NONUCASE_RE_CC: print "NONUCASE";
		LCASE_RE_CC: print "LCASE";
		NONLCASE_RE_CC: print "NONLCASE";
		WHITESPACE_RE_CC: print "WHITESPACE";
		NONWHITESPACE_RE_CC: print "NONWHITESPACE";
		PUNCTUATION_RE_CC: print "PUNCTUATION";
		NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";
		WORD_RE_CC: print "WORD";
		NONWORD_RE_CC: print "NONWORD";
		ALWAYS_RE_CC: print "ALWAYS";
		NEVER_RE_CC: print "NEVER";
		START_RE_CC: print "START";
		END_RE_CC: print "END";
		BOUNDARY_RE_CC: print "BOUNDARY";
		NONBOUNDARY_RE_CC: print "NONBOUNDARY";
		ANYTHING_RE_CC: print "ANYTHING";
		NOTHING_RE_CC: print "NOTHING";
		RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(findt, i);
		VARIABLE_RE_CC: print "VARIABLE ", par1;
		SUBEXP_RE_CC:
			if (par1 == 0) print "EXP";
			else print "SUBEXP ";
			if (par1 >= 0) print "= V", par1;
			if (par2 == 1) {
				if (par3 == 0) print " (?=...) lookahead";
				else print " (?<=...) lookbehind of width ", par3;
			}
			if (par2 == 2) {
				if (par3 == 0) print " (?!...) negated lookahead";
				else print " (?<!...) negated lookbehind of width ", par3;
			}
			if (par2 == 3) print " uncollecting";
			if (par2 == 0 or 3) {
				if (par3 == 1) print " forcing case sensitivity";
				if (par3 == 2) print " forcing case insensitivity";
			}
			if (par2 == 4) print " (?>...) possessive";
		NEWLINE_RE_CC: print "NEWLINE";
		TAB_RE_CC: print "TAB";
		QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;
			if (par3) print " (lazy)"; else print " (greedy)";
		LITERAL_RE_CC: print "LITERAL";
			print " ";
			for (i=par1:i<par2:i++) print (char) BlkValueRead(findt, i);
		DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";
		CHOICE_RE_CC: print "CHOICE no ", par1;
		SENSITIVITY_RE_CC: print "SENSITIVITY";
			if (par1) print " off"; else print " on";
		IF_RE_CC: print "IF"; if (par1 >= 1) print " = V", par1;
		CONDITION_RE_CC: print "CONDITION"; if (par1 >= 1) print " = V", par1;
		THEN_RE_CC: print "THEN";
		ELSE_RE_CC: print "ELSE";
	}
	if (detail)
		print ": ", offset-->RE_DATA1, ", ", offset-->RE_DATA2, ", ", offset-->RE_CONSTRAINT;
	print "^";
];

[ IT_CHR_CompileTree findt exactly
	root literal fto no_packets token attach_to;

	fto = IT_CharacterLength(findt);

	root = IT_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);
	literal = IT_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);
	
	root-->RE_DOWN = literal;
	literal-->RE_UP = root;

	if (exactly) {
		no_packets = 2;
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = IT_RE_ExpandChoices(RE_PACKET_space, no_packets);
];

Array Subexp_Posns --> 20;
[ IT_RE_CompileTree findt exactly
	no_packets ffrom fto cc par1 par2 par3
	quantifiable token attach_to no_subs blevel bits;

	fto = IT_CharacterLength(findt);
	if (fto == 0) {
		IT_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches
		return 1;
	}

	attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);
	RE_Subexpressions-->0 = attach_to; RE_Subexpressions-->10 = 1; no_subs = 1;

	quantifiable = false; blevel = 0;
	
	for (ffrom = 0: ffrom < fto: ) {
		cc = BlkValueRead(findt, ffrom++); par1 = 0; par2 = 0; par3 = 0;
		if (cc == '\') {
			if (ffrom == fto) return "Search pattern not terminated";
			cc = BlkValueRead(findt, ffrom++);
			switch (cc) {
				'b': cc = BOUNDARY_RE_CC;
				'B': cc = NONBOUNDARY_RE_CC;
				'd': cc = DIGIT_RE_CC;
				'D': cc = NONDIGIT_RE_CC;
				'l': cc = LCASE_RE_CC;
				'L': cc = NONLCASE_RE_CC;
				'n': cc = NEWLINE_RE_CC;
				'p': cc = PUNCTUATION_RE_CC;
				'P': cc = NONPUNCTUATION_RE_CC;
				's': cc = WHITESPACE_RE_CC;
				'S': cc = NONWHITESPACE_RE_CC;
				't': cc = TAB_RE_CC;
				'u': cc = UCASE_RE_CC;
				'U': cc = NONUCASE_RE_CC;
				'w': cc = WORD_RE_CC;
				'W': cc = NONWORD_RE_CC;
				default:
					if ((cc >= '1') && (cc <= '9')) {
						par1 = cc-'0';
						cc = VARIABLE_RE_CC;
					} else {
						if (((cc >= 'a') && (cc <= 'z')) ||
							((cc >= 'A') && (cc <= 'Z'))) return "unknown escape";
						cc = LITERAL_RE_CC;
						par1 = ffrom-1; par2 = ffrom;
					}
			}
			quantifiable = true;
		} else {
			switch (cc) {
				'(': par2 = 0;
					!if (BlkValueRead(findt, ffrom) == ')') return "empty subexpression";
					if (BlkValueRead(findt, ffrom) == '?') {
						ffrom++;
						bits = true;
						if (BlkValueRead(findt, ffrom) == '-') { ffrom++; bits = false; }
						else if (BlkValueRead(findt, ffrom) == '<') { ffrom++; bits = false; }
						switch (cc = BlkValueRead(findt, ffrom++)) {
							'#': while (BlkValueRead(findt, ffrom++) ~= 0 or ')') ;
								if (BlkValueRead(findt, ffrom-1) == 0)
									return "comment never ends";
								continue;
							'(': cc = BlkValueRead(findt, ffrom);
								if ((cc == '1' or '2' or '3' or '4' or
									'5' or '6' or '7' or '8' or '9') &&
									(BlkValueRead(findt, ffrom+1) ==')')) {
									ffrom = ffrom + 2;
									par1 = cc - '0';
								} else ffrom--;
								cc = IF_RE_CC; ! (?(...)...) conditional
								quantifiable = false;
								if (blevel == 20) return "subexpressions too deep";
								Subexp_Posns-->(blevel++) = IT_RE_NodeAddress(no_packets);
								jump CClassKnown;
							'=': par2 = 1; ! (?=...) lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							'!': par2 = 2; ! (?!...) negated lookahead/behind
								par3 = 0; if (bits == false) par3 = -1;
							':': par2 = 3; ! (?:...) uncollecting subexpression
							'>': par2 = 4; ! (?>...) possessive
							default:
								if (BlkValueRead(findt, ffrom) == ')') {
									if (cc == 'i') {
										cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;
										jump CClassKnown;
									}
								}
								if (BlkValueRead(findt, ffrom) == ':') {
									if (cc == 'i') {
										par1 = bits; par2 = 3; par3 = bits+1; ffrom++;
										jump AllowForm;
									}
								}
								return "unknown (?...) form";
						}
					}
					.AllowForm;
					if (par2 == 0) par1 = no_subs++; else par1 = -1;
					cc = SUBEXP_RE_CC; 
					quantifiable = false;
					if (blevel == 20) return "subexpressions too deep";
					Subexp_Posns-->(blevel++) = IT_RE_NodeAddress(no_packets);
				')': if (blevel == 0) return "subexpression bracket mismatch";
					blevel--;
					attach_to = Subexp_Posns-->blevel;
					if (attach_to-->RE_DOWN == NULL) {
						if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
						attach_to-->RE_DOWN =
							IT_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);
						(attach_to-->RE_DOWN)-->RE_UP = attach_to;
					}
					quantifiable = true;
					continue;
				'.': cc = ANYTHING_RE_CC; quantifiable = true;
				'|': cc = CHOICE_RE_CC; quantifiable = false;
				'^': cc = START_RE_CC; quantifiable = false;
				'$': cc = END_RE_CC; quantifiable = false;
				'{': if (quantifiable == false) return "quantifier misplaced";
					par1 = 0; par2 = -1; bits = 1;
					while ((cc=BlkValueRead(findt, ffrom++)) ~= 0 or '}') {
						if (cc == ',') {
							bits++;
							if (bits >= 3) return "too many colons in ?{...}";
							continue;
						}
						if ((cc >= '0') || (cc <= '9')) {
							if (bits == 1) {
								if (par1 < 0) par1 = 0;
								par1 = par1*10 + (cc-'0');
							} else {
								if (par2 < 0) par2 = 0;
								par2 = par2*10 + (cc-'0');
							}
						} else return "non-digit in ?{...}";
					}
					if (cc ~= '}') return "{x,y} quantifier never ends";
					cc = QUANTIFIER_RE_CC;
					if (par2 == -1) {
						if (bits == 2) par2 = 30000;
						else par2 = par1;
					}
					if (par1 > par2) return "{x,y} with x greater than y";
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'<', '[': par3 = false; if (cc == '<') bits = '>'; else bits = ']';
					if (BlkValueRead(findt, ffrom) == '^') { ffrom++; par3 = true; }
					par1 = ffrom;
					if (BlkValueRead(findt, ffrom) == bits) { ffrom++; }
					while (cc ~= bits or 0) {
						cc = BlkValueRead(findt, ffrom++);
						if (cc == '\') {
							cc = BlkValueRead(findt, ffrom++);
							if (cc ~= 0) cc = BlkValueRead(findt, ffrom++);
						}
					}
					if (cc == 0) return "Character range never ends";
					par2 = ffrom-1;
					if ((par2 > par1 + 1) &&
						(BlkValueRead(findt, par1) == ':') &&
						(BlkValueRead(findt, par2-1) == ':') &&
						(BlkValueRead(findt, par2-2) ~= '\'))
						return "POSIX named character classes unsupported";
					bits = IT_RE_RangeSyntaxCorrect(findt, par1, par2);
					if (bits) return bits;
					if (par1 < par2) cc = RANGE_RE_CC;
					else cc = NOTHING_RE_CC;
					quantifiable = true;
				'*': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 30000;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'+': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 1; par2 = 30000;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
				'?': if (quantifiable == false) return "quantifier misplaced";
					cc = QUANTIFIER_RE_CC;
					par1 = 0; par2 = 1;
					if (BlkValueRead(findt, ffrom) == '?') { ffrom++; par3 = true; }
					quantifiable = false;
			}
		}
		
		.CClassKnown;
		
		if (cc >= 0) {
			quantifiable = true;
			if ((attach_to-->RE_CCLASS == LITERAL_RE_CC) &&
				(BlkValueRead(findt, ffrom) ~= '*' or '+' or '?' or '{')) {
				(attach_to-->RE_PAR2)++;
				if (IT_RE_Trace == 2) {
					print "Extending literal by ", cc, "=", (char) cc, "^";
				}
				continue;
			}
			cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;
		}
		
		if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";

		if (IT_RE_Trace == 2) {
			print "Attaching packet ", no_packets+1, " to ";
			IT_RE_DebugNode(attach_to, findt);
			IT_RE_DebugTree(findt);
		}

		token = IT_RE_Node(no_packets++, cc, par1, par2, par3);

		if ((token-->RE_CCLASS == SUBEXP_RE_CC) && (token-->RE_PAR2 == 0)) {
			RE_Subexpressions-->(token-->RE_PAR1) = token;
			(RE_Subexpressions-->10)++;
		}
		
		if ((attach_to-->RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &&
			(attach_to-->RE_DOWN == NULL)) {
			attach_to-->RE_DOWN = token; token-->RE_UP = attach_to;
		} else {
			if ((token-->RE_CCLASS == CHOICE_RE_CC) &&
				((attach_to-->RE_UP)-->RE_CCLASS == CHOICE_RE_CC)) {
				no_packets--; token = attach_to-->RE_UP;
			} else {
				if (token-->RE_CCLASS == CHOICE_RE_CC) {
					while (attach_to-->RE_PREVIOUS ~= NULL)
						attach_to = attach_to-->RE_PREVIOUS;
				}
				if (token-->RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {
					token-->RE_PREVIOUS = attach_to-->RE_PREVIOUS;
					token-->RE_UP = attach_to-->RE_UP;
					if ((attach_to-->RE_UP ~= NULL) && (attach_to-->RE_PREVIOUS == NULL))
						(attach_to-->RE_UP)-->RE_DOWN = token;
					token-->RE_DOWN = attach_to;
					bits = attach_to;
					while (bits ~= NULL) {
						bits-->RE_UP = token;
						bits = bits-->RE_NEXT;
					}
					attach_to-->RE_PREVIOUS = NULL;
					if (token-->RE_PREVIOUS ~= NULL)
						(token-->RE_PREVIOUS)-->RE_NEXT = token;
				} else {
					attach_to-->RE_NEXT = token; token-->RE_PREVIOUS = attach_to;
					token-->RE_UP = attach_to-->RE_UP;
				}
			}
		}
		
		if (token-->RE_CCLASS == CHOICE_RE_CC) {
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			token-->RE_NEXT = IT_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);
			(token-->RE_NEXT)-->RE_PREVIOUS = token;
			(token-->RE_NEXT)-->RE_UP = token-->RE_UP;
			token = token-->RE_NEXT;
		}

		attach_to = token;

		if (IT_RE_Trace == 2) {
			print "Result:^";
			IT_RE_DebugTree(findt);
		}

	}
	
	if (blevel ~= 0) return "subexpression bracket mismatch";

	if (exactly) {
		if (no_packets+3 > RE_MAX_PACKETS) return "regexp too complex";
		exactly = RE_PACKET_space-->RE_DOWN;
		token = IT_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);
		RE_PACKET_space-->RE_DOWN = token; token-->RE_UP = RE_PACKET_space;
		attach_to = IT_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);
		token-->RE_NEXT = attach_to; attach_to-->RE_PREVIOUS = token;
		attach_to-->RE_UP = RE_PACKET_space;
		attach_to-->RE_NEXT = IT_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);
		(attach_to-->RE_NEXT)-->RE_PREVIOUS = attach_to;
		(attach_to-->RE_NEXT)-->RE_UP = RE_PACKET_space;
		attach_to-->RE_DOWN = exactly;
		while (exactly ~= NULL) {
			exactly-->RE_UP = attach_to; exactly = exactly-->RE_NEXT;
		}
	}
	
	no_packets = IT_RE_ExpandChoices(RE_PACKET_space, no_packets);

	if (IT_RE_Trace) {
		print "Compiled pattern:^";
		IT_RE_DebugTree(findt);
	}
	
	bits = IT_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;
	
	return no_packets;
];

[ IT_RE_RangeSyntaxCorrect findt rf rt
	i chm;
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(findt, ++i);
			if (((chm >= 'a') && (chm <= 'z')) ||
				((chm >= 'A') && (chm <= 'Z'))) {
				if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'
					or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')
					return "Invalid escape in {} range";
			}
		}
		if ((i+2<rt) && (BlkValueRead(findt, i+1) == '-')) {
			if (chm > BlkValueRead(findt, i+2)) return "Invalid {} range";
			i=i+2;
		}
	}
	rfalse;
];

[ IT_RE_ExpandChoices token no_packets
	rv prev nex holder new ct n cond_node then_node else_node;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == IF_RE_CC) {
			if ((token-->RE_DOWN)-->RE_CCLASS == CHOICE_RE_CC) {
				for (nex=token-->RE_DOWN, n=0: nex~=NULL: nex=nex-->RE_NEXT) n++;
				if (n~=2) return "conditional has too many clauses";
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
				}
				then_node = token-->RE_DOWN;
				then_node-->RE_CCLASS = THEN_RE_CC;
				else_node = then_node-->RE_NEXT;
				else_node-->RE_CCLASS = ELSE_RE_CC;
				if (cond_node-->RE_PAR1 < 1) {
					cond_node-->RE_DOWN = then_node-->RE_DOWN;
					then_node-->RE_DOWN = (then_node-->RE_DOWN)-->RE_NEXT;
					if (then_node-->RE_DOWN ~= NULL)
						(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node; cond_node-->RE_UP = token;
				cond_node-->RE_NEXT = then_node; then_node-->RE_PREVIOUS = cond_node;
			} else {
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				cond_node = IT_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);
				if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
				then_node = IT_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);
				if (token-->RE_PAR1 >= 1) {
					cond_node-->RE_PAR1 = token-->RE_PAR1;
					then_node-->RE_DOWN = token-->RE_DOWN;
				} else {
					cond_node-->RE_DOWN = token-->RE_DOWN;
					then_node-->RE_DOWN = (token-->RE_DOWN)-->RE_NEXT;
					(cond_node-->RE_DOWN)-->RE_NEXT = NULL;
					(cond_node-->RE_DOWN)-->RE_UP = cond_node;
				}
				token-->RE_DOWN = cond_node;
				cond_node-->RE_UP = token; cond_node-->RE_NEXT = then_node;
				then_node-->RE_PREVIOUS = cond_node; then_node-->RE_UP = token;
				then_node-->RE_NEXT = NULL;
				if (then_node-->RE_DOWN ~= NULL)
					(then_node-->RE_DOWN)-->RE_PREVIOUS = NULL;
				for (nex = then_node-->RE_DOWN: nex ~= NULL: nex = nex-->RE_NEXT) {
					nex-->RE_UP = then_node;
				}
			}
			
			if (cond_node-->RE_DOWN ~= NULL) {
				nex = cond_node-->RE_DOWN;
				if ((nex-->RE_CCLASS ~= SUBEXP_RE_CC) ||
					(nex-->RE_NEXT ~= NULL) ||
					(nex-->RE_PAR2 ~= 1 or 2)) {
					!IT_RE_DebugSubtree(0, 0, nex, true);
					return "condition not lookahead/behind";
				}
			}
		}
		if ((token-->RE_CCLASS == CHOICE_RE_CC) && (token-->RE_PAR1 < 1)) {
			prev = token-->RE_PREVIOUS;
			nex = token-->RE_NEXT;
			while ((nex ~= NULL) && (nex-->RE_CCLASS == CHOICE_RE_CC))
				nex = nex-->RE_NEXT;
			holder = token-->RE_UP; if (holder == NULL) return "bang";
			if (no_packets >= RE_MAX_PACKETS) return "regexp too complex";
			new = IT_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);
			holder-->RE_DOWN = new; new-->RE_UP = holder;
			if (prev ~= NULL) {
				prev-->RE_NEXT = new; new-->RE_PREVIOUS = prev;
			}
			if (nex ~= NULL) {
				nex-->RE_PREVIOUS = new; new-->RE_NEXT = nex;
			}
			new-->RE_DOWN = token;
			token-->RE_PREVIOUS = NULL;
			ct = 1;
			while (token ~= NULL) {
				token-->RE_PAR1 = ct++;
				token-->RE_UP = new;
				if ((token-->RE_NEXT ~= NULL) &&
					((token-->RE_NEXT)-->RE_CCLASS ~= CHOICE_RE_CC))
					token-->RE_NEXT = NULL;
				token = token-->RE_NEXT;
			}
			new-->RE_PAR1 = ct-1;
			if (token ~= NULL) token-->RE_NEXT = NULL;
			token = new; continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			no_packets = IT_RE_ExpandChoices(token-->RE_DOWN, no_packets);
			if ((no_packets<0) || (no_packets >= RE_MAX_PACKETS)) break;
		}
		token = token-->RE_NEXT;
	}
	return no_packets;
];

[ IT_RE_CheckTree token no_subs
	rv;
	while (token ~= NULL) {
		if (token-->RE_CCLASS == VARIABLE_RE_CC) {
			if (token-->RE_PAR1 >= no_subs) return "reference to nonexistent group";
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2) &&
			(token-->RE_PAR3 == -1)) {
			token-->RE_PAR3 = IT_RE_Width(token-->RE_DOWN);
			if (token-->RE_PAR3 == -1) return "variable length lookbehind not implemented";
		}
		if (token-->RE_DOWN ~= NULL) {
			rv = IT_RE_CheckTree(token-->RE_DOWN, no_subs);
			if (rv) return rv;
		}
		token = token-->RE_NEXT;
	}
	rfalse;
];

[ IT_RE_Width token downwards
	w rv aw choice;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,
			PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,
			ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,
			UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
				w++;
			START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
				;
			LITERAL_RE_CC:
				w = w + token-->RE_PAR2 - token-->RE_PAR1;
			VARIABLE_RE_CC:
				return -1;
			IF_RE_CC:
				rv = IT_RE_Width((token-->RE_DOWN)-->RE_NEXT);
				if (rv == -1) return -1;
				if (rv ~= IT_RE_Width(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT))
					return -1;
				w = w + rv;
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) rv = 0;
				else {
					rv = IT_RE_Width(token-->RE_DOWN);
					if (rv == -1) return -1;
				}
				w = w + rv;
			QUANTIFIER_RE_CC:
				if (token-->RE_PAR1 ~= token-->RE_PAR2) return -1;
				rv = IT_RE_Width(token-->RE_DOWN);
				if (rv == -1) return -1;
				w = w + rv*(token-->RE_PAR1);				
			DISJUNCTION_RE_CC:
				aw = -1;
				for (choice = token-->RE_DOWN: choice ~= NULL: choice = choice-->RE_NEXT) {
					rv = IT_RE_Width(choice-->RE_DOWN);
					!print "Option found ", rv, "^";
					if (rv == -1) return -1;
					if ((aw >= 0) && (aw ~= rv)) return -1;
					aw = rv;
				}
				w = w + aw;
			SENSITIVITY_RE_CC:
				;
		}
		if (downwards) return w;
		if (token ~= NULL) token = token-->RE_NEXT;
	}
	return w;
];

Global IT_RE_RewindCount;
[ IT_RE_PrintNoRewinds; print IT_RE_RewindCount; ];

Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;

[ IT_RE_Parse findt indt ipos insens
	ilen rv root i initial_mode;

	ilen = IT_CharacterLength(indt);
	if ((ipos<0) || (ipos>ilen)) return -1;
	
	root = RE_PACKET_space;
	
	initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;
	
	IT_RE_Clear_Markers(RE_PACKET_space);
	
	for (:ipos<=ilen:ipos++) {
		if ((RE_PACKET_space-->RE_DOWN ~= NULL) &&
			((RE_PACKET_space-->RE_DOWN)-->RE_CCLASS == START_RE_CC) &&
			(ipos>0)) { rv = -1; break; }
		if (ipos > 0) IT_RE_EraseConstraints(RE_PACKET_space, initial_mode);
		IT_RE_RewindCount = 0;
		rv = IT_RE_ParseAtPosition(findt, indt, ipos, ilen, RE_PACKET_space, initial_mode);
		if (rv >= 0) break;
	}

	if (rv == -1) {
		root-->RE_DATA1 = -1;
		root-->RE_DATA2 = -1;
	} else {
		root-->RE_DATA1 = ipos;
		root-->RE_DATA2 = ipos+rv;
	}
	return rv;
];

[ IT_RE_ParseAtPosition findt indt ifrom ito token mode_flags
	outcome ipos npos rv i ch edge rewind_this;

	if (ifrom > ito) return -1;

	ipos = ifrom;

	.Rewind;
	while (token ~= NULL) {
		outcome = false;
		if (IT_RE_Trace) {
			print "Matching at ", ipos, ": ";
			IT_RE_DebugNode(token, findt, true);
		}

		if (ipos<ito) ch = BlkValueRead(indt, ipos); else ch = 0;

		token-->RE_MODES = mode_flags; ! Save in case of backtrack

		switch (token-->RE_CCLASS) {
			
			! Should never happen
			
			CHOICE_RE_CC: return "internal error";
			
			! Mode switches
			
			SENSITIVITY_RE_CC:
				if (token-->RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;
				else mode_flags = mode_flags & (~CIS_MFLAG);
				outcome = true;
		
			! Zero-length positional markers
			
			ALWAYS_RE_CC:
				outcome = true;
			NEVER_RE_CC:
			START_RE_CC:
				if (ipos == 0) outcome = true;
			END_RE_CC:
				if (BlkValueRead(indt, ipos) == 0) outcome = true;
			BOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv == 1) outcome = true;
			NONBOUNDARY_RE_CC:
				rv = 0;
				if (BlkValueRead(indt, ipos) == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (ipos == 0) ch = 0;
				else ch = BlkValueRead(indt, ipos-1);
				if (ch == 0 or 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') rv++;
				if (rv ~= 1) outcome = true;

			! Control constructs
		
			IF_RE_CC:
				i = token-->RE_PAR1; ch = false;
				if (IT_RE_Trace) {
					print "Trying conditional from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				if (i >= 1) {
					 if ((i<RE_Subexpressions-->10) &&
					 	((RE_Subexpressions-->i)-->RE_DATA1 >= 0)) ch = true;
				} else {					 	
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						(token-->RE_DOWN)-->RE_DOWN, mode_flags);
					if (rv >= 0) ch = true;
				}
				if (IT_RE_Trace) {
					print "Condition found to be ", ch, "^";
				}
				if (ch) {
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						((token-->RE_DOWN)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Then clause returned ", rv, "^";
				} else {
					if ((((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT) == NULL)
						rv = 0; ! The empty else clause matches
					else rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						(((token-->RE_DOWN)-->RE_NEXT)-->RE_NEXT)-->RE_DOWN, mode_flags);
					!print "Else clause returned ", rv, "^";
				}
				if (rv >= 0) {
					outcome = true;
					ipos = ipos + rv;
				}
			DISJUNCTION_RE_CC:
				if (IT_RE_Trace) {
					print "Trying disjunction from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				for (ch = token-->RE_DOWN: ch ~= NULL: ch = ch-->RE_NEXT) {
					if (ch-->RE_PAR1 <= token-->RE_CONSTRAINT) continue;
					if (IT_RE_Trace) {
						print "Trying choice at ", ipos, ": ";
						IT_RE_DebugNode(ch, findt, true);
					}
					rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito,
						ch-->RE_DOWN, mode_flags);
					if (rv >= 0) {
						token-->RE_DATA1 = ipos; ! Where match was made
						token-->RE_DATA2 = ch-->RE_PAR1; ! Option taken
						ipos = ipos + rv;
						outcome = true;
						if (IT_RE_Trace) {
							print "Choice worked with width ", rv, ": ";
							IT_RE_DebugNode(ch, findt, true);
						}
						break;
					} else {
						if (mode_flags & ACCUM_MFLAG == false)
							IT_RE_FailSubexpressions(ch-->RE_DOWN);
					}						
				}
				if (outcome == false) {
					if (IT_RE_Trace) {
						print "Failed disjunction from ", ipos, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
					token-->RE_DATA1 = ipos; ! Where match was tried
					token-->RE_DATA2 = -1; ! No option was taken
				}
			SUBEXP_RE_CC:
				if (token-->RE_PAR2 == 1 or 2) {
					npos = ipos - token-->RE_PAR3;
					if (npos<0) rv = -1; ! Lookbehind fails: nothing behind
					else rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
						mode_flags);
				} else {
					switch (token-->RE_PAR3) {
						0: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags);
						1: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags & (~CIS_MFLAG));
						2: rv = IT_RE_ParseAtPosition(findt, indt, ipos, ito, token-->RE_DOWN,
							mode_flags | CIS_MFLAG);
					}
				}
				npos = ipos;
				if (rv >= 0) npos = ipos + rv;
				switch (token-->RE_PAR2) {
					1: if (rv >= 0) rv = 0;
					2: if (rv >= 0) rv = -1; else rv = 0;
				}
				if (rv >= 0) {
					token-->RE_DATA1 = ipos;
					ipos = ipos + rv;
					token-->RE_DATA2 = npos;
					outcome = true;
				} else {
					if (mode_flags & ACCUM_MFLAG == false) {
						token-->RE_DATA1 = -1;
						token-->RE_DATA2 = -1;
					}
				}
				if (token-->RE_PAR2 == 2) IT_RE_FailSubexpressions(token, true);
			QUANTIFIER_RE_CC:
				token-->RE_DATA1 = ipos;
				if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
					(token-->RE_DOWN)-->RE_CACHE1 = -1;
					(token-->RE_DOWN)-->RE_CACHE2 = -1;	
				}
				if (IT_RE_Trace) {
					print "Trying quantifier from ", ipos, ": ";
					IT_RE_DebugNode(token, findt, true);
				}
				if (token-->RE_PAR3 == false) { ! Greedy quantifier
					!edge = ito; if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					edge = token-->RE_PAR2;
					if (token-->RE_CONSTRAINT >= 0) edge = token-->RE_CONSTRAINT;
					rv = -1;
					for (i=0, npos=ipos: i<edge: i++) {
						if (IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							IT_RE_DebugNode(token, findt, true);
						}
						rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= token-->RE_PAR1) && (i <= token-->RE_PAR2))
						outcome = true;
				} else { ! Lazy quantifier
					edge = token-->RE_PAR1;
					if (token-->RE_CONSTRAINT > edge) edge = token-->RE_CONSTRAINT;
					for (i=0, npos=ipos: (npos<ito) && (i < token-->RE_PAR2): i++) {
						if (i >= edge) break;
						if (IT_RE_Trace) {
							print "Trying quant rep ", i+1, " at ", npos, ": ";
							IT_RE_DebugNode(token, findt, true);
						}
						rv = IT_RE_ParseAtPosition(findt, indt, npos, ito, token-->RE_DOWN,
							mode_flags | ACCUM_MFLAG);
						if (rv < 0) break;
						if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
							(token-->RE_DOWN)-->RE_CACHE1 = (token-->RE_DOWN)-->RE_DATA1;
							(token-->RE_DOWN)-->RE_CACHE2 = (token-->RE_DOWN)-->RE_DATA2;	
						}
						if ((rv == 0) && (token-->RE_PAR2 == 30000) && (i>=1)) { i++; break; }
						npos = npos + rv;
					}
					if ((i >= edge) && (i <= token-->RE_PAR2))
						outcome = true;
				}
				if (outcome) {
					if (token-->RE_PAR3 == false) { ! Greedy quantifier
						if (i > token-->RE_PAR1) { ! I.e., if we have been greedy
							token-->RE_DATA2 = i-1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					} else { ! Lazy quantifier
						if (i < token-->RE_PAR2) { ! I.e., if we have been lazy
							token-->RE_DATA2 = i+1; ! And its edge limitation
						} else {
							token-->RE_DATA2 = -1;
						}
					}
					ipos = npos;
					if ((i == 0) && (mode_flags & ACCUM_MFLAG == false))
						IT_RE_FailSubexpressions(token-->RE_DOWN);
					if ((token-->RE_DOWN)-->RE_CCLASS == SUBEXP_RE_CC) {
						(token-->RE_DOWN)-->RE_DATA1 = (token-->RE_DOWN)-->RE_CACHE1;
						(token-->RE_DOWN)-->RE_DATA2 = (token-->RE_DOWN)-->RE_CACHE2;	
					}
					if (IT_RE_Trace) {
						print "Successful quant reps ", i, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
				} else {
					!token-->RE_DATA2 = -1;
					if (mode_flags & ACCUM_MFLAG == false)
						IT_RE_FailSubexpressions(token-->RE_DOWN);
					if (IT_RE_Trace) {
						print "Failed quant reps ", i, ": ";
						IT_RE_DebugNode(token, findt, true);
					}
				}
				
			! Character classes
				
			NOTHING_RE_CC: ;
			ANYTHING_RE_CC: if (ch) outcome = true; ipos++;
			WHITESPACE_RE_CC:
				if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }
			NONWHITESPACE_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }
			PUNCTUATION_RE_CC:
				if (ch == '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			NONPUNCTUATION_RE_CC:
				if ((ch) && (ch ~= '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			WORD_RE_CC:
				if ((ch) && (ch ~= 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }
			NONWORD_RE_CC:
				if (ch == 10 or 13 or 32 or 9
					or '.' or ',' or '!' or '?'
					or '-' or '/' or '"' or ':' or ';'
					or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }
			DIGIT_RE_CC:
				if (ch == '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }
			NONDIGIT_RE_CC:
				if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
					or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }
			LCASE_RE_CC:
				if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }
			NONLCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }
			UCASE_RE_CC:
				if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }
			NONUCASE_RE_CC:
				if ((ch) && (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }
			NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }
			TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }
			RANGE_RE_CC:
				if (IT_RE_Range(ch, findt,
					token-->RE_PAR1, token-->RE_PAR2, token-->RE_PAR3, mode_flags & CIS_MFLAG))
					{ outcome = true; ipos++; }
			
			! Substring matches
			
			LITERAL_RE_CC:
				rv = IT_RE_MatchSubstring(indt, ipos,
					findt, token-->RE_PAR1, token-->RE_PAR2, mode_flags & CIS_MFLAG);
				if (rv >= 0) { ipos = ipos + rv; outcome = true; }
			VARIABLE_RE_CC:
				i = token-->RE_PAR1;
				if ((RE_Subexpressions-->i)-->RE_DATA1 >= 0) {
					rv = IT_RE_MatchSubstring(indt, ipos,
						indt, (RE_Subexpressions-->i)-->RE_DATA1,
						(RE_Subexpressions-->i)-->RE_DATA2, mode_flags & CIS_MFLAG);
					if (rv >= 0) { ipos = ipos + rv; outcome = true; }
				}
				.NeverMatchIncompleteVar;
		}
		
		if (outcome == false) {
			if (IT_RE_RewindCount++ >= 10000) {
				if (IT_RE_RewindCount == 10001) {
					style bold; print "OVERFLOW^"; style roman;
				}
				return -1;
			}
			if (IT_RE_Trace) {
				print "Rewind sought from failure at pos ", ipos, " with: ";
					IT_RE_DebugNode(token, findt, true);
			}
			if ((token-->RE_CCLASS == QUANTIFIER_RE_CC) &&
				(IT_RE_SeekBacktrack(token-->RE_DOWN, findt, false, ito, false)))
				jump RewindFound;
			if (mode_flags & ACCUM_MFLAG == false) IT_RE_FailSubexpressions(token);
			token = token-->RE_PREVIOUS;
			while (token ~= NULL) {
				if (IT_RE_SeekBacktrack(token, findt, true, ito, false)) {
					.RewindFound;
					ipos = token-->RE_DATA1;
					mode_flags = token-->RE_MODES;
					if (mode_flags & ACCUM_MFLAG == false)
						IT_RE_FailSubexpressions(token, true);
					if (ipos == -1)
						IT_RE_DebugTree(findt, true);
					if (IT_RE_Trace) {
						print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";
						IT_RE_DebugNode(token, findt, true);
					}
					jump Rewind;
				}
				token = token-->RE_PREVIOUS;
			}
			if (IT_RE_Trace)
				print "^Rewind impossible^";
			return -1;
		}

		token = token-->RE_NEXT;
	}
	return ipos - ifrom;
];

[ IT_RE_SeekBacktrack token findt downwards ito report_only
	untried;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if ((IT_RE_Trace) && (report_only == false)) {
			print "Scan for rewind: ";
			IT_RE_DebugNode(token, findt, true);
		}
		if ((token-->RE_CCLASS == SUBEXP_RE_CC) &&
			(token-->RE_PAR2 == 1 or 2 or 4)) {
			if (downwards) rfalse;
			continue;
		}
		if (token-->RE_DOWN ~= NULL) {
			if ((IT_RE_Trace) && (report_only == false)) print "Descend^";
			if (IT_RE_SeekBacktrack(token-->RE_DOWN, findt, false, ito, report_only)) rtrue;
		}
		untried = false;
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC:
				if ((token-->RE_DATA2 >= 1) &&
					(token-->RE_DATA2 < token-->RE_PAR1) &&
					(token-->RE_CONSTRAINT < token-->RE_PAR1)) { ! Matched but earlier than last
					if (report_only) rtrue;
					if (token-->RE_CONSTRAINT == -1)
						token-->RE_CONSTRAINT = 1;
					else
						(token-->RE_CONSTRAINT)++;
					untried = true;
				}
			QUANTIFIER_RE_CC:
				if (token-->RE_CONSTRAINT ~= -2) {
					if ((IT_RE_Trace) && (report_only == false)) {
						print "Quant with cons not -2: ";
						IT_RE_DebugNode(token, findt, true);
					}
					if (token-->RE_DATA2 >= 0) {
						if (report_only) rtrue;
						token-->RE_CONSTRAINT = token-->RE_DATA2;
						untried = true;
					}
				}
		}
		if (untried) {
			if (IT_RE_Trace) {
				print "Grounds for rewind at: ";
				IT_RE_DebugNode(token, findt, true);
			}
			IT_RE_EraseConstraints(token-->RE_NEXT);
			IT_RE_EraseConstraints(token-->RE_DOWN);
			rtrue;
		}
		if (downwards) rfalse;
	}
	rfalse;
];

[ IT_RE_FailSubexpressions token downwards;
	for (: token ~= NULL: token = token-->RE_NEXT) {
		if (token-->RE_DOWN ~= NULL) IT_RE_FailSubexpressions(token-->RE_DOWN);
		if (token-->RE_CCLASS == SUBEXP_RE_CC) {
			token-->RE_DATA1 = -1;
			token-->RE_DATA2 = -1;
		}
		if (downwards) break;
	}
];

[ IT_RE_EraseConstraints token;
	while (token ~= NULL) {
		switch (token-->RE_CCLASS) {
			DISJUNCTION_RE_CC: token-->RE_CONSTRAINT = -1;
			QUANTIFIER_RE_CC: token-->RE_CONSTRAINT = -1;
		}
		if (token-->RE_DOWN) IT_RE_EraseConstraints(token-->RE_DOWN);
		token = token-->RE_NEXT;
	}
];

[ IT_RE_MatchSubstring indt ipos mindt mfrom mto insens
	i ch;
	if (mfrom < 0) return 0;
	if (insens)
		for (i=mfrom:i<mto:i++) {
			ch = BlkValueRead(mindt, i);
			if (BlkValueRead(indt, ipos++) ~= ch or IT_RevCase(ch))
				return -1;
		}
	else
		for (i=mfrom:i<mto:i++)
			if (BlkValueRead(indt, ipos++) ~= BlkValueRead(mindt, i))
				return -1;
	return mto-mfrom;
];

[ IT_RE_Range ch findt rf rt negate insens
	i chm upper crev;
	if (ch == 0) rfalse;
	if (negate == true) {
		if (IT_RE_Range(ch, findt, rf, rt, false, insens)) rfalse;
		rtrue;
	}
	for (i=rf: i<rt: i++) {
		chm = BlkValueRead(findt, i);
		if ((chm == '\') && (i+1<rt)) {
			chm = BlkValueRead(findt, ++i);
			switch (chm) {
				's':
					if (ch == 10 or 13 or 32 or 9) rtrue;
				'S':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9)) rtrue;
				'p':
					if (ch == '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'P':
					if ((ch) && (ch ~= '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'w':
					if ((ch) && (ch ~= 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;
				'W':
					if (ch == 10 or 13 or 32 or 9
						or '.' or ',' or '!' or '?'
						or '-' or '/' or '"' or ':' or ';'
						or '(' or ')' or '[' or ']' or '{' or '}') rtrue;
				'd':
					if (ch == '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9') rtrue;
				'D':
					if ((ch) && (ch ~= '0' or '1' or '2' or '3' or '4'
						or '5' or '6' or '7' or '8' or '9')) rtrue;
				'l': if (CharIsOfCase(ch, 0)) rtrue;
				'L': if (CharIsOfCase(ch, 0) == false) rtrue;
				'u': if (CharIsOfCase(ch, 1)) rtrue;
				'U': if (CharIsOfCase(ch, 1) == false) rtrue;
				'n': if (ch == 10) rtrue;
				't': if (ch == 9) rtrue;
			}
		}
		if ((i+2<rt) && (BlkValueRead(findt, i+1) == '-')) {
			upper = BlkValueRead(findt, i+2);
			if ((ch >= chm) && (ch <= upper)) rtrue;
			if (insens) {
				crev = IT_RevCase(ch);
				if ((crev >= chm) && (crev <= upper)) rtrue;
			}
			i=i+2;
		} else {
			if (chm == ch) rtrue;
			if ((insens) && (chm == IT_RevCase(ch))) rtrue;
		}
	}
	rfalse;
];

[ IT_Replace_RE findtype indt findt rindt insens exactly
	cindt csize ilen i cl mpos cpos ch chm;
	ilen = IT_CharacterLength(indt);

	IT_RE_Err = 0;
	switch (findtype) {
		REGEXP_BLOB: i = IT_RE_CompileTree(findt, exactly);
		CHR_BLOB: i = IT_CHR_CompileTree(findt, exactly);
		default: "*** bad findtype ***";
	}
	
	if ((i<0) || (i>RE_MAX_PACKETS)) {
		IT_RE_Err = i;
		print "*** Regular expression error: ", (string) IT_RE_Err, " ***^";
		RunTimeProblem(RTP_REGEXPSYNTAXERROR);
		return 0;
	}

	if (IT_RE_Trace) {
		IT_RE_DebugTree(findt);
		print "(compiled to ", i, " packets)^";
	}
	
	if (findtype == REGEXP_BLOB) IT_RE_EmptyMatchVars();

	mpos = 0; chm = 0; cpos = 0;
	while (IT_RE_Parse(findt, indt, mpos, insens) >= 0) {
		chm++;
		
		if (IT_RE_Trace) {
			print "^*** Match ", chm, " found (", RE_PACKET_space-->RE_DATA1, ",",
				RE_PACKET_space-->RE_DATA2, "): ";
			if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2) {
				print "<empty>";
			}
			for (i=RE_PACKET_space-->RE_DATA1:i<RE_PACKET_space-->RE_DATA2:i++) {
				print (char) BlkValueRead(indt, i);
			}
			print " ***^";
		}
		
		if (rindt == 0) break; ! Accept only one match, replace nothing
		
		if (rindt ~= 0 or 1) {
			if (chm == 1) {
				cindt = BlkValueCreate(INDEXED_TEXT_TY);
				csize = BlkValueExtent(cindt);
			}

			for (i=cpos:i<RE_PACKET_space-->RE_DATA1:i++) {
				ch = BlkValueRead(indt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 7) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
			BlkValueWrite(cindt, cl, 0);
	
			IT_Concatenate(cindt, rindt, findtype, indt);
			csize = BlkValueExtent(cindt);
			cl = IT_CharacterLength(cindt);			
		}

		mpos = RE_PACKET_space-->RE_DATA2; cpos = mpos;
		if (RE_PACKET_space-->RE_DATA1 == RE_PACKET_space-->RE_DATA2)
			mpos++;

		if (IT_RE_Trace) {
			if (chm == 100) { ! Purely to keep the output from being excessive
				print "(Stopping after 100 matches.)^"; break;
			}
		}
	}
	if (chm > 0) {
		if (rindt ~= 0 or 1) {
			for (i=cpos:i<ilen:i++) {
				ch = BlkValueRead(indt, i);
				if (cl+1 >= csize) {
					if (BlkValueSetExtent(cindt, 2*cl, 8) == false) break;
					csize = BlkValueExtent(cindt);
				}
				BlkValueWrite(cindt, cl++, ch);
			}
		}
		
		if (findtype == REGEXP_BLOB) {
			IT_RE_CreateMatchVars(indt);
			if (IT_RE_Trace)
				IT_RE_DebugMatchVars(indt);
		}

		if (rindt ~= 0 or 1) {
			BlkValueWrite(cindt, cl, 0);
			BlkValueCopy(indt, cindt);	
			BlkFree(cindt);
		}
	}
	return chm;
];

[ IT_RE_Concatenate indt_to indt_from blobtype indt_ref
	pos len ch i tosize x y case;
	if ((indt_to==0) || (BlkType(indt_to) ~= INDEXED_TEXT_TY)) rfalse;
	if ((indt_from==0) || (BlkType(indt_from) ~= INDEXED_TEXT_TY)) return indt_to;
	pos = IT_CharacterLength(indt_to);
	tosize = BlkValueExtent(indt_to);
	len = IT_CharacterLength(indt_from);
	for (i=0:i<len:i++) {
		ch = BlkValueRead(indt_from, i);
		if ((ch == '\') && (i < len-1)) {
			ch = BlkValueRead(indt_from, ++i);
			if (ch == 'n') ch = 10;
			if (ch == 't') ch = 9;
			case = -1;
			if (ch == 'l') case = 0;
			if (ch == 'u') case = 1;
			if (case >= 0) ch = BlkValueRead(indt_from, ++i);
			if ((ch >= '0') && (ch <= '9')) {
				ch = ch - '0';
				if (ch < RE_Subexpressions-->10) {
					x = (RE_Subexpressions-->ch)-->RE_DATA1;
					y = (RE_Subexpressions-->ch)-->RE_DATA2;
					if (x >= 0) {
						for (:x<y:x++) {
							ch = BlkValueRead(indt_ref, x);
							if (pos+1 >= tosize) {
								if (BlkValueSetExtent(indt_to, 2*tosize, 11) == false) break;
								tosize = BlkValueExtent(indt_to);
							}
							if (case >= 0)
								BlkValueWrite(indt_to, pos++, CharToCase(ch, case));
							else
								BlkValueWrite(indt_to, pos++, ch);
						}
					}
				}
				continue;
			}
			
		}
		if (pos+1 >= tosize) {
			if (BlkValueSetExtent(indt_to, 2*tosize, 12) == false) break;
			tosize = BlkValueExtent(indt_to);
		}
		BlkValueWrite(indt_to, pos++, ch);
	}
	BlkValueWrite(indt_to, pos, 0);
	return indt_to;
];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of indexed texts

[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     return STORED_ACTION_TY_Create();
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return STORED_ACTION_TY_Destroy(arg1);
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       return STORED_ACTION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return STORED_ACTION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return STORED_ACTION_TY_Hash(arg1);
	}
];

[ STORED_ACTION_TY_Create stora;
	stora = BlkAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);
	BlkValueWrite(stora, 0, ##Wait); ! action
	BlkValueWrite(stora, 1, 0); ! noun
	BlkValueWrite(stora, 2, 0); ! second
	BlkValueWrite(stora, 3, player); ! actor
	BlkValueWrite(stora, 4, false); ! whether a request
	BlkValueWrite(stora, 5, 0); ! indexed text of command if necessary, 0 if not
	return stora;
];

[ STORED_ACTION_TY_New a n s ac req  stora;
	if (stora == 0) stora = STORED_ACTION_TY_Create();
	BlkValueWrite(stora, 0, a);
	BlkValueWrite(stora, 1, n);
	BlkValueWrite(stora, 2, s);
	BlkValueWrite(stora, 3, ac);
	BlkValueWrite(stora, 4, req);
	BlkValueWrite(stora, 5, 0);
	return stora;
];

[ STORED_ACTION_TY_Destroy stora toc;
	toc = BlkValueRead(stora, 5);
	if (toc) BlkFree(toc);
];

[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
	tocfrom = BlkValueRead(storafrom, 5);
	if (tocfrom == 0) return;
	tocto = INDEXED_TEXT_TY_Support(CREATE_KOVS);
	BlkValueCopy(tocto, tocfrom);
	BlkValueWrite(storato, 5, tocto);
];

[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
	delta = BlkValueRead(storaleft, 0) - BlkValueRead(storaright, 0);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 1) - BlkValueRead(storaright, 1);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 2) - BlkValueRead(storaright, 2);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 3) - BlkValueRead(storaright, 3);
	if (delta) return delta;
	delta = BlkValueRead(storaleft, 4) - BlkValueRead(storaright, 4);
	if (delta) return delta;
	itleft = BlkValueRead(storaleft, 5);
	itright = BlkValueRead(storaright, 5);
	if ((itleft ~= 0) && (itright ~= 0))
		return INDEXED_TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
	return itleft - itright;
];

[ STORED_ACTION_TY_Distinguish stora1 stora2;
	if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;
	rtrue;
];

[ STORED_ACTION_TY_Hash stora  rv it;
	rv = BlkValueRead(stora, 0);
	rv = rv * 33 + BlkValueRead(stora, 1);
	rv = rv * 33 + BlkValueRead(stora, 2);
	rv = rv * 33 + BlkValueRead(stora, 3);
	rv = rv * 33 + BlkValueRead(stora, 4);
	it = BlkValueRead(stora, 5);
	if (it ~= 0)
		rv = rv * 33 + INDEXED_TEXT_TY_Support(HASH_KOVS, it);
	return rv;
];

[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return;
	text_of_command = BlkValueRead(stora, 5);
	if (text_of_command) {
		saved_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, saved_command);
		SetPlayersCommand(text_of_command);
	}
	saved_pn = parsed_number; saved_action = action;
	action = BlkValueRead(stora, 0);
	at = FindAction(-1);
	K1 = ActionData-->(at+AD_NOUN_KOV);
	K2 = ActionData-->(at+AD_SECOND_KOV);
	if (K1 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, 1);
		if ((K1 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}
	if (K2 ~= OBJECT_TY) {
		parsed_number = BlkValueRead(stora, 2);
		if ((K2 == UNDERSTANDING_TY) && (text_of_command == 0)) {
			if (saved_command == 0) saved_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(players_command, SNIPPET_TY, saved_command);
			text_of_command = INDEXED_TEXT_TY_Create();
			INDEXED_TEXT_TY_Cast(parsed_number, TEXT_TY, text_of_command);
			SetPlayersCommand(text_of_command);
			parsed_number = players_command;
		}
	}	
	DB_Action(BlkValueRead(stora, 3), BlkValueRead(stora, 4), BlkValueRead(stora, 0),
		BlkValueRead(stora, 1), BlkValueRead(stora, 2), true);
	parsed_number = saved_pn; action = saved_action;
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}
];

[ STORED_ACTION_TY_Involves stora item at;
	at = FindAction(BlkValueRead(stora, 0));
	if (at) {
		if ((ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, 1) == item)) rtrue;
		if ((ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) &&
			(BlkValueRead(stora, 2) == item)) rtrue;
	}
	if (BlkValueRead(stora, 3) == item) rtrue;
	rfalse;
];

[ STORED_ACTION_TY_Part stora ind at ado;
	if (ind == 1 or 2) {
		if (ind == 1) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;
		at = FindAction(BlkValueRead(stora, 0));
		if ((at) && (ActionData-->(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);
		return nothing;
	}
	return BlkValueRead(stora, ind);
];

Array SAT_Tmp-->7;
[ STORED_ACTION_TY_Adopt stora at;
	SAT_Tmp-->1 = action;
	SAT_Tmp-->2 = noun;
	SAT_Tmp-->3 = second;
	SAT_Tmp-->4 = actor;
	SAT_Tmp-->5 = act_requester;
	SAT_Tmp-->6 = parsed_number;
	action = BlkValueRead(stora, 0);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) noun = BlkValueRead(stora, 1);
	else { parsed_number = BlkValueRead(stora, 1); noun = nothing; }
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) second = BlkValueRead(stora, 2);
	else { parsed_number = BlkValueRead(stora, 2); second = nothing; }
	actor = BlkValueRead(stora, 3);
	if (BlkValueRead(stora, 4)) act_requester = player; else act_requester = nothing;
];

[ STORED_ACTION_TY_Unadopt;
	action = SAT_Tmp-->1;
	noun = SAT_Tmp-->2;
	second = SAT_Tmp-->3;	
	actor = SAT_Tmp-->4;	
	act_requester = SAT_Tmp-->5;
	parsed_number = SAT_Tmp-->6;
	return SAT_Tmp-->0;
];

[ STORED_ACTION_TY_Current stora at text_of_command;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return 0;
	BlkValueWrite(stora, 0, action);
	at = FindAction(-1);
	if (ActionData-->(at+AD_NOUN_KOV) == OBJECT_TY) BlkValueWrite(stora, 1, noun);
	else BlkValueWrite(stora, 1, parsed_number);
	if (ActionData-->(at+AD_SECOND_KOV) == OBJECT_TY) BlkValueWrite(stora, 2, second);
	else BlkValueWrite(stora, 2, parsed_number);
	BlkValueWrite(stora, 3, actor);
	if (act_requester) BlkValueWrite(stora, 4, true); else BlkValueWrite(stora, 4, false);
	if ((at) && ((ActionData-->(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||
			(ActionData-->(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {
		text_of_command = BlkValueRead(stora, 5);
		if (text_of_command == 0) {
			text_of_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
			BlkValueWrite(stora, 5, text_of_command);
		}
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, text_of_command);
	} else BlkValueWrite(stora, 5, 0);
	return stora;
];

[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;
	if ((stora==0) || (BlkType(stora) ~= STORED_ACTION_TY)) return;
	if (ks) { @push keep_silent; keep_silent=1; }
	text_of_command = BlkValueRead(stora, 5);
	if (text_of_command) {
		saved_command = INDEXED_TEXT_TY_Support(CREATE_KOVS);
		INDEXED_TEXT_TY_Support(CAST_KOVS, players_command, SNIPPET_TY, saved_command);
		SetPlayersCommand(text_of_command);
	}
	TryAction(BlkValueRead(stora, 4), BlkValueRead(stora, 3),
		BlkValueRead(stora, 0), BlkValueRead(stora, 1), BlkValueRead(stora, 2));
	if (text_of_command) {
		SetPlayersCommand(saved_command);
		BlkFree(saved_command);
	}
	if (ks) { @pull keep_silent; }
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ STORED_ACTION_TY_Say stora; ];
[ STORED_ACTION_TY_New a n s ac req stora; return false; ];
[ STORED_ACTION_TY_Support t a b c; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ LIST_OF_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = LIST_OF_TY_Create(arg2);
		                 if (arg1) LIST_OF_TY_CopyRawArray(arg3, arg1, 2, 0);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return LIST_OF_TY_Destroy(arg1);
		PRECOPY_KOVS:    return LIST_OF_TY_PreCopy(arg1, arg2);
		COPY_KOVS:       return LIST_OF_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return LIST_OF_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return LIST_OF_TY_Hash(arg1);
	}
];

Constant LIST_ITEM_KOV_F = 0; ! Entry 0: the kind of the list
Constant LIST_LENGTH_F = 1; ! Entry 1: length, i.e., number of items
Constant LIST_ITEM_BASE = 2; ! List items begin at this entry

[ LIST_OF_TY_Create skov list;
	skov = KindBaseTerm(skov, 0);
	list = BlkAllocate(28*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);
	BlkValueWrite(list, LIST_ITEM_KOV_F, skov);
	BlkValueWrite(list, LIST_LENGTH_F, 0);
	return list;
];

[ LIST_OF_TY_CopyRawArray list arr rea cast len i ex bk v w;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueExtent(list);
	len = arr-->2;
	if ((len+LIST_ITEM_BASE > ex) &&
		(BlkValueSetExtent(list, len+LIST_ITEM_BASE) == false)) return 0;
	BlkValueWrite(list, LIST_LENGTH_F, len);
	if (rea == 2) bk = BlkValueRead(list, LIST_ITEM_KOV_F);
	else {
		bk = arr-->1;
		BlkValueWrite(list, LIST_ITEM_KOV_F, bk);
	}
	for (i=0:i<len:i++) {
		v = arr-->(i+3);
		if (KindAtomic(bk) == LIST_OF_TY) {
			w = LIST_OF_TY_Create(v-->1);
			LIST_OF_TY_CopyRawArray(w, v, 0, KindBaseTerm(bk, 0));
			BlkValueWrite(list, i+LIST_ITEM_BASE, w);
		} else {
			if ((cast) && (cast ~= bk)) {
				if (KOVIsBlockValue(cast)) v = BlkValueCreate(cast, v, bk);
			} else {
				if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk, v);
			}
			BlkValueWrite(list, i+LIST_ITEM_BASE, v);
		}
	}
	if ((cast) && (cast ~= bk)) BlkValueWrite(list, LIST_ITEM_KOV_F, cast);
	#ifdef SHOW_ALLOCATIONS;
	print "Copied raw array to list: "; LIST_OF_TY_Say(list, 1); print "^";
	#endif;
	return list;
];

[ LIST_OF_TY_Destroy list no_items i;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		no_items = BlkValueRead(list, LIST_LENGTH_F);
		for (i=0; i<no_items; i++) BlkFree(BlkValueRead(list, i+LIST_ITEM_BASE));
	}
	return list;
];

Global precopied_list_kov;

[ LIST_OF_TY_PreCopy lto lfrom list;
	precopied_list_kov = BlkValueRead(lto, LIST_ITEM_KOV_F);
];

[ LIST_OF_TY_Copy lto lfrom list no_items i nv bk val splk;
	no_items = BlkValueRead(lfrom, LIST_LENGTH_F);
	bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);
	if (precopied_list_kov ~= 0 or 1) BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
	else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
	if ((precopied_list_kov == INDEXED_TEXT_TY) && (bk == TEXT_TY)) {
		for (i=0; i<no_items; i++) {
			nv = BlkValueCreate(INDEXED_TEXT_TY);
			INDEXED_TEXT_TY_Cast(BlkValueRead(lfrom, i+LIST_ITEM_BASE), TEXT_TY, nv);
			BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
		}
	} else {
		if (KOVIsBlockValue(bk)) {
			for (i=0; i<no_items; i++) {
				val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);
				nv = BlkValueCreate(BlkType(val));
				BlkValueCopy(nv, val);
				BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);
			}
		}
	}
	precopied_list_kov = 0;
];

[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
	delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);
	if (delta) return delta;
	no_items = BlkValueRead(listleft, LIST_LENGTH_F);
	if (no_items == 0) return 0;
	delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);
	if (delta) return delta;
	cf = LIST_OF_TY_ComparisonFn(listleft);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<no_items; i++) {
			delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -
				BlkValueRead(listright, i+LIST_ITEM_BASE);
			if (delta) return delta;
		}
	} else {
		for (i=0; i<no_items; i++) {
			delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),
				BlkValueRead(listright, i+LIST_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ LIST_OF_TY_ComparisonFn list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];

[ LIST_OF_TY_Distinguish txb1 txb2;
	if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ LIST_OF_TY_Hash list  len kov rv i;
	rv = 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	kov = BlkValueRead(list, LIST_ITEM_KOV_F);
	for (i=0: i<len: i++)
		rv = rv * 33 + KOVHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));
	return rv;
];

[ LIST_OF_TY_Say list format no_items v i bk;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));
	! print "kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";
	if (format == 1) print "{";
	for (i=0:i<no_items:i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		switch (format) {
			2: print (the) v;
			3: print (a) v;
			default:
				if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
				else if ((bk == TEXT_TY or INDEXED_TEXT_TY) && (format == 1)) {
					print "~"; PrintKindValuePair(bk, v); print "~";
				}
				else PrintKindValuePair(bk, v);
		}
		if (i<no_items-2) print ", ";
		if (i==no_items-2) {
			if (format == 1) print ", "; else {
				#ifdef SERIAL_COMMA; if (no_items ~= 2) print ","; #endif;
				print (string) LISTAND2__TX;
			}
		}
	}
	if (format == 1) print "}";
];

[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	ex = BlkValueExtent(list);
	len = desc(-3);
!	for (len=0, obj=desc(-2, nothing, len): obj: len++, obj=desc(-2, obj, len)) ;
!	len++;
	if (len+LIST_ITEM_BASE > ex) {
		if (BlkValueSetExtent(list, len+LIST_ITEM_BASE) == false)
			return 0;
	}
	if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
	else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
	BlkValueWrite(list, LIST_LENGTH_F, len);
	obj = 0;
	for (i=0: i<len: i++) {
		obj = desc(-2, obj, i);
		! print "i = ", i, " and obj = ", obj, "^";
		BlkValueWrite(list, i+LIST_ITEM_BASE, obj);
	}
	return list;
];

[ LIST_OF_TY_FindItem list v i no_items cf;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (cf == 0 or UnsignedCompare) {
		for (i=0; i<no_items; i++)
			if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;
	} else {
		for (i=0; i<no_items; i++)
			if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;
	}
	rfalse;
];

[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	if (nodups && (LIST_OF_TY_FindItem(list, v))) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	ex = BlkValueExtent(list);
	if (no_items+LIST_ITEM_BASE+1 > ex) {
		if (BlkValueSetExtent(list, ex+16) == false) return 0;
	}
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if (posnflag) {
		posn--;
		for (i=no_items:i>posn:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-1+LIST_ITEM_BASE));			
		}
		BlkValueWrite(list, posn+LIST_ITEM_BASE, v);
	} else {
		BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+1);
	return list;
];

[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	if ((more==0) || (BlkType(more) ~= LIST_OF_TY)) return list;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((posnflag) && ((posn<1) || (posn > no_items+1))) {
		print "*** Couldn't add at entry ", posn, " in the list ";
		LIST_OF_TY_Say(list, true);
		print ", which has entries in the range 1 to ", no_items, " ***^";
		RunTimeProblem(RTP_LISTRANGEERROR);
		rfalse;
	}
	msize = BlkValueRead(more, LIST_LENGTH_F);
	ex = BlkValueExtent(list);
	if (no_items+msize+LIST_ITEM_BASE > ex) {
		if (BlkValueSetExtent(list, no_items+msize+LIST_ITEM_BASE+8) == false)
			return 0;
	}
	if (posnflag) {
		posn--;
		for (i=no_items+msize:i>=posn+msize:i--) {
			BlkValueWrite(list, i+LIST_ITEM_BASE,
				BlkValueRead(list, i-msize+LIST_ITEM_BASE));			
		}
		! BlkValueWrite(list, posn, v);
		for (j=0: j<msize: j++) {
			v = BlkValueRead(more, j+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);
		}
	} else {
		for (i=0, j=0: i<msize: i++) {
			v = BlkValueRead(more, i+LIST_ITEM_BASE);
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
				nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
				BlkValueCopy(nv, v);
				v = nv;
			}
			if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {
				BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);
				j++;
			}
		}
	}
	BlkValueWrite(list, LIST_LENGTH_F, no_items+j);
	return list;
];

[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	cf = LIST_OF_TY_ComparisonFn(list);
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	for (i=0; i<no_items; i++) {
		delendum = BlkValueRead(list, i+LIST_ITEM_BASE);
		if (cf == 0 or UnsignedCompare)
			f = (v == delendum);
		else
			f = (cf(v, delendum) == 0);
		if (f) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				BlkFree(delendum);
			for (j=i+1; j<no_items; j++)
				BlkValueWrite(list, j-1+LIST_ITEM_BASE,
					BlkValueRead(list, j+LIST_ITEM_BASE));
			no_items--; i--;
			BlkValueWrite(list, LIST_LENGTH_F, no_items);
		}
	}
	if (odsize ~= no_items) rfalse;
	if (forgive) rfalse;
	print "*** Couldn't remove: the value ";
	PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
	print " was not present in the list ";
	LIST_OF_TY_Say(list, true);
	print " ***^";
	RunTimeProblem(RTP_LISTRANGEERROR);
];

[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((from > to) || (from <= 0) || (to > no_items)) {
		if (forgive) {
			if (from <= 0) from = 1;
			if (to >= no_items) to = no_items;
			if (from > to) return list;
		} else {
			print "*** Couldn't remove entries ", from, " to ", to, " from the list ";
			LIST_OF_TY_Say(list, true);
			print ", which has entries in the range 1 to ", no_items, " ***^";
			RunTimeProblem(RTP_LISTRANGEERROR);
			rfalse;
		}
	}
	to--; from--;
	d = to-from+1;
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
		for (i=0; i<d; i++)
			BlkFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));
	for (i=from: i<no_items-d: i++)
		BlkValueWrite(list, i+LIST_ITEM_BASE,
			BlkValueRead(list, i+d+LIST_ITEM_BASE));
	BlkValueWrite(list, LIST_LENGTH_F, no_items-d);
	return list;
];

[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;
	rsize = BlkValueRead(rlist, LIST_LENGTH_F);
	cf = LIST_OF_TY_ComparisonFn(list);
	for (i=0: i<no_items: i++) {
		v = BlkValueRead(list, i+LIST_ITEM_BASE);
		for (k=0: k<rsize: k++) {
			w = BlkValueRead(rlist, k+LIST_ITEM_BASE);
			if (cf == 0 or UnsignedCompare)
				f = (v == w);
			else
				f = (cf(v, w) == 0);
			if (f) {
				if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
					BlkFree(v);
				for (j=i+1: j<no_items: j++)
					BlkValueWrite(list, j+LIST_ITEM_BASE-1, 
						BlkValueRead(list, j+LIST_ITEM_BASE));
				no_items--; i--;
				BlkValueWrite(list, LIST_LENGTH_F, no_items);
				break;
			}
		}
	}
	rfalse;
];

[ LIST_OF_TY_GetLength list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	return BlkValueRead(list, LIST_LENGTH_F);
];

[ LIST_OF_TY_Empty list;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) rfalse;
	if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;
	rfalse;
];

[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	if (newsize < 0) "*** Cannot resize a list to negative length ***";
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < newsize) {
		if (this_way_only == -1) return list;
		ex = BlkValueExtent(list);
		if (newsize+LIST_ITEM_BASE > ex) {
			if (BlkValueSetExtent(list, newsize+LIST_ITEM_BASE) == false)
				return 0;
		}
		dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));
		for (i=no_items: i<newsize: i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i, dv);
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	if (no_items > newsize) {
		if (this_way_only == 1) return list;
		if (truncation_end == -1) {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=0: i<no_items-newsize: i++)
					BlkFree(BlkValueRead(list, LIST_ITEM_BASE+i));
			for (i=0: i<newsize: i++)
				BlkValueWrite(list, LIST_ITEM_BASE+i,
					BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));
		} else {
			if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))
				for (i=newsize: i<no_items: i++)
					BlkFree(BlkValueRead(list, LIST_ITEM_BASE+i));
		}
		BlkValueWrite(list, LIST_LENGTH_F, newsize);
	}
	return list;
];

[ LIST_OF_TY_GetItem list i forgive no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		if (forgive) return false;
		print "*** Couldn't read from entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		RunTimeProblem(RTP_LISTRANGEERROR);
		if (no_items >= 1) i = 1;
		else return false;
	}
	return BlkValueRead(list, LIST_ITEM_BASE+i-1);
];

[ WriteLIST_OF_TY_GetItem list i val no_items;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if ((i<=0) || (i>no_items)) {
		print "*** Couldn't write to list entry ", i, " of a list which";
		switch (no_items) {
			0: print " is empty ***^";
			1: print " has only one entry, numbered 1 ***^";
			default: print " has entries numbered from 1 to ", no_items, " ***^";
		}
		return RunTimeProblem(RTP_LISTRANGEERROR);
	}
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);
];

[ LIST_OF_TY_PutItem list i v  no_items nv;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return false;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
		nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));
		BlkValueCopy(nv, v);
		v = nv;
	}
	if ((i<=0) || (i>no_items)) return false;
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);
];

[ LIST_OF_TY_Mol list len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	len = multiple_object-->0;
	LIST_OF_TY_SetLength(list, len);
	for (i=1: i<=len: i++)
		LIST_OF_TY_PutItem(list, i, multiple_object-->i);
	return list;
];

[ LIST_OF_TY_Set_Mol list len i;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	len = BlkValueRead(list, LIST_LENGTH_F);
	if (len > 63) len = 63;
	multiple_object-->0 = len;
	for (i=1: i<=len: i++)
		multiple_object-->i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
];

[ LIST_OF_TY_Reverse list no_items i v;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	for (i=0;i*2<no_items;i++) {
		v = BlkValueRead(list, LIST_ITEM_BASE+i);
		BlkValueWrite(list, LIST_ITEM_BASE+i,
			BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));
		BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);
	}
	return list;
];

[ LIST_OF_TY_Rotate list backwards  no_items i v;
	if ((list==0) || (BlkType(list) ~= LIST_OF_TY)) return 0;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (no_items < 2) return list;
	if (backwards) {
		v = BlkValueRead(list, LIST_ITEM_BASE);
		for (i=0:i<no_items-1:i++)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i+1));
		BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);
	} else {
		v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);
		for (i=no_items-1:i>0:i--)
			BlkValueWrite(list, LIST_ITEM_BASE+i,
				BlkValueRead(list, LIST_ITEM_BASE+i-1));
		BlkValueWrite(list, LIST_ITEM_BASE, v);
	}
	return list;
];

Global LIST_OF_TY_Sort_cf;

[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;
	no_items = BlkValueRead(list, LIST_LENGTH_F);
	if (dir == 2) {
		if (no_items < 2) return;
		for (i=1:i<no_items:i++) {
			j = random(i+1) - 1;
			v = BlkValueRead(list, LIST_ITEM_BASE+i);
			BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));
			BlkValueWrite(list, LIST_ITEM_BASE+j, v);
		}
		return;
	}
	SetSortDomain(ListSwapEntries, ListCompareEntries);
	if (cf) { LIST_OF_TY_Sort_cf = BlkValueCompare; ! dir = -dir;
	}
	else LIST_OF_TY_Sort_cf = 0;
	SortArray(list, prop, dir, no_items, false, 0);
];

[ ListSwapEntries list i j v;
	if (i==j) return;
	v = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));
	BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);
];

[ ListCompareEntries list col i j d cf;
	if (i==j) return 0;
	i = BlkValueRead(list, LIST_ITEM_BASE+i-1);
	j = BlkValueRead(list, LIST_ITEM_BASE+j-1);
	if (I7S_Col) {
		if (i provides I7S_Col) i=i.I7S_Col; else i=0;
		if (j provides I7S_Col) j=j.I7S_Col; else j=0;
		cf = LIST_OF_TY_Sort_cf;
	} else {
		cf = LIST_OF_TY_ComparisonFn(list);
	}
	if (cf == 0)
		return i - j;
	else
		return cf(i, j);
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ LIST_OF_TY_Support t a b c; rfalse; ];
[ LIST_OF_TY_Say list; ];
[ LIST_OF_TY_FindItem list v; rfalse; ];
[ LIST_OF_TY_Empty list; rfalse; ];
[ LIST_OF_TY_SetLength l n; rfalse; ];
[ LIST_OF_TY_InsertItem a b c d e; rfalse; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE

#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap

[ COMBINATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = COMBINATION_TY_Create(arg2);
		                 if (arg1) COMBINATION_TY_CopyRawArray(arg3, arg1, 2);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return COMBINATION_TY_Destroy(arg1);
		PRECOPY_KOVS:    return COMBINATION_TY_PreCopy(arg1, arg2);
		COPY_KOVS:       return COMBINATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return COMBINATION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return COMBINATION_TY_Hash(arg1);
	}
];

Constant COMBINATION_KIND_F = 0; ! A pointer to a block indicating the kind
Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry

[ COMBINATION_TY_Create kind comb N i bk v;
	N = KindBaseArity(kind);
	comb = BlkAllocate((COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);
	BlkValueWrite(comb, COMBINATION_KIND_F, kind);
	for (i=0; i<N; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			v = BlkValueCreate(bk);
		else
			v = DefaultValueOfKOV(bk);
		BlkValueWrite(comb, COMBINATION_ITEM_BASE+i, v);
	}
	return comb;
];

[ COMBINATION_TY_CopyRawArray comb raw rea len i ex bk v w;
	if ((comb==0) || (BlkType(comb) ~= COMBINATION_TY)) return false;
	ex = BlkValueExtent(comb);
	len = raw-->2;
	if ((len+COMBINATION_ITEM_BASE > ex) &&
		(BlkValueSetExtent(comb, len+COMBINATION_ITEM_BASE) == false)) return 0;
	BlkValueWrite(comb, LIST_LENGTH_F, len);
	if (rea == 2) bk = BlkValueRead(comb, COMBINATION_KIND_F);
	else {
		bk = raw-->1;
		BlkValueWrite(comb, COMBINATION_KIND_F, bk);
	}
	for (i=0:i<len:i++) {
		v = raw-->(i+3);
		if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk, v);
		BlkValueWrite(comb, i+COMBINATION_ITEM_BASE, v);
	}
	#ifdef SHOW_ALLOCATIONS;
	print "Copied raw array to comb: "; COMBINATION_TY_Say(comb, 1); print "^";
	#endif;
	return comb;
];

[ COMBINATION_TY_Destroy comb kind no_items i bk;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk))
			BlkFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return comb;
];

Global precopied_comb_kov;

[ COMBINATION_TY_PreCopy lto lfrom comb no_items i nv bk;
	precopied_comb_kov = BlkValueRead(lto, COMBINATION_KIND_F);
];

[ COMBINATION_TY_Copy lto lfrom no_items i nv kind bk;
	kind = BlkValueRead(lto, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	BlkValueWrite(lto, COMBINATION_KIND_F, precopied_comb_kov);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		if (KOVIsBlockValue(bk)) {
			nv = BlkValueCreate(bk);
			BlkValueCopy(nv, BlkValueRead(lfrom, i+COMBINATION_ITEM_BASE));
			BlkValueWrite(lto, i+COMBINATION_ITEM_BASE, nv);
		}
	}
];

[ COMBINATION_TY_Compare listleft listright delta no_items i cf kind bk;
	kind = BlkValueRead(listleft, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0; i<no_items; i++) {
		bk = KindBaseTerm(kind, i);
		cf = KOVComparisonFunction(bk);
		if (cf == 0 or UnsignedCompare) {
			delta = BlkValueRead(listleft, i+COMBINATION_ITEM_BASE) -
				BlkValueRead(listright, i+COMBINATION_ITEM_BASE);
			if (delta) return delta;
		} else {
			delta = cf(BlkValueRead(listleft, i+COMBINATION_ITEM_BASE),
				BlkValueRead(listright, i+COMBINATION_ITEM_BASE));
			if (delta) return delta;
		}
	}
	return 0;
];

[ COMBINATION_TY_Distinguish txb1 txb2;
	if (COMBINATION_TY_Compare(txb1, txb2) == 0) rfalse;
	rtrue;
];

[ COMBINATION_TY_Hash comb  kind rv no_items i bk;
	rv = 0;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	for (i=0: i<no_items: i++) {
		bk = KindBaseTerm(kind, i);
		rv = rv * 33 + KOVHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));
	}
	return rv;
];

[ COMBINATION_TY_Say comb format no_items v i kind bk;
	if ((comb==0) || (BlkType(comb) ~= COMBINATION_TY)) return;
	kind = BlkValueRead(comb, COMBINATION_KIND_F);
	no_items = KindBaseArity(kind);
	print "(";
	for (i=0; i<no_items; i++) {
		if (i>0) print ", ";
		bk = KindBaseTerm(kind, i);
		v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);
		if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);
		else PrintKindValuePair(bk, v);
	}
	print ")";
];

#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ COMBINATION_TY_Support t a b c; rfalse; ];
[ COMBINATION_TY_Say comb; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE


Constant RRV_NAME     		RR_NAME-4;
Constant RRV_PERMISSIONS	RR_PERMISSIONS-4;
Constant RRV_STORAGE		RR_STORAGE-4;
Constant RRV_KIND		RR_KIND-4;
Constant RRV_HANDLER		RR_HANDLER-4;
Constant RRV_DESCRIPTION	RR_DESCRIPTION-4;
Constant RRV_USED		6;
Constant RRV_FILLED		7;
Constant RRV_DATA_BASE		8;

! valencies
Constant RRVAL_V_TO_V		0;
Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V		RELS_X_UNIQUE;
Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;
Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;
Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;
Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;

! dictionary entry flags
Constant RRF_USED	$0001;	! entry contains a value
Constant RRF_DELETED	$0002;	! entry used to contain a value
Constant RRF_SINGLE	$0004;	! entry's Y is a value, not a list
Constant RRF_HASX	$0010;	! 2-in-1 entry contains a corresponding key
Constant RRF_HASY	$0020;	! 2-in-1 entry contains a corresponding value
Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV
Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV

! permission/task constants (those commented out here are generated by I7)
!Constant RELS_SYMMETRIC $8000;
!Constant RELS_EQUIVALENCE $4000;
!Constant RELS_X_UNIQUE $2000;
!Constant RELS_Y_UNIQUE $1000;
!Constant RELS_TEST $0800;
!Constant RELS_ASSERT_TRUE $0400;
!Constant RELS_ASSERT_FALSE $0200;
!Constant RELS_SHOW $0100;
!Constant RELS_ROUTE_FIND $0080;
!Constant RELS_ROUTE_FIND_COUNT $0040;
Constant RELS_COPY $0020;
Constant RELS_DESTROY $0010;
!Constant RELS_LOOKUP_ANY $0008;
!Constant RELS_LOOKUP_ALL_X $0004;
!Constant RELS_LOOKUP_ALL_Y $0002;
!Constant RELS_LIST $0001;

Constant RELS_EMPTY $0003;
Constant RELS_SET_VALENCY $0005;

! RELS_LOOKUP_ANY mode selection constants
Constant RLANY_GET_X 1;
Constant RLANY_GET_Y 2;
Constant RLANY_CAN_GET_X 3;
Constant RLANY_CAN_GET_Y 4;

! RELS_LIST mode selection constant
Constant RLIST_ALL_X 1;
Constant RLIST_ALL_Y 2;
Constant RLIST_ALL_PAIRS 3;


Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)
Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence
Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables
Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables
Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?
Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1


[ RelationTest relation task X Y  handler;
	handler = relation-->RR_HANDLER;
	return handler(relation, task, X, Y);
];


[ EmptyRelationHandler relation task X Y;
	if (task == RELS_EMPTY) rtrue;
	rfalse;
];


#IFDEF MEMORY_HEAP_SIZE; ! Will exist if any use is made of heap


[ RELATION_TY_Support task arg1 arg2 arg3;
	switch(task) {
		CREATE_KOVS:     arg3 = RELATION_TY_Create(arg2, arg1);
		                 return arg3;
		CAST_KOVS:       rfalse;
		DESTROY_KOVS:    return RELATION_TY_Destroy(arg1);
		PRECOPY_KOVS:    rfalse;
		COPY_KOVS:       return RELATION_TY_Copy(arg1, arg2);
		COMPARE_KOVS:    return RELATION_TY_Compare(arg1, arg2);
		READ_FILE_KOVS:  rfalse;
		WRITE_FILE_KOVS: rfalse;
		HASH_KOVS:       return arg1;
	}
];


[ RELATION_TY_Create kov from rel i skov handler;
	rel = BlkAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,
		RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
	if ((from == 0) && (kov ~= 0)) from = DefaultValueFinder(kov);
	if (from) {
		for (i=0: i<RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i));
		if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {
			handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND));
			BlkValueWrite(rel, RRV_NAME, "anonymous relation");
			BlkValueWrite(rel, RRV_PERMISSIONS,
				RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW);
			BlkValueWrite(rel, RRV_HANDLER, handler);
			BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1);
			BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation");
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
		}
	} else {
		handler = ChooseRelationHandler(kov);
		BlkValueWrite(rel, RRV_NAME, "anonymous relation");
		BlkValueWrite(rel, RRV_PERMISSIONS,
			RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW);
		BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1);
		BlkValueWrite(rel, RRV_KIND, kov);
		BlkValueWrite(rel, RRV_HANDLER, handler);
		BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation");
		BlkValueWrite(rel, RRV_USED, 0);
		BlkValueWrite(rel, RRV_FILLED, 0);
	}
	return rel;
];


[ RELATION_TY_Destroy rel  handler;
	handler = BlkValueRead(rel, RRV_HANDLER);
	handler(rel, RELS_DESTROY);
	return rel;
];


[ RELATION_TY_Copy lto lfrom  handler;
	handler = BlkValueRead(lto, RRV_HANDLER);
	handler(lto, RELS_COPY);
];


[ RELATION_TY_Compare rleft rright ind1 ind2;
	ind1 = BlkValueRead(rleft, RRV_HANDLER);
	ind2 = BlkValueRead(rright, RRV_HANDLER);
	if (ind1 ~= ind2)
		return ind1 - ind2;
	return rleft - rright;
];

[ RELATION_TY_Distinguish rleft rright;
	if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;
	rtrue;
];


[ RELATION_TY_Say rel;
	if (rel == 0) print "(null relation)"; ! shouldn't happen
	else print (string) rel-->RR_NAME;
];


[ RELATION_TY_Name rel txt;
	if (rel) {
		BlkValueWrite(rel, RRV_NAME, txt);
		BlkValueWrite(rel, RRV_DESCRIPTION, txt);
	}
];


[ ChooseRelationHandler kov sym;
	if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
		if (sym) return SymHashListRelationHandler;
		return HashListRelationHandler;
	}
	if (sym) return SymDoubleHashSetRelationHandler;
	return DoubleHashSetRelationHandler;
];


[ RELATION_TY_SetValency rel val  kov filled cur handler ext;
	filled = BlkValueRead(rel, RRV_FILLED);
	if (filled) { print "*** Illegal valency change ***^"; rfalse; }
	kov = BlkValueRead(rel, RRV_KIND);
	if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {
		if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {
			print "*** Relation cannot be made symmetric ***^";
			rfalse;
		}
	}
	cur = BlkValueRead(rel, RRV_HANDLER);
	switch (val) {
		RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);
		RRVAL_V_TO_O:		handler = HashTableRelationHandler;
		RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;
		RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;
		RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;
		RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);
		RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;
		default:		print "*** Illegal valency value ***^"; rfalse;
	}
	if (cur == handler) rtrue;
	! adjust size when going to or from 2-in-1
	if (cur == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetExtent(rel, RRV_DATA_BASE + 3*ext);
	} else if (handler == TwoInOneHashTableRelationHandler) {
		ext = BlkValueRead(rel, RRV_STORAGE) + 1;
		BlkValueSetExtent(rel, RRV_DATA_BASE + 4*ext);
	}
	BlkValueWrite(rel, RRV_HANDLER, handler);
];

[ RELATION_TY_GetValency rel  handler;
	return BlkValueRead(rel, RRV_PERMISSIONS) & VALENCY_MASK;
];


[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		for (at = BlkValueRead(rel, RRV_STORAGE); at >= 0; at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (kx) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (tmp & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (sym && (kov(X, Y) > 0)) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			DoubleHashSetRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {
					v = BlkValueRead(rel, tmp + 2);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				} else {
					v = BlkValueRead(rel, tmp + 1);
					if (KOVIsBlockValue(kx)) {
						if (BlkValueCompare(v, X) ~= 0) continue;
					} else {
						if (v ~= X) continue;
					}
					if (Y == RLANY_CAN_GET_Y) rtrue;
					return BlkValueRead(rel, tmp + 2);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 2);
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			if (BlkValueRead(rel, tmp) & RRF_USED) {
				v = BlkValueRead(rel, tmp + 1);
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(v, X) ~= 0) continue;
				} else {
					if (v ~= X) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (X == 0 || BlkType(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X, RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						tmp++;
						if (Y == RLIST_ALL_Y) tmp++;
						v = BlkValueRead(rel, tmp);
						LIST_OF_TY_InsertItem(X, v, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, kov);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					if (BlkValueRead(rel, tmp) & RRF_USED) {
						v = BlkValueRead(rel, tmp + 1);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
						v = BlkValueRead(rel, tmp + 2);
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		rfalse;
	}
	at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
	switch(task) {
		RELS_TEST:
			if (at >= 0) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			if (at >= 0) rtrue;
			at = ~at;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
			if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
			if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
			DoubleHashSetCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			if (KOVIsBlockValue(ky))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];

[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;
	! calculate a hash value for the pair
	hashv = KOVHashValue(kx, x) + KOVHashValue(ky, y);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) return ~i;
	if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
			if (free >= 0) return ~free;
			return ~i;
		}
		if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))
			return i;
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (3*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1);
			Y = BlkValueRead(temp, 3*i + 2);
			at = DoubleHashSetLookUp(rel, kx, ky, X, Y);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
	if (KOVIsBlockValue(ky)) {
		if (BlkValueCompare(cy, Y) ~= 0) rfalse;
	} else {
		if (cy ~= Y) rfalse;
	}
	rtrue;
];


[ HashListRelationHandler rel task X Y  sym kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];


[ HashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


[ ReversedHashTableRelationHandler rel task X Y  kov kx ky;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	switch (task) {
		RELS_SET_VALENCY:
			return RELATION_TY_SetValency(rel, X);
		RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
			return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
		RELS_LOOKUP_ANY:
			switch (Y) {
				RLANY_GET_X: Y = RLANY_GET_Y;
				RLANY_GET_Y: Y = RLANY_GET_X;
				RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;
				RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;
			}
		RELS_LOOKUP_ALL_X:
			task = RELS_LOOKUP_ALL_Y;
		RELS_LOOKUP_ALL_Y:
			task = RELS_LOOKUP_ALL_X;
		RELS_SHOW:
		RELS_LIST:
			switch (Y) {
				RLIST_ALL_X: Y = RLIST_ALL_Y;
				RLIST_ALL_Y: Y = RLIST_ALL_X;
			}
	}
	return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];


[ SymDoubleHashSetRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		DoubleHashSetRelationHandler(rel, task, Y, X);
	return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];

[ SymHashListRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		HashListRelationHandler(rel, task, Y, X);
	return HashListRelationHandler(rel, task, X, Y);
];

[ Sym2in1HashTableRelationHandler rel task X Y;
	if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)
		TwoInOneHashTableRelationHandler(rel, task, Y, X);
	return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];


[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (kx) BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				if (ky || ~~(fl & RRF_SINGLE))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
			}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				if (X) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);
				}
				if (Y || ~~(fl & RRF_SINGLE)) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
					tmp = BlkValueCopy(BlkValueCreate(BlkType(tmp)), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		! Z-machine doesn't have the room to let us pass sym/rev as parameters
		switch (RELATION_TY_GetValency(rel)) {
			RRVAL_SYM_V_TO_V:
				sym = 1;
				tmp = KOVComparisonFunction(kx);
				if (~~tmp) tmp = UnsignedCompare;
			RRVAL_O_TO_V:
				rev = 1;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			if (fl & RRF_USED) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				if (fl & RRF_SINGLE) {
					if (sym && tmp(X, Y) > 0) continue;
					print "  ";
					if (rev) PrintKindValuePair(ky, Y);
					else PrintKindValuePair(kx, X);
					if (sym) print " <=> "; else print " >=> ";
					if (rev) PrintKindValuePair(kx, X);
					else PrintKindValuePair(ky, Y);
					print "^";
				} else {
					for (mult=1: mult<=LIST_OF_TY_GetLength(Y): mult++) {
						fl = LIST_OF_TY_GetItem(Y, mult);
						if (sym && tmp(X, fl) > 0) continue;
						print "  ";
						if (rev) PrintKindValuePair(ky, fl);
						else PrintKindValuePair(kx, X);
						if (sym) print " <=> "; else print " >=> ";
						if (rev) PrintKindValuePair(kx, X);
						else PrintKindValuePair(ky, fl);
						print "^";
					}
				}
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			HashCoreRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) {
				if (Y == RLANY_CAN_GET_Y) rtrue;
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				tmp = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) return tmp;
				return LIST_OF_TY_GetItem(tmp, 1);
			}
		} else {
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					sym = BlkValueRead(rel, tmp + 2);
					if (fl & RRF_SINGLE) {
						if (KOVIsBlockValue(ky)) {
							if (BlkValueCompare(X, sym) ~= 0) continue;
						} else {
							if (X ~= sym) continue;
						}
					} else {
						if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
					}
					if (Y == RLANY_CAN_GET_X) rtrue;
					return BlkValueRead(rel, tmp + 1);
				}
			}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			if (fl & RRF_USED) {
				sym = BlkValueRead(rel, tmp + 2);
				if (fl & RRF_SINGLE) {
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(X, sym) ~= 0) continue;
					} else {
						if (X ~= sym) continue;
					}
				} else {
					if (LIST_OF_TY_FindItem(sym, X) == 0) continue;
				}
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
			}
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		at = HashCoreLookUp(rel, kx, X);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 3*at;
			fl = BlkValueRead(rel, tmp);
			tmp = BlkValueRead(rel, tmp + 2);
			if (fl & RRF_SINGLE)
				LIST_OF_TY_InsertItem(Y, tmp);
			else
				LIST_OF_TY_AppendList(Y, tmp);
		}
		return Y;
	} else if (task == RELS_LIST) {
		if (BlkType(X) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(X, 0);
		switch (Y) {
			RLIST_ALL_X:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));
				}
				return X;
			RLIST_ALL_Y:
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE)
							LIST_OF_TY_InsertItem(X, tmp, false, 0, true);
						else
							LIST_OF_TY_AppendList(X, tmp, false, 0, true);
					}
				}
				return X;
			RLIST_ALL_PAIRS:
				if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 3*at;
					fl = BlkValueRead(rel, tmp);
					if (fl & RRF_USED) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));
						tmp = BlkValueRead(rel, tmp + 2);
						if (fl & RRF_SINGLE) {
							BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);
							LIST_OF_TY_InsertItem(X, Y);
						} else {
							for (mult = LIST_OF_TY_GetLength(tmp): mult > 0: mult--) {
								BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,
									LIST_OF_TY_GetItem(tmp, mult));
								LIST_OF_TY_InsertItem(X, Y);
							}
						}
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		rfalse;
	}
	at = HashCoreLookUp(rel, kx, X);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (fl & RRF_SINGLE) {
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				rfalse;
			} else {
				return LIST_OF_TY_FindItem(tmp, Y);
			}
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! no entry exists for this key, just add one
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				HashCoreCheckResize(rel);
				break;
			}
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if Y is the same as the stored key, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) == 0) rtrue;
				} else {
					if (tmp == Y) rtrue;
				}
				! it's different: either replace it or expand into a list,
				! depending on the value of mult
				if (mult) {
					fl = LIST_OF_TY_Create(UNKNOWN_TY);	! new list
					BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
					LIST_OF_TY_SetLength(fl, 2);
					BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy
					LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);
				} else {
					if (KOVIsBlockValue(ky)) {
						BlkFree(tmp);
						Y = BlkValueCopy(BlkValueCreate(ky), Y);
					}
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
				}
			} else {
				! if Y is present already, do nothing. otherwise add it.
				LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
			}
			rtrue;
		RELS_ASSERT_FALSE:
			if (at < 0) rtrue;
			! an entry exists: could be a list or a single value
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list
			if (fl & RRF_SINGLE) {
				! if the stored key isn't Y, we have nothing to do
				if (KOVIsBlockValue(ky)) {
					if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
				} else {
					if (tmp ~= Y) rtrue;
				}
				! delete the entry
				if (KOVIsBlockValue(ky))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));
				.DeleteEntryIgnoringY;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
				if (KOVIsBlockValue(kx))
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			} else {
				! remove Y from the list if present
				LIST_OF_TY_RemoveValue(tmp, Y, 1);
				! if the list is now empty, delete the whole entry
				if (LIST_OF_TY_GetLength(tmp) == 0) {
					BlkFree(tmp);
					jump DeleteEntryIgnoringY;
				}
			}
			rtrue;
	}
	rtrue;
];

[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;
!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";
	! calculate a hash value for the key
	hashv = KOVHashValue(kx, x);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
		return i;
	}
	flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if (HashCoreEntryMatches(rel, i, kx, X)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (3*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*3: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*3);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*3: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 3*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			X = BlkValueRead(temp, 3*i + 1);
			Y = BlkValueRead(temp, 3*i + 2);
			at = HashCoreLookUp(rel, kx, X);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ HashCoreEntryMatches rel at kx X  cx cy;
	cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
	if (KOVIsBlockValue(kx)) {
		if (BlkValueCompare(cx, X) ~= 0) rfalse;
	} else {
		if (cx ~= X) rfalse;
	}
	rtrue;
];


[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;
	kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_COPY) {
		if (KOVIsBlockValue(kx)) {
			at = BlkValueRead(rel, RRV_STORAGE);
			while (at >= 0) {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl & RRF_USED) {
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);
					tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);
				}
				at--;
			}
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		ext = BlkValueRead(rel, RRV_STORAGE);
		! flag all items by negating their group numbers
		for (at=0, X=RRV_DATA_BASE: at<=ext: at++, X=X+3)
			if (BlkValueRead(rel, X) & RRF_USED)
				BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));
		! display groups, unflagging them as we go
		for (at=0, X=RRV_DATA_BASE, fl=0: at<=ext: at++, X=X+3, fl=0) {
			if (BlkValueRead(rel, X) & RRF_USED) {
				fl = BlkValueRead(rel, X + 2);
				if (fl > 0) continue;		! already visited
				BlkValueWrite(rel, X + 2, -fl);	! unflag it
				! display the group starting with this member, but only
				! if there are more members in the group
				tmp = BlkValueRead(rel, X + 1);
				i = 0;
				for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2<=ext: at2++, Y=Y+3) {
					if (BlkValueRead(rel, Y) & RRF_USED) {
						if (BlkValueRead(rel, Y + 2) ~= fl) continue;
						BlkValueWrite(rel, Y + 2, -fl);
						if (~~i) {
							! print the saved first member
							print "  { ";
							PrintKindValuePair(kx, tmp);
							i = 1;
						}
						print ", ";
						PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));
					}
				}
				if (i) print " }^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		! never empty since R(x,x) is always true
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		! kind of a cheat, but it's faster than searching for a better value to return
		if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;
		return X;
	} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {
		if (BlkType(Y) ~= LIST_OF_TY) rfalse;
		LIST_OF_TY_SetLength(Y, 0);
		BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
		at = HashCoreLookUp(rel, kx, X);
		if (at < 0) {
			LIST_OF_TY_InsertItem(Y, X);
		} else {
			X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 3*at;
				fl = BlkValueRead(rel, tmp);
				if (fl & RRF_USED) {
					if (BlkValueRead(rel, tmp + 2) ~= X) continue;
					LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));
				}
			}
		}
		return Y;
	} else if (task == RELS_LIST) {
		print "*** Domains of equivalence relations cannot be listed ***^";
		return X;
	}
	at = HashCoreLookUp(rel, kx, X);
	at2 = HashCoreLookUp(rel, kx, Y);
	switch(task) {
		RELS_TEST:
			if (at < 0) {
				! X is a loner, but could still be true if X == Y
				if (KOVIsBlockValue(kx)) {
					if (BlkValueCompare(X, Y) == 0) rtrue;
				} else {
					if (X == Y) rtrue;
				}
				rfalse;
			}
			if (at2 < 0) rfalse;
			if (at == at2) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;
			rfalse;
		RELS_ASSERT_TRUE:
			! if X and Y are the same, we have nothing to do
			if (KOVIsBlockValue(kx)) {
				if (BlkValueCompare(X, Y) == 0) rtrue;
			} else {
				if (X == Y) rtrue;
			}
			if (at < 0) {
				if (at2 < 0) {
					! X and Y both missing: find a new group number and add both entries
					tmp = 0;		! candidate group number
					ext = BlkValueRead(rel, RRV_STORAGE);
					for (i=0: i<=ext: i++) {
						fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);
						if (fl & RRF_USED) {
							fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);
							if (fl > tmp) tmp = fl;
						}
					}
					tmp++;			! new group number
					BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);
					! add X entry
					at = ~at;
					if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
					! add Y entry. at2 might change if X and Y have the same hash code.
					at2 = ~(HashCoreLookUp(rel, kx, Y));
					if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
					fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
					if (fl == 0)
						BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
					BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
					jump CheckResize;
				}
				! X missing, Y present: add a new X entry
				at = ~at;
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);
				jump CheckResize;
			}
			if (at2 < 0) {
				! X present, Y missing: add a new Y entry
				at2 = ~at2;
				if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);
				tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
				BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);
				jump CheckResize;
			}
			! X and Y both present: merge higher group into lower group
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group
			fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group
			if (tmp < fl) { i = tmp; tmp = fl; fl = i; }
			ext = BlkValueRead(rel, RRV_STORAGE);
			for (at=0: at<=ext: at++) {
				i = RRV_DATA_BASE + 3*at + 2;
				if (BlkValueRead(rel, i) == tmp)
					BlkValueWrite(rel, i, fl);
			}
			.CheckResize;
			HashCoreCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! if X and Y are already in different groups, we have nothing to do
			if (at < 0 || at2 < 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);
			if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;
			! delete the entry for X
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
			if (KOVIsBlockValue(kx))
				BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);
			BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);
			rtrue;
	}
];


[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;
	kov = BlkValueRead(rel, RRV_KIND);
	kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
	if (task == RELS_SET_VALENCY) {
		return RELATION_TY_SetValency(rel, X);
	} else if (task == RELS_DESTROY) {
		! clear
		kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);
		if (~~(kx || ky)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED)
				if ((kx && (fl & RRF_ENTKEYX)) || (ky && (fl & RRF_ENTKEYY))) {
					BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
				}
			at--;
		}
		return;
	} else if (task == RELS_COPY) {
		X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);
		if (~~(X || Y)) return;
		at = BlkValueRead(rel, RRV_STORAGE);
		while (at >= 0) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (fl & RRF_USED) {
				if ((X && (fl & RRF_ENTKEYX)) || (Y && (fl & RRF_ENTKEYY))) {
					! copy the entry key
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
					if (fl & RRF_ENTKEYX)
						tmp = BlkValueCopy(BlkValueCreate(kx), tmp);
					else
						tmp = BlkValueCopy(BlkValueCreate(ky), tmp);
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);
					! update references in X/Y fields pointing here
					if (fl & RRF_HASX) {
						at2 = TwoInOneLookUp(rel, kx,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),
							RRF_ENTKEYX);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);
					}
					if (fl & RRF_HASY) {
						at2 = TwoInOneLookUp(rel, ky,
							BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),
							RRF_ENTKEYY);
						if (at2 >= 0)
							BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);
					}
				}
			}
			at--;
		}
		return;
	} else if (task == RELS_SHOW) {
		print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";
		if (sym) {
			kov = KOVComparisonFunction(kx);
			if (~~kov) kov = UnsignedCompare;
		}
		for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
				(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
				Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
				if (sym && kov(X, Y) > 0) continue;
				print "  ";
				PrintKindValuePair(kx, X);
				if (sym) print " <=> "; else print " >=> ";
				PrintKindValuePair(ky, Y);
				print "^";
			}
		}
		return;
	} else if (task == RELS_EMPTY) {
		if (BlkValueRead(rel, RRV_USED) == 0) rtrue;
		if (X == 1) {
			TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
			for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
				tmp = RRV_DATA_BASE + 4*at;
				BlkValueWrite(rel, tmp, 0);
				BlkValueWrite(rel, tmp + 1, 0);
				BlkValueWrite(rel, tmp + 2, 0);
				BlkValueWrite(rel, tmp + 3, 0);
			}
			BlkValueWrite(rel, RRV_USED, 0);
			BlkValueWrite(rel, RRV_FILLED, 0);
			rtrue;
		}
		rfalse;
	} else if (task == RELS_LOOKUP_ANY) {
		switch (Y) {
			RLANY_GET_X, RLANY_CAN_GET_X:
				at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASX) {
						if (Y == RLANY_CAN_GET_X) rtrue;
						return BlkValueRead(rel, tmp + 2);
					}
				}
			RLANY_GET_Y, RLANY_CAN_GET_Y:
				at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
				if (at >= 0) {
					tmp = RRV_DATA_BASE + 4*at;
					if (BlkValueRead(rel, tmp) & RRF_HASY) {
						if (Y == RLANY_CAN_GET_Y) rtrue;
						return BlkValueRead(rel, tmp + 3);
					}
				}
		}
		if (Y == RLANY_GET_X or RLANY_GET_Y)
			print "*** Lookup failed: value not found ***^";
		rfalse;
	} else if (task == RELS_LOOKUP_ALL_X) {
		at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASX)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));
		}
		return Y;
	} else if (task == RELS_LOOKUP_ALL_Y) {
		at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
		if (at >= 0) {
			tmp = RRV_DATA_BASE + 4*at;
			if (BlkValueRead(rel, tmp) & RRF_HASY)
				LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));
		}
		return Y;
	} else if (task == RELS_LIST) {
		switch (Y) {
			RLIST_ALL_X:
				fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;
				jump ListEntryKeys;
			RLIST_ALL_Y:
				fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;
				.ListEntryKeys;
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					if ((BlkValueRead(rel, tmp) & fl) == fl)
						LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);
				}
			RLIST_ALL_PAIRS:
				tmp = BlkValueRead(X, LIST_ITEM_KOV_F);
				if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;
				! LIST_OF_TY_InsertItem will make a deep copy of the item,
				! so we can reuse a single combination value here
				Y = BlkValueCreate(COMBINATION_TY, 0, tmp);
				for (at = BlkValueRead(rel, RRV_STORAGE): at >= 0: at--) {
					tmp = RRV_DATA_BASE + 4*at;
					fl = BlkValueRead(rel, tmp);
					if ((fl & (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==
						(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {
						BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));
						BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));
						LIST_OF_TY_InsertItem(X, Y);
					}
				}
				BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
				BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);
				BlkFree(Y);
				return X;
		}
		return X;
	}
	at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);
	switch(task) {
		RELS_TEST:
			if (at < 0) rfalse;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if (~~(fl & RRF_HASY)) rfalse;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) == 0) rtrue;
			} else {
				if (tmp == Y) rtrue;
			}
			rfalse;
		RELS_ASSERT_TRUE:
			if (at < 0) {
				! create a new forward entry
				at = ~at;
				BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl == 0)
					BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
				fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;
				if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
					fl = fl + RRF_ENTKEYY;
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
				if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);
				BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
			} else {
				fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				if (fl & RRF_HASY) {
					! if the Y we're inserting is already there, we're done
					tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
					if (KOVIsBlockValue(ky)) {
						if (BlkValueCompare(tmp, Y) == 0) rtrue;
					} else {
						if (tmp == Y) rtrue;
					}
					! it's different, so delete the reverse entry
					at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);
					if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				} else {
					BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);
				}
				! use the existing copy of X
				X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
			}
			! use the existing copy of Y if there is one
			at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);
			if (KOVIsBlockValue(ky)) {
				if (at2 >= 0)
					Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);
				else
					Y = BlkValueCopy(BlkValueCreate(ky), Y);
			}
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
			if (at2 >= 0) {
				! delete existing reverse entry (and its own forward entry)
				TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
			} else {
				at2 = ~at2;
			}
			! create reverse entry
			BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);
			if (fl == 0)
				BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);
			fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);
			if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))
				fl = fl | RRF_ENTKEYX;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);
			TwoInOneCheckResize(rel);
			rtrue;
		RELS_ASSERT_FALSE:
			! we only have work to do if the entry exists and has a Y which
			! matches the Y we're deleting
			if (at < 0) rtrue;
			fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			if ((fl & RRF_HASY) == 0) rtrue;
			tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);
			if (KOVIsBlockValue(ky)) {
				if (BlkValueCompare(tmp, Y) ~= 0) rtrue;
			} else {
				if (tmp ~= Y) rtrue;
			}
			TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
			rtrue;
	}
];

[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;
!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";
	fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
	if (ekflag == RRF_ENTKEYX) {
		if (fl & RRF_HASY) {
			i = RRV_DATA_BASE + 4*at + 3;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching Y<-X entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
				if (at2 >= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
				if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
			}
			fl = fl & ~RRF_HASY;
		}
	} else {
		if (fl & RRF_HASX) {
			i = RRV_DATA_BASE + 4*at + 2;
			if (both) E = BlkValueRead(rel, i);
			BlkValueWrite(rel, i, 0);
			! delete matching X->Y entry if needed
			if (both) {
				at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
				if (at2 >= 0) {
					TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
					if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);
				}
			}
			fl = fl & ~RRF_HASX;
		}
	}
	if ((fl & (RRF_HASX+RRF_HASY)) == 0) {
		! entry is now empty, mark it deleted
		if (((fl & RRF_ENTKEYX) && KOVIsBlockValue(kx)) ||
		    ((ky ~= kx) && (fl & RRF_ENTKEYY) && KOVIsBlockValue(ky))) {
			BlkFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));
		}
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);
		BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);
	} else {
		BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);
	}
];

[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;
!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";
	! calculate a hash value for the key
	hashv = KOVHashValue(ke, E);
	! look in the first expected slot
	mask = BlkValueRead(rel, RRV_STORAGE);
	i = hashv & mask;
!print "hv=", hashv, ", trying ", i;
	flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
	if (flags == 0) {
!print " - not found]^";
		return ~i;
	}
	if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
		return i;
	}
	! not here, keep looking in sequence
	free = -1;
	if (flags & RRF_DELETED) free = i;
	perturb = hashv;
	hashv = i;
	for (::) {
		hashv = hashv*5 + perturb + 1;
		i = hashv & mask;
!print ", ", i;
		flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);
		if (flags == 0) {
!print " - not found]^";
			if (free >= 0) return ~free;
			return ~i;
		}
		if ((flags & ekflag) && TwoInOneEntryMatches(rel, i, ke, E)) {
!print " - found]^";
			return i;
		}
		if ((free < 0) && (flags & RRF_DELETED)) free = i;
		#ifdef TARGET_ZCODE;
		@log_shift perturb (-RRP_PERTURB_SHIFT) -> perturb;
		#ifnot;
		@ushiftr perturb RRP_PERTURB_SHIFT perturb;
		#endif;
	}
];

[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;
	filled = BlkValueRead(rel, RRV_FILLED);
	ext = BlkValueRead(rel, RRV_STORAGE) + 1;
	if (filled >= (ext - filled) * RRP_CROWDED_IS) {
		! copy entries to temporary space
		temp = BlkAllocate(ext * (4*WORDSIZE), INDEXED_TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);
		for (i=0: i<ext*4: i++)
			BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i));
		! resize and clear our data
		if (ext >= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;
		else newext = ext * RRP_RESIZE_SMALL;
		BlkValueSetExtent(rel, RRV_DATA_BASE + newext*4);
		BlkValueWrite(rel, RRV_STORAGE, newext - 1);
		BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
		for (i=0: i<newext*4: i++)
			BlkValueWrite(rel, RRV_DATA_BASE+i, 0);
		! copy entries back from temporary space
		kov = BlkValueRead(rel, RRV_KIND);
		kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);
		for (i=0: i<ext: i++) {
			F = BlkValueRead(temp, 4*i);
			if (F == 0 || (F & RRF_DELETED)) continue;
			E = BlkValueRead(temp, 4*i + 1);
			X = BlkValueRead(temp, 4*i + 2);
			Y = BlkValueRead(temp, 4*i + 3);
			if (F & RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);
			else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);
			if (at >= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }
			at = ~at;
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);
			BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);
		}
		! done with temporary space
		BlkFree(temp);
	}
];

[ TwoInOneEntryMatches rel at ke E  ce;
	ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);
	if (KOVIsBlockValue(ke)) {
		if (BlkValueCompare(ce, E) ~= 0) rfalse;
	} else {
		if (ce ~= E) rfalse;
	}
	rtrue;
];


#IFNOT; ! IFDEF MEMORY_HEAP_SIZE

[ RELATION_TY_Support t a b c; rfalse; ];
[ RELATION_TY_Say comb; ];
[ RELATION_TY_Name rel txt; ];

#ENDIF; ! IFDEF MEMORY_HEAP_SIZE


[ RELATION_TY_Empty rel set  handler;
	handler = rel-->RR_HANDLER;
	return handler(rel, RELS_EMPTY, set);
];


Array ResourceIDsOfFigures --> 0 1  0;

Array ResourceIDsOfSounds --> 0  0;


[ CreateBlockConstants;
];



! End of automatically generated I6 source
! --------------------------------------------------------------------------
